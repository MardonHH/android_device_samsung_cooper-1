From 86e408714251dc5c5140e9028d9628f55e68378f Mon Sep 17 00:00:00 2001
From: Konsta <konsta09@gmail.com>
Date: Mon, 26 Nov 2012 14:44:25 +0200
Subject: [PATCH] Revert "Remove the no longer used PV software aac decoder."

This reverts commit 1f8834711f23f66d528aca98cca9602fb18cab66.
---
 media/libstagefright/codecs/aacdec/Android.mk      |  223 +-
 media/libstagefright/codecs/aacdec/SoftAAC.cpp     |  553 +++++
 media/libstagefright/codecs/aacdec/SoftAAC.h       |   78 +
 media/libstagefright/codecs/aacdec/aac_mem_funcs.h |   50 +
 .../codecs/aacdec/analysis_sub_band.cpp            |  289 +++
 .../codecs/aacdec/analysis_sub_band.h              |   82 +
 .../libstagefright/codecs/aacdec/apply_ms_synt.cpp |  454 ++++
 media/libstagefright/codecs/aacdec/apply_ms_synt.h |   94 +
 media/libstagefright/codecs/aacdec/apply_tns.cpp   |  424 ++++
 media/libstagefright/codecs/aacdec/apply_tns.h     |  113 +
 .../codecs/aacdec/bit_reversal_swap.h              |   93 +
 media/libstagefright/codecs/aacdec/buf_getbits.cpp |  167 ++
 media/libstagefright/codecs/aacdec/buf_getbits.h   |   94 +
 .../codecs/aacdec/buffer_normalization.h           |   93 +
 media/libstagefright/codecs/aacdec/byte_align.cpp  |  179 ++
 .../codecs/aacdec/calc_auto_corr.cpp               |  416 ++++
 .../libstagefright/codecs/aacdec/calc_auto_corr.h  |  122 +
 .../codecs/aacdec/calc_gsfb_table.cpp              |  267 ++
 .../codecs/aacdec/calc_sbr_anafilterbank.cpp       |  360 +++
 .../codecs/aacdec/calc_sbr_anafilterbank.h         |  113 +
 .../codecs/aacdec/calc_sbr_envelope.cpp            | 2203 +++++++++++++++++
 .../codecs/aacdec/calc_sbr_envelope.h              |  144 ++
 .../codecs/aacdec/calc_sbr_synfilterbank.cpp       |  639 +++++
 .../codecs/aacdec/calc_sbr_synfilterbank.h         |   94 +
 media/libstagefright/codecs/aacdec/chans.h         |  107 +
 media/libstagefright/codecs/aacdec/check_crc.cpp   |  144 ++
 media/libstagefright/codecs/aacdec/check_crc.h     |  124 +
 media/libstagefright/codecs/aacdec/dct16.cpp       |  266 ++
 media/libstagefright/codecs/aacdec/dct16.h         |   68 +
 media/libstagefright/codecs/aacdec/dct64.cpp       |  569 +++++
 media/libstagefright/codecs/aacdec/dct64.h         |   81 +
 .../codecs/aacdec/decode_huff_cw_binary.cpp        |  708 ++++++
 .../codecs/aacdec/decode_noise_floorlevels.cpp     |  163 ++
 .../codecs/aacdec/decode_noise_floorlevels.h       |   92 +
 .../libstagefright/codecs/aacdec/deinterleave.cpp  |  287 +++
 .../codecs/aacdec/digit_reversal_tables.cpp        |  279 +++
 .../codecs/aacdec/digit_reversal_tables.h          |   86 +
 media/libstagefright/codecs/aacdec/dst16.cpp       |  172 ++
 media/libstagefright/codecs/aacdec/dst16.h         |   68 +
 media/libstagefright/codecs/aacdec/dst32.cpp       |  200 ++
 media/libstagefright/codecs/aacdec/dst32.h         |   69 +
 media/libstagefright/codecs/aacdec/dst8.cpp        |  179 ++
 media/libstagefright/codecs/aacdec/dst8.h          |   68 +
 media/libstagefright/codecs/aacdec/e_adif_const.h  |   97 +
 .../codecs/aacdec/e_blockswitching.h               |  112 +
 .../libstagefright/codecs/aacdec/e_coupling_mode.h |   88 +
 media/libstagefright/codecs/aacdec/e_elementid.h   |   99 +
 .../libstagefright/codecs/aacdec/e_huffmanconst.h  |  119 +
 .../libstagefright/codecs/aacdec/e_infoinitconst.h |   96 +
 media/libstagefright/codecs/aacdec/e_invf_mode.h   |   91 +
 media/libstagefright/codecs/aacdec/e_maskstatus.h  |   91 +
 media/libstagefright/codecs/aacdec/e_mp4ff_const.h |  105 +
 .../codecs/aacdec/e_progconfigconst.h              |  110 +
 .../codecs/aacdec/e_rawbitstreamconst.h            |  130 +
 .../codecs/aacdec/e_sbr_element_id.h               |   87 +
 media/libstagefright/codecs/aacdec/e_sbr_error.h   |  106 +
 .../codecs/aacdec/e_sbr_header_status.h            |   88 +
 .../codecs/aacdec/e_sbr_master_status.h            |   87 +
 .../codecs/aacdec/e_sbr_sync_state.h               |   88 +
 media/libstagefright/codecs/aacdec/e_sr_mode.h     |   88 +
 .../codecs/aacdec/e_tmp4audioobjecttype.h          |  118 +
 media/libstagefright/codecs/aacdec/e_tns_const.h   |   91 +
 .../codecs/aacdec/e_window_sequence.h              |   90 +
 .../libstagefright/codecs/aacdec/e_window_shape.h  |   89 +
 .../codecs/aacdec/esc_iquant_scaling.cpp           |  789 ++++++
 .../codecs/aacdec/esc_iquant_scaling.h             |  102 +
 .../codecs/aacdec/extractframeinfo.cpp             |  487 ++++
 .../codecs/aacdec/extractframeinfo.h               |   96 +
 media/libstagefright/codecs/aacdec/fft_rx4.h       |  110 +
 .../libstagefright/codecs/aacdec/fft_rx4_long.cpp  |  428 ++++
 .../libstagefright/codecs/aacdec/fft_rx4_short.cpp |  468 ++++
 .../codecs/aacdec/fft_rx4_tables_fxp.cpp           |  269 ++
 .../codecs/aacdec/find_adts_syncword.cpp           |  305 +++
 .../codecs/aacdec/find_adts_syncword.h             |   87 +
 .../codecs/aacdec/fwd_long_complex_rot.cpp         |  284 +++
 .../codecs/aacdec/fwd_long_complex_rot.h           |   96 +
 .../codecs/aacdec/fwd_short_complex_rot.cpp        |  261 ++
 .../codecs/aacdec/fwd_short_complex_rot.h          |   92 +
 media/libstagefright/codecs/aacdec/fxp_mul32.h     |   72 +
 .../codecs/aacdec/fxp_mul32_arm_gcc.h              |  547 ++++
 .../codecs/aacdec/fxp_mul32_arm_v4.h               |  429 ++++
 .../codecs/aacdec/fxp_mul32_arm_v4_gcc.h           |  630 +++++
 .../codecs/aacdec/fxp_mul32_arm_v5.h               |  450 ++++
 .../codecs/aacdec/fxp_mul32_c_equivalent.h         |  285 +++
 .../codecs/aacdec/fxp_mul32_c_msc_evc.h            |  254 ++
 .../codecs/aacdec/fxp_mul32_c_msc_evc_armv5.h      |  178 ++
 .../codecs/aacdec/fxp_mul32_pentium.h              |   55 +
 .../codecs/aacdec/gen_rand_vector.cpp              |  512 ++++
 .../libstagefright/codecs/aacdec/gen_rand_vector.h |   87 +
 .../codecs/aacdec/get_adif_header.cpp              |  443 ++++
 .../libstagefright/codecs/aacdec/get_adif_header.h |   95 +
 .../codecs/aacdec/get_adts_header.cpp              |  672 +++++
 .../libstagefright/codecs/aacdec/get_adts_header.h |   90 +
 .../codecs/aacdec/get_audio_specific_config.cpp    |  691 ++++++
 .../codecs/aacdec/get_audio_specific_config.h      |   86 +
 media/libstagefright/codecs/aacdec/get_dse.cpp     |  215 ++
 media/libstagefright/codecs/aacdec/get_dse.h       |   87 +
 .../libstagefright/codecs/aacdec/get_ele_list.cpp  |  243 ++
 media/libstagefright/codecs/aacdec/get_ele_list.h  |   90 +
 .../codecs/aacdec/get_ga_specific_config.cpp       |  473 ++++
 .../codecs/aacdec/get_ga_specific_config.h         |   94 +
 .../libstagefright/codecs/aacdec/get_ics_info.cpp  |  608 +++++
 media/libstagefright/codecs/aacdec/get_ics_info.h  |  111 +
 .../codecs/aacdec/get_prog_config.cpp              |  739 ++++++
 .../libstagefright/codecs/aacdec/get_prog_config.h |   89 +
 .../codecs/aacdec/get_pulse_data.cpp               |  286 +++
 .../libstagefright/codecs/aacdec/get_pulse_data.h  |  100 +
 .../codecs/aacdec/get_sbr_bitstream.cpp            |  183 ++
 .../codecs/aacdec/get_sbr_bitstream.h              |  126 +
 .../codecs/aacdec/get_sbr_startfreq.cpp            |  183 ++
 .../codecs/aacdec/get_sbr_startfreq.h              |   85 +
 .../codecs/aacdec/get_sbr_stopfreq.cpp             |  190 ++
 .../codecs/aacdec/get_sbr_stopfreq.h               |   85 +
 media/libstagefright/codecs/aacdec/get_sign_bits.h |   99 +
 media/libstagefright/codecs/aacdec/get_tns.cpp     |  573 +++++
 media/libstagefright/codecs/aacdec/get_tns.h       |  124 +
 media/libstagefright/codecs/aacdec/getbits.h       |  346 +++
 media/libstagefright/codecs/aacdec/getfill.cpp     |  247 ++
 media/libstagefright/codecs/aacdec/getfill.h       |   88 +
 media/libstagefright/codecs/aacdec/getgroup.cpp    |  255 ++
 media/libstagefright/codecs/aacdec/getics.cpp      |  674 +++++
 media/libstagefright/codecs/aacdec/getmask.cpp     |  384 +++
 media/libstagefright/codecs/aacdec/hcbtables.h     |  118 +
 .../codecs/aacdec/hcbtables_binary.cpp             | 1938 +++++++++++++++
 media/libstagefright/codecs/aacdec/huffcb.cpp      |  381 +++
 media/libstagefright/codecs/aacdec/huffdecode.cpp  |  528 ++++
 media/libstagefright/codecs/aacdec/hufffac.cpp     |  550 +++++
 media/libstagefright/codecs/aacdec/huffman.h       |  241 ++
 .../libstagefright/codecs/aacdec/huffspec_fxp.cpp  |  671 +++++
 media/libstagefright/codecs/aacdec/ibstream.h      |  115 +
 media/libstagefright/codecs/aacdec/idct16.cpp      |  204 ++
 media/libstagefright/codecs/aacdec/idct16.h        |   69 +
 media/libstagefright/codecs/aacdec/idct32.cpp      |  196 ++
 media/libstagefright/codecs/aacdec/idct32.h        |   69 +
 media/libstagefright/codecs/aacdec/idct8.cpp       |  168 ++
 media/libstagefright/codecs/aacdec/idct8.h         |   69 +
 media/libstagefright/codecs/aacdec/imdct_fxp.cpp   |  476 ++++
 media/libstagefright/codecs/aacdec/imdct_fxp.h     |  122 +
 media/libstagefright/codecs/aacdec/infoinit.cpp    |  355 +++
 .../libstagefright/codecs/aacdec/init_sbr_dec.cpp  |  192 ++
 media/libstagefright/codecs/aacdec/init_sbr_dec.h  |  115 +
 .../codecs/aacdec/intensity_right.cpp              |  457 ++++
 .../libstagefright/codecs/aacdec/intensity_right.h |   97 +
 .../codecs/aacdec/inv_long_complex_rot.cpp         |  408 +++
 .../codecs/aacdec/inv_long_complex_rot.h           |   99 +
 .../codecs/aacdec/inv_short_complex_rot.cpp        |  305 +++
 .../codecs/aacdec/inv_short_complex_rot.h          |   88 +
 .../libstagefright/codecs/aacdec/iquant_table.cpp  | 1131 +++++++++
 media/libstagefright/codecs/aacdec/iquant_table.h  |   85 +
 .../codecs/aacdec/long_term_prediction.cpp         |  648 +++++
 .../codecs/aacdec/long_term_prediction.h           |  122 +
 .../codecs/aacdec/long_term_synthesis.cpp          | 1158 +++++++++
 .../codecs/aacdec/long_term_synthesis.h            |  105 +
 media/libstagefright/codecs/aacdec/lt_decode.cpp   |  507 ++++
 media/libstagefright/codecs/aacdec/lt_decode.h     |   96 +
 media/libstagefright/codecs/aacdec/lt_prediction.h |   69 +
 .../codecs/aacdec/ltp_common_internal.h            |  115 +
 media/libstagefright/codecs/aacdec/mdct_fxp.cpp    |  450 ++++
 media/libstagefright/codecs/aacdec/mdct_fxp.h      |  107 +
 .../codecs/aacdec/mdct_tables_fxp.cpp              |  253 ++
 media/libstagefright/codecs/aacdec/mdst.cpp        |  294 +++
 media/libstagefright/codecs/aacdec/mdst.h          |   73 +
 .../libstagefright/codecs/aacdec/mix_radix_fft.cpp |  319 +++
 media/libstagefright/codecs/aacdec/mix_radix_fft.h |   98 +
 media/libstagefright/codecs/aacdec/ms_map_mask.h   |   87 +
 media/libstagefright/codecs/aacdec/ms_synt.cpp     |  403 +++
 media/libstagefright/codecs/aacdec/ms_synt.h       |   96 +
 media/libstagefright/codecs/aacdec/pns_corr.cpp    |  342 +++
 media/libstagefright/codecs/aacdec/pns_corr.h      |   95 +
 .../codecs/aacdec/pns_intensity_right.cpp          |  653 +++++
 .../codecs/aacdec/pns_intensity_right.h            |  106 +
 media/libstagefright/codecs/aacdec/pns_left.cpp    |  431 ++++
 media/libstagefright/codecs/aacdec/pns_left.h      |  113 +
 .../codecs/aacdec/ps_all_pass_filter_coeff.cpp     |  311 +++
 .../codecs/aacdec/ps_all_pass_filter_coeff.h       |  105 +
 .../aacdec/ps_all_pass_fract_delay_filter.cpp      |  391 +++
 .../codecs/aacdec/ps_all_pass_fract_delay_filter.h |  117 +
 .../codecs/aacdec/ps_allocate_decoder.cpp          |  341 +++
 .../codecs/aacdec/ps_allocate_decoder.h            |   94 +
 media/libstagefright/codecs/aacdec/ps_applied.cpp  |  216 ++
 media/libstagefright/codecs/aacdec/ps_applied.h    |  101 +
 .../codecs/aacdec/ps_bstr_decoding.cpp             |  304 +++
 .../codecs/aacdec/ps_bstr_decoding.h               |   98 +
 .../codecs/aacdec/ps_channel_filtering.cpp         |  281 +++
 .../codecs/aacdec/ps_channel_filtering.h           |  104 +
 media/libstagefright/codecs/aacdec/ps_constants.h  |   89 +
 .../codecs/aacdec/ps_decode_bs_utils.cpp           |  274 ++
 .../codecs/aacdec/ps_decode_bs_utils.h             |  112 +
 .../codecs/aacdec/ps_decorrelate.cpp               |  499 ++++
 .../libstagefright/codecs/aacdec/ps_decorrelate.h  |   99 +
 media/libstagefright/codecs/aacdec/ps_fft_rx8.cpp  |  318 +++
 media/libstagefright/codecs/aacdec/ps_fft_rx8.h    |   94 +
 .../codecs/aacdec/ps_hybrid_analysis.cpp           |  285 +++
 .../codecs/aacdec/ps_hybrid_analysis.h             |   98 +
 .../aacdec/ps_hybrid_filter_bank_allocation.cpp    |  213 ++
 .../aacdec/ps_hybrid_filter_bank_allocation.h      |   97 +
 .../codecs/aacdec/ps_hybrid_synthesis.cpp          |  192 ++
 .../codecs/aacdec/ps_hybrid_synthesis.h            |   97 +
 .../codecs/aacdec/ps_init_stereo_mixing.cpp        |  496 ++++
 .../codecs/aacdec/ps_init_stereo_mixing.h          |   97 +
 .../codecs/aacdec/ps_pwr_transient_detection.cpp   |  340 +++
 .../codecs/aacdec/ps_pwr_transient_detection.h     |   96 +
 .../libstagefright/codecs/aacdec/ps_read_data.cpp  |  388 +++
 media/libstagefright/codecs/aacdec/ps_read_data.h  |  100 +
 .../codecs/aacdec/ps_stereo_processing.cpp         |  372 +++
 .../codecs/aacdec/ps_stereo_processing.h           |   98 +
 media/libstagefright/codecs/aacdec/pulse_nc.cpp    |  298 +++
 media/libstagefright/codecs/aacdec/pulse_nc.h      |  104 +
 .../codecs/aacdec/pv_audio_type_defs.h             |  183 ++
 media/libstagefright/codecs/aacdec/pv_div.cpp      |  188 ++
 media/libstagefright/codecs/aacdec/pv_div.h        |   74 +
 media/libstagefright/codecs/aacdec/pv_log2.cpp     |  168 ++
 media/libstagefright/codecs/aacdec/pv_log2.h       |   69 +
 .../libstagefright/codecs/aacdec/pv_normalize.cpp  |  167 ++
 media/libstagefright/codecs/aacdec/pv_normalize.h  |  105 +
 media/libstagefright/codecs/aacdec/pv_pow2.cpp     |  170 ++
 media/libstagefright/codecs/aacdec/pv_pow2.h       |   68 +
 media/libstagefright/codecs/aacdec/pv_sine.cpp     |  182 ++
 media/libstagefright/codecs/aacdec/pv_sine.h       |   68 +
 media/libstagefright/codecs/aacdec/pv_sqrt.cpp     |  218 ++
 media/libstagefright/codecs/aacdec/pv_sqrt.h       |   74 +
 .../codecs/aacdec/pvmp4audiodecoder_api.h          |  376 +++
 .../codecs/aacdec/pvmp4audiodecoderconfig.cpp      |  285 +++
 .../codecs/aacdec/pvmp4audiodecoderframe.cpp       | 1458 +++++++++++
 .../aacdec/pvmp4audiodecodergetmemrequirements.cpp |  157 ++
 .../codecs/aacdec/pvmp4audiodecoderinitlibrary.cpp |  418 ++++
 .../codecs/aacdec/pvmp4audiodecoderresetbuffer.cpp |  354 +++
 .../codecs/aacdec/pvmp4setaudioconfig.cpp          |  368 +++
 media/libstagefright/codecs/aacdec/q_normalize.cpp |  388 +++
 media/libstagefright/codecs/aacdec/q_normalize.h   |  103 +
 .../codecs/aacdec/qmf_filterbank_coeff.cpp         |  319 +++
 .../codecs/aacdec/qmf_filterbank_coeff.h           |   99 +
 media/libstagefright/codecs/aacdec/s_adif_header.h |   98 +
 media/libstagefright/codecs/aacdec/s_bit_buffer.h  |   93 +
 media/libstagefright/codecs/aacdec/s_bits.h        |  112 +
 media/libstagefright/codecs/aacdec/s_ch_info.h     |  103 +
 media/libstagefright/codecs/aacdec/s_crc_buffer.h  |   90 +
 media/libstagefright/codecs/aacdec/s_elelist.h     |   90 +
 media/libstagefright/codecs/aacdec/s_frameinfo.h   |  127 +
 media/libstagefright/codecs/aacdec/s_hcb.h         |  123 +
 media/libstagefright/codecs/aacdec/s_huffman.h     |   91 +
 media/libstagefright/codecs/aacdec/s_hybrid.h      |  100 +
 .../codecs/aacdec/s_lt_pred_status.h               |  174 ++
 media/libstagefright/codecs/aacdec/s_mc_info.h     |  116 +
 media/libstagefright/codecs/aacdec/s_mixdown.h     |   88 +
 media/libstagefright/codecs/aacdec/s_patch.h       |  121 +
 media/libstagefright/codecs/aacdec/s_progconfig.h  |  108 +
 media/libstagefright/codecs/aacdec/s_ps_dec.h      |  154 ++
 media/libstagefright/codecs/aacdec/s_pulseinfo.h   |   97 +
 media/libstagefright/codecs/aacdec/s_sbr_channel.h |  115 +
 media/libstagefright/codecs/aacdec/s_sbr_dec.h     |  145 ++
 .../codecs/aacdec/s_sbr_element_stream.h           |   92 +
 .../codecs/aacdec/s_sbr_frame_data.h               |  181 ++
 .../codecs/aacdec/s_sbr_header_data.h              |  112 +
 .../libstagefright/codecs/aacdec/s_sbrbitstream.h  |   91 +
 media/libstagefright/codecs/aacdec/s_sectinfo.h    |   91 +
 media/libstagefright/codecs/aacdec/s_sr_info.h     |   91 +
 .../libstagefright/codecs/aacdec/s_tdec_int_chan.h |  183 ++
 .../libstagefright/codecs/aacdec/s_tdec_int_file.h |  277 +++
 .../codecs/aacdec/s_tns_frame_info.h               |  147 ++
 media/libstagefright/codecs/aacdec/s_tnsfilt.h     |  132 +
 media/libstagefright/codecs/aacdec/s_wnd_shape.h   |   89 +
 .../codecs/aacdec/sbr_aliasing_reduction.cpp       |  366 +++
 .../codecs/aacdec/sbr_aliasing_reduction.h         |   92 +
 media/libstagefright/codecs/aacdec/sbr_applied.cpp |  435 ++++
 media/libstagefright/codecs/aacdec/sbr_applied.h   |  136 +
 .../codecs/aacdec/sbr_code_book_envlevel.cpp       |  403 +++
 .../codecs/aacdec/sbr_code_book_envlevel.h         |  103 +
 media/libstagefright/codecs/aacdec/sbr_constants.h |  210 ++
 .../libstagefright/codecs/aacdec/sbr_crc_check.cpp |  191 ++
 media/libstagefright/codecs/aacdec/sbr_crc_check.h |   98 +
 .../codecs/aacdec/sbr_create_limiter_bands.cpp     |  253 ++
 .../codecs/aacdec/sbr_create_limiter_bands.h       |   95 +
 media/libstagefright/codecs/aacdec/sbr_dec.cpp     |  960 ++++++++
 media/libstagefright/codecs/aacdec/sbr_dec.h       |  144 ++
 .../codecs/aacdec/sbr_decode_envelope.cpp          |  286 +++
 .../codecs/aacdec/sbr_decode_envelope.h            |   94 +
 .../codecs/aacdec/sbr_decode_huff_cw.cpp           |  149 ++
 .../codecs/aacdec/sbr_decode_huff_cw.h             |   93 +
 .../codecs/aacdec/sbr_downsample_lo_res.cpp        |  162 ++
 .../codecs/aacdec/sbr_downsample_lo_res.h          |   97 +
 .../codecs/aacdec/sbr_envelope_calc_tbl.cpp        |  424 ++++
 .../codecs/aacdec/sbr_envelope_calc_tbl.h          |   96 +
 .../codecs/aacdec/sbr_envelope_unmapping.cpp       |  427 ++++
 .../codecs/aacdec/sbr_envelope_unmapping.h         |   89 +
 .../codecs/aacdec/sbr_extract_extended_data.cpp    |  223 ++
 .../codecs/aacdec/sbr_extract_extended_data.h      |   93 +
 .../codecs/aacdec/sbr_find_start_andstop_band.cpp  |  198 ++
 .../codecs/aacdec/sbr_find_start_andstop_band.h    |   89 +
 .../codecs/aacdec/sbr_generate_high_freq.cpp       | 1040 ++++++++
 .../codecs/aacdec/sbr_generate_high_freq.h         |  144 ++
 .../codecs/aacdec/sbr_get_additional_data.cpp      |  145 ++
 .../codecs/aacdec/sbr_get_additional_data.h        |   87 +
 media/libstagefright/codecs/aacdec/sbr_get_cpe.cpp |  266 ++
 media/libstagefright/codecs/aacdec/sbr_get_cpe.h   |   88 +
 .../codecs/aacdec/sbr_get_dir_control_data.cpp     |  153 ++
 .../codecs/aacdec/sbr_get_dir_control_data.h       |   87 +
 .../codecs/aacdec/sbr_get_envelope.cpp             |  265 ++
 .../codecs/aacdec/sbr_get_envelope.h               |   93 +
 .../codecs/aacdec/sbr_get_header_data.cpp          |  221 ++
 .../codecs/aacdec/sbr_get_header_data.h            |   89 +
 .../codecs/aacdec/sbr_get_noise_floor_data.cpp     |  218 ++
 .../codecs/aacdec/sbr_get_noise_floor_data.h       |   94 +
 media/libstagefright/codecs/aacdec/sbr_get_sce.cpp |  202 ++
 media/libstagefright/codecs/aacdec/sbr_get_sce.h   |  102 +
 .../codecs/aacdec/sbr_inv_filt_levelemphasis.cpp   |  214 ++
 .../codecs/aacdec/sbr_inv_filt_levelemphasis.h     |   91 +
 media/libstagefright/codecs/aacdec/sbr_open.cpp    |  195 ++
 media/libstagefright/codecs/aacdec/sbr_open.h      |  116 +
 .../libstagefright/codecs/aacdec/sbr_read_data.cpp |  324 +++
 media/libstagefright/codecs/aacdec/sbr_read_data.h |  127 +
 .../codecs/aacdec/sbr_requantize_envelope_data.cpp |  183 ++
 .../codecs/aacdec/sbr_requantize_envelope_data.h   |   83 +
 .../libstagefright/codecs/aacdec/sbr_reset_dec.cpp |  269 ++
 media/libstagefright/codecs/aacdec/sbr_reset_dec.h |  118 +
 .../codecs/aacdec/sbr_update_freq_scale.cpp        |  364 +++
 .../codecs/aacdec/sbr_update_freq_scale.h          |  104 +
 media/libstagefright/codecs/aacdec/set_mc_info.cpp |  309 +++
 media/libstagefright/codecs/aacdec/set_mc_info.h   |   98 +
 media/libstagefright/codecs/aacdec/sfb.cpp         |  275 +++
 media/libstagefright/codecs/aacdec/sfb.h           |  117 +
 media/libstagefright/codecs/aacdec/shellsort.cpp   |  138 ++
 media/libstagefright/codecs/aacdec/shellsort.h     |   84 +
 media/libstagefright/codecs/aacdec/stereo_2_mono.h |   97 +
 .../codecs/aacdec/synthesis_sub_band.cpp           |  483 ++++
 .../codecs/aacdec/synthesis_sub_band.h             |   78 +
 .../libstagefright/codecs/aacdec/tns_ar_filter.cpp |  474 ++++
 media/libstagefright/codecs/aacdec/tns_ar_filter.h |  104 +
 .../codecs/aacdec/tns_decode_coef.cpp              |  500 ++++
 .../libstagefright/codecs/aacdec/tns_decode_coef.h |  115 +
 .../codecs/aacdec/tns_inv_filter.cpp               |  421 ++++
 .../libstagefright/codecs/aacdec/tns_inv_filter.h  |   99 +
 .../codecs/aacdec/trans4m_freq_2_time_fxp.cpp      | 2604 ++++++++++++++++++++
 .../codecs/aacdec/trans4m_time_2_freq_fxp.cpp      |  663 +++++
 media/libstagefright/codecs/aacdec/unpack_idx.cpp  |  660 +++++
 media/libstagefright/codecs/aacdec/unpack_idx.h    |  115 +
 .../codecs/aacdec/window_block_fxp.h               |  231 ++
 .../codecs/aacdec/window_tables_fxp.cpp            |  730 ++++++
 media/libstagefright/codecs/aacdec/write_output.h  |  138 ++
 339 files changed, 82369 insertions(+), 19 deletions(-)
 create mode 100644 media/libstagefright/codecs/aacdec/SoftAAC.cpp
 create mode 100644 media/libstagefright/codecs/aacdec/SoftAAC.h
 create mode 100644 media/libstagefright/codecs/aacdec/aac_mem_funcs.h
 create mode 100644 media/libstagefright/codecs/aacdec/analysis_sub_band.cpp
 create mode 100644 media/libstagefright/codecs/aacdec/analysis_sub_band.h
 create mode 100644 media/libstagefright/codecs/aacdec/apply_ms_synt.cpp
 create mode 100644 media/libstagefright/codecs/aacdec/apply_ms_synt.h
 create mode 100644 media/libstagefright/codecs/aacdec/apply_tns.cpp
 create mode 100644 media/libstagefright/codecs/aacdec/apply_tns.h
 create mode 100644 media/libstagefright/codecs/aacdec/bit_reversal_swap.h
 create mode 100644 media/libstagefright/codecs/aacdec/buf_getbits.cpp
 create mode 100644 media/libstagefright/codecs/aacdec/buf_getbits.h
 create mode 100644 media/libstagefright/codecs/aacdec/buffer_normalization.h
 create mode 100644 media/libstagefright/codecs/aacdec/byte_align.cpp
 create mode 100644 media/libstagefright/codecs/aacdec/calc_auto_corr.cpp
 create mode 100644 media/libstagefright/codecs/aacdec/calc_auto_corr.h
 create mode 100644 media/libstagefright/codecs/aacdec/calc_gsfb_table.cpp
 create mode 100644 media/libstagefright/codecs/aacdec/calc_sbr_anafilterbank.cpp
 create mode 100644 media/libstagefright/codecs/aacdec/calc_sbr_anafilterbank.h
 create mode 100644 media/libstagefright/codecs/aacdec/calc_sbr_envelope.cpp
 create mode 100644 media/libstagefright/codecs/aacdec/calc_sbr_envelope.h
 create mode 100644 media/libstagefright/codecs/aacdec/calc_sbr_synfilterbank.cpp
 create mode 100644 media/libstagefright/codecs/aacdec/calc_sbr_synfilterbank.h
 create mode 100644 media/libstagefright/codecs/aacdec/chans.h
 create mode 100644 media/libstagefright/codecs/aacdec/check_crc.cpp
 create mode 100644 media/libstagefright/codecs/aacdec/check_crc.h
 create mode 100644 media/libstagefright/codecs/aacdec/dct16.cpp
 create mode 100644 media/libstagefright/codecs/aacdec/dct16.h
 create mode 100644 media/libstagefright/codecs/aacdec/dct64.cpp
 create mode 100644 media/libstagefright/codecs/aacdec/dct64.h
 create mode 100644 media/libstagefright/codecs/aacdec/decode_huff_cw_binary.cpp
 create mode 100644 media/libstagefright/codecs/aacdec/decode_noise_floorlevels.cpp
 create mode 100644 media/libstagefright/codecs/aacdec/decode_noise_floorlevels.h
 create mode 100644 media/libstagefright/codecs/aacdec/deinterleave.cpp
 create mode 100644 media/libstagefright/codecs/aacdec/digit_reversal_tables.cpp
 create mode 100644 media/libstagefright/codecs/aacdec/digit_reversal_tables.h
 create mode 100644 media/libstagefright/codecs/aacdec/dst16.cpp
 create mode 100644 media/libstagefright/codecs/aacdec/dst16.h
 create mode 100644 media/libstagefright/codecs/aacdec/dst32.cpp
 create mode 100644 media/libstagefright/codecs/aacdec/dst32.h
 create mode 100644 media/libstagefright/codecs/aacdec/dst8.cpp
 create mode 100644 media/libstagefright/codecs/aacdec/dst8.h
 create mode 100644 media/libstagefright/codecs/aacdec/e_adif_const.h
 create mode 100644 media/libstagefright/codecs/aacdec/e_blockswitching.h
 create mode 100644 media/libstagefright/codecs/aacdec/e_coupling_mode.h
 create mode 100644 media/libstagefright/codecs/aacdec/e_elementid.h
 create mode 100644 media/libstagefright/codecs/aacdec/e_huffmanconst.h
 create mode 100644 media/libstagefright/codecs/aacdec/e_infoinitconst.h
 create mode 100644 media/libstagefright/codecs/aacdec/e_invf_mode.h
 create mode 100644 media/libstagefright/codecs/aacdec/e_maskstatus.h
 create mode 100644 media/libstagefright/codecs/aacdec/e_mp4ff_const.h
 create mode 100644 media/libstagefright/codecs/aacdec/e_progconfigconst.h
 create mode 100644 media/libstagefright/codecs/aacdec/e_rawbitstreamconst.h
 create mode 100644 media/libstagefright/codecs/aacdec/e_sbr_element_id.h
 create mode 100644 media/libstagefright/codecs/aacdec/e_sbr_error.h
 create mode 100644 media/libstagefright/codecs/aacdec/e_sbr_header_status.h
 create mode 100644 media/libstagefright/codecs/aacdec/e_sbr_master_status.h
 create mode 100644 media/libstagefright/codecs/aacdec/e_sbr_sync_state.h
 create mode 100644 media/libstagefright/codecs/aacdec/e_sr_mode.h
 create mode 100644 media/libstagefright/codecs/aacdec/e_tmp4audioobjecttype.h
 create mode 100644 media/libstagefright/codecs/aacdec/e_tns_const.h
 create mode 100644 media/libstagefright/codecs/aacdec/e_window_sequence.h
 create mode 100644 media/libstagefright/codecs/aacdec/e_window_shape.h
 create mode 100644 media/libstagefright/codecs/aacdec/esc_iquant_scaling.cpp
 create mode 100644 media/libstagefright/codecs/aacdec/esc_iquant_scaling.h
 create mode 100644 media/libstagefright/codecs/aacdec/extractframeinfo.cpp
 create mode 100644 media/libstagefright/codecs/aacdec/extractframeinfo.h
 create mode 100644 media/libstagefright/codecs/aacdec/fft_rx4.h
 create mode 100644 media/libstagefright/codecs/aacdec/fft_rx4_long.cpp
 create mode 100644 media/libstagefright/codecs/aacdec/fft_rx4_short.cpp
 create mode 100644 media/libstagefright/codecs/aacdec/fft_rx4_tables_fxp.cpp
 create mode 100644 media/libstagefright/codecs/aacdec/find_adts_syncword.cpp
 create mode 100644 media/libstagefright/codecs/aacdec/find_adts_syncword.h
 create mode 100644 media/libstagefright/codecs/aacdec/fwd_long_complex_rot.cpp
 create mode 100644 media/libstagefright/codecs/aacdec/fwd_long_complex_rot.h
 create mode 100644 media/libstagefright/codecs/aacdec/fwd_short_complex_rot.cpp
 create mode 100644 media/libstagefright/codecs/aacdec/fwd_short_complex_rot.h
 create mode 100644 media/libstagefright/codecs/aacdec/fxp_mul32.h
 create mode 100644 media/libstagefright/codecs/aacdec/fxp_mul32_arm_gcc.h
 create mode 100644 media/libstagefright/codecs/aacdec/fxp_mul32_arm_v4.h
 create mode 100755 media/libstagefright/codecs/aacdec/fxp_mul32_arm_v4_gcc.h
 create mode 100644 media/libstagefright/codecs/aacdec/fxp_mul32_arm_v5.h
 create mode 100644 media/libstagefright/codecs/aacdec/fxp_mul32_c_equivalent.h
 create mode 100644 media/libstagefright/codecs/aacdec/fxp_mul32_c_msc_evc.h
 create mode 100644 media/libstagefright/codecs/aacdec/fxp_mul32_c_msc_evc_armv5.h
 create mode 100644 media/libstagefright/codecs/aacdec/fxp_mul32_pentium.h
 create mode 100644 media/libstagefright/codecs/aacdec/gen_rand_vector.cpp
 create mode 100644 media/libstagefright/codecs/aacdec/gen_rand_vector.h
 create mode 100644 media/libstagefright/codecs/aacdec/get_adif_header.cpp
 create mode 100644 media/libstagefright/codecs/aacdec/get_adif_header.h
 create mode 100644 media/libstagefright/codecs/aacdec/get_adts_header.cpp
 create mode 100644 media/libstagefright/codecs/aacdec/get_adts_header.h
 create mode 100644 media/libstagefright/codecs/aacdec/get_audio_specific_config.cpp
 create mode 100644 media/libstagefright/codecs/aacdec/get_audio_specific_config.h
 create mode 100644 media/libstagefright/codecs/aacdec/get_dse.cpp
 create mode 100644 media/libstagefright/codecs/aacdec/get_dse.h
 create mode 100644 media/libstagefright/codecs/aacdec/get_ele_list.cpp
 create mode 100644 media/libstagefright/codecs/aacdec/get_ele_list.h
 create mode 100644 media/libstagefright/codecs/aacdec/get_ga_specific_config.cpp
 create mode 100644 media/libstagefright/codecs/aacdec/get_ga_specific_config.h
 create mode 100644 media/libstagefright/codecs/aacdec/get_ics_info.cpp
 create mode 100644 media/libstagefright/codecs/aacdec/get_ics_info.h
 create mode 100644 media/libstagefright/codecs/aacdec/get_prog_config.cpp
 create mode 100644 media/libstagefright/codecs/aacdec/get_prog_config.h
 create mode 100644 media/libstagefright/codecs/aacdec/get_pulse_data.cpp
 create mode 100644 media/libstagefright/codecs/aacdec/get_pulse_data.h
 create mode 100644 media/libstagefright/codecs/aacdec/get_sbr_bitstream.cpp
 create mode 100644 media/libstagefright/codecs/aacdec/get_sbr_bitstream.h
 create mode 100644 media/libstagefright/codecs/aacdec/get_sbr_startfreq.cpp
 create mode 100644 media/libstagefright/codecs/aacdec/get_sbr_startfreq.h
 create mode 100644 media/libstagefright/codecs/aacdec/get_sbr_stopfreq.cpp
 create mode 100644 media/libstagefright/codecs/aacdec/get_sbr_stopfreq.h
 create mode 100644 media/libstagefright/codecs/aacdec/get_sign_bits.h
 create mode 100644 media/libstagefright/codecs/aacdec/get_tns.cpp
 create mode 100644 media/libstagefright/codecs/aacdec/get_tns.h
 create mode 100644 media/libstagefright/codecs/aacdec/getbits.h
 create mode 100644 media/libstagefright/codecs/aacdec/getfill.cpp
 create mode 100644 media/libstagefright/codecs/aacdec/getfill.h
 create mode 100644 media/libstagefright/codecs/aacdec/getgroup.cpp
 create mode 100644 media/libstagefright/codecs/aacdec/getics.cpp
 create mode 100644 media/libstagefright/codecs/aacdec/getmask.cpp
 create mode 100644 media/libstagefright/codecs/aacdec/hcbtables.h
 create mode 100644 media/libstagefright/codecs/aacdec/hcbtables_binary.cpp
 create mode 100644 media/libstagefright/codecs/aacdec/huffcb.cpp
 create mode 100644 media/libstagefright/codecs/aacdec/huffdecode.cpp
 create mode 100644 media/libstagefright/codecs/aacdec/hufffac.cpp
 create mode 100644 media/libstagefright/codecs/aacdec/huffman.h
 create mode 100644 media/libstagefright/codecs/aacdec/huffspec_fxp.cpp
 create mode 100644 media/libstagefright/codecs/aacdec/ibstream.h
 create mode 100644 media/libstagefright/codecs/aacdec/idct16.cpp
 create mode 100644 media/libstagefright/codecs/aacdec/idct16.h
 create mode 100644 media/libstagefright/codecs/aacdec/idct32.cpp
 create mode 100644 media/libstagefright/codecs/aacdec/idct32.h
 create mode 100644 media/libstagefright/codecs/aacdec/idct8.cpp
 create mode 100644 media/libstagefright/codecs/aacdec/idct8.h
 create mode 100644 media/libstagefright/codecs/aacdec/imdct_fxp.cpp
 create mode 100644 media/libstagefright/codecs/aacdec/imdct_fxp.h
 create mode 100644 media/libstagefright/codecs/aacdec/infoinit.cpp
 create mode 100644 media/libstagefright/codecs/aacdec/init_sbr_dec.cpp
 create mode 100644 media/libstagefright/codecs/aacdec/init_sbr_dec.h
 create mode 100644 media/libstagefright/codecs/aacdec/intensity_right.cpp
 create mode 100644 media/libstagefright/codecs/aacdec/intensity_right.h
 create mode 100644 media/libstagefright/codecs/aacdec/inv_long_complex_rot.cpp
 create mode 100644 media/libstagefright/codecs/aacdec/inv_long_complex_rot.h
 create mode 100644 media/libstagefright/codecs/aacdec/inv_short_complex_rot.cpp
 create mode 100644 media/libstagefright/codecs/aacdec/inv_short_complex_rot.h
 create mode 100644 media/libstagefright/codecs/aacdec/iquant_table.cpp
 create mode 100644 media/libstagefright/codecs/aacdec/iquant_table.h
 create mode 100644 media/libstagefright/codecs/aacdec/long_term_prediction.cpp
 create mode 100644 media/libstagefright/codecs/aacdec/long_term_prediction.h
 create mode 100644 media/libstagefright/codecs/aacdec/long_term_synthesis.cpp
 create mode 100644 media/libstagefright/codecs/aacdec/long_term_synthesis.h
 create mode 100644 media/libstagefright/codecs/aacdec/lt_decode.cpp
 create mode 100644 media/libstagefright/codecs/aacdec/lt_decode.h
 create mode 100644 media/libstagefright/codecs/aacdec/lt_prediction.h
 create mode 100644 media/libstagefright/codecs/aacdec/ltp_common_internal.h
 create mode 100644 media/libstagefright/codecs/aacdec/mdct_fxp.cpp
 create mode 100644 media/libstagefright/codecs/aacdec/mdct_fxp.h
 create mode 100644 media/libstagefright/codecs/aacdec/mdct_tables_fxp.cpp
 create mode 100644 media/libstagefright/codecs/aacdec/mdst.cpp
 create mode 100644 media/libstagefright/codecs/aacdec/mdst.h
 create mode 100644 media/libstagefright/codecs/aacdec/mix_radix_fft.cpp
 create mode 100644 media/libstagefright/codecs/aacdec/mix_radix_fft.h
 create mode 100644 media/libstagefright/codecs/aacdec/ms_map_mask.h
 create mode 100644 media/libstagefright/codecs/aacdec/ms_synt.cpp
 create mode 100644 media/libstagefright/codecs/aacdec/ms_synt.h
 create mode 100644 media/libstagefright/codecs/aacdec/pns_corr.cpp
 create mode 100644 media/libstagefright/codecs/aacdec/pns_corr.h
 create mode 100644 media/libstagefright/codecs/aacdec/pns_intensity_right.cpp
 create mode 100644 media/libstagefright/codecs/aacdec/pns_intensity_right.h
 create mode 100644 media/libstagefright/codecs/aacdec/pns_left.cpp
 create mode 100644 media/libstagefright/codecs/aacdec/pns_left.h
 create mode 100644 media/libstagefright/codecs/aacdec/ps_all_pass_filter_coeff.cpp
 create mode 100644 media/libstagefright/codecs/aacdec/ps_all_pass_filter_coeff.h
 create mode 100644 media/libstagefright/codecs/aacdec/ps_all_pass_fract_delay_filter.cpp
 create mode 100644 media/libstagefright/codecs/aacdec/ps_all_pass_fract_delay_filter.h
 create mode 100644 media/libstagefright/codecs/aacdec/ps_allocate_decoder.cpp
 create mode 100644 media/libstagefright/codecs/aacdec/ps_allocate_decoder.h
 create mode 100644 media/libstagefright/codecs/aacdec/ps_applied.cpp
 create mode 100644 media/libstagefright/codecs/aacdec/ps_applied.h
 create mode 100644 media/libstagefright/codecs/aacdec/ps_bstr_decoding.cpp
 create mode 100644 media/libstagefright/codecs/aacdec/ps_bstr_decoding.h
 create mode 100644 media/libstagefright/codecs/aacdec/ps_channel_filtering.cpp
 create mode 100644 media/libstagefright/codecs/aacdec/ps_channel_filtering.h
 create mode 100644 media/libstagefright/codecs/aacdec/ps_constants.h
 create mode 100644 media/libstagefright/codecs/aacdec/ps_decode_bs_utils.cpp
 create mode 100644 media/libstagefright/codecs/aacdec/ps_decode_bs_utils.h
 create mode 100644 media/libstagefright/codecs/aacdec/ps_decorrelate.cpp
 create mode 100644 media/libstagefright/codecs/aacdec/ps_decorrelate.h
 create mode 100644 media/libstagefright/codecs/aacdec/ps_fft_rx8.cpp
 create mode 100644 media/libstagefright/codecs/aacdec/ps_fft_rx8.h
 create mode 100644 media/libstagefright/codecs/aacdec/ps_hybrid_analysis.cpp
 create mode 100644 media/libstagefright/codecs/aacdec/ps_hybrid_analysis.h
 create mode 100644 media/libstagefright/codecs/aacdec/ps_hybrid_filter_bank_allocation.cpp
 create mode 100644 media/libstagefright/codecs/aacdec/ps_hybrid_filter_bank_allocation.h
 create mode 100644 media/libstagefright/codecs/aacdec/ps_hybrid_synthesis.cpp
 create mode 100644 media/libstagefright/codecs/aacdec/ps_hybrid_synthesis.h
 create mode 100644 media/libstagefright/codecs/aacdec/ps_init_stereo_mixing.cpp
 create mode 100644 media/libstagefright/codecs/aacdec/ps_init_stereo_mixing.h
 create mode 100644 media/libstagefright/codecs/aacdec/ps_pwr_transient_detection.cpp
 create mode 100644 media/libstagefright/codecs/aacdec/ps_pwr_transient_detection.h
 create mode 100644 media/libstagefright/codecs/aacdec/ps_read_data.cpp
 create mode 100644 media/libstagefright/codecs/aacdec/ps_read_data.h
 create mode 100644 media/libstagefright/codecs/aacdec/ps_stereo_processing.cpp
 create mode 100644 media/libstagefright/codecs/aacdec/ps_stereo_processing.h
 create mode 100644 media/libstagefright/codecs/aacdec/pulse_nc.cpp
 create mode 100644 media/libstagefright/codecs/aacdec/pulse_nc.h
 create mode 100644 media/libstagefright/codecs/aacdec/pv_audio_type_defs.h
 create mode 100644 media/libstagefright/codecs/aacdec/pv_div.cpp
 create mode 100644 media/libstagefright/codecs/aacdec/pv_div.h
 create mode 100644 media/libstagefright/codecs/aacdec/pv_log2.cpp
 create mode 100644 media/libstagefright/codecs/aacdec/pv_log2.h
 create mode 100644 media/libstagefright/codecs/aacdec/pv_normalize.cpp
 create mode 100644 media/libstagefright/codecs/aacdec/pv_normalize.h
 create mode 100644 media/libstagefright/codecs/aacdec/pv_pow2.cpp
 create mode 100644 media/libstagefright/codecs/aacdec/pv_pow2.h
 create mode 100644 media/libstagefright/codecs/aacdec/pv_sine.cpp
 create mode 100644 media/libstagefright/codecs/aacdec/pv_sine.h
 create mode 100644 media/libstagefright/codecs/aacdec/pv_sqrt.cpp
 create mode 100644 media/libstagefright/codecs/aacdec/pv_sqrt.h
 create mode 100644 media/libstagefright/codecs/aacdec/pvmp4audiodecoder_api.h
 create mode 100644 media/libstagefright/codecs/aacdec/pvmp4audiodecoderconfig.cpp
 create mode 100644 media/libstagefright/codecs/aacdec/pvmp4audiodecoderframe.cpp
 create mode 100644 media/libstagefright/codecs/aacdec/pvmp4audiodecodergetmemrequirements.cpp
 create mode 100644 media/libstagefright/codecs/aacdec/pvmp4audiodecoderinitlibrary.cpp
 create mode 100644 media/libstagefright/codecs/aacdec/pvmp4audiodecoderresetbuffer.cpp
 create mode 100644 media/libstagefright/codecs/aacdec/pvmp4setaudioconfig.cpp
 create mode 100644 media/libstagefright/codecs/aacdec/q_normalize.cpp
 create mode 100644 media/libstagefright/codecs/aacdec/q_normalize.h
 create mode 100644 media/libstagefright/codecs/aacdec/qmf_filterbank_coeff.cpp
 create mode 100644 media/libstagefright/codecs/aacdec/qmf_filterbank_coeff.h
 create mode 100644 media/libstagefright/codecs/aacdec/s_adif_header.h
 create mode 100644 media/libstagefright/codecs/aacdec/s_bit_buffer.h
 create mode 100644 media/libstagefright/codecs/aacdec/s_bits.h
 create mode 100644 media/libstagefright/codecs/aacdec/s_ch_info.h
 create mode 100644 media/libstagefright/codecs/aacdec/s_crc_buffer.h
 create mode 100644 media/libstagefright/codecs/aacdec/s_elelist.h
 create mode 100644 media/libstagefright/codecs/aacdec/s_frameinfo.h
 create mode 100644 media/libstagefright/codecs/aacdec/s_hcb.h
 create mode 100644 media/libstagefright/codecs/aacdec/s_huffman.h
 create mode 100644 media/libstagefright/codecs/aacdec/s_hybrid.h
 create mode 100644 media/libstagefright/codecs/aacdec/s_lt_pred_status.h
 create mode 100644 media/libstagefright/codecs/aacdec/s_mc_info.h
 create mode 100644 media/libstagefright/codecs/aacdec/s_mixdown.h
 create mode 100644 media/libstagefright/codecs/aacdec/s_patch.h
 create mode 100644 media/libstagefright/codecs/aacdec/s_progconfig.h
 create mode 100644 media/libstagefright/codecs/aacdec/s_ps_dec.h
 create mode 100644 media/libstagefright/codecs/aacdec/s_pulseinfo.h
 create mode 100644 media/libstagefright/codecs/aacdec/s_sbr_channel.h
 create mode 100644 media/libstagefright/codecs/aacdec/s_sbr_dec.h
 create mode 100644 media/libstagefright/codecs/aacdec/s_sbr_element_stream.h
 create mode 100644 media/libstagefright/codecs/aacdec/s_sbr_frame_data.h
 create mode 100644 media/libstagefright/codecs/aacdec/s_sbr_header_data.h
 create mode 100644 media/libstagefright/codecs/aacdec/s_sbrbitstream.h
 create mode 100644 media/libstagefright/codecs/aacdec/s_sectinfo.h
 create mode 100644 media/libstagefright/codecs/aacdec/s_sr_info.h
 create mode 100644 media/libstagefright/codecs/aacdec/s_tdec_int_chan.h
 create mode 100644 media/libstagefright/codecs/aacdec/s_tdec_int_file.h
 create mode 100644 media/libstagefright/codecs/aacdec/s_tns_frame_info.h
 create mode 100644 media/libstagefright/codecs/aacdec/s_tnsfilt.h
 create mode 100644 media/libstagefright/codecs/aacdec/s_wnd_shape.h
 create mode 100644 media/libstagefright/codecs/aacdec/sbr_aliasing_reduction.cpp
 create mode 100644 media/libstagefright/codecs/aacdec/sbr_aliasing_reduction.h
 create mode 100644 media/libstagefright/codecs/aacdec/sbr_applied.cpp
 create mode 100644 media/libstagefright/codecs/aacdec/sbr_applied.h
 create mode 100644 media/libstagefright/codecs/aacdec/sbr_code_book_envlevel.cpp
 create mode 100644 media/libstagefright/codecs/aacdec/sbr_code_book_envlevel.h
 create mode 100644 media/libstagefright/codecs/aacdec/sbr_constants.h
 create mode 100644 media/libstagefright/codecs/aacdec/sbr_crc_check.cpp
 create mode 100644 media/libstagefright/codecs/aacdec/sbr_crc_check.h
 create mode 100644 media/libstagefright/codecs/aacdec/sbr_create_limiter_bands.cpp
 create mode 100644 media/libstagefright/codecs/aacdec/sbr_create_limiter_bands.h
 create mode 100644 media/libstagefright/codecs/aacdec/sbr_dec.cpp
 create mode 100644 media/libstagefright/codecs/aacdec/sbr_dec.h
 create mode 100644 media/libstagefright/codecs/aacdec/sbr_decode_envelope.cpp
 create mode 100644 media/libstagefright/codecs/aacdec/sbr_decode_envelope.h
 create mode 100644 media/libstagefright/codecs/aacdec/sbr_decode_huff_cw.cpp
 create mode 100644 media/libstagefright/codecs/aacdec/sbr_decode_huff_cw.h
 create mode 100644 media/libstagefright/codecs/aacdec/sbr_downsample_lo_res.cpp
 create mode 100644 media/libstagefright/codecs/aacdec/sbr_downsample_lo_res.h
 create mode 100644 media/libstagefright/codecs/aacdec/sbr_envelope_calc_tbl.cpp
 create mode 100644 media/libstagefright/codecs/aacdec/sbr_envelope_calc_tbl.h
 create mode 100644 media/libstagefright/codecs/aacdec/sbr_envelope_unmapping.cpp
 create mode 100644 media/libstagefright/codecs/aacdec/sbr_envelope_unmapping.h
 create mode 100644 media/libstagefright/codecs/aacdec/sbr_extract_extended_data.cpp
 create mode 100644 media/libstagefright/codecs/aacdec/sbr_extract_extended_data.h
 create mode 100644 media/libstagefright/codecs/aacdec/sbr_find_start_andstop_band.cpp
 create mode 100644 media/libstagefright/codecs/aacdec/sbr_find_start_andstop_band.h
 create mode 100644 media/libstagefright/codecs/aacdec/sbr_generate_high_freq.cpp
 create mode 100644 media/libstagefright/codecs/aacdec/sbr_generate_high_freq.h
 create mode 100644 media/libstagefright/codecs/aacdec/sbr_get_additional_data.cpp
 create mode 100644 media/libstagefright/codecs/aacdec/sbr_get_additional_data.h
 create mode 100644 media/libstagefright/codecs/aacdec/sbr_get_cpe.cpp
 create mode 100644 media/libstagefright/codecs/aacdec/sbr_get_cpe.h
 create mode 100644 media/libstagefright/codecs/aacdec/sbr_get_dir_control_data.cpp
 create mode 100644 media/libstagefright/codecs/aacdec/sbr_get_dir_control_data.h
 create mode 100644 media/libstagefright/codecs/aacdec/sbr_get_envelope.cpp
 create mode 100644 media/libstagefright/codecs/aacdec/sbr_get_envelope.h
 create mode 100644 media/libstagefright/codecs/aacdec/sbr_get_header_data.cpp
 create mode 100644 media/libstagefright/codecs/aacdec/sbr_get_header_data.h
 create mode 100644 media/libstagefright/codecs/aacdec/sbr_get_noise_floor_data.cpp
 create mode 100644 media/libstagefright/codecs/aacdec/sbr_get_noise_floor_data.h
 create mode 100644 media/libstagefright/codecs/aacdec/sbr_get_sce.cpp
 create mode 100644 media/libstagefright/codecs/aacdec/sbr_get_sce.h
 create mode 100644 media/libstagefright/codecs/aacdec/sbr_inv_filt_levelemphasis.cpp
 create mode 100644 media/libstagefright/codecs/aacdec/sbr_inv_filt_levelemphasis.h
 create mode 100644 media/libstagefright/codecs/aacdec/sbr_open.cpp
 create mode 100644 media/libstagefright/codecs/aacdec/sbr_open.h
 create mode 100644 media/libstagefright/codecs/aacdec/sbr_read_data.cpp
 create mode 100644 media/libstagefright/codecs/aacdec/sbr_read_data.h
 create mode 100644 media/libstagefright/codecs/aacdec/sbr_requantize_envelope_data.cpp
 create mode 100644 media/libstagefright/codecs/aacdec/sbr_requantize_envelope_data.h
 create mode 100644 media/libstagefright/codecs/aacdec/sbr_reset_dec.cpp
 create mode 100644 media/libstagefright/codecs/aacdec/sbr_reset_dec.h
 create mode 100644 media/libstagefright/codecs/aacdec/sbr_update_freq_scale.cpp
 create mode 100644 media/libstagefright/codecs/aacdec/sbr_update_freq_scale.h
 create mode 100644 media/libstagefright/codecs/aacdec/set_mc_info.cpp
 create mode 100644 media/libstagefright/codecs/aacdec/set_mc_info.h
 create mode 100644 media/libstagefright/codecs/aacdec/sfb.cpp
 create mode 100644 media/libstagefright/codecs/aacdec/sfb.h
 create mode 100644 media/libstagefright/codecs/aacdec/shellsort.cpp
 create mode 100644 media/libstagefright/codecs/aacdec/shellsort.h
 create mode 100644 media/libstagefright/codecs/aacdec/stereo_2_mono.h
 create mode 100644 media/libstagefright/codecs/aacdec/synthesis_sub_band.cpp
 create mode 100644 media/libstagefright/codecs/aacdec/synthesis_sub_band.h
 create mode 100644 media/libstagefright/codecs/aacdec/tns_ar_filter.cpp
 create mode 100644 media/libstagefright/codecs/aacdec/tns_ar_filter.h
 create mode 100644 media/libstagefright/codecs/aacdec/tns_decode_coef.cpp
 create mode 100644 media/libstagefright/codecs/aacdec/tns_decode_coef.h
 create mode 100644 media/libstagefright/codecs/aacdec/tns_inv_filter.cpp
 create mode 100644 media/libstagefright/codecs/aacdec/tns_inv_filter.h
 create mode 100644 media/libstagefright/codecs/aacdec/trans4m_freq_2_time_fxp.cpp
 create mode 100644 media/libstagefright/codecs/aacdec/trans4m_time_2_freq_fxp.cpp
 create mode 100644 media/libstagefright/codecs/aacdec/unpack_idx.cpp
 create mode 100644 media/libstagefright/codecs/aacdec/unpack_idx.h
 create mode 100644 media/libstagefright/codecs/aacdec/window_block_fxp.h
 create mode 100644 media/libstagefright/codecs/aacdec/window_tables_fxp.cpp
 create mode 100644 media/libstagefright/codecs/aacdec/write_output.h

diff --git a/media/libstagefright/codecs/aacdec/Android.mk b/media/libstagefright/codecs/aacdec/Android.mk
index 4dc38a8..91457c5 100644
--- a/media/libstagefright/codecs/aacdec/Android.mk
+++ b/media/libstagefright/codecs/aacdec/Android.mk
@@ -1,28 +1,213 @@
 LOCAL_PATH:= $(call my-dir)
 
-include $(CLEAR_VARS)
+AAC_LIBRARY = fraunhofer
 
-LOCAL_SRC_FILES := \
-      SoftAAC2.cpp
+ifeq ($(AAC_LIBRARY), fraunhofer)
+  include $(CLEAR_VARS)
 
-LOCAL_C_INCLUDES := \
-      frameworks/av/media/libstagefright/include \
-      frameworks/native/include/media/openmax \
-      external/aac/libAACdec/include \
-      external/aac/libPCMutils/include \
-      external/aac/libFDK/include \
-      external/aac/libMpegTPDec/include \
-      external/aac/libSBRdec/include \
-      external/aac/libSYS/include
+  LOCAL_SRC_FILES := \
+          SoftAAC2.cpp
 
-LOCAL_CFLAGS :=
+  LOCAL_C_INCLUDES := \
+          frameworks/av/media/libstagefright/include \
+          frameworks/native/include/media/openmax \
+          external/aac/libAACdec/include \
+          external/aac/libPCMutils/include \
+          external/aac/libFDK/include \
+          external/aac/libMpegTPDec/include \
+          external/aac/libSBRdec/include \
+          external/aac/libSYS/include
 
-LOCAL_STATIC_LIBRARIES := libFraunhoferAAC
+  LOCAL_CFLAGS :=
 
-LOCAL_SHARED_LIBRARIES := \
-      libstagefright_omx libstagefright_foundation libutils libcutils
+  LOCAL_STATIC_LIBRARIES := libFraunhoferAAC
 
-LOCAL_MODULE := libstagefright_soft_aacdec
-LOCAL_MODULE_TAGS := optional
+  LOCAL_SHARED_LIBRARIES := \
+          libstagefright_omx libstagefright_foundation libutils libcutils
 
-include $(BUILD_SHARED_LIBRARY)
+  LOCAL_MODULE := libstagefright_soft_aacdec
+  LOCAL_MODULE_TAGS := optional
+
+  include $(BUILD_SHARED_LIBRARY)
+
+else # pv
+
+  LOCAL_SRC_FILES := \
+          analysis_sub_band.cpp \
+          apply_ms_synt.cpp \
+          apply_tns.cpp \
+          buf_getbits.cpp \
+          byte_align.cpp \
+          calc_auto_corr.cpp \
+          calc_gsfb_table.cpp \
+          calc_sbr_anafilterbank.cpp \
+          calc_sbr_envelope.cpp \
+          calc_sbr_synfilterbank.cpp \
+          check_crc.cpp \
+          dct16.cpp \
+          dct64.cpp \
+          decode_huff_cw_binary.cpp \
+          decode_noise_floorlevels.cpp \
+          deinterleave.cpp \
+          digit_reversal_tables.cpp \
+          dst16.cpp \
+          dst32.cpp \
+          dst8.cpp \
+          esc_iquant_scaling.cpp \
+          extractframeinfo.cpp \
+          fft_rx4_long.cpp \
+          fft_rx4_short.cpp \
+          fft_rx4_tables_fxp.cpp \
+          find_adts_syncword.cpp \
+          fwd_long_complex_rot.cpp \
+          fwd_short_complex_rot.cpp \
+          gen_rand_vector.cpp \
+          get_adif_header.cpp \
+          get_adts_header.cpp \
+          get_audio_specific_config.cpp \
+          get_dse.cpp \
+          get_ele_list.cpp \
+          get_ga_specific_config.cpp \
+          get_ics_info.cpp \
+          get_prog_config.cpp \
+          get_pulse_data.cpp \
+          get_sbr_bitstream.cpp \
+          get_sbr_startfreq.cpp \
+          get_sbr_stopfreq.cpp \
+          get_tns.cpp \
+          getfill.cpp \
+          getgroup.cpp \
+          getics.cpp \
+          getmask.cpp \
+          hcbtables_binary.cpp \
+          huffcb.cpp \
+          huffdecode.cpp \
+          hufffac.cpp \
+          huffspec_fxp.cpp \
+          idct16.cpp \
+          idct32.cpp \
+          idct8.cpp \
+          imdct_fxp.cpp \
+          infoinit.cpp \
+          init_sbr_dec.cpp \
+          intensity_right.cpp \
+          inv_long_complex_rot.cpp \
+          inv_short_complex_rot.cpp \
+          iquant_table.cpp \
+          long_term_prediction.cpp \
+          long_term_synthesis.cpp \
+          lt_decode.cpp \
+          mdct_fxp.cpp \
+          mdct_tables_fxp.cpp \
+          mdst.cpp \
+          mix_radix_fft.cpp \
+          ms_synt.cpp \
+          pns_corr.cpp \
+          pns_intensity_right.cpp \
+          pns_left.cpp \
+          ps_all_pass_filter_coeff.cpp \
+          ps_all_pass_fract_delay_filter.cpp \
+          ps_allocate_decoder.cpp \
+          ps_applied.cpp \
+          ps_bstr_decoding.cpp \
+          ps_channel_filtering.cpp \
+          ps_decode_bs_utils.cpp \
+          ps_decorrelate.cpp \
+          ps_fft_rx8.cpp \
+          ps_hybrid_analysis.cpp \
+          ps_hybrid_filter_bank_allocation.cpp \
+          ps_hybrid_synthesis.cpp \
+          ps_init_stereo_mixing.cpp \
+          ps_pwr_transient_detection.cpp \
+          ps_read_data.cpp \
+          ps_stereo_processing.cpp \
+          pulse_nc.cpp \
+          pv_div.cpp \
+          pv_log2.cpp \
+          pv_normalize.cpp \
+          pv_pow2.cpp \
+          pv_sine.cpp \
+          pv_sqrt.cpp \
+          pvmp4audiodecoderconfig.cpp \
+          pvmp4audiodecoderframe.cpp \
+          pvmp4audiodecodergetmemrequirements.cpp \
+          pvmp4audiodecoderinitlibrary.cpp \
+          pvmp4audiodecoderresetbuffer.cpp \
+          q_normalize.cpp \
+          qmf_filterbank_coeff.cpp \
+          sbr_aliasing_reduction.cpp \
+          sbr_applied.cpp \
+          sbr_code_book_envlevel.cpp \
+          sbr_crc_check.cpp \
+          sbr_create_limiter_bands.cpp \
+          sbr_dec.cpp \
+          sbr_decode_envelope.cpp \
+          sbr_decode_huff_cw.cpp \
+          sbr_downsample_lo_res.cpp \
+          sbr_envelope_calc_tbl.cpp \
+          sbr_envelope_unmapping.cpp \
+          sbr_extract_extended_data.cpp \
+          sbr_find_start_andstop_band.cpp \
+          sbr_generate_high_freq.cpp \
+          sbr_get_additional_data.cpp \
+          sbr_get_cpe.cpp \
+          sbr_get_dir_control_data.cpp \
+          sbr_get_envelope.cpp \
+          sbr_get_header_data.cpp \
+          sbr_get_noise_floor_data.cpp \
+          sbr_get_sce.cpp \
+          sbr_inv_filt_levelemphasis.cpp \
+          sbr_open.cpp \
+          sbr_read_data.cpp \
+          sbr_requantize_envelope_data.cpp \
+          sbr_reset_dec.cpp \
+          sbr_update_freq_scale.cpp \
+          set_mc_info.cpp \
+          sfb.cpp \
+          shellsort.cpp \
+          synthesis_sub_band.cpp \
+          tns_ar_filter.cpp \
+          tns_decode_coef.cpp \
+          tns_inv_filter.cpp \
+          trans4m_freq_2_time_fxp.cpp \
+          trans4m_time_2_freq_fxp.cpp \
+          unpack_idx.cpp \
+          window_tables_fxp.cpp \
+          pvmp4setaudioconfig.cpp \
+
+  LOCAL_CFLAGS := -DAAC_PLUS -DHQ_SBR -DPARAMETRICSTEREO -DOSCL_IMPORT_REF= -DOSCL_EXPORT_REF= -DOSCL_UNUSED_ARG=
+
+  LOCAL_C_INCLUDES := \
+          frameworks/av/media/libstagefright/include \
+
+  LOCAL_ARM_MODE := arm
+
+  LOCAL_MODULE := libstagefright_aacdec
+
+  include $(BUILD_STATIC_LIBRARY)
+
+  ################################################################################
+
+  include $(CLEAR_VARS)
+
+  LOCAL_SRC_FILES := \
+        SoftAAC.cpp
+
+  LOCAL_C_INCLUDES := \
+          frameworks/av/media/libstagefright/include \
+          frameworks/native/include/media/openmax
+
+  LOCAL_CFLAGS := -DOSCL_IMPORT_REF=
+
+  LOCAL_STATIC_LIBRARIES := \
+          libstagefright_aacdec
+
+  LOCAL_SHARED_LIBRARIES := \
+          libstagefright_omx libstagefright_foundation libutils
+
+  LOCAL_MODULE := libstagefright_soft_aacdec
+  LOCAL_MODULE_TAGS := optional
+
+  include $(BUILD_SHARED_LIBRARY)
+
+endif # $(AAC_LIBRARY)
diff --git a/media/libstagefright/codecs/aacdec/SoftAAC.cpp b/media/libstagefright/codecs/aacdec/SoftAAC.cpp
new file mode 100644
index 0000000..7c82484
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/SoftAAC.cpp
@@ -0,0 +1,553 @@
+/*
+ * Copyright (C) 2011 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+//#define LOG_NDEBUG 0
+#define LOG_TAG "SoftAAC"
+#include <utils/Log.h>
+
+#include "SoftAAC.h"
+
+#include "pvmp4audiodecoder_api.h"
+
+#include <media/stagefright/foundation/ADebug.h>
+#include <media/stagefright/foundation/hexdump.h>
+#include <media/stagefright/MediaErrors.h>
+
+namespace android {
+
+template<class T>
+static void InitOMXParams(T *params) {
+    params->nSize = sizeof(T);
+    params->nVersion.s.nVersionMajor = 1;
+    params->nVersion.s.nVersionMinor = 0;
+    params->nVersion.s.nRevision = 0;
+    params->nVersion.s.nStep = 0;
+}
+
+SoftAAC::SoftAAC(
+        const char *name,
+        const OMX_CALLBACKTYPE *callbacks,
+        OMX_PTR appData,
+        OMX_COMPONENTTYPE **component)
+    : SimpleSoftOMXComponent(name, callbacks, appData, component),
+      mConfig(new tPVMP4AudioDecoderExternal),
+      mIsADTS(false),
+      mDecoderBuf(NULL),
+      mInputBufferCount(0),
+      mUpsamplingFactor(2),
+      mAnchorTimeUs(0),
+      mNumSamplesOutput(0),
+      mSignalledError(false),
+      mOutputPortSettingsChange(NONE) {
+    initPorts();
+    CHECK_EQ(initDecoder(), (status_t)OK);
+}
+
+SoftAAC::~SoftAAC() {
+    free(mDecoderBuf);
+    mDecoderBuf = NULL;
+
+    delete mConfig;
+    mConfig = NULL;
+}
+
+void SoftAAC::initPorts() {
+    OMX_PARAM_PORTDEFINITIONTYPE def;
+    InitOMXParams(&def);
+
+    def.nPortIndex = 0;
+    def.eDir = OMX_DirInput;
+    def.nBufferCountMin = kNumInputBuffers;
+    def.nBufferCountActual = def.nBufferCountMin;
+    def.nBufferSize = 8192;
+    def.bEnabled = OMX_TRUE;
+    def.bPopulated = OMX_FALSE;
+    def.eDomain = OMX_PortDomainAudio;
+    def.bBuffersContiguous = OMX_FALSE;
+    def.nBufferAlignment = 1;
+
+    def.format.audio.cMIMEType = const_cast<char *>("audio/aac");
+    def.format.audio.pNativeRender = NULL;
+    def.format.audio.bFlagErrorConcealment = OMX_FALSE;
+    def.format.audio.eEncoding = OMX_AUDIO_CodingAAC;
+
+    addPort(def);
+
+    def.nPortIndex = 1;
+    def.eDir = OMX_DirOutput;
+    def.nBufferCountMin = kNumOutputBuffers;
+    def.nBufferCountActual = def.nBufferCountMin;
+    def.nBufferSize = 8192;
+    def.bEnabled = OMX_TRUE;
+    def.bPopulated = OMX_FALSE;
+    def.eDomain = OMX_PortDomainAudio;
+    def.bBuffersContiguous = OMX_FALSE;
+    def.nBufferAlignment = 2;
+
+    def.format.audio.cMIMEType = const_cast<char *>("audio/raw");
+    def.format.audio.pNativeRender = NULL;
+    def.format.audio.bFlagErrorConcealment = OMX_FALSE;
+    def.format.audio.eEncoding = OMX_AUDIO_CodingPCM;
+
+    addPort(def);
+}
+
+status_t SoftAAC::initDecoder() {
+    memset(mConfig, 0, sizeof(tPVMP4AudioDecoderExternal));
+    mConfig->outputFormat = OUTPUTFORMAT_16PCM_INTERLEAVED;
+    mConfig->aacPlusEnabled = 1;
+
+    // The software decoder doesn't properly support mono output on
+    // AACplus files. Always output stereo.
+    mConfig->desiredChannels = 2;
+
+    UInt32 memRequirements = PVMP4AudioDecoderGetMemRequirements();
+    mDecoderBuf = malloc(memRequirements);
+
+    Int err = PVMP4AudioDecoderInitLibrary(mConfig, mDecoderBuf);
+    if (err != MP4AUDEC_SUCCESS) {
+        ALOGE("Failed to initialize MP4 audio decoder");
+        return UNKNOWN_ERROR;
+    }
+
+    return OK;
+}
+
+OMX_ERRORTYPE SoftAAC::internalGetParameter(
+        OMX_INDEXTYPE index, OMX_PTR params) {
+    switch (index) {
+        case OMX_IndexParamAudioAac:
+        {
+            OMX_AUDIO_PARAM_AACPROFILETYPE *aacParams =
+                (OMX_AUDIO_PARAM_AACPROFILETYPE *)params;
+
+            if (aacParams->nPortIndex != 0) {
+                return OMX_ErrorUndefined;
+            }
+
+            aacParams->nBitRate = 0;
+            aacParams->nAudioBandWidth = 0;
+            aacParams->nAACtools = 0;
+            aacParams->nAACERtools = 0;
+            aacParams->eAACProfile = OMX_AUDIO_AACObjectMain;
+
+            aacParams->eAACStreamFormat =
+                mIsADTS
+                    ? OMX_AUDIO_AACStreamFormatMP4ADTS
+                    : OMX_AUDIO_AACStreamFormatMP4FF;
+
+            aacParams->eChannelMode = OMX_AUDIO_ChannelModeStereo;
+
+            if (!isConfigured()) {
+                aacParams->nChannels = 1;
+                aacParams->nSampleRate = 44100;
+                aacParams->nFrameLength = 0;
+            } else {
+                aacParams->nChannels = mConfig->encodedChannels;
+                aacParams->nSampleRate = mConfig->samplingRate;
+                aacParams->nFrameLength = mConfig->frameLength;
+            }
+
+            return OMX_ErrorNone;
+        }
+
+        case OMX_IndexParamAudioPcm:
+        {
+            OMX_AUDIO_PARAM_PCMMODETYPE *pcmParams =
+                (OMX_AUDIO_PARAM_PCMMODETYPE *)params;
+
+            if (pcmParams->nPortIndex != 1) {
+                return OMX_ErrorUndefined;
+            }
+
+            pcmParams->eNumData = OMX_NumericalDataSigned;
+            pcmParams->eEndian = OMX_EndianBig;
+            pcmParams->bInterleaved = OMX_TRUE;
+            pcmParams->nBitPerSample = 16;
+            pcmParams->ePCMMode = OMX_AUDIO_PCMModeLinear;
+            pcmParams->eChannelMapping[0] = OMX_AUDIO_ChannelLF;
+            pcmParams->eChannelMapping[1] = OMX_AUDIO_ChannelRF;
+
+            if (!isConfigured()) {
+                pcmParams->nChannels = 1;
+                pcmParams->nSamplingRate = 44100;
+            } else {
+                pcmParams->nChannels = mConfig->desiredChannels;
+                pcmParams->nSamplingRate = mConfig->samplingRate;
+            }
+
+            return OMX_ErrorNone;
+        }
+
+        default:
+            return SimpleSoftOMXComponent::internalGetParameter(index, params);
+    }
+}
+
+OMX_ERRORTYPE SoftAAC::internalSetParameter(
+        OMX_INDEXTYPE index, const OMX_PTR params) {
+    switch (index) {
+        case OMX_IndexParamStandardComponentRole:
+        {
+            const OMX_PARAM_COMPONENTROLETYPE *roleParams =
+                (const OMX_PARAM_COMPONENTROLETYPE *)params;
+
+            if (strncmp((const char *)roleParams->cRole,
+                        "audio_decoder.aac",
+                        OMX_MAX_STRINGNAME_SIZE - 1)) {
+                return OMX_ErrorUndefined;
+            }
+
+            return OMX_ErrorNone;
+        }
+
+        case OMX_IndexParamAudioAac:
+        {
+            const OMX_AUDIO_PARAM_AACPROFILETYPE *aacParams =
+                (const OMX_AUDIO_PARAM_AACPROFILETYPE *)params;
+
+            if (aacParams->nPortIndex != 0) {
+                return OMX_ErrorUndefined;
+            }
+
+            if (aacParams->eAACStreamFormat == OMX_AUDIO_AACStreamFormatMP4FF) {
+                mIsADTS = false;
+            } else if (aacParams->eAACStreamFormat
+                        == OMX_AUDIO_AACStreamFormatMP4ADTS) {
+                mIsADTS = true;
+            } else {
+                return OMX_ErrorUndefined;
+            }
+
+            return OMX_ErrorNone;
+        }
+
+        case OMX_IndexParamAudioPcm:
+        {
+            const OMX_AUDIO_PARAM_PCMMODETYPE *pcmParams =
+                (OMX_AUDIO_PARAM_PCMMODETYPE *)params;
+
+            if (pcmParams->nPortIndex != 1) {
+                return OMX_ErrorUndefined;
+            }
+
+            return OMX_ErrorNone;
+        }
+
+        default:
+            return SimpleSoftOMXComponent::internalSetParameter(index, params);
+    }
+}
+
+bool SoftAAC::isConfigured() const {
+    return mInputBufferCount > 0;
+}
+
+void SoftAAC::onQueueFilled(OMX_U32 portIndex) {
+    if (mSignalledError || mOutputPortSettingsChange != NONE) {
+        return;
+    }
+
+    List<BufferInfo *> &inQueue = getPortQueue(0);
+    List<BufferInfo *> &outQueue = getPortQueue(1);
+
+    if (portIndex == 0 && mInputBufferCount == 0) {
+        ++mInputBufferCount;
+
+        BufferInfo *info = *inQueue.begin();
+        OMX_BUFFERHEADERTYPE *header = info->mHeader;
+
+        mConfig->pInputBuffer = header->pBuffer + header->nOffset;
+        mConfig->inputBufferCurrentLength = header->nFilledLen;
+        mConfig->inputBufferMaxLength = 0;
+
+        Int err = PVMP4AudioDecoderConfig(mConfig, mDecoderBuf);
+        if (err != MP4AUDEC_SUCCESS) {
+            mSignalledError = true;
+            notify(OMX_EventError, OMX_ErrorUndefined, err, NULL);
+            return;
+        }
+
+        inQueue.erase(inQueue.begin());
+        info->mOwnedByUs = false;
+        notifyEmptyBufferDone(header);
+
+        notify(OMX_EventPortSettingsChanged, 1, 0, NULL);
+        mOutputPortSettingsChange = AWAITING_DISABLED;
+        return;
+    }
+
+    while (!inQueue.empty() && !outQueue.empty()) {
+        BufferInfo *inInfo = *inQueue.begin();
+        OMX_BUFFERHEADERTYPE *inHeader = inInfo->mHeader;
+
+        BufferInfo *outInfo = *outQueue.begin();
+        OMX_BUFFERHEADERTYPE *outHeader = outInfo->mHeader;
+
+        if (inHeader->nFlags & OMX_BUFFERFLAG_EOS) {
+            inQueue.erase(inQueue.begin());
+            inInfo->mOwnedByUs = false;
+            notifyEmptyBufferDone(inHeader);
+
+            outHeader->nFilledLen = 0;
+            outHeader->nFlags = OMX_BUFFERFLAG_EOS;
+
+            outQueue.erase(outQueue.begin());
+            outInfo->mOwnedByUs = false;
+            notifyFillBufferDone(outHeader);
+            return;
+        }
+
+        if (inHeader->nOffset == 0) {
+            mAnchorTimeUs = inHeader->nTimeStamp;
+            mNumSamplesOutput = 0;
+        }
+
+        size_t adtsHeaderSize = 0;
+        if (mIsADTS) {
+            // skip 30 bits, aac_frame_length follows.
+            // ssssssss ssssiiip ppffffPc ccohCCll llllllll lll?????
+
+            const uint8_t *adtsHeader = inHeader->pBuffer + inHeader->nOffset;
+
+            bool signalError = false;
+            if (inHeader->nFilledLen < 7) {
+                ALOGE("Audio data too short to contain even the ADTS header. "
+                      "Got %ld bytes.", inHeader->nFilledLen);
+                hexdump(adtsHeader, inHeader->nFilledLen);
+                signalError = true;
+            } else {
+                bool protectionAbsent = (adtsHeader[1] & 1);
+
+                unsigned aac_frame_length =
+                    ((adtsHeader[3] & 3) << 11)
+                    | (adtsHeader[4] << 3)
+                    | (adtsHeader[5] >> 5);
+
+                if (inHeader->nFilledLen < aac_frame_length) {
+                    ALOGE("Not enough audio data for the complete frame. "
+                          "Got %ld bytes, frame size according to the ADTS "
+                          "header is %u bytes.",
+                          inHeader->nFilledLen, aac_frame_length);
+                    hexdump(adtsHeader, inHeader->nFilledLen);
+                    signalError = true;
+                } else {
+                    adtsHeaderSize = (protectionAbsent ? 7 : 9);
+
+                    mConfig->pInputBuffer =
+                        (UChar *)adtsHeader + adtsHeaderSize;
+
+                    mConfig->inputBufferCurrentLength =
+                        aac_frame_length - adtsHeaderSize;
+
+                    inHeader->nOffset += adtsHeaderSize;
+                    inHeader->nFilledLen -= adtsHeaderSize;
+                }
+            }
+
+            if (signalError) {
+                mSignalledError = true;
+
+                notify(OMX_EventError, OMX_ErrorStreamCorrupt,
+                       ERROR_MALFORMED, NULL);
+
+                return;
+            }
+        } else {
+            mConfig->pInputBuffer = inHeader->pBuffer + inHeader->nOffset;
+            mConfig->inputBufferCurrentLength = inHeader->nFilledLen;
+        }
+
+        mConfig->inputBufferMaxLength = 0;
+        mConfig->inputBufferUsedLength = 0;
+        mConfig->remainderBits = 0;
+
+        mConfig->pOutputBuffer =
+            reinterpret_cast<Int16 *>(outHeader->pBuffer + outHeader->nOffset);
+
+        mConfig->pOutputBuffer_plus = &mConfig->pOutputBuffer[2048];
+        mConfig->repositionFlag = false;
+
+        Int32 prevSamplingRate = mConfig->samplingRate;
+        Int decoderErr = PVMP4AudioDecodeFrame(mConfig, mDecoderBuf);
+
+        /*
+         * AAC+/eAAC+ streams can be signalled in two ways: either explicitly
+         * or implicitly, according to MPEG4 spec. AAC+/eAAC+ is a dual
+         * rate system and the sampling rate in the final output is actually
+         * doubled compared with the core AAC decoder sampling rate.
+         *
+         * Explicit signalling is done by explicitly defining SBR audio object
+         * type in the bitstream. Implicit signalling is done by embedding
+         * SBR content in AAC extension payload specific to SBR, and hence
+         * requires an AAC decoder to perform pre-checks on actual audio frames.
+         *
+         * Thus, we could not say for sure whether a stream is
+         * AAC+/eAAC+ until the first data frame is decoded.
+         */
+        if (decoderErr == MP4AUDEC_SUCCESS && mInputBufferCount <= 2) {
+            ALOGV("audio/extended audio object type: %d + %d",
+                mConfig->audioObjectType, mConfig->extendedAudioObjectType);
+            ALOGV("aac+ upsampling factor: %d desired channels: %d",
+                mConfig->aacPlusUpsamplingFactor, mConfig->desiredChannels);
+
+            if (mInputBufferCount == 1) {
+                mUpsamplingFactor = mConfig->aacPlusUpsamplingFactor;
+                // Check on the sampling rate to see whether it is changed.
+                if (mConfig->samplingRate != prevSamplingRate) {
+                    ALOGW("Sample rate was %d Hz, but now is %d Hz",
+                            prevSamplingRate, mConfig->samplingRate);
+
+                    // We'll hold onto the input buffer and will decode
+                    // it again once the output port has been reconfigured.
+
+                    // We're going to want to revisit this input buffer, but
+                    // may have already advanced the offset. Undo that if
+                    // necessary.
+                    inHeader->nOffset -= adtsHeaderSize;
+                    inHeader->nFilledLen += adtsHeaderSize;
+
+                    notify(OMX_EventPortSettingsChanged, 1, 0, NULL);
+                    mOutputPortSettingsChange = AWAITING_DISABLED;
+                    return;
+                }
+            } else {  // mInputBufferCount == 2
+                if (mConfig->extendedAudioObjectType == MP4AUDIO_AAC_LC ||
+                    mConfig->extendedAudioObjectType == MP4AUDIO_LTP) {
+                    if (mUpsamplingFactor == 2) {
+                        // The stream turns out to be not aacPlus mode anyway
+                        ALOGW("Disable AAC+/eAAC+ since extended audio object "
+                             "type is %d",
+                             mConfig->extendedAudioObjectType);
+                        mConfig->aacPlusEnabled = 0;
+                    }
+                } else {
+                    if (mUpsamplingFactor == 1) {
+                        // aacPlus mode does not buy us anything, but to cause
+                        // 1. CPU load to increase, and
+                        // 2. a half speed of decoding
+                        ALOGW("Disable AAC+/eAAC+ since upsampling factor is 1");
+                        mConfig->aacPlusEnabled = 0;
+                    }
+                }
+            }
+        }
+
+        size_t numOutBytes =
+            mConfig->frameLength * sizeof(int16_t) * mConfig->desiredChannels;
+
+        if (decoderErr == MP4AUDEC_SUCCESS) {
+            CHECK_LE(mConfig->inputBufferUsedLength, inHeader->nFilledLen);
+
+            inHeader->nFilledLen -= mConfig->inputBufferUsedLength;
+            inHeader->nOffset += mConfig->inputBufferUsedLength;
+        } else {
+            ALOGW("AAC decoder returned error %d, substituting silence",
+                 decoderErr);
+
+            memset(outHeader->pBuffer + outHeader->nOffset, 0, numOutBytes);
+
+            // Discard input buffer.
+            inHeader->nFilledLen = 0;
+
+            // fall through
+        }
+
+        if (decoderErr == MP4AUDEC_SUCCESS || mNumSamplesOutput > 0) {
+            // We'll only output data if we successfully decoded it or
+            // we've previously decoded valid data, in the latter case
+            // (decode failed) we'll output a silent frame.
+
+            if (mUpsamplingFactor == 2) {
+                if (mConfig->desiredChannels == 1) {
+                    memcpy(&mConfig->pOutputBuffer[1024],
+                           &mConfig->pOutputBuffer[2048],
+                           numOutBytes * 2);
+                }
+                numOutBytes *= 2;
+            }
+
+            outHeader->nFilledLen = numOutBytes;
+            outHeader->nFlags = 0;
+
+            outHeader->nTimeStamp =
+                mAnchorTimeUs
+                    + (mNumSamplesOutput * 1000000ll) / mConfig->samplingRate;
+
+            mNumSamplesOutput += mConfig->frameLength * mUpsamplingFactor;
+
+            outInfo->mOwnedByUs = false;
+            outQueue.erase(outQueue.begin());
+            outInfo = NULL;
+            notifyFillBufferDone(outHeader);
+            outHeader = NULL;
+        }
+
+        if (inHeader->nFilledLen == 0) {
+            inInfo->mOwnedByUs = false;
+            inQueue.erase(inQueue.begin());
+            inInfo = NULL;
+            notifyEmptyBufferDone(inHeader);
+            inHeader = NULL;
+        }
+
+        if (decoderErr == MP4AUDEC_SUCCESS) {
+            ++mInputBufferCount;
+        }
+    }
+}
+
+void SoftAAC::onPortFlushCompleted(OMX_U32 portIndex) {
+    if (portIndex == 0) {
+        // Make sure that the next buffer output does not still
+        // depend on fragments from the last one decoded.
+        PVMP4AudioDecoderResetBuffer(mDecoderBuf);
+    }
+}
+
+void SoftAAC::onPortEnableCompleted(OMX_U32 portIndex, bool enabled) {
+    if (portIndex != 1) {
+        return;
+    }
+
+    switch (mOutputPortSettingsChange) {
+        case NONE:
+            break;
+
+        case AWAITING_DISABLED:
+        {
+            CHECK(!enabled);
+            mOutputPortSettingsChange = AWAITING_ENABLED;
+            break;
+        }
+
+        default:
+        {
+            CHECK_EQ((int)mOutputPortSettingsChange, (int)AWAITING_ENABLED);
+            CHECK(enabled);
+            mOutputPortSettingsChange = NONE;
+            break;
+        }
+    }
+}
+
+}  // namespace android
+
+android::SoftOMXComponent *createSoftOMXComponent(
+        const char *name, const OMX_CALLBACKTYPE *callbacks,
+        OMX_PTR appData, OMX_COMPONENTTYPE **component) {
+    return new android::SoftAAC(name, callbacks, appData, component);
+}
diff --git a/media/libstagefright/codecs/aacdec/SoftAAC.h b/media/libstagefright/codecs/aacdec/SoftAAC.h
new file mode 100644
index 0000000..2e75005
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/SoftAAC.h
@@ -0,0 +1,78 @@
+/*
+ * Copyright (C) 2011 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef SOFT_AAC_H_
+
+#define SOFT_AAC_H_
+
+#include "SimpleSoftOMXComponent.h"
+
+struct tPVMP4AudioDecoderExternal;
+
+namespace android {
+
+struct SoftAAC : public SimpleSoftOMXComponent {
+    SoftAAC(const char *name,
+            const OMX_CALLBACKTYPE *callbacks,
+            OMX_PTR appData,
+            OMX_COMPONENTTYPE **component);
+
+protected:
+    virtual ~SoftAAC();
+
+    virtual OMX_ERRORTYPE internalGetParameter(
+            OMX_INDEXTYPE index, OMX_PTR params);
+
+    virtual OMX_ERRORTYPE internalSetParameter(
+            OMX_INDEXTYPE index, const OMX_PTR params);
+
+    virtual void onQueueFilled(OMX_U32 portIndex);
+    virtual void onPortFlushCompleted(OMX_U32 portIndex);
+    virtual void onPortEnableCompleted(OMX_U32 portIndex, bool enabled);
+
+private:
+    enum {
+        kNumInputBuffers        = 4,
+        kNumOutputBuffers       = 4,
+    };
+
+    tPVMP4AudioDecoderExternal *mConfig;
+    bool mIsADTS;
+    void *mDecoderBuf;
+
+    size_t mInputBufferCount;
+    size_t mUpsamplingFactor;
+    int64_t mAnchorTimeUs;
+    int64_t mNumSamplesOutput;
+
+    bool mSignalledError;
+
+    enum {
+        NONE,
+        AWAITING_DISABLED,
+        AWAITING_ENABLED
+    } mOutputPortSettingsChange;
+
+    void initPorts();
+    status_t initDecoder();
+    bool isConfigured() const;
+
+    DISALLOW_EVIL_CONSTRUCTORS(SoftAAC);
+};
+
+}  // namespace android
+
+#endif  // SOFT_AAC_H_
diff --git a/media/libstagefright/codecs/aacdec/aac_mem_funcs.h b/media/libstagefright/codecs/aacdec/aac_mem_funcs.h
new file mode 100644
index 0000000..ce7cb12
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/aac_mem_funcs.h
@@ -0,0 +1,50 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+ Filename: aac_mem_funcs.h
+ Funtions:
+
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+
+ Who:                                   Date: MM/DD/YYYY
+ Description:
+------------------------------------------------------------------------------
+
+
+----------------------------------------------------------------------------
+; CONTINUE ONLY IF NOT ALREADY DEFINED
+----------------------------------------------------------------------------*/
+
+#include <string.h>
+
+#ifndef AAC_MEM_FUNCS_H
+#define AAC_MEM_FUNCS_H
+
+#define pv_memset(to, c, n)         memset(to, c, n)
+
+
+#define pv_memcpy(to, from, n)      memcpy(to, from, n)
+#define pv_memmove(to, from, n)     memmove(to, from, n)
+#define pv_memcmp(p, q, n)          memcmp(p, q, n)
+
+
+
+#endif
diff --git a/media/libstagefright/codecs/aacdec/analysis_sub_band.cpp b/media/libstagefright/codecs/aacdec/analysis_sub_band.cpp
new file mode 100644
index 0000000..2786dcc
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/analysis_sub_band.cpp
@@ -0,0 +1,289 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Filename: analysis_sub_band.c
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+
+ Who:                                   Date: MM/DD/YYYY
+ Description:
+
+------------------------------------------------------------------------------
+ INPUT AND OUTPUT DEFINITIONS
+
+    Int32 vec[],            Input vector, 32-bit
+    const Int32 *cosTerms,  Cosine Terms
+    Int   maxbands          number of bands used
+    Int32 *scratch_mem      Scratch memory
+
+
+------------------------------------------------------------------------------
+ FUNCTION DESCRIPTION
+
+    Implement root squared of a number
+
+------------------------------------------------------------------------------
+ REQUIREMENTS
+
+
+------------------------------------------------------------------------------
+ REFERENCES
+
+------------------------------------------------------------------------------
+ PSEUDO-CODE
+
+------------------------------------------------------------------------------
+*/
+
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+
+#ifdef AAC_PLUS
+
+
+#include "analysis_sub_band.h"
+#include "dst32.h"
+#include "idct32.h"
+#include "mdst.h"
+
+#include "aac_mem_funcs.h"
+#include "pv_audio_type_defs.h"
+#include "fxp_mul32.h"
+
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here. Include conditional
+; compile variables also.
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; LOCAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; LOCAL STORE/BUFFER/POINTER DEFINITIONS
+; Variable declaration - defined here and used outside this module
+----------------------------------------------------------------------------*/
+
+
+#ifdef HQ_SBR
+
+
+const Int32 exp_1_5_phi[32] =
+{
+
+    0x7FEA04B6,  0x7F380E1C, 0x7DD6176E, 0x7BC6209F,
+    0x790A29A4,  0x75A6326E, 0x719E3AF3, 0x6CF94326,
+    0x67BD4AFB,  0x61F15269, 0x5B9D5964, 0x54CA5FE4,
+    0x4D8165DE,  0x45CD6B4B, 0x3DB87023, 0x354E7460,
+    0x2C9977FB,  0x23A77AEF, 0x1A837D3A, 0x113A7ED6,
+    0x07D97FC2,  0xFE6E7FFE, 0xF5057F87, 0xEBAB7E60,
+    0xE26D7C89,  0xD9587A06, 0xD07976D9, 0xC7DB7308,
+    0xBF8C6E97,  0xB796698C, 0xB00563EF, 0xA8E25DC8,
+
+};
+
+#endif
+
+
+/*----------------------------------------------------------------------------
+; EXTERNAL FUNCTION REFERENCES
+; Declare functions defined elsewhere and referenced in this module
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL GLOBAL STORE/BUFFER/POINTER REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; FUNCTION CODE
+----------------------------------------------------------------------------*/
+
+
+void analysis_sub_band_LC(Int32 vec[64],
+                          Int32 cosine_total[],
+                          Int32 maxBand,
+                          Int32 scratch_mem[][64])
+{
+    Int32 i;
+    Int32 *cosine_term = &scratch_mem[0][0];
+    Int32 *sine_term   = &scratch_mem[0][32];
+
+    Int32 *pt_cos_t;
+
+
+    Int32 *pt_vec    =  &vec[0];
+    Int32 *pt_vec_32 =  &vec[32];
+
+    Int32 *pt_cos = cosine_term;
+    Int32 *pt_sin = sine_term;
+
+    for (i = 8; i != 0; i--)
+    {
+        Int32 tmp1 = *(pt_vec_32++);
+        Int32 tmp3 = *(pt_vec_32++);
+        Int32 tmp2 = *(pt_vec++);
+        Int32 tmp4 = *(pt_vec++);
+        *(pt_cos++) = (tmp1 - tmp2) >> 1;
+        *(pt_cos++) = (tmp3 - tmp4) >> 1;
+        *(pt_sin++) = (tmp1 + tmp2);
+        *(pt_sin++) = (tmp3 + tmp4);
+        tmp1 = *(pt_vec_32++);
+        tmp3 = *(pt_vec_32++);
+        tmp2 = *(pt_vec++);
+        tmp4 = *(pt_vec++);
+        *(pt_cos++) = (tmp1 - tmp2) >> 1;
+        *(pt_cos++) = (tmp3 - tmp4) >> 1;
+        *(pt_sin++) = (tmp1 + tmp2);
+        *(pt_sin++) = (tmp3 + tmp4);
+    }
+
+
+    idct_32(cosine_term, scratch_mem[1]);
+
+    dst_32(sine_term, scratch_mem[1]);
+
+    pt_cos  = cosine_term;
+    pt_sin  = sine_term;
+
+    pt_cos_t  = cosine_total;
+
+    for (i = 0; i < maxBand; i += 4)
+    {
+        *(pt_cos_t++) = (*(pt_cos++) + *(pt_sin++));
+        *(pt_cos_t++) = (-*(pt_cos++) + *(pt_sin++));
+        *(pt_cos_t++) = (-*(pt_cos++) - *(pt_sin++));
+        *(pt_cos_t++) = (*(pt_cos++) - *(pt_sin++));
+    }
+
+    pt_cos_t  = &cosine_total[maxBand];
+
+    for (i = (32 - maxBand); i != 0; i--)
+    {
+        *(pt_cos_t++) =   0;
+    }
+}
+
+
+#ifdef HQ_SBR
+
+
+void analysis_sub_band(Int32 vec[64],
+                       Int32 cosine_total[],
+                       Int32 sine_total[],
+                       Int32 maxBand,
+                       Int32 scratch_mem[][64])
+{
+    Int32 i;
+    Int32 *sine_term1   = &scratch_mem[0][0];
+    Int32 *sine_term2   = &scratch_mem[0][32];
+
+    Int32 temp1;
+    Int32 temp2;
+    Int32 temp3;
+    Int32 temp4;
+
+    const Int32 *pt_exp;
+    Int32 exp_1_5;
+
+    Int32 *pt_vec    =  &vec[0];
+    Int32 *pt_vec_32 =  &vec[32];
+
+    Int32 *pt_cos1 = pt_vec;
+    Int32 *pt_sin1 = sine_term1;
+    Int32 *pt_cos2 = pt_vec_32;
+    Int32 *pt_sin2 = sine_term2;
+
+
+    pv_memcpy(sine_term1, vec, 64*sizeof(*vec));
+
+    mdst_32(sine_term1, scratch_mem[1]);
+    mdst_32(sine_term2, scratch_mem[1]);
+
+    mdct_32(&vec[ 0]);
+    mdct_32(&vec[32]);
+
+    pt_cos1 = &vec[ 0];
+    pt_cos2 = &vec[32];
+
+
+    pt_sin1 = sine_term1;
+    pt_sin2 = sine_term2;
+
+    pt_vec     = cosine_total;
+    pt_vec_32  =   sine_total;
+    pt_exp  = exp_1_5_phi;
+
+    temp3 = (*(pt_cos1++) - *(pt_sin2++));
+    temp4 = (*(pt_sin1++) + *(pt_cos2++));
+
+    for (i = 0; i < maxBand; i += 2)
+    {
+
+        exp_1_5 = *(pt_exp++);
+        temp1    =  cmplx_mul32_by_16(temp3,  temp4, exp_1_5);
+        temp2    =  cmplx_mul32_by_16(temp4, -temp3, exp_1_5);
+
+        *(pt_vec++)    =  shft_lft_1(temp1);
+        *(pt_vec_32++) =  shft_lft_1(temp2);
+
+        temp3 = (*(pt_cos1++) + *(pt_sin2++));
+        temp4 = (*(pt_sin1++) - *(pt_cos2++));
+
+        exp_1_5 = *(pt_exp++);
+        temp1    =  cmplx_mul32_by_16(temp3,  temp4, exp_1_5);
+        temp2    =  cmplx_mul32_by_16(temp4, -temp3, exp_1_5);
+
+        *(pt_vec++)    =  shft_lft_1(temp1);
+        *(pt_vec_32++) =  shft_lft_1(temp2);
+
+        temp3 = (*(pt_cos1++) - *(pt_sin2++));
+        temp4 = (*(pt_sin1++) + *(pt_cos2++));
+    }
+
+
+    pt_cos1  = &cosine_total[maxBand];  /* in the chance that maxband is not even */
+    pt_sin1  = &sine_total[maxBand];
+
+    for (i = (32 - maxBand); i != 0; i--)
+    {
+        *(pt_cos1++) =  0;
+        *(pt_sin1++) =  0;
+    }
+
+}
+
+
+#endif
+
+#endif
+
diff --git a/media/libstagefright/codecs/aacdec/analysis_sub_band.h b/media/libstagefright/codecs/aacdec/analysis_sub_band.h
new file mode 100644
index 0000000..815456c
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/analysis_sub_band.h
@@ -0,0 +1,82 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Pathname: ./c/include/analysis_sub_band.h
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+ Who:                                       Date:
+ Description:
+------------------------------------------------------------------------------
+ INCLUDE DESCRIPTION
+
+------------------------------------------------------------------------------
+*/
+
+#ifndef ANALYSIS_SUB_BAND_H
+#define ANALYSIS_SUB_BAND_H
+
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+
+#include "pv_audio_type_defs.h"
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+    /*----------------------------------------------------------------------------
+    ; EXTERNAL VARIABLES REFERENCES
+    ----------------------------------------------------------------------------*/
+
+    /*----------------------------------------------------------------------------
+    ; DEFINES AND SIMPLE TYPEDEF'S
+    ----------------------------------------------------------------------------*/
+
+
+    void analysis_sub_band_LC(Int32 vec[64],
+    Int32 cosine_total[],
+    Int32 maxBand,
+    Int32 scratch_mem[][64]);
+
+#ifdef HQ_SBR
+
+
+    void analysis_sub_band(Int32 vec[64],
+                           Int32 cosine_total[],
+                           Int32 sine_total[],
+                           Int32 maxBand,
+                           Int32 scratch_mem[][64]);
+
+#endif
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif  /* ANALYSIS_SUB_BAND_H */
diff --git a/media/libstagefright/codecs/aacdec/apply_ms_synt.cpp b/media/libstagefright/codecs/aacdec/apply_ms_synt.cpp
new file mode 100644
index 0000000..ab36c6a
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/apply_ms_synt.cpp
@@ -0,0 +1,454 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Pathname: ./src/apply_ms_synt.c
+
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+ Description: Updated pseudocode to correct capitalized format for the IF
+ FOR and WHILE statements.
+
+ Description: Delete local variable start_indx, since it is never used.
+
+ Who:                       Date:
+ Description:
+------------------------------------------------------------------------------
+ INPUT AND OUTPUT DEFINITIONS
+
+ Inputs:
+
+    pFrameInfo = Pointer to structure that holds information about each group.
+                 (long block flag, number of windows, scalefactor bands
+                  per group, etc.)
+                 [const pFrameInfo * const]
+
+    group      = Array that contains indexes of the
+                 first window in the next group.
+                 [const Int *, length 8]
+
+    mask_map   = Array that denotes whether M/S stereo is turned on for
+                 each grouped scalefactor band.
+                 [const Int *, length MAX_SFB]
+
+    codebook_map = Array that denotes which Huffman codebook was used for
+                   the encoding of each grouped scalefactor band.
+                   [const Int *, length MAX_SFB]
+
+    coefLeft = Array containing the fixed-point spectral coefficients
+                       for the left channel.
+                       [Int32 *, length 1024]
+
+    coefRight = Array containing the fixed-point spectral coefficients
+                        for the right channel.
+                        [Int32 *, length 1024]
+
+    q_formatLeft = The Q-format for the left channel's fixed-point spectral
+                   coefficients, on a per-scalefactor band, non-grouped basis.
+                   [Int *, length MAX_SFB]
+
+    q_formatRight = The Q-format for the right channel's fixed-point spectral
+                    coefficients, on a per-scalefactor band, non-grouped basis.
+                    [Int *, length MAX_SFB]
+
+ Local Stores/Buffers/Pointers Needed:
+    None
+
+ Global Stores/Buffers/Pointers Needed:
+    None
+
+ Outputs:
+    None
+
+ Pointers and Buffers Modified:
+    coefLeft  = Contains the new spectral information.
+
+    coefRight = Contains the new spectral information.
+
+    q_formatLeft      = Q-format may be updated with changed to fixed-point
+                        data in coefLeft.
+
+    q_formatRight     = Q-format may be updated with changed to fixed-point
+                        data in coefRight.
+
+ Local Stores Modified:
+    None
+
+ Global Stores Modified:
+    None
+
+------------------------------------------------------------------------------
+ FUNCTION DESCRIPTION
+
+ This function steps through all of the tools that are applied on a
+ scalefactor band basis.
+
+ The use of M/S stereo is checked for.  For M/S decoding to take
+ place, ms_mask_map must be TRUE for that particular SFB, AND the Huffman
+ codebook used must be < NOISE_HCB.
+
+------------------------------------------------------------------------------
+ REQUIREMENTS
+
+
+------------------------------------------------------------------------------
+ REFERENCES
+
+ (1) ISO/IEC 14496-3:1999(E)
+     Part 3
+        Subpart 4.6.7.1   M/S stereo
+        Subpart 4.6.2     ScaleFactors
+
+ (2) MPEG-2 NBC Audio Decoder
+   "This software module was originally developed by AT&T, Dolby
+   Laboratories, Fraunhofer Gesellschaft IIS in the course of development
+   of the MPEG-2 NBC/MPEG-4 Audio standard ISO/IEC 13818-7, 14496-1,2 and
+   3. This software module is an implementation of a part of one or more
+   MPEG-2 NBC/MPEG-4 Audio tools as specified by the MPEG-2 NBC/MPEG-4
+   Audio standard. ISO/IEC  gives users of the MPEG-2 NBC/MPEG-4 Audio
+   standards free license to this software module or modifications thereof
+   for use in hardware or software products claiming conformance to the
+   MPEG-2 NBC/MPEG-4 Audio  standards. Those intending to use this software
+   module in hardware or software products are advised that this use may
+   infringe existing patents. The original developer of this software
+   module and his/her company, the subsequent editors and their companies,
+   and ISO/IEC have no liability for use of this software module or
+   modifications thereof in an implementation. Copyright is not released
+   for non MPEG-2 NBC/MPEG-4 Audio conforming products.The original
+   developer retains full right to use the code for his/her own purpose,
+   assign or donate the code to a third party and to inhibit third party
+   from using the code for non MPEG-2 NBC/MPEG-4 Audio conforming products.
+   This copyright notice must be included in all copies or derivative
+   works."
+   Copyright(c)1996.
+
+------------------------------------------------------------------------------
+ PSEUDO-CODE
+
+    pCoefRight = coefRight;
+    pCoefLeft = coefLeft;
+
+    window_start = 0;
+    tot_sfb = 0;
+
+    coef_per_win = pFrameInfo->coef_per_win[0];
+
+    sfb_per_win = pFrameInfo->sfb_per_win[0];
+
+    DO
+
+        pBand     = pFrameInfo->win_sfb_top[window_start];
+
+        partition = *(pGroup);
+
+        pGroup = pGroup + 1;
+
+        band_start = 0;
+
+        wins_in_group = (partition - window_start);
+
+        FOR (sfb = sfb_per_win; sfb > 0; sfb--)
+
+            band_stop = *(pBand);
+
+            pBand = pBand + 1;
+
+            codebook = *(pCodebookMap);
+
+            pCodebookMap = pCodebookMap + 1;
+
+            mask_enabled = *(pMaskMap);
+
+            pMaskMap = pMaskMap + 1;
+
+            IF (codebook < NOISE_HCB)
+            THEN
+                IF (mask_enabled != FALSE)
+                THEN
+                    band_length = band_stop - band_start;
+
+                    CALL
+                        ms_synt(
+                            wins_in_group,
+                            coef_per_win,
+                            sfb_per_win,
+                            band_length,
+                           &(pCoefLeft[band_start]),
+                           &(pCoefRight[band_start]),
+                           &(q_formatLeft[tot_sfb]),
+                           &(q_formatRight[tot_sfb]) );
+
+                    MODIFYING
+                        &(pCoefLeft[band_start]),
+                        &(pCoefRight[band_start]),
+                        &(q_formatLeft[tot_sfb]),
+                        &(q_formatRight[tot_sfb])
+
+                    RETURNING
+                        None
+                ENDIF
+            ENDIF
+            band_start = band_stop;
+
+            tot_sfb = tot_sfb + 1;
+
+        ENDFOR
+
+        pCoefRight = pCoefRight + coef_per_win * wins_in_group;
+        pCoefLeft  = pCoefLeft  + coef_per_win * wins_in_group;
+
+        wins_in_group = wins_in_group - 1;
+
+        tot_sfb = tot_sfb + sfb_per_win * wins_in_group;
+
+        window_start = partition;
+
+    WHILE (partition < pFrameInfo->num_win);
+
+    return;
+------------------------------------------------------------------------------
+ RESOURCES USED
+   When the code is written for a specific target processor the
+     resources used should be documented below.
+
+ STACK USAGE: [stack count for this module] + [variable to represent
+          stack usage for each subroutine called]
+
+     where: [stack usage variable] = stack usage for [subroutine
+         name] (see [filename].ext)
+
+ DATA MEMORY USED: x words
+
+ PROGRAM MEMORY USED: x words
+
+ CLOCK CYCLES: [cycle count equation for this module] + [variable
+           used to represent cycle count for each subroutine
+           called]
+
+     where: [cycle count variable] = cycle count for [subroutine
+        name] (see [filename].ext)
+
+------------------------------------------------------------------------------
+*/
+
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+#include "pv_audio_type_defs.h"
+#include "apply_ms_synt.h"
+#include "e_huffmanconst.h"
+#include "ms_synt.h"
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here. Include conditional
+; compile variables also.
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; LOCAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; LOCAL STORE/BUFFER/POINTER DEFINITIONS
+; Variable declaration - defined here and used outside this module
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL FUNCTION REFERENCES
+; Declare functions defined elsewhere and referenced in this module
+----------------------------------------------------------------------------*/
+
+
+/*----------------------------------------------------------------------------
+; EXTERNAL GLOBAL STORE/BUFFER/POINTER REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; FUNCTION CODE
+----------------------------------------------------------------------------*/
+
+void apply_ms_synt(
+    const FrameInfo * const pFrameInfo,
+    const Int        group[],
+    const Bool       mask_map[],
+    const Int        codebook_map[],
+    Int32      coefLeft[],
+    Int32      coefRight[],
+    Int        q_formatLeft[MAXBANDS],
+    Int        q_formatRight[MAXBANDS])
+
+{
+
+    Int32   *pCoefRight;
+
+    Int32   *pCoefLeft;
+
+    Int     tot_sfb;
+    Int     sfb;
+
+    Int     band_length;
+    Int     band_start;
+    Int     band_stop;
+    Int     coef_per_win;
+
+    Int     codebook;
+    Int     partition;
+    Int     window_start;
+
+    Int     sfb_per_win;
+    Int     wins_in_group;
+
+    const Int16 *pBand;
+    const Int   *pCodebookMap  = codebook_map;
+    const Int   *pGroup        = group;
+    const Bool  *pMaskMap      = mask_map;
+
+    Bool mask_enabled;
+
+    pCoefRight = coefRight;
+    pCoefLeft = coefLeft;
+
+    window_start = 0;
+    tot_sfb = 0;
+
+    /*
+     * Each window in the frame should have the same number of coef's,
+     * so coef_per_win is constant in all the loops
+     */
+    coef_per_win = pFrameInfo->coef_per_win[0];
+
+    /*
+     * Because the number of scalefactor bands per window should be
+     * constant for each frame, sfb_per_win can be determined outside
+     * of the loop.
+     *
+     * For 44.1 kHz sampling rate   sfb_per_win = 14 for short windows
+     *                              sfb_per_win = 49 for long  windows
+     */
+
+    sfb_per_win = pFrameInfo->sfb_per_win[0];
+
+    do
+    {
+        pBand     = pFrameInfo->win_sfb_top[window_start];
+
+        /*
+         * Partition is equal to the first window in the next group
+         *
+         * { Group 0    }{      Group 1      }{    Group 2 }{Group 3}
+         * [win 0][win 1][win 2][win 3][win 4][win 5][win 6][win 7]
+         *
+         * pGroup[0] = 2
+         * pGroup[1] = 5
+         * pGroup[2] = 7
+         * pGroup[3] = 8
+         */
+
+        partition = *(pGroup++);
+
+        band_start = 0;
+
+        wins_in_group = (partition - window_start);
+
+        for (sfb = sfb_per_win; sfb > 0; sfb--)
+        {
+            /* band is offset table, band_stop is last coef in band */
+            band_stop = *(pBand++);
+
+            codebook = *(pCodebookMap++);
+
+            mask_enabled = *(pMaskMap++);
+
+            /*
+             * When a codebook < NOISE_HCB is found, apply M/S to that
+             * scalefactorband.
+             *
+             * Example...  sfb[3] == NOISE_HCB
+             *
+             * [ Group 1                                      ]
+             * [win 0                 ][win 1                 ]
+             * [0][1][2][X][4][5][6][7][0][1][2][X][4][5][6][7]
+             *
+             * The for(sfb) steps through the sfb's 0-7 in win 0.
+             *
+             * Finding sfb[3]'s codebook == NOISE_HCB, the code
+             * steps through all the windows in the group (they share
+             * the same scalefactors) and replaces that sfb with noise.
+             */
+
+            if (codebook < NOISE_HCB)
+            {
+                if (mask_enabled != FALSE)
+                {
+                    band_length = band_stop - band_start;
+
+                    ms_synt(
+                        wins_in_group,
+                        coef_per_win,
+                        sfb_per_win,
+                        band_length,
+                        &(pCoefLeft[band_start]),
+                        &(pCoefRight[band_start]),
+                        &(q_formatLeft[tot_sfb]),
+                        &(q_formatRight[tot_sfb]));
+                }
+            }
+            band_start = band_stop;
+
+            tot_sfb++;
+
+        } /* for (sfb) */
+
+        /*
+         * Increment pCoefRight and pCoefLeft by
+         * coef_per_win * the number of windows
+         */
+
+        pCoefRight += coef_per_win * wins_in_group;
+        pCoefLeft  += coef_per_win * wins_in_group--;
+
+        /*
+         * Increase tot_sfb by sfb_per_win times the number of windows minus 1.
+         * The minus 1 comes from the fact that tot_sfb is already pointing
+         * to the first sfb in the 2nd window of the group.
+         */
+        tot_sfb += sfb_per_win * wins_in_group;
+
+        window_start = partition;
+
+    }
+    while (partition < pFrameInfo->num_win);
+
+    /* pFrameInfo->num_win = 1 for long windows, 8 for short_windows */
+
+    return;
+
+} /* apply_ms_synt() */
+
+
diff --git a/media/libstagefright/codecs/aacdec/apply_ms_synt.h b/media/libstagefright/codecs/aacdec/apply_ms_synt.h
new file mode 100644
index 0000000..ed7fb7a
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/apply_ms_synt.h
@@ -0,0 +1,94 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Pathname: ./include/apply_ms_synt.h
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+ Who:                       Date:
+ Description:
+------------------------------------------------------------------------------
+ INCLUDE DESCRIPTION
+
+ This file includes the function declaration for apply_ms_synt().
+
+------------------------------------------------------------------------------
+*/
+
+/*----------------------------------------------------------------------------
+; CONTINUE ONLY IF NOT ALREADY DEFINED
+----------------------------------------------------------------------------*/
+#ifndef APPLY_MS_SYNT_H
+#define APPLY_MS_SYNT_H
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+#include "pv_audio_type_defs.h"
+#include "s_frameinfo.h"
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here.
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL VARIABLES REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; SIMPLE TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; ENUMERATED TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; STRUCTURES TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; GLOBAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+
+void apply_ms_synt(
+    const FrameInfo * const pFrameInfo,
+    const Int        group[],
+    const Bool       mask_map[],
+    const Int        codebook_map[],
+    Int32      coefLeft[],
+    Int32      coefRight[],
+    Int        q_formatLeft[MAXBANDS],
+    Int        q_formatRight[MAXBANDS]);
+
+/*----------------------------------------------------------------------------
+; END
+----------------------------------------------------------------------------*/
+#endif
+
+
diff --git a/media/libstagefright/codecs/aacdec/apply_tns.cpp b/media/libstagefright/codecs/aacdec/apply_tns.cpp
new file mode 100644
index 0000000..96ecd27
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/apply_tns.cpp
@@ -0,0 +1,424 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Pathname: apply_tns.c
+
+------------------------------------------------------------------------------
+ INPUT AND OUTPUT DEFINITIONS
+
+ Inputs:
+    coef =       Array of input coefficients.
+                 [Int32 *, length 1024]
+
+    q_format   = Array of q-formats, one per scalefactor band, for the
+                 entire frame.  In the case of tns_inv_filter, only the
+                 first element is used, since the input to tns_inv_filter
+                 is all of the same q-format.
+                 [Int * const, length MAX_SFB]
+
+    pFrameInfo = Pointer to structure that holds information about each group.
+                 (long block flag, number of windows, scalefactor bands
+                  per group, etc.)
+                 [const FrameInfo * const]
+
+    pTNS_frame_info = pointer to structure containing the details on each
+                      TNS filter (order, filter coefficients,
+                      coefficient res., etc.)
+                      [TNS_frame_info * const]
+
+    inverse_flag   = TRUE  if inverse filter is to be applied.
+                     FALSE if forward filter is to be applied.
+                     [Bool]
+
+    scratch_Int_buffer = Pointer to scratch memory to store the
+                           filter's state memory.  Used by both
+                           tns_inv_filter.
+                           [Int *, length TNS_MAX_ORDER]
+
+ Local Stores/Buffers/Pointers Needed:
+    None
+
+ Global Stores/Buffers/Pointers Needed:
+    None
+
+ Outputs:
+    None
+
+ Pointers and Buffers Modified:
+    coef[]   = TNS altered data.
+    q_format = q-formats in TNS scalefactor bands may be modified.
+
+ Local Stores Modified:
+    None
+
+ Global Stores Modified:
+    None
+
+------------------------------------------------------------------------------
+ FUNCTION DESCRIPTION
+
+    This function applies either the TNS forward or TNS inverse filter, based
+    on inverse_flag being FALSE or TRUE, respectively.
+
+    For the TNS forward filter, the data fed into tns_ar_filter is normalized
+    all to the same q-format.
+
+------------------------------------------------------------------------------
+ REQUIREMENTS
+
+    The input, coef, should use all 32-bits, else the scaling by tns_ar_filter
+    may eliminate the data.
+
+------------------------------------------------------------------------------
+ REFERENCES
+
+ (1) ISO/IEC 14496-3:1999(E)
+     Part 3
+        Subpart 4.6.8 (Temporal Noise Shaping)
+
+------------------------------------------------------------------------------
+ PSEUDO-CODE
+
+    NO PSEUDO-CODE
+
+------------------------------------------------------------------------------
+ RESOURCES USED
+   When the code is written for a specific target processor
+     the resources used should be documented below.
+
+ STACK USAGE: [stack count for this module] + [variable to represent
+          stack usage for each subroutine called]
+
+     where: [stack usage variable] = stack usage for [subroutine
+         name] (see [filename].ext)
+
+ DATA MEMORY USED: x words
+
+ PROGRAM MEMORY USED: x words
+
+ CLOCK CYCLES: [cycle count equation for this module] + [variable
+           used to represent cycle count for each subroutine
+           called]
+
+     where: [cycle count variable] = cycle count for [subroutine
+        name] (see [filename].ext)
+
+------------------------------------------------------------------------------
+*/
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+#include "pv_audio_type_defs.h"
+#include "s_tns_frame_info.h"
+#include "s_tnsfilt.h"
+#include "s_frameinfo.h"
+#include "tns_inv_filter.h"
+#include "tns_ar_filter.h"
+#include "apply_tns.h"
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here. Include conditional
+; compile variables also.
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; LOCAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; LOCAL STORE/BUFFER/POINTER DEFINITIONS
+; Variable declaration - defined here and used outside this module
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL FUNCTION REFERENCES
+; Declare functions defined elsewhere and referenced in this module
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL GLOBAL STORE/BUFFER/POINTER REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; FUNCTION CODE
+----------------------------------------------------------------------------*/
+
+void apply_tns(
+    Int32                  coef[],
+    Int                    q_format[],
+    const FrameInfo      * const pFrameInfo,
+    TNS_frame_info * const pTNS_frame_info,
+    const Bool                   inverse_flag,
+    Int32                  scratch_Int_buffer[])
+{
+    Int num_tns_bands;
+    Int num_TNS_coef;
+
+    Int f;
+
+    Int tempInt;
+    Int tempInt2;
+
+    Int sfb_per_win;
+    Int sfbWidth;
+
+    Int coef_per_win;
+    Int min_q;
+    Int win;
+
+    Int32 *pCoef = coef;
+    Int32 *pTempCoef;
+
+    Int   *pStartQformat = q_format;
+
+    Int   *pQformat;
+    Int32 *pLpcCoef;
+
+    Int sfb_offset;
+
+    const Int16 *pWinSfbTop;
+
+    TNSfilt *pFilt;
+
+    coef_per_win = pFrameInfo->coef_per_win[0];
+    sfb_per_win  = pFrameInfo->sfb_per_win[0];
+
+    win = 0;
+
+    pLpcCoef = pTNS_frame_info->lpc_coef;
+
+    pFilt = pTNS_frame_info->filt;
+
+    do
+    {
+        for (f = pTNS_frame_info->n_filt[win]; f > 0; f--)
+        {
+            /* Skip to the next filter if the order is 0 */
+            tempInt = pFilt->order;
+
+            if (tempInt > 0)
+            {
+                /*
+                 * Do not call tns_ar_filter or tns_inv_filter
+                 * if the difference
+                 * between start_coef and stop_stop is <= 0.
+                 *
+                 */
+                num_TNS_coef = (pFilt->stop_coef - pFilt->start_coef);
+
+                if (num_TNS_coef > 0)
+                {
+                    if (inverse_flag != FALSE)
+                    {
+                        tns_inv_filter(
+                            &(pCoef[pFilt->start_coef]),
+                            num_TNS_coef,
+                            pFilt->direction,
+                            pLpcCoef,
+                            pFilt->q_lpc,
+                            pFilt->order,
+                            scratch_Int_buffer);
+                    }
+                    else
+                    {
+                        num_tns_bands = (pFilt->stop_band - pFilt->start_band);
+
+                        /*
+                         * pQformat is initialized only once.
+                         *
+                         * Here is how TNS is applied on scalefactor bands
+                         *
+                         * [0][1][2][3][4][5][6][7][8]
+                         *  |                        \
+                         * start_band               stop_band
+                         *
+                         * In this example, TNS would be applied to 8
+                         * scalefactor bands, 0-7.
+                         *
+                         * pQformat is initially set to &(pStartQformat[8])
+                         *
+                         * 1st LOOP
+                         *      Entry: pQformat = &(pStartQformat[8])
+                         *
+                         *      pQformat is pre-decremented 8 times in the
+                         *      search for min_q
+                         *
+                         *      Exit:  pQformat = &(pStartQformat[0])
+                         *
+                         * 2nd LOOP
+                         *      Entry: pQformat = &(pStartQformat[0])
+                         *
+                         *      pQformat is post-incremented 8 times in the
+                         *      normalization of the data loop.
+                         *
+                         *      Exit:  pQformat = &(pStartQformat[8]
+                         *
+                         *
+                         * shift_amt = tns_ar_filter(...)
+                         *
+                         * 3rd LOOP
+                         *      Entry: pQformat = &(pStartQformat[8])
+                         *
+                         *      pQformat is pre-decremented 8 times in the
+                         *      adjustment of the q-format to min_q - shift_amt
+                         *
+                         *      Exit:  pQformat = &(pStartQformat[0])
+                         *
+                         */
+
+                        pQformat =
+                            &(pStartQformat[pFilt->stop_band]);
+
+                        /*
+                         * Scan the array of q-formats and find the minimum over
+                         * the range where the filter is to be applied.
+                         *
+                         * At the end of this scan,
+                         * pQformat = &(q-format[pFilt->start_band]);
+                         *
+                         */
+
+                        min_q = INT16_MAX;
+
+                        for (tempInt = num_tns_bands; tempInt > 0; tempInt--)
+                        {
+                            tempInt2 = *(--pQformat);
+
+                            if (tempInt2 < min_q)
+                            {
+                                min_q = tempInt2;
+                            }
+                        } /* for(tempInt = num_bands; tempInt > 0; tempInt--)*/
+
+                        /*
+                         * Set up the pointers so we can index into coef[]
+                         * on a scalefactor band basis.
+                         */
+                        tempInt = pFilt->start_band;
+
+                        tempInt--;
+
+                        /* Initialize sfb_offset and pWinSfbTop */
+                        if (tempInt >= 0)
+                        {
+                            pWinSfbTop =
+                                &(pFrameInfo->win_sfb_top[win][tempInt]);
+
+                            sfb_offset = *(pWinSfbTop++);
+                        }
+                        else
+                        {
+                            pWinSfbTop = pFrameInfo->win_sfb_top[win];
+                            sfb_offset = 0;
+                        }
+
+                        pTempCoef = pCoef + pFilt->start_coef;
+
+                        /* Scale the data in the TNS bands to min_q q-format */
+                        for (tempInt = num_tns_bands; tempInt > 0; tempInt--)
+                        {
+                            sfbWidth  = *(pWinSfbTop++) - sfb_offset;
+
+                            sfb_offset += sfbWidth;
+
+                            tempInt2 = *(pQformat++) - min_q;
+
+                            /*
+                             * This should zero out the data in one scalefactor
+                             * band if it is so much less than the neighboring
+                             * scalefactor bands.
+                             *
+                             * The only way this "should" happen is if one
+                             * scalefactor band contains zero data.
+                             *
+                             * Zero data can be of any q-format, but we always
+                             * set it very high to avoid the zero-data band being
+                             * picked as the one to normalize to in the scan for
+                             * min_q.
+                             *
+                             */
+                            if (tempInt2 > 31)
+                            {
+                                tempInt2 = 31;
+                            }
+
+                            for (sfbWidth >>= 2; sfbWidth > 0; sfbWidth--)
+                            {
+                                *(pTempCoef++) >>= tempInt2;
+                                *(pTempCoef++) >>= tempInt2;
+                                *(pTempCoef++) >>= tempInt2;
+                                *(pTempCoef++) >>= tempInt2;
+                            }
+
+                        } /* for(tempInt = num_bands; tempInt > 0; tempInt--)*/
+
+                        tempInt2 =
+                            tns_ar_filter(
+                                &(pCoef[pFilt->start_coef]),
+                                num_TNS_coef,
+                                pFilt->direction,
+                                pLpcCoef,
+                                pFilt->q_lpc,
+                                pFilt->order);
+
+                        /*
+                         * Update the q-format for all the scalefactor bands
+                         * taking into account the adjustment caused by
+                         * tns_ar_filter
+                         */
+
+                        min_q -= tempInt2;
+
+                        for (tempInt = num_tns_bands; tempInt > 0; tempInt--)
+                        {
+                            *(--pQformat) = min_q;
+                        }
+
+                    } /* if (inverse_flag != FALSE) */
+
+                } /* if (num_TNS_coef > 0) */
+
+                pLpcCoef += pFilt->order;
+
+            } /* if (tempInt > 0) */
+
+            pFilt++;
+
+        } /* for (f = pTNSinfo->n_filt; f > 0; f--) */
+
+        pCoef += coef_per_win;
+        pStartQformat += sfb_per_win;
+
+        win++;
+
+    }
+    while (win < pFrameInfo->num_win);
+
+    return;
+
+} /* apply_tns() */
diff --git a/media/libstagefright/codecs/aacdec/apply_tns.h b/media/libstagefright/codecs/aacdec/apply_tns.h
new file mode 100644
index 0000000..85fb851
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/apply_tns.h
@@ -0,0 +1,113 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Pathname: ./include/apply_tns.h
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+ Description: Updated per review comments.
+
+ Description: Changed function prototype to mirror changes made in apply_tns.c
+
+ Description: The scratch memory was mistakenly declared here as type "Int32"
+ It should have been "Int"
+
+ Who:                       Date:
+ Description:
+
+
+------------------------------------------------------------------------------
+ INCLUDE DESCRIPTION
+
+ This include file contains the function declaration for
+ apply_tns.c
+
+------------------------------------------------------------------------------
+*/
+
+/*----------------------------------------------------------------------------
+; CONTINUE ONLY IF NOT ALREADY DEFINED
+----------------------------------------------------------------------------*/
+#ifndef APPLY_TNS_H
+#define APPLY_TNS_H
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+#include "pv_audio_type_defs.h"
+#include "s_tns_frame_info.h"
+#include "s_frameinfo.h"
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here.
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL VARIABLES REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; SIMPLE TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; ENUMERATED TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; STRUCTURES TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; GLOBAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+    void apply_tns(
+        Int32                  coef[],
+        Int                    q_format[],
+        const FrameInfo      * const pFrameInfo,
+        TNS_frame_info * const pTNS_frame_info,
+        const Bool                   inverse_flag,
+        Int32                  scratch_Int_buffer[]);
+
+
+#ifdef __cplusplus
+}
+#endif
+
+/*----------------------------------------------------------------------------
+; END
+----------------------------------------------------------------------------*/
+#endif
+
+
diff --git a/media/libstagefright/codecs/aacdec/bit_reversal_swap.h b/media/libstagefright/codecs/aacdec/bit_reversal_swap.h
new file mode 100644
index 0000000..2669f87
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/bit_reversal_swap.h
@@ -0,0 +1,93 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+ Pathname: ./include/bit_reversal_swap.h
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+ Description:  Changed definitions from Int to Int32 for Data[]
+
+ Who:                       Date:
+ Description:
+
+------------------------------------------------------------------------------
+ INCLUDE DESCRIPTION
+
+ Header file for function bit_reversal_swap()
+
+
+------------------------------------------------------------------------------
+*/
+
+/*----------------------------------------------------------------------------
+; CONTINUE ONLY IF NOT ALREADY DEFINED
+----------------------------------------------------------------------------*/
+#ifndef BIT_REVERSAL_SWAP_H
+#define BIT_REVERSAL_SWAP_H
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+#include "pv_audio_type_defs.h"
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here.
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL VARIABLES REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+extern const Int Index_64_a[];
+extern const Int Index_64_b[];
+
+extern const Int Index_512_a[];
+extern const Int Index_512_b[];
+
+/*----------------------------------------------------------------------------
+; SIMPLE TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; ENUMERATED TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; STRUCTURES TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; GLOBAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+void bit_reversal_swap(
+    Int32        Data[],
+    const Int *pIndex_a,
+    const Int *pIndex_b);
+
+/*----------------------------------------------------------------------------
+; END
+----------------------------------------------------------------------------*/
+#endif  /* BIT_REVERSAL_SWAP_H */
diff --git a/media/libstagefright/codecs/aacdec/buf_getbits.cpp b/media/libstagefright/codecs/aacdec/buf_getbits.cpp
new file mode 100644
index 0000000..34f4f60
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/buf_getbits.cpp
@@ -0,0 +1,167 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Filename: buf_getbits.c
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+
+ Who:                                   Date: MM/DD/YYYY
+ Description:
+
+------------------------------------------------------------------------------
+ INPUT AND OUTPUT DEFINITIONS
+
+ Arguments:   hBitBuf Handle to Bitbuffer
+              n       Number of bits to read
+
+ Return:      bits
+
+
+------------------------------------------------------------------------------
+ FUNCTION DESCRIPTION
+
+            Reads n bits from Bitbuffer
+
+------------------------------------------------------------------------------
+ REQUIREMENTS
+
+
+------------------------------------------------------------------------------
+ REFERENCES
+
+SC 29 Software Copyright Licencing Disclaimer:
+
+This software module was originally developed by
+  Coding Technologies
+
+and edited by
+  -
+
+in the course of development of the ISO/IEC 13818-7 and ISO/IEC 14496-3
+standards for reference purposes and its performance may not have been
+optimized. This software module is an implementation of one or more tools as
+specified by the ISO/IEC 13818-7 and ISO/IEC 14496-3 standards.
+ISO/IEC gives users free license to this software module or modifications
+thereof for use in products claiming conformance to audiovisual and
+image-coding related ITU Recommendations and/or ISO/IEC International
+Standards. ISO/IEC gives users the same free license to this software module or
+modifications thereof for research purposes and further ISO/IEC standardisation.
+Those intending to use this software module in products are advised that its
+use may infringe existing patents. ISO/IEC have no liability for use of this
+software module or modifications thereof. Copyright is not released for
+products that do not conform to audiovisual and image-coding related ITU
+Recommendations and/or ISO/IEC International Standards.
+The original developer retains full right to modify and use the code for its
+own purpose, assign or donate the code to a third party and to inhibit third
+parties from using the code for products that do not conform to audiovisual and
+image-coding related ITU Recommendations and/or ISO/IEC International Standards.
+This copyright notice must be included in all copies or derivative works.
+Copyright (c) ISO/IEC 2002.
+
+------------------------------------------------------------------------------
+ PSEUDO-CODE
+
+------------------------------------------------------------------------------
+*/
+
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+
+#ifdef AAC_PLUS
+
+#include    "buf_getbits.h"
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here. Include conditional
+; compile variables also.
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; LOCAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; LOCAL STORE/BUFFER/POINTER DEFINITIONS
+; Variable declaration - defined here and used outside this module
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL FUNCTION REFERENCES
+; Declare functions defined elsewhere and referenced in this module
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL GLOBAL STORE/BUFFER/POINTER REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; FUNCTION CODE
+----------------------------------------------------------------------------*/
+
+UInt32 buf_getbits(BIT_BUFFER * hBitBuf, Int32 n)
+{
+
+    /* read bits from MSB side */
+    if (hBitBuf->buffered_bits <= 16)
+    {
+        hBitBuf->buffer_word    = (hBitBuf->buffer_word << 16) | (*(hBitBuf->char_ptr++) << 8);
+        hBitBuf->buffer_word   |= *(hBitBuf->char_ptr++);
+        hBitBuf->buffered_bits += 16;
+    }
+
+    hBitBuf->buffered_bits -= n;
+    hBitBuf->nrBitsRead    += n;
+
+    return ((hBitBuf->buffer_word >> hBitBuf->buffered_bits) & ((1 << n) - 1));
+
+}
+
+
+UInt32 buf_get_1bit(BIT_BUFFER * hBitBuf)
+{
+
+    /* read bits from MSB side */
+    if (hBitBuf->buffered_bits <= 16)
+    {
+        hBitBuf->buffer_word    = (hBitBuf->buffer_word << 16) | (*(hBitBuf->char_ptr++) << 8);
+        hBitBuf->buffer_word   |= *(hBitBuf->char_ptr++);
+        hBitBuf->buffered_bits += 16;
+    }
+
+    hBitBuf->buffered_bits--;
+    hBitBuf->nrBitsRead++;
+
+    return ((hBitBuf->buffer_word >> hBitBuf->buffered_bits) & 1);
+
+}
+
+#endif
diff --git a/media/libstagefright/codecs/aacdec/buf_getbits.h b/media/libstagefright/codecs/aacdec/buf_getbits.h
new file mode 100644
index 0000000..1b5d252
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/buf_getbits.h
@@ -0,0 +1,94 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+  Filename: buf_getbits.h
+
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+
+ Who:                                   Date: MM/DD/YYYY
+ Description:
+------------------------------------------------------------------------------
+
+
+----------------------------------------------------------------------------
+; CONTINUE ONLY IF NOT ALREADY DEFINED
+----------------------------------------------------------------------------*/
+#ifndef BUF_GETBITS_H
+#define BUF_GETBITS_H
+
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+#include "s_bit_buffer.h"
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+    /*----------------------------------------------------------------------------
+    ; DEFINES
+    ; Include all pre-processor statements here.
+    ----------------------------------------------------------------------------*/
+
+    /*----------------------------------------------------------------------------
+    ; EXTERNAL VARIABLES REFERENCES
+    ; Declare variables used in this module but defined elsewhere
+    ----------------------------------------------------------------------------*/
+
+    /*----------------------------------------------------------------------------
+    ; SIMPLE TYPEDEF'S
+    ----------------------------------------------------------------------------*/
+
+    /*----------------------------------------------------------------------------
+    ; ENUMERATED TYPEDEF'S
+    ----------------------------------------------------------------------------*/
+
+    /*----------------------------------------------------------------------------
+    ; STRUCTURES TYPEDEF'S
+    ----------------------------------------------------------------------------*/
+
+
+    /*----------------------------------------------------------------------------
+    ; GLOBAL FUNCTION DEFINITIONS
+    ; Function Prototype declaration
+    ----------------------------------------------------------------------------*/
+
+    UInt32 buf_getbits(BIT_BUFFER * hBitBuf, Int32 n);
+
+    UInt32 buf_get_1bit(BIT_BUFFER * hBitBuf);
+
+
+#ifdef __cplusplus
+}
+#endif
+
+/*----------------------------------------------------------------------------
+; END
+----------------------------------------------------------------------------*/
+#endif
+
+
diff --git a/media/libstagefright/codecs/aacdec/buffer_normalization.h b/media/libstagefright/codecs/aacdec/buffer_normalization.h
new file mode 100644
index 0000000..031216a
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/buffer_normalization.h
@@ -0,0 +1,93 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Pathname: ./include/buffer_normalization.h
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+ Description:  Changed definitions from Int to Int32 for IO_buffer[]
+
+ Description:  Added copyrigth notice, added 'const' definitions to function
+
+ Who:                          Date:
+ Description:
+
+------------------------------------------------------------------------------
+ INCLUDE DESCRIPTION
+
+ Header file for function buffer_normalization()
+
+
+------------------------------------------------------------------------------
+*/
+
+/*----------------------------------------------------------------------------
+; CONTINUE ONLY IF NOT ALREADY DEFINED
+----------------------------------------------------------------------------*/
+#ifndef BUFFER_NORMALIZATION_H
+#define BUFFER_NORMALIZATION_H
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+#include "pv_audio_type_defs.h"
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here.
+----------------------------------------------------------------------------*/
+#define     ALL_ZEROS_BUFFER     -100
+
+/*----------------------------------------------------------------------------
+; EXTERNAL VARIABLES REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; SIMPLE TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; ENUMERATED TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; STRUCTURES TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; GLOBAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+void buffer_normalization(
+    Int     q_format,
+    Int32   IO_buffer[],
+    const Int     buffer_size,
+    Int   * const pExp);
+
+/*----------------------------------------------------------------------------
+; END
+----------------------------------------------------------------------------*/
+#endif  /* BUFFER_NORMALIZATION_H */
diff --git a/media/libstagefright/codecs/aacdec/byte_align.cpp b/media/libstagefright/codecs/aacdec/byte_align.cpp
new file mode 100644
index 0000000..e75c79e
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/byte_align.cpp
@@ -0,0 +1,179 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+------------------------------------------------------------------------------
+ INPUT AND OUTPUT DEFINITIONS
+
+ Inputs:
+    pInputStream = pointer to a BITS structure that holds information
+                   regarding the input stream.
+
+ Local Stores/Buffers/Pointers Needed:
+    None
+
+ Global Stores/Buffers/Pointers Needed:
+    None
+
+ Outputs:
+    None
+
+ Pointers and Buffers Modified:
+    pInputStream->usedBits is rounded up to a number that represents the next
+    byte boundary.
+
+ Local Stores Modified:
+    None
+
+ Global Stores Modified:
+    None
+
+------------------------------------------------------------------------------
+ FUNCTION DESCRIPTION
+
+ Makes the input stream structure pointed to align to the next byte boundary.
+ If it is already at a byte boundary it is left alone.
+
+------------------------------------------------------------------------------
+ REQUIREMENTS
+
+  This function shall not use global or static variables.
+
+------------------------------------------------------------------------------
+ REFERENCES
+
+ (1) MPEG-2 NBC Audio Decoder
+   "This software module was originally developed by AT&T, Dolby
+   Laboratories, Fraunhofer Gesellschaft IIS in the course of development
+   of the MPEG-2 NBC/MPEG-4 Audio standard ISO/IEC 13818-7, 14496-1,2 and
+   3. This software module is an implementation of a part of one or more
+   MPEG-2 NBC/MPEG-4 Audio tools as specified by the MPEG-2 NBC/MPEG-4
+   Audio standard. ISO/IEC gives users of the MPEG-2 NBC/MPEG-4 Audio
+   standards free license to this software module or modifications thereof
+   for use in hardware or software products claiming conformance to the
+   MPEG-2 NBC/MPEG-4 Audio  standards. Those intending to use this software
+   module in hardware or software products are advised that this use may
+   infringe existing patents. The original developer of this software
+   module and his/her company, the subsequent editors and their companies,
+   and ISO/IEC have no liability for use of this software module or
+   modifications thereof in an implementation. Copyright is not released
+   for non MPEG-2 NBC/MPEG-4 Audio conforming products.The original
+   developer retains full right to use the code for his/her own purpose,
+   assign or donate the code to a third party and to inhibit third party
+   from using the code for non MPEG-2 NBC/MPEG-4 Audio conforming products.
+   This copyright notice must be included in all copies or derivative
+   works."
+   Copyright(c)1996.
+
+------------------------------------------------------------------------------
+ PSEUDO-CODE
+
+void byte_align(
+    BITS  *pInputStream)
+
+    MODIFYING(pInputStream->usedBits = pInputStream->usedBits +
+                (pInputStream->usedBits + 7) % 8)
+
+    RETURN(nothing)
+
+------------------------------------------------------------------------------
+ RESOURCES USED
+
+ STACK USAGE:
+
+     where:
+
+ DATA MEMORY USED: x words
+
+ PROGRAM MEMORY USED: x words
+
+ CLOCK CYCLES:
+
+------------------------------------------------------------------------------
+*/
+
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+
+
+
+#include "pv_audio_type_defs.h"
+#include "s_bits.h"
+#include "ibstream.h"
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here. Include conditional
+; compile variables also.
+----------------------------------------------------------------------------*/
+
+/*
+ * A negative number was used for this mask so that it works on both
+ * 16-bit or 32-bit machines. The mask must be cast to unsigned int to
+ * work with TI compiler, ver 1.80.
+ */
+#define BYTE_ALIGN_MASK    ((UInt)(-8))
+
+#define BYTE_ALIGN_ROUNDUP  7
+
+/*----------------------------------------------------------------------------
+; LOCAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; LOCAL VARIABLE DEFINITIONS
+; Variable declaration - defined here and used outside this module
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL FUNCTION REFERENCES
+; Declare functions defined elsewhere and referenced in this module
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL VARIABLES REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; FUNCTION CODE
+----------------------------------------------------------------------------*/
+void byte_align(
+    BITS  *pInputStream)
+{
+    /*
+     * Round up to the next byte by adding 7 and masking off with
+     * FFF8 or FFFFFFF8. The masking operation is a faster way to
+     * perform modulo arithmetic if the number is a power of 2.
+     *
+     * This code is the same as
+     * pInputStream->usedBits += (pInputStream->usedBits + 7) % 8
+     */
+    pInputStream->usedBits += BYTE_ALIGN_ROUNDUP;
+    pInputStream->usedBits &= BYTE_ALIGN_MASK;
+
+    return;
+}
+
diff --git a/media/libstagefright/codecs/aacdec/calc_auto_corr.cpp b/media/libstagefright/codecs/aacdec/calc_auto_corr.cpp
new file mode 100644
index 0000000..ee32398
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/calc_auto_corr.cpp
@@ -0,0 +1,416 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Filename: calc_auto_corr.c
+
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+
+ Who:                                   Date: MM/DD/YYYY
+ Description:
+
+------------------------------------------------------------------------------
+ INPUT AND OUTPUT DEFINITIONS
+
+
+
+------------------------------------------------------------------------------
+ FUNCTION DESCRIPTION
+
+
+------------------------------------------------------------------------------
+ REQUIREMENTS
+
+
+------------------------------------------------------------------------------
+ REFERENCES
+
+SC 29 Software Copyright Licencing Disclaimer:
+
+This software module was originally developed by
+  Coding Technologies
+
+and edited by
+  -
+
+in the course of development of the ISO/IEC 13818-7 and ISO/IEC 14496-3
+standards for reference purposes and its performance may not have been
+optimized. This software module is an implementation of one or more tools as
+specified by the ISO/IEC 13818-7 and ISO/IEC 14496-3 standards.
+ISO/IEC gives users free license to this software module or modifications
+thereof for use in products claiming conformance to audiovisual and
+image-coding related ITU Recommendations and/or ISO/IEC International
+Standards. ISO/IEC gives users the same free license to this software module or
+modifications thereof for research purposes and further ISO/IEC standardisation.
+Those intending to use this software module in products are advised that its
+use may infringe existing patents. ISO/IEC have no liability for use of this
+software module or modifications thereof. Copyright is not released for
+products that do not conform to audiovisual and image-coding related ITU
+Recommendations and/or ISO/IEC International Standards.
+The original developer retains full right to modify and use the code for its
+own purpose, assign or donate the code to a third party and to inhibit third
+parties from using the code for products that do not conform to audiovisual and
+image-coding related ITU Recommendations and/or ISO/IEC International Standards.
+This copyright notice must be included in all copies or derivative works.
+Copyright (c) ISO/IEC 2002.
+
+------------------------------------------------------------------------------
+ PSEUDO-CODE
+
+------------------------------------------------------------------------------
+*/
+
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+#ifdef AAC_PLUS
+
+
+#include    "calc_auto_corr.h"
+#include    "aac_mem_funcs.h"
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here. Include conditional
+; compile variables also.
+----------------------------------------------------------------------------*/
+#include    "fxp_mul32.h"
+#include    "pv_normalize.h"
+
+#define N   2
+
+/*----------------------------------------------------------------------------
+; LOCAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; LOCAL STORE/BUFFER/POINTER DEFINITIONS
+; Variable declaration - defined here and used outside this module
+----------------------------------------------------------------------------*/
+
+
+/*----------------------------------------------------------------------------
+; EXTERNAL FUNCTION REFERENCES
+; Declare functions defined elsewhere and referenced in this module
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL GLOBAL STORE/BUFFER/POINTER REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; FUNCTION CODE
+----------------------------------------------------------------------------*/
+
+
+
+void calc_auto_corr_LC(struct ACORR_COEFS *ac,
+                       Int32  realBuf[][32],
+                       Int32  bd,
+                       Int32  len)
+{
+    Int32 j;
+    Int32 temp1;
+    Int32 temp3;
+    Int32 temp5;
+
+    int64_t temp_r01r;
+    int64_t temp_r02r;
+    int64_t temp_r11r;
+    int64_t temp_r12r;
+    int64_t temp_r22r;
+    int64_t max = 0;
+
+
+    temp1 = (realBuf[ 0][bd]) >> N;
+    temp3 = (realBuf[-1][bd]) >> N;
+    temp5 = (realBuf[-2][bd]) >> N;
+
+
+    temp_r11r = fxp_mac64_Q31(0, temp3, temp3);   /* [j-1]*[j-1]  */
+    temp_r12r = fxp_mac64_Q31(0, temp3, temp5);   /* [j-1]*[j-2]  */
+    temp_r22r = fxp_mac64_Q31(0, temp5, temp5);   /* [j-2]*[j-2]  */
+
+    temp_r01r = 0;
+    temp_r02r = 0;
+
+    for (j = 1; j < len; j++)
+    {
+        temp_r01r = fxp_mac64_Q31(temp_r01r, temp1, temp3);    /* [j  ]*[j-1]  */
+        temp_r02r = fxp_mac64_Q31(temp_r02r, temp1, temp5);    /* [j  ]*[j-2]  */
+        temp_r11r = fxp_mac64_Q31(temp_r11r, temp1, temp1);    /* [j-1]*[j-1]  */
+
+        temp5 = temp3;
+        temp3 = temp1;
+        temp1 = (realBuf[j][bd]) >> N;
+    }
+
+
+    temp_r22r += temp_r11r;
+    temp_r12r += temp_r01r;          /* [j-1]*[j-2]  */
+
+    temp_r22r  = fxp_mac64_Q31(temp_r22r, -temp3, temp3);
+
+    temp_r01r = fxp_mac64_Q31(temp_r01r, temp1, temp3);
+    temp_r02r = fxp_mac64_Q31(temp_r02r, temp1, temp5);
+
+    max  |= temp_r01r ^(temp_r01r >> 63);
+    max  |= temp_r02r ^(temp_r02r >> 63);
+    max  |= temp_r11r;
+    max  |= temp_r12r ^(temp_r12r >> 63);
+    max  |= temp_r22r;
+
+    if (max)
+    {
+        temp1 = (UInt32)(max >> 32);
+        if (temp1)
+        {
+            temp3 = 33 - pv_normalize(temp1);
+            ac->r01r = (Int32)(temp_r01r >> temp3);
+            ac->r02r = (Int32)(temp_r02r >> temp3);
+            ac->r11r = (Int32)(temp_r11r >> temp3);
+            ac->r12r = (Int32)(temp_r12r >> temp3);
+            ac->r22r = (Int32)(temp_r22r >> temp3);
+
+        }
+        else
+        {
+            temp3 = pv_normalize(((UInt32)max) >> 1) - 2;
+
+            if (temp3 > 0)
+            {
+                ac->r01r = (Int32)(temp_r01r << temp3);
+                ac->r02r = (Int32)(temp_r02r << temp3);
+                ac->r11r = (Int32)(temp_r11r << temp3);
+                ac->r12r = (Int32)(temp_r12r << temp3);
+                ac->r22r = (Int32)(temp_r22r << temp3);
+            }
+            else
+            {
+                temp3 = -temp3;
+                ac->r01r = (Int32)(temp_r01r >> temp3);
+                ac->r02r = (Int32)(temp_r02r >> temp3);
+                ac->r11r = (Int32)(temp_r11r >> temp3);
+                ac->r12r = (Int32)(temp_r12r >> temp3);
+                ac->r22r = (Int32)(temp_r22r >> temp3);
+            }
+
+        }
+
+        /*
+         *  ac->det = ac->r11r*ac->r22r - rel*(ac->r12r*ac->r12r);
+         */
+        /* 1/(1 + 1e-6) == 1 - 1e-6 */
+        /* 2^-20 == 1e-6 */
+        ac->det  = fxp_mul32_Q30(ac->r12r, ac->r12r);
+
+        ac->det -= ac->det >> 20;
+
+        ac->det  = fxp_mul32_Q30(ac->r11r, ac->r22r) - ac->det;
+    }
+    else
+    {
+        pv_memset((void *)ac, 0, sizeof(struct ACORR_COEFS));
+    }
+
+
+}
+
+
+#ifdef HQ_SBR
+
+
+void calc_auto_corr(struct ACORR_COEFS *ac,
+                    Int32  realBuf[][32],
+                    Int32  imagBuf[][32],
+                    Int32  bd,
+                    Int32  len)
+{
+
+
+    Int32 j;
+    Int32 temp1;
+    Int32 temp2;
+    Int32 temp3;
+    Int32 temp4;
+    Int32 temp5;
+    Int32 temp6;
+
+    int64_t accu1 = 0;
+    int64_t accu2 = 0;
+    int64_t accu3 = 0;
+    int64_t accu4 = 0;
+    int64_t accu5 = 0;
+
+
+    int64_t temp_r12r;
+    int64_t temp_r12i;
+    int64_t temp_r22r;
+    int64_t max = 0;
+
+
+    temp1 = realBuf[0  ][bd] >> N;
+    temp2 = imagBuf[0  ][bd] >> N;
+    temp3 = realBuf[0-1][bd] >> N;
+    temp4 = imagBuf[0-1][bd] >> N;
+    temp5 = realBuf[0-2][bd] >> N;
+    temp6 = imagBuf[0-2][bd] >> N;
+
+    temp_r22r =  fxp_mac64_Q31(0, temp5, temp5);
+    temp_r22r =  fxp_mac64_Q31(temp_r22r, temp6, temp6);
+    temp_r12r =  fxp_mac64_Q31(0, temp3, temp5);
+    temp_r12r =  fxp_mac64_Q31(temp_r12r, temp4, temp6);
+    temp_r12i = -fxp_mac64_Q31(0, temp3, temp6);
+    temp_r12i =  fxp_mac64_Q31(temp_r12i, temp4, temp5);
+
+    for (j = 1; j < len; j++)
+    {
+        accu1  = fxp_mac64_Q31(accu1, temp3, temp3);
+        accu1  = fxp_mac64_Q31(accu1, temp4, temp4);
+        accu2  = fxp_mac64_Q31(accu2, temp1, temp3);
+        accu2  = fxp_mac64_Q31(accu2, temp2, temp4);
+        accu3  = fxp_mac64_Q31(accu3, temp2, temp3);
+        accu3  = fxp_mac64_Q31(accu3, -temp1, temp4);
+        accu4  = fxp_mac64_Q31(accu4, temp1, temp5);
+        accu4  = fxp_mac64_Q31(accu4, temp2, temp6);
+        accu5  = fxp_mac64_Q31(accu5, temp2, temp5);
+        accu5  = fxp_mac64_Q31(accu5, -temp1, temp6);
+
+        temp5 = temp3;
+        temp6 = temp4;
+        temp3 = temp1;
+        temp4 = temp2;
+        temp1 = realBuf[j][bd] >> N;
+        temp2 = imagBuf[j][bd] >> N;
+    }
+
+
+    temp_r22r += accu1;
+    temp_r12r += accu2;
+    temp_r12i += accu3;
+
+
+    accu1  = fxp_mac64_Q31(accu1, temp3, temp3);
+    accu1  = fxp_mac64_Q31(accu1, temp4, temp4);
+    accu2  = fxp_mac64_Q31(accu2, temp1, temp3);
+    accu2  = fxp_mac64_Q31(accu2, temp2, temp4);
+    accu3  = fxp_mac64_Q31(accu3, temp2, temp3);
+    accu3  = fxp_mac64_Q31(accu3, -temp1, temp4);
+    accu4  = fxp_mac64_Q31(accu4, temp1, temp5);
+    accu4  = fxp_mac64_Q31(accu4, temp2, temp6);
+    accu5  = fxp_mac64_Q31(accu5, temp2, temp5);
+    accu5  = fxp_mac64_Q31(accu5, -temp1, temp6);
+
+
+    max  |= accu5 ^(accu5 >> 63);
+    max  |= accu4 ^(accu4 >> 63);
+    max  |= accu3 ^(accu3 >> 63);
+    max  |= accu2 ^(accu2 >> 63);
+    max  |= accu1;
+    max  |= temp_r12r ^(temp_r12r >> 63);
+    max  |= temp_r12i ^(temp_r12i >> 63);
+    max  |= temp_r22r;
+
+    if (max)
+    {
+
+        temp1 = (UInt32)(max >> 32);
+        if (temp1)
+        {
+            temp1 = 34 - pv_normalize(temp1);
+            ac->r11r = (Int32)(accu1 >> temp1);
+            ac->r01r = (Int32)(accu2 >> temp1);
+            ac->r01i = (Int32)(accu3 >> temp1);
+            ac->r02r = (Int32)(accu4 >> temp1);
+            ac->r02i = (Int32)(accu5 >> temp1);
+            ac->r12r = (Int32)(temp_r12r >> temp1);
+            ac->r12i = (Int32)(temp_r12i >> temp1);
+            ac->r22r = (Int32)(temp_r22r >> temp1);
+        }
+        else
+        {
+            temp1 = pv_normalize(((UInt32)max) >> 1) - 3;
+
+            if (temp1 > 0)
+            {
+                ac->r11r = (Int32)(accu1 << temp1);
+                ac->r01r = (Int32)(accu2 << temp1);
+                ac->r01i = (Int32)(accu3 << temp1);
+                ac->r02r = (Int32)(accu4 << temp1);
+                ac->r02i = (Int32)(accu5 << temp1);
+                ac->r12r = (Int32)(temp_r12r << temp1);
+                ac->r12i = (Int32)(temp_r12i << temp1);
+                ac->r22r = (Int32)(temp_r22r << temp1);
+            }
+            else
+            {
+                temp1 = -temp1;
+                ac->r11r = (Int32)(accu1 >> temp1);
+                ac->r01r = (Int32)(accu2 >> temp1);
+                ac->r01i = (Int32)(accu3 >> temp1);
+                ac->r02r = (Int32)(accu4 >> temp1);
+                ac->r02i = (Int32)(accu5 >> temp1);
+                ac->r12r = (Int32)(temp_r12r >> temp1);
+                ac->r12i = (Int32)(temp_r12i >> temp1);
+                ac->r22r = (Int32)(temp_r22r >> temp1);
+            }
+
+        }
+
+        /*
+         *  ac->det = ac->r11r*ac->r22r - rel*(ac->r12r*ac->r12r);
+         */
+        /* 1/(1 + 1e-6) == 1 - 1e-6 */
+        /* 2^-20 == 1e-6 */
+
+        ac->det =   fxp_mul32_Q29(ac->r12i, ac->r12i);
+        ac->det =   fxp_mac32_Q29(ac->r12r, ac->r12r, ac->det);
+
+        ac->det -= ac->det >> 20;
+
+        ac->det =  -fxp_msu32_Q29(ac->r11r, ac->r22r, ac->det);
+
+    }
+    else
+    {
+        pv_memset((void *)ac, 0, sizeof(struct ACORR_COEFS));
+    }
+
+}
+
+#endif
+
+
+
+
+
+#endif
+
+
diff --git a/media/libstagefright/codecs/aacdec/calc_auto_corr.h b/media/libstagefright/codecs/aacdec/calc_auto_corr.h
new file mode 100644
index 0000000..0f0dae2
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/calc_auto_corr.h
@@ -0,0 +1,122 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Filename: calc_auto_corr.h
+ Funtions:
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+
+ Who:                                   Date: MM/DD/YYYY
+ Description:
+------------------------------------------------------------------------------
+
+
+ ----------------------------------------------------------------------------
+; CONTINUE ONLY IF NOT ALREADY DEFINED
+----------------------------------------------------------------------------*/
+#ifndef CALC_AUTO_CORR_H
+#define CALC_AUTO_CORR_H
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+#include "pv_audio_type_defs.h"
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here.
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL VARIABLES REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; SIMPLE TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; ENUMERATED TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; STRUCTURES TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+
+struct ACORR_COEFS
+{
+    Int32  r11r;
+    Int32  r01r;
+    Int32  r02r;
+    Int32  r12r;
+    Int32  r22r;
+#ifdef HQ_SBR
+    Int32  r01i;
+    Int32  r02i;
+    Int32  r12i;
+#endif
+    Int32  det;
+};
+
+/*----------------------------------------------------------------------------
+; GLOBAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+    void calc_auto_corr_LC(struct ACORR_COEFS *ac,
+    Int32  realBuf[][32],
+    Int32  bd,
+    Int32  len);
+
+
+#ifdef HQ_SBR
+
+    void calc_auto_corr(struct ACORR_COEFS *ac,
+                        Int32  realBuf[][32],
+                        Int32  imagBuf[][32],
+                        Int32  bd,
+                        Int32  len);
+
+#endif
+
+
+#ifdef __cplusplus
+}
+#endif
+
+/*----------------------------------------------------------------------------
+; END
+----------------------------------------------------------------------------*/
+#endif
+
+
diff --git a/media/libstagefright/codecs/aacdec/calc_gsfb_table.cpp b/media/libstagefright/codecs/aacdec/calc_gsfb_table.cpp
new file mode 100644
index 0000000..4047502
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/calc_gsfb_table.cpp
@@ -0,0 +1,267 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Pathname: ./src/calc_gsfb_table.c
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+ Description:  Modified from original shareware code
+
+ Description: (1) Modified to bring in-line with PV standards
+              (2) Removed if(pFrameInfo->islong), only short windows will
+                  call this routine from getics.c
+
+ Description: Modified per review comments
+
+ Who:                       Date:
+ Description:
+
+------------------------------------------------------------------------------
+ INPUT AND OUTPUT DEFINITIONS
+
+ Inputs:
+    pFrameInfo  = pointer to structure that holds information for current
+                  frame. Data type FrameInfo
+
+    group[]     = array that contains the grouping information of short
+                  windows (stop index of windows in each group).
+                  Data type Int
+
+ Local Stores/Buffers/Pointers Needed:
+    None
+
+ Global Stores/Buffers/Pointers Needed:
+    None
+
+ Outputs:
+    None
+
+ Pointers and Buffers Modified:
+    pFrameInfo -> frame_sfb_top   contains the cumulative bandwidth of
+                                    scalefactor bands in each group
+
+ Local Stores Modified:
+    None
+
+ Global Stores Modified:
+    None
+
+------------------------------------------------------------------------------
+ FUNCTION DESCRIPTION
+
+ This function is only invoked when short windows are present. It calculates
+ the number of groups in one frame, and the scalefactor bandwidth of each
+ scalefactor band in each group.
+ All windows within one group share the same scalefactors and are interleaved
+ on a scalefactor band basis. Within each group, the actual length of one
+ scalefactor band equals to the number of windows times the number of
+ coefficients in a regular scalefactor band.
+
+------------------------------------------------------------------------------
+ REQUIREMENTS
+
+ This function shall replace the contents of pFrameInfo->frame_sfb_top
+ with the cumulative bandwidth of each scalefactor band in each group
+
+------------------------------------------------------------------------------
+ REFERENCES
+
+ (1) MPEG-2 NBC Audio Decoder
+   "This software module was originally developed by AT&T, Dolby
+   Laboratories, Fraunhofer Gesellschaft IIS in the course of development
+   of the MPEG-2 NBC/MPEG-4 Audio standard ISO/IEC 13818-7, 14496-1,2 and
+   3. This software module is an implementation of a part of one or more
+   MPEG-2 NBC/MPEG-4 Audio tools as specified by the MPEG-2 NBC/MPEG-4
+   Audio standard. ISO/IEC  gives users of the MPEG-2 NBC/MPEG-4 Audio
+   standards free license to this software module or modifications thereof
+   for use in hardware or software products claiming conformance to the
+   MPEG-2 NBC/MPEG-4 Audio  standards. Those intending to use this software
+   module in hardware or software products are advised that this use may
+   infringe existing patents. The original developer of this software
+   module and his/her company, the subsequent editors and their companies,
+   and ISO/IEC have no liability for use of this software module or
+   modifications thereof in an implementation. Copyright is not released
+   for non MPEG-2 NBC/MPEG-4 Audio conforming products.The original
+   developer retains full right to use the code for his/her own purpose,
+   assign or donate the code to a third party and to inhibit third party
+   from using the code for non MPEG-2 NBC/MPEG-4 Audio conforming products.
+   This copyright notice must be included in all copies or derivative
+   works."
+   Copyright(c)1996.
+
+ (2) ISO/IEC 14496-3: 1999(E)
+    Subpart 4       p54.    4.5.2.3.2   decoding process
+
+------------------------------------------------------------------------------
+ PSEUDO-CODE
+
+    offset      = 0;
+    group_idx   = 0;
+
+    DO
+        pFrameInfo->group_len[group_idx] = group[group_idx] - offset;
+        offset = group[group_idx];
+        group_idx++;
+
+    WHILE (offset < NUM_SHORT_WINDOWS);
+
+
+    pFrameInfo->num_groups = group_idx;
+
+    pFrameSfbTop = pFrameInfo->frame_sfb_top;
+    offset = 0;
+
+    FOR (group_idx = 0; group_idx < pFrameInfo->num_groups; group_idx++)
+
+        len = pFrameInfo->group_len[group_idx];
+
+        FOR (sfb = 0; sfb < pFrameInfo->sfb_per_win[group_idx]; sfb++)
+
+            offset += pFrameInfo->sfb_width_128[sfb] * len;
+            *pFrameSfbTop++ = offset;
+
+        ENDFOR
+
+    ENDFOR
+
+------------------------------------------------------------------------------
+ RESOURCES USED
+   When the code is written for a specific target processor the
+     the resources used should be documented below.
+
+ STACK USAGE: [stack count for this module] + [variable to represent
+          stack usage for each subroutine called]
+
+     where: [stack usage variable] = stack usage for [subroutine
+         name] (see [filename].ext)
+
+ DATA MEMORY USED: x words
+
+ PROGRAM MEMORY USED: x words
+
+ CLOCK CYCLES: [cycle count equation for this module] + [variable
+           used to represent cycle count for each subroutine
+           called]
+
+     where: [cycle count variable] = cycle count for [subroutine
+        name] (see [filename].ext)
+
+------------------------------------------------------------------------------
+*/
+
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+#include    "pv_audio_type_defs.h"
+#include    "huffman.h"
+#include    "aac_mem_funcs.h"
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here. Include conditional
+; compile variables also.
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; LOCAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; LOCAL STORE/BUFFER/POINTER DEFINITIONS
+; Variable declaration - defined here and used outside this module
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL FUNCTION REFERENCES
+; Declare functions defined elsewhere and referenced in this module
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL GLOBAL STORE/BUFFER/POINTER REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; FUNCTION CODE
+----------------------------------------------------------------------------*/
+void  calc_gsfb_table(
+    FrameInfo   *pFrameInfo,
+    Int         group[])
+{
+
+    Int      group_idx;
+    Int      offset;
+    Int     *pFrameSfbTop;
+    Int     *pSfbWidth128;
+    Int      sfb;
+    Int      nsfb;
+    Int      len;
+    Int      ngroups;
+
+    /* clear out the default values set by infoinit */
+    /* */
+    pv_memset(pFrameInfo->frame_sfb_top,
+              0,
+              MAXBANDS*sizeof(pFrameInfo->frame_sfb_top[0]));
+    /* */
+    /* first calculate the group length*/
+    offset      = 0;
+    ngroups     = 0;
+    do
+    {
+        pFrameInfo->group_len[ngroups] = group[ngroups] - offset;
+        offset = group[ngroups];
+        ngroups++;
+
+    }
+    while (offset < NUM_SHORT_WINDOWS);
+
+
+    /* calculate the cumulative scalefactor bandwidth for one frame */
+    pFrameInfo->num_groups = ngroups;
+
+    pFrameSfbTop = pFrameInfo->frame_sfb_top;
+    offset = 0;
+
+
+    for (group_idx = 0; group_idx < ngroups; group_idx++)
+    {
+        len  = pFrameInfo->group_len[  group_idx];
+        nsfb = pFrameInfo->sfb_per_win[group_idx];
+
+        pSfbWidth128 = pFrameInfo->sfb_width_128;
+
+        for (sfb = nsfb; sfb > 0; sfb--)
+        {
+            offset += *pSfbWidth128++ * len;
+            *pFrameSfbTop++ = offset;
+        }
+    }
+
+
+} /* calc_gsfb_table */
+
diff --git a/media/libstagefright/codecs/aacdec/calc_sbr_anafilterbank.cpp b/media/libstagefright/codecs/aacdec/calc_sbr_anafilterbank.cpp
new file mode 100644
index 0000000..5ec3f69
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/calc_sbr_anafilterbank.cpp
@@ -0,0 +1,360 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Filename: calc_sbr_anafilterbank.c
+
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+
+ Who:                                   Date: MM/DD/YYYY
+ Description:
+
+------------------------------------------------------------------------------
+ INPUT AND OUTPUT DEFINITIONS
+
+
+
+------------------------------------------------------------------------------
+ FUNCTION DESCRIPTION
+
+
+------------------------------------------------------------------------------
+ REQUIREMENTS
+
+
+------------------------------------------------------------------------------
+ REFERENCES
+
+SC 29 Software Copyright Licencing Disclaimer:
+
+This software module was originally developed by
+  Coding Technologies
+
+and edited by
+  -
+
+in the course of development of the ISO/IEC 13818-7 and ISO/IEC 14496-3
+standards for reference purposes and its performance may not have been
+optimized. This software module is an implementation of one or more tools as
+specified by the ISO/IEC 13818-7 and ISO/IEC 14496-3 standards.
+ISO/IEC gives users free license to this software module or modifications
+thereof for use in products claiming conformance to audiovisual and
+image-coding related ITU Recommendations and/or ISO/IEC International
+Standards. ISO/IEC gives users the same free license to this software module or
+modifications thereof for research purposes and further ISO/IEC standardisation.
+Those intending to use this software module in products are advised that its
+use may infringe existing patents. ISO/IEC have no liability for use of this
+software module or modifications thereof. Copyright is not released for
+products that do not conform to audiovisual and image-coding related ITU
+Recommendations and/or ISO/IEC International Standards.
+The original developer retains full right to modify and use the code for its
+own purpose, assign or donate the code to a third party and to inhibit third
+parties from using the code for products that do not conform to audiovisual and
+image-coding related ITU Recommendations and/or ISO/IEC International Standards.
+This copyright notice must be included in all copies or derivative works.
+Copyright (c) ISO/IEC 2002.
+
+------------------------------------------------------------------------------
+ PSEUDO-CODE
+
+------------------------------------------------------------------------------
+*/
+
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+
+#ifdef AAC_PLUS
+
+
+#include    "calc_sbr_anafilterbank.h"
+#include    "qmf_filterbank_coeff.h"
+#include    "analysis_sub_band.h"
+
+#include    "aac_mem_funcs.h"
+#include    "fxp_mul32.h"
+
+
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here. Include conditional
+; compile variables also.
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; LOCAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; LOCAL STORE/BUFFER/POINTER DEFINITIONS
+; Variable declaration - defined here and used outside this module
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL FUNCTION REFERENCES
+; Declare functions defined elsewhere and referenced in this module
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL GLOBAL STORE/BUFFER/POINTER REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; FUNCTION CODE
+----------------------------------------------------------------------------*/
+
+void calc_sbr_anafilterbank_LC(Int32 * Sr,
+                               Int16 * X,
+                               Int32 scratch_mem[][64],
+                               Int32 maxBand)
+{
+
+    Int i;
+    Int32   *p_Y_1;
+    Int32   *p_Y_2;
+
+    Int16 * pt_X_1;
+    Int16 * pt_X_2;
+    Int32 realAccu1;
+    Int32 realAccu2;
+
+    Int32 tmp1;
+    Int32 tmp2;
+
+
+    const Int32 * pt_C;
+
+    p_Y_1 = scratch_mem[0];
+
+
+    p_Y_2 = p_Y_1 + 63;
+    pt_C   = &sbrDecoderFilterbankCoefficients_an_filt_LC[0];
+
+    pt_X_1 = X;
+
+
+    realAccu1  =  fxp_mul32_by_16(Qfmt27(-0.51075594183097F),   pt_X_1[-192]);
+
+    realAccu1  =  fxp_mac32_by_16(Qfmt27(-0.51075594183097F), -pt_X_1[-128], realAccu1);
+    realAccu1  =  fxp_mac32_by_16(Qfmt27(-0.01876919066980F),  pt_X_1[-256], realAccu1);
+    *(p_Y_1++) =  fxp_mac32_by_16(Qfmt27(-0.01876919066980F), -pt_X_1[ -64], realAccu1);
+
+
+    /* create array Y */
+
+    pt_X_1 = &X[-1];
+    pt_X_2 = &X[-319];
+
+
+    for (i = 15; i != 0; i--)
+    {
+        tmp1 = *(pt_X_1--);
+        tmp2 = *(pt_X_2++);
+
+        realAccu1  = fxp_mul32_by_16(*(pt_C), tmp1);
+        realAccu2  = fxp_mul32_by_16(*(pt_C++), tmp2);
+        tmp1 = pt_X_1[ -63];
+        tmp2 = pt_X_2[ +63];
+        realAccu1  = fxp_mac32_by_16(*(pt_C), tmp1, realAccu1);
+        realAccu2  = fxp_mac32_by_16(*(pt_C++), tmp2, realAccu2);
+        tmp1 = pt_X_1[ -127];
+        tmp2 = pt_X_2[ +127];
+        realAccu1  = fxp_mac32_by_16(*(pt_C), tmp1, realAccu1);
+        realAccu2  = fxp_mac32_by_16(*(pt_C++), tmp2, realAccu2);
+        tmp1 = pt_X_1[ -191];
+        tmp2 = pt_X_2[ +191];
+        realAccu1  = fxp_mac32_by_16(*(pt_C), tmp1, realAccu1);
+        realAccu2  = fxp_mac32_by_16(*(pt_C++), tmp2, realAccu2);
+        tmp1 = pt_X_1[ -255];
+        tmp2 = pt_X_2[ +255];
+        *(p_Y_1++) = fxp_mac32_by_16(*(pt_C), tmp1, realAccu1);
+        *(p_Y_2--) = fxp_mac32_by_16(*(pt_C++), tmp2, realAccu2);
+
+        tmp1 = *(pt_X_1--);
+        tmp2 = *(pt_X_2++);
+        realAccu1  = fxp_mul32_by_16(*(pt_C), tmp1);
+        realAccu2  = fxp_mul32_by_16(*(pt_C++), tmp2);
+
+        tmp1 = pt_X_1[ -63];
+        tmp2 = pt_X_2[ +63];
+        realAccu1  = fxp_mac32_by_16(*(pt_C), tmp1, realAccu1);
+        realAccu2  = fxp_mac32_by_16(*(pt_C++), tmp2, realAccu2);
+        tmp1 = pt_X_1[ -127];
+        tmp2 = pt_X_2[ +127];
+        realAccu1  = fxp_mac32_by_16(*(pt_C), tmp1, realAccu1);
+        realAccu2  = fxp_mac32_by_16(*(pt_C++), tmp2, realAccu2);
+        tmp1 = pt_X_1[ -191];
+        tmp2 = pt_X_2[ +191];
+        realAccu1  = fxp_mac32_by_16(*(pt_C), tmp1, realAccu1);
+        realAccu2  = fxp_mac32_by_16(*(pt_C++), tmp2, realAccu2);
+        tmp1 = pt_X_1[ -255];
+        tmp2 = pt_X_2[ +255];
+        *(p_Y_1++) = fxp_mac32_by_16(*(pt_C), tmp1, realAccu1);
+        *(p_Y_2--) = fxp_mac32_by_16(*(pt_C++), tmp2, realAccu2);
+
+    }
+
+
+    tmp1 = *(pt_X_1--);
+    tmp2 = *(pt_X_2++);
+    realAccu1  = fxp_mul32_by_16(*(pt_C), tmp1);
+    realAccu2  = fxp_mul32_by_16(*(pt_C++), tmp2);
+
+    tmp1 = pt_X_1[ -63];
+    tmp2 = pt_X_2[ +63];
+    realAccu1  = fxp_mac32_by_16(*(pt_C), tmp1, realAccu1);
+    realAccu2  = fxp_mac32_by_16(*(pt_C++), tmp2, realAccu2);
+    tmp1 = pt_X_1[ -127];
+    tmp2 = pt_X_2[ +127];
+    realAccu1  = fxp_mac32_by_16(*(pt_C), tmp1, realAccu1);
+    realAccu2  = fxp_mac32_by_16(*(pt_C++), tmp2, realAccu2);
+    tmp1 = pt_X_1[ -191];
+    tmp2 = pt_X_2[ +191];
+    realAccu1  = fxp_mac32_by_16(*(pt_C), tmp1, realAccu1);
+    realAccu2  = fxp_mac32_by_16(*(pt_C++), tmp2, realAccu2);
+    tmp1 = pt_X_1[ -255];
+    tmp2 = pt_X_2[ +255];
+    *(p_Y_1++) = fxp_mac32_by_16(*(pt_C), tmp1, realAccu1);
+    *(p_Y_2--) = fxp_mac32_by_16(*(pt_C++), tmp2, realAccu2);
+
+
+    pt_X_1 = X;
+
+    realAccu2  = fxp_mul32_by_16(Qfmt27(0.00370548843500F), X[ -32]);
+
+    realAccu2  = fxp_mac32_by_16(Qfmt27(0.00370548843500F), pt_X_1[-288], realAccu2);
+    realAccu2  = fxp_mac32_by_16(Qfmt27(0.09949460091720F), pt_X_1[ -96], realAccu2);
+    realAccu2  = fxp_mac32_by_16(Qfmt27(0.09949460091720F), pt_X_1[-224], realAccu2);
+    *(p_Y_1++) = fxp_mac32_by_16(Qfmt27(1.20736865027288F), pt_X_1[-160], realAccu2);
+
+
+    analysis_sub_band_LC(scratch_mem[0],
+                         Sr,
+                         maxBand,
+                         (Int32(*)[64])scratch_mem[1]);
+
+}
+
+
+
+#ifdef HQ_SBR
+
+void calc_sbr_anafilterbank(Int32 * Sr,
+                            Int32 * Si,
+                            Int16 * X,
+                            Int32 scratch_mem[][64],
+                            Int32   maxBand)
+{
+    Int i;
+    Int32   *p_Y_1;
+    Int32   *p_Y_2;
+
+
+
+
+    const Int32 * pt_C;
+    Int16 * pt_X_1;
+    Int16 * pt_X_2;
+    Int32 realAccu1;
+    Int32 realAccu2;
+
+    Int32 tmp1;
+    Int32 tmp2;
+
+
+    p_Y_1 = scratch_mem[0];
+
+
+    p_Y_2 = p_Y_1 + 63;
+    pt_C   = &sbrDecoderFilterbankCoefficients_an_filt[0];
+
+    realAccu1  =  fxp_mul32_by_16(Qfmt27(-0.36115899F),   X[-192]);
+
+
+    realAccu1  =  fxp_mac32_by_16(Qfmt27(-0.36115899F),  -X[-128], realAccu1);
+    realAccu1  =  fxp_mac32_by_16(Qfmt27(-0.013271822F),  X[-256], realAccu1);
+    *(p_Y_1++) =  fxp_mac32_by_16(Qfmt27(-0.013271822F), -X[ -64], realAccu1);
+
+    /* create array Y */
+
+    pt_X_1 = &X[-1];
+    pt_X_2 = &X[-319];
+
+
+    for (i = 31; i != 0; i--)
+    {
+        tmp1 = *(pt_X_1--);
+        tmp2 = *(pt_X_2++);
+        realAccu1  = fxp_mul32_by_16(*(pt_C), tmp1);
+        realAccu2  = fxp_mul32_by_16(*(pt_C++), tmp2);
+        tmp1 = pt_X_1[ -63];
+        tmp2 = pt_X_2[  63];
+        realAccu1  = fxp_mac32_by_16(*(pt_C), tmp1, realAccu1);
+        realAccu2  = fxp_mac32_by_16(*(pt_C++), tmp2, realAccu2);
+        tmp1 = pt_X_1[ -127];
+        tmp2 = pt_X_2[  127];
+        realAccu1  = fxp_mac32_by_16(*(pt_C), tmp1, realAccu1);
+        realAccu2  = fxp_mac32_by_16(*(pt_C++), tmp2, realAccu2);
+        tmp1 = pt_X_1[ -191];
+        tmp2 = pt_X_2[  191];
+        realAccu1  = fxp_mac32_by_16(*(pt_C), tmp1, realAccu1);
+        realAccu2  = fxp_mac32_by_16(*(pt_C++), tmp2, realAccu2);
+        tmp1 = pt_X_1[ -255];
+        tmp2 = pt_X_2[  255];
+        *(p_Y_1++) = fxp_mac32_by_16(*(pt_C), tmp1, realAccu1);
+        *(p_Y_2--) = fxp_mac32_by_16(*(pt_C++), tmp2, realAccu2);
+    }
+
+
+    realAccu2  = fxp_mul32_by_16(Qfmt27(0.002620176F), X[ -32]);
+    realAccu2  = fxp_mac32_by_16(Qfmt27(0.002620176F), X[-288], realAccu2);
+    realAccu2  = fxp_mac32_by_16(Qfmt27(0.070353307F), X[ -96], realAccu2);
+    realAccu2  = fxp_mac32_by_16(Qfmt27(0.070353307F), X[-224], realAccu2);
+
+
+    *(p_Y_1++) = fxp_mac32_by_16(Qfmt27(0.85373856F), (X[-160]), realAccu2);
+
+
+    analysis_sub_band(scratch_mem[0],
+                      Sr,
+                      Si,
+                      maxBand,
+                      (Int32(*)[64])scratch_mem[1]);
+
+}
+
+
+#endif
+
+
+
+#endif   /*  AAC_PLUS */
+
diff --git a/media/libstagefright/codecs/aacdec/calc_sbr_anafilterbank.h b/media/libstagefright/codecs/aacdec/calc_sbr_anafilterbank.h
new file mode 100644
index 0000000..c93848e
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/calc_sbr_anafilterbank.h
@@ -0,0 +1,113 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Filename: calc_sbr_anafilterbank.h
+ Funtions:
+    get_dse
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+
+ Who:                                   Date: MM/DD/YYYY
+ Description:
+------------------------------------------------------------------------------
+
+*/
+
+/*----------------------------------------------------------------------------
+; CONTINUE ONLY IF NOT ALREADY DEFINED
+----------------------------------------------------------------------------*/
+#ifndef CALC_SBR_ANAFILTERBANK_H
+#define CALC_SBR_ANAFILTERBANK_H
+
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+
+#include "pv_audio_type_defs.h"
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+    /*----------------------------------------------------------------------------
+    ; MACROS
+    ; Define module specific macros here
+    ----------------------------------------------------------------------------*/
+
+    /*----------------------------------------------------------------------------
+    ; DEFINES
+    ; Include all pre-processor statements here.
+    ----------------------------------------------------------------------------*/
+
+#define ROUND_ANAFIL     0
+//#define ROUND_ANAFIL     0
+#define ROUND_ANAFIL_LC  (0)
+
+    /*----------------------------------------------------------------------------
+    ; EXTERNAL VARIABLES REFERENCES
+    ; Declare variables used in this module but defined elsewhere
+    ----------------------------------------------------------------------------*/
+
+    /*----------------------------------------------------------------------------
+    ; SIMPLE TYPEDEF'S
+    ----------------------------------------------------------------------------*/
+
+    /*----------------------------------------------------------------------------
+    ; ENUMERATED TYPEDEF'S
+    ----------------------------------------------------------------------------*/
+
+    /*----------------------------------------------------------------------------
+    ; STRUCTURES TYPEDEF'S
+    ----------------------------------------------------------------------------*/
+
+    /*----------------------------------------------------------------------------
+    ; GLOBAL FUNCTION DEFINITIONS
+    ; Function Prototype declaration
+    ----------------------------------------------------------------------------*/
+
+
+    void calc_sbr_anafilterbank_LC(Int32 * Sr,
+    Int16 * X,
+    Int32 scratch_mem[][64],
+    Int32 maxBand);
+
+
+#ifdef HQ_SBR
+
+    void calc_sbr_anafilterbank(Int32 * Sr,
+                                Int32 * Si,
+                                Int16 * X,
+                                Int32 scratch_mem[][64],
+                                Int32 maxBand);
+
+#endif
+
+
+#ifdef __cplusplus
+}
+#endif
+
+/*----------------------------------------------------------------------------
+; END
+----------------------------------------------------------------------------*/
+#endif  /*  CALC_SBR_ANAFILTERBANK_H */
diff --git a/media/libstagefright/codecs/aacdec/calc_sbr_envelope.cpp b/media/libstagefright/codecs/aacdec/calc_sbr_envelope.cpp
new file mode 100644
index 0000000..4fb3535
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/calc_sbr_envelope.cpp
@@ -0,0 +1,2203 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+ Filename: calc_sbr_envelope.c
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+
+ Who:                                   Date: MM/DD/YYYY
+ Description:
+
+------------------------------------------------------------------------------
+ INPUT AND OUTPUT DEFINITIONS
+
+
+
+------------------------------------------------------------------------------
+ FUNCTION DESCRIPTION
+
+
+------------------------------------------------------------------------------
+ REQUIREMENTS
+
+
+------------------------------------------------------------------------------
+ REFERENCES
+
+SC 29 Software Copyright Licencing Disclaimer:
+
+This software module was originally developed by
+  Coding Technologies
+
+and edited by
+  -
+
+in the course of development of the ISO/IEC 13818-7 and ISO/IEC 14496-3
+standards for reference purposes and its performance may not have been
+optimized. This software module is an implementation of one or more tools as
+specified by the ISO/IEC 13818-7 and ISO/IEC 14496-3 standards.
+ISO/IEC gives users free license to this software module or modifications
+thereof for use in products claiming conformance to audiovisual and
+image-coding related ITU Recommendations and/or ISO/IEC International
+Standards. ISO/IEC gives users the same free license to this software module or
+modifications thereof for research purposes and further ISO/IEC standardisation.
+Those intending to use this software module in products are advised that its
+use may infringe existing patents. ISO/IEC have no liability for use of this
+software module or modifications thereof. Copyright is not released for
+products that do not conform to audiovisual and image-coding related ITU
+Recommendations and/or ISO/IEC International Standards.
+The original developer retains full right to modify and use the code for its
+own purpose, assign or donate the code to a third party and to inhibit third
+parties from using the code for products that do not conform to audiovisual and
+image-coding related ITU Recommendations and/or ISO/IEC International Standards.
+This copyright notice must be included in all copies or derivative works.
+Copyright (c) ISO/IEC 2002.
+
+------------------------------------------------------------------------------
+ PSEUDO-CODE
+
+------------------------------------------------------------------------------
+*/
+
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+
+#ifdef AAC_PLUS
+
+
+#include    "calc_sbr_envelope.h"
+#include    "sbr_envelope_calc_tbl.h"
+#include    "sbr_create_limiter_bands.h"
+#include    "aac_mem_funcs.h"
+
+#include    "fxp_mul32.h"
+#include    "pv_normalize.h"
+
+#include    "sbr_aliasing_reduction.h"
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here. Include conditional
+; compile variables also.
+----------------------------------------------------------------------------*/
+#include    "pv_sqrt.h"
+
+#include    "pv_div.h"
+#include    "fxp_mul32.h"
+#include    "pv_normalize.h"
+
+#define Q30fmt(x)   (Int32)(x*((Int32)1<<30) + (x>=0?0.5F:-0.5F))
+#define Q28fmt(x)   (Int32)(x*((Int32)1<<28) + (x>=0?0.5F:-0.5F))
+#define Q15fmt(x)   (Int32)(x*((Int32)1<<15) + (x>=0?0.5F:-0.5F))
+
+
+/*----------------------------------------------------------------------------
+; LOCAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+    void envelope_application_LC(Int32  *aBufR,
+    Int32  *nrg_gain_man,
+    Int32  *nrg_gain_exp,
+    Int32  *noise_level_man,
+    Int32  *noise_level_exp,
+    Int32  *nrg_tone_man,
+    Int32  *nrg_tone_exp,
+    Int32  band_nrg_tone_detector,
+    const Int32 *frame_info,
+    Int32  *harm_index,
+    Int32  *phase_index,
+    Int32  i,
+    Int32  lowSubband,
+    Int32  noSubbands,
+    Int32  noNoiseFlag);
+
+
+    void energy_estimation_LC(Int32 *aBufR,
+                              Int32 *nrg_est_man,
+                              Int32 *nrg_est_exp,
+                              const Int32 *frame_info,
+                              Int32 i,
+                              Int32 k,
+                              Int32 c,
+                              Int32 ui2);
+
+#ifdef HQ_SBR
+
+
+    void envelope_application(Int32  *aBufR,
+                              Int32  *aBufI,
+                              Int32  *nrg_gain_man,
+                              Int32  *nrg_gain_exp,
+                              Int32  *noise_level_man,
+                              Int32  *noise_level_exp,
+                              Int32  *nrg_tone_man,
+                              Int32  *nrg_tone_exp,
+                              Int32 *fBuf_man[64],
+                              Int32 *fBuf_exp[64],
+                              Int32 *fBufN_man[64],
+                              Int32 *fBufN_exp[64],
+                              const Int32 *frame_info,
+                              Int32  *harm_index,
+                              Int32  *phase_index,
+                              Int32  i,
+                              Int32  lowSubband,
+                              Int32  noSubbands,
+                              Int32  noNoiseFlag,
+                              Int32  band_nrg_tone_detector,
+                              Int32  maxSmoothLength,
+                              Int32  smooth_length);
+
+
+    void energy_estimation(Int32 *aBufR,
+                           Int32 *aBufI,
+                           Int32 *nrg_est_man,
+                           Int32 *nrg_est_exp,
+                           const Int32 *frame_info,
+                           Int32 i,
+                           Int32 k,
+                           Int32 c,
+                           Int32 ui2);
+
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+
+/*----------------------------------------------------------------------------
+; LOCAL STORE/BUFFER/POINTER DEFINITIONS
+; Variable declaration - defined here and used outside this module
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL FUNCTION REFERENCES
+; Declare functions defined elsewhere and referenced in this module
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL GLOBAL STORE/BUFFER/POINTER REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; FUNCTION CODE
+----------------------------------------------------------------------------*/
+
+void calc_sbr_envelope(SBR_FRAME_DATA *frameData,
+                       Int32 *aBufR,
+                       Int32 *aBufI,
+                       Int freqBandTable1[2][MAX_FREQ_COEFFS + 1],
+                       const Int32 *nSfb,
+                       Int32 freqBandTable2[MAX_NOISE_COEFFS + 1],
+                       Int32 nNBands,
+                       Int32 reset,
+                       Int32 *degreeAlias,
+                       Int32 *harm_index,
+                       Int32 *phase_index,
+                       Int32 hFp[64],
+                       Int32 *sUp,
+                       Int32 limSbc[][13],
+                       Int32 *gateMode,
+#ifdef HQ_SBR
+                       Int32 *fBuf_man[64],
+                       Int32 *fBuf_exp[64],
+                       Int32 *fBufN_man[64],
+                       Int32 *fBufN_exp[64],
+#endif
+                       Int32 scratch_mem[][64],
+                       struct PATCH Patch,
+                       Int32  sqrt_cache[][4],
+                       Int32  LC_flag)
+{
+
+    Int32 c;
+    Int32 li;
+    Int32 ui;
+    Int32 i;
+    Int32 j;
+    Int32 k = 0;
+    Int32 l;
+    Int m = 0;
+    Int kk = 0;
+    Int o;
+    Int next = -1;
+    Int32 ui2;
+    Int flag;
+    Int noNoiseFlag;
+    Int *ptr;
+
+
+    UInt32 nrg = 0;
+    Int32 nrg_exp = 0;
+    struct intg_div   quotient;
+    struct intg_sqrt  root_sq;
+
+    Int32 aux1;
+
+    Int32 *nL_man       = frameData->sbrNoiseFloorLevel_man;
+    Int32 *nL_exp       = frameData->sbrNoiseFloorLevel_exp;
+
+    Int32 *sfb_nrg_man  = frameData->iEnvelope_man;
+    Int32 *sfb_nrg_exp  = frameData->iEnvelope_exp;
+
+    Int32 tmp_q1;
+    Int32 tmp_q2;
+
+    Int32 g_max_man;
+    Int32 g_max_exp;
+
+    Int32 p_ref_man;
+    Int32 p_ref_exp;
+
+    Int32 p_est_man;
+    Int32 p_est_exp;
+
+    Int32 p_adj_man;
+    Int32 p_adj_exp;
+    Int32 avg_gain;
+
+    Int32 boost_gain_q;
+
+    Int32 band_nrg_tone_detector;
+
+    Int32 *nrg_est_man     = scratch_mem[0];
+    Int32 *nrg_est_exp     = scratch_mem[1];
+    Int32 *nrg_ref_man     = scratch_mem[2];
+    Int32 *nrg_ref_exp     = scratch_mem[3];
+    Int32 *nrg_gain_man    = scratch_mem[4];
+    Int32 *nrg_gain_exp    = scratch_mem[5];
+    Int32 *noise_level_man = scratch_mem[6];
+    Int32 *noise_level_exp = scratch_mem[7];
+    Int32 *nrg_tone_man    = scratch_mem[8];
+    Int32 *nrg_tone_exp    = scratch_mem[9];
+    Int32 *hF              = scratch_mem[10];
+
+
+
+    const Int32 *frame_info = frameData->frameInfo;
+    Int32 int_mode          = frameData->sbr_header.interpolFreq;
+
+
+
+
+
+    Int32 dontUseTheseGainValues[64];
+
+#ifdef HQ_SBR
+
+    Int32 n;
+    Int32 smooth_length;
+    Int32 smoothingLength   = frameData->sbr_header.smoothingLength;
+    Int32 maxSmoothLength   = smoothLengths[0];
+
+#endif
+
+    Int32 limiterBand       = frameData->sbr_header.limiterBands;
+    Int32 limiterGains      = frameData->sbr_header.limiterGains;
+    Int32 *addHarmonics     = frameData->addHarmonics;
+
+    Int32 lowSubband        = freqBandTable1[LOW_RES][0];
+    Int32 noSubbands        = freqBandTable1[LOW_RES][nSfb[LOW_RES]] - lowSubband;
+    Int32 nEnv              = frame_info[0];
+    Int32 sEnv              = frame_info[(nEnv + 1)<<1];
+
+    /* ensure that noSubbands in the range [0,64] */
+    noSubbands = (noSubbands >> 31) ^ noSubbands;
+    if (noSubbands > 64)
+    {
+        noSubbands = 64;
+    }
+
+    if (reset)
+    {
+        *sUp = 1;
+        *phase_index = 0;
+        sbr_create_limiter_bands(limSbc,
+                                 gateMode,
+                                 freqBandTable1[LOW_RES],
+                                 Patch,
+                                 nSfb[LOW_RES]);
+    }
+
+    /* Mapping. */
+    pv_memset((void*)hF, 0, (sizeof(*hF) << 6));
+
+    ptr  = freqBandTable1[HI];
+    l = *(ptr++);
+
+    for (i = nSfb[HI]; i != 0; i--)
+    {
+        k     = *(ptr++);
+        j     = ((k + l) >> 1) - lowSubband;
+        l   = k;
+        hF[j] = *(addHarmonics++);
+    }
+
+
+    /* Envelope adjustment. */
+
+    for (i = 0; i < nEnv; i++)
+    {
+
+        if (frame_info[1+i] == frame_info[(nEnv<<1)+4+kk])
+        {
+            kk++, next++;
+        }
+
+        noNoiseFlag = (i == sEnv || i == frameData->prevEnvIsShort) ? 1 : 0;
+
+#ifdef HQ_SBR
+        smooth_length = (noNoiseFlag ? 0 : smoothLengths[smoothingLength]);
+#endif
+
+
+        /* Estimate levels. */
+        c = 0;
+        o = 0;
+
+        band_nrg_tone_detector = 0;
+
+        Int kkkk = freqBandTable1[ frame_info[nEnv+2+i] ][0];
+
+        for (j = 0; j <  nSfb[frame_info[nEnv+2+i]]; j++)
+        {
+            li = freqBandTable1[ frame_info[nEnv+2+i] ][j    ];
+            ui = freqBandTable1[ frame_info[nEnv+2+i] ][j + 1];
+            flag = 0;
+
+            for (k = li; k < ui; k++)
+            {                               /* Calculate the average energy over the current envelope, */
+                ui2   = (frame_info[1+i] << 1);
+
+                if (LC_flag == ON)
+                {
+                    energy_estimation_LC((Int32 *)aBufR,
+                                         nrg_est_man,
+                                         nrg_est_exp,
+                                         frame_info,
+                                         i,
+                                         k - kkkk,
+                                         c,
+                                         ui2);
+                }
+#ifdef HQ_SBR
+                else
+                {
+
+                    energy_estimation((Int32 *)aBufR,
+                                      (Int32 *)aBufI,
+                                      nrg_est_man,
+                                      nrg_est_exp,
+                                      frame_info,
+                                      i,
+                                      k - kkkk,
+                                      c,
+                                      ui2);
+                }
+#endif
+
+                flag = (hF[c] && (i >= sEnv || hFp[c+lowSubband])) ? 1 : flag;
+                c++;
+            }
+
+
+            ui2 = freqBandTable2[o+1];
+
+            if (!int_mode)
+            {                                /* If no interpolation is used,   */
+
+                tmp_q1 = -100;
+
+                for (k = c - (ui - li); k < c; k++)
+                {
+                    if (tmp_q1 < nrg_est_exp[k])
+                    {
+                        tmp_q1 = nrg_est_exp[k];
+                    }
+                }
+
+                nrg = 0;
+                for (k = c - (ui - li); k < c; k++)
+                {    /* average the energy in all the QMF bands, */
+                    nrg += nrg_est_man[k] >> (tmp_q1 - nrg_est_exp[k]); /* for the whole scalefactor band.  */
+                }
+                nrg /= (ui - li);
+                nrg_exp = tmp_q1;
+
+            }
+
+            c -= (ui - li);
+
+            for (k = 0; k < ui - li; k++)
+            {
+                o = (k + li >= ui2) ? o + 1 : o;
+                ui2 = freqBandTable2[o+1];
+                /*
+                 *  If no interpolation is used, use the averaged energy from above,
+                 *  otherwise do nothing.
+                 */
+
+
+                if (!int_mode)
+                {
+                    nrg_est_man[c] = nrg;
+                    nrg_est_exp[c] = nrg_exp;
+                }
+
+                if (LC_flag == ON)
+                {
+                    nrg_est_exp[c] += 1;
+
+                    if (flag)
+                    {
+                        dontUseTheseGainValues[k + li - lowSubband] = 1;
+                    }
+                    else
+                    {
+                        dontUseTheseGainValues[k + li - lowSubband] = 0;
+                    }
+                }
+
+                nrg_ref_man[c] = sfb_nrg_man[m];
+                nrg_ref_exp[c] = sfb_nrg_exp[m];
+
+                /*
+                 *  compute nL/(1 + nL);   where nL = nL_man*2^nL_exp
+                 */
+                aux1 = next * nNBands + o;
+
+                tmp_q1 = nL_exp[aux1];
+
+                if (tmp_q1 >= 0)
+                {
+                    pv_div(nL_man[aux1], nL_man[aux1] + (0x3FFFFFFF >> tmp_q1), &quotient);
+                }
+                else
+                {
+                    tmp_q1 = nL_man[aux1] >> (-tmp_q1);
+                    pv_div(tmp_q1, tmp_q1 + 0x3FFFFFFF, &quotient);
+                }
+
+                /*
+                 *  tmp_q1 = nL/(1 + nL)*nrg_ref[c];
+                 */
+
+                tmp_q1 = fxp_mul32_Q30(quotient.quotient >> quotient.shift_factor,  nrg_ref_man[c]);
+
+                if (flag)
+                {
+                    /*
+                     *  Calculate levels and gain, dependent on whether a synthetic, a sine is present or not.
+                     *
+                     *  nrg_gain[c]=(float)pv_sqrt( tmp/(nrg_est[c] + 1), sqrt_cache[1] );
+                     */
+
+
+                    pv_div(tmp_q1, nrg_est_man[c] + 1, &quotient);
+                    /*
+                     *  nrg_est_man[c] is an integer number, while tmp_q1 and quotient.quotient
+                     *  are fractions in Q30
+                     */
+
+                    tmp_q2 = nrg_ref_exp[c] - nrg_est_exp[c] - quotient.shift_factor - 30;
+
+                    pv_sqrt(quotient.quotient, tmp_q2, &root_sq, sqrt_cache[1]);
+                    nrg_gain_man[c] = root_sq.root;     /*  in Q28 format */
+                    nrg_gain_exp[c] = root_sq.shift_factor;
+
+
+                    /*
+                     *  nrg_tone[c]=(float)( (hF[c] && (i >= sEnv || hFp[c+lowSubband])) ?
+                     *                          pv_sqrt(nrg_ref[c]/(1+tmp_nL), sqrt_cache[2]) : 0);
+                     */
+                    if (hF[c] && (i >= sEnv || hFp[c+lowSubband]))
+                    {
+                        /*
+                         *  nrg_ref[c] and  nL, as well as quotient.quotient
+                         *  are fractions in Q30
+                         */
+
+                        /*  aux1 == next*nNBands + o */
+
+                        tmp_q2 = nL_exp[aux1];
+                        /*
+                         *  nrg_ref[c]/(1+tmp_nL)
+                         */
+
+                        if (tmp_q2 >= 0)
+                        {
+                            pv_div(nrg_ref_man[c], nL_man[aux1] + (0x3FFFFFFF >> tmp_q2), &quotient);
+                        }
+                        else
+                        {
+                            tmp_q2 = nL_man[aux1] >> (-tmp_q2);
+                            pv_div(nrg_ref_man[c], tmp_q2 + 0x3FFFFFFF, &quotient);
+                            tmp_q2 = 0;     /* exponent has been applied to the sum ((man>>exp) + 1)  */
+                        }
+
+                        tmp_q2 = nrg_ref_exp[c] - tmp_q2 - quotient.shift_factor;
+
+                        pv_sqrt(quotient.quotient, tmp_q2, &root_sq, sqrt_cache[2]);
+                        nrg_tone_man[c]    = root_sq.root;
+                        nrg_tone_exp[c]    = root_sq.shift_factor;
+
+                    }
+                    else
+                    {
+                        nrg_tone_man[c]    = 0;
+                        nrg_tone_exp[c]    = 0;
+                    }
+
+                }
+                else
+                {
+                    if (noNoiseFlag)
+                    {
+                        /*
+                         * nrg_gain[c] = (float) pv_sqrt(nrg_ref[c] /(nrg_est[c] + 1), sqrt_cache[3]);
+                         */
+
+                        pv_div(nrg_ref_man[c], nrg_est_man[c] + 1, &quotient);
+
+                        /*
+                         *  nrg_est_man[c] is an integer number, while nrg_ref_man[c] and
+                         *  quotient.quotient are fractions in Q30
+                         */
+
+                        tmp_q2 = nrg_ref_exp[c] - nrg_est_exp[c] - quotient.shift_factor - 30;
+
+                        pv_sqrt(quotient.quotient, tmp_q2, &root_sq, sqrt_cache[3]);
+                        nrg_gain_man[c] = root_sq.root;
+                        nrg_gain_exp[c] = root_sq.shift_factor;
+
+                    }
+                    else
+                    {
+                        /*
+                         *  nrg_gain[c] = (float) pv_sqrt(nrg_ref[c]/((nrg_est[c] + 1)*(1+tmp_nL)), sqrt_cache[4]);
+                         */
+                        /*  aux1 == next*nNBands + o */
+
+                        tmp_q2 = nL_exp[aux1];
+                        /*
+                         *  nrg_ref[c]/((nrg_est[c] + 1)*(1+tmp_nL))
+                         */
+
+                        if (nrg_est_man[c] == 0)
+                        {
+                            tmp_q2 = 0;     /*  avoid division by 0 in next if-else, this could be due to
+                                                rounding noise */
+                        }
+
+
+                        if (tmp_q2 >= 0)
+                        {
+
+                            tmp_q2 = fxp_mul32_Q30(nrg_est_man[c] + 1, nL_man[aux1] + (0x3FFFFFFF >> tmp_q2));
+                            pv_div(nrg_ref_man[c], tmp_q2, &quotient);
+                            /*
+                             *  nrg_est_man[c] is an integer number, while nrg_ref_man[c] and
+                             *  quotient.quotient are fractions in Q30
+                             */
+                            tmp_q2 = nrg_ref_exp[c] - quotient.shift_factor - 30 - nL_exp[aux1];
+                            if (nrg_est_man[c])
+                            {
+                                tmp_q2 -=  nrg_est_exp[c];
+                            }
+
+                            tmp_q2 = nrg_ref_exp[c] - nrg_est_exp[c] - quotient.shift_factor - 30 - nL_exp[aux1];
+                        }
+                        else
+                        {
+                            if (tmp_q2 > - 10)
+                            {
+                                tmp_q2 = nL_man[aux1] >> (-tmp_q2);
+
+                                tmp_q2 = fxp_mul32_Q30(nrg_est_man[c] + 1, tmp_q2 + 0x3FFFFFFF);
+                            }
+                            else
+                            {
+                                tmp_q2 = nrg_est_man[c] + 1;
+                            }
+
+
+                            pv_div(nrg_ref_man[c], tmp_q2, &quotient);
+                            /*
+                             *  nrg_est_man[c] is an integer number, while nrg_ref_man[c] and
+                             *  quotient.quotient are fractions in Q30
+                             */
+
+                            tmp_q2 = nrg_ref_exp[c] - quotient.shift_factor - 30;
+                            if (nrg_est_man[c])
+                            {
+                                tmp_q2 -=  nrg_est_exp[c];
+                            }
+
+                        }
+
+                        pv_sqrt(quotient.quotient, tmp_q2, &root_sq, sqrt_cache[4]);
+                        nrg_gain_man[c] = root_sq.root;
+                        nrg_gain_exp[c] = root_sq.shift_factor;
+
+                    }
+
+                    nrg_tone_man[c]    = 0;
+                    nrg_tone_exp[c]    = -100;
+
+                }
+
+                band_nrg_tone_detector |= nrg_tone_man[c];   /*  detect any tone activity  */
+
+                pv_sqrt(tmp_q1, nrg_ref_exp[c], &root_sq, sqrt_cache[5]);
+                noise_level_man[c] = root_sq.root;
+                noise_level_exp[c] = root_sq.shift_factor;
+
+                c++;
+
+            }   /* ---- end-for-loop (k) ------ */
+            m++;
+
+        }   /* -------- Estimate levels end-for-loop (j) ----- */
+
+
+
+        /*
+         *      Limiter
+         */
+
+
+        for (c = 0; c < gateMode[limiterBand]; c++)
+        {
+
+            p_ref_man = 0;
+            p_est_man = 0;
+
+            /*
+             *  get max exponent for the reference and estimated energy
+             */
+            p_ref_exp = -100;
+            p_est_exp = -100;
+
+            for (k = limSbc[limiterBand][c]; k < limSbc[limiterBand][c + 1]; k++)
+            {
+                if (p_ref_exp < nrg_ref_exp[k])
+                {
+                    p_ref_exp = nrg_ref_exp[k];    /* max */
+                }
+                if (p_est_exp < nrg_est_exp[k])
+                {
+                    p_est_exp = nrg_est_exp[k];    /* max */
+                }
+            }
+
+            k -= limSbc[limiterBand][c];     /*  number of element used in the addition */
+
+            while (k != 0)      /*  bit guard protection depends on log2(k)  */
+            {
+                k >>= 1;
+                p_ref_exp++;       /*  add extra bit-overflow-guard, nrg_ref_exp is in Q30 format */
+            }
+
+
+            for (k = limSbc[limiterBand][c]; k < limSbc[limiterBand][c + 1]; k++)
+            {   /*Calculate the average gain for the current limiter band.*/
+                p_ref_man += (nrg_ref_man[k] >> (p_ref_exp - nrg_ref_exp[k]));
+                p_est_man += (nrg_est_man[k] >> (p_est_exp - nrg_est_exp[k]));
+
+            }
+
+            if (p_est_man)
+            {
+                /*
+                 *  "average gain" (not equal to average of nrg_gain)
+                 */
+                pv_div(p_ref_man, p_est_man, &quotient);
+
+                tmp_q2 = p_ref_exp - 30 - p_est_exp - quotient.shift_factor;
+
+                /*
+                 *  avg_gain = sqrt(p_ref/p_est)
+                 */
+                pv_sqrt(quotient.quotient, tmp_q2, &root_sq, sqrt_cache[6]);
+                avg_gain  = root_sq.root;
+                g_max_exp = root_sq.shift_factor;
+
+                /*
+                 *  maximum gain allowed is calculated from table.
+                 */
+
+                /*
+                 *  g_max = avg_gain * limGains[limiterGains];
+                 */
+
+                g_max_man = fxp_mul32_Q30(avg_gain, limGains[limiterGains]);   /*  table is in Q30 */
+
+                if (limiterGains == 3)
+                {
+                    g_max_exp = limGains[4];
+                }
+
+                tmp_q1 = g_max_exp >= 16 ? g_max_exp : 16;
+
+                tmp_q2 = g_max_man >> (tmp_q1 - g_max_exp);
+                tmp_q1 = Q28fmt(1.52587890625F) >> (tmp_q1 - 16);
+
+                if (tmp_q2 > tmp_q1)
+                {
+                    /* upper limit, +100 dB */
+                    g_max_man = Q28fmt(1.52587890625F);
+                    g_max_exp = 16;
+                }
+            }
+            else
+            {
+                /*  Qfmt(1.52587890625F)    exp = 16 */
+                g_max_man = Q28fmt(1.52587890625F);
+                g_max_exp = 16;
+            }
+
+            /*
+             *  Compute Adjusted power p_adj
+             */
+            for (k = limSbc[limiterBand][c]; k < limSbc[limiterBand][c + 1]; k++)
+            {
+
+                tmp_q1 = g_max_exp >= nrg_gain_exp[k] ? g_max_exp : nrg_gain_exp[k];
+
+                tmp_q2 = g_max_man >> (tmp_q1 - g_max_exp);
+                tmp_q1 = nrg_gain_man[k] >> (tmp_q1 - nrg_gain_exp[k]);
+                /*
+                 *  if(g_max <= nrg_gain[k])
+                 */
+                if (tmp_q2 <= tmp_q1)
+                {
+                    tmp_q1 = fxp_mul32_Q28(noise_level_man[k], g_max_man);
+                    pv_div(tmp_q1, nrg_gain_man[k], &quotient);
+                    noise_level_man[k] = quotient.quotient >> 2;   /* in Q28 */
+                    noise_level_exp[k] = noise_level_exp[k] + g_max_exp - quotient.shift_factor - nrg_gain_exp[k];
+
+                    nrg_gain_man[k] =  g_max_man;       /* gains with noise supression */
+                    nrg_gain_exp[k] =  g_max_exp;
+                }
+            }
+
+            p_adj_exp = -100;
+
+            for (k = limSbc[limiterBand][c]; k < limSbc[limiterBand][c + 1]; k++)
+            {
+                tmp_q1 = nrg_est_exp[k] + (nrg_gain_exp[k] << 1) + 28;  /* 28 to match shift down by mult32_Q28  */
+
+                if (p_adj_exp < tmp_q1)
+                {
+                    p_adj_exp = tmp_q1;
+                }
+                if (nrg_tone_man[k])
+                {
+                    tmp_q1 = (nrg_tone_exp[k] << 1);
+                    if (p_adj_exp < tmp_q1)
+                    {
+                        p_adj_exp = tmp_q1;
+                    }
+                }
+                else if (!noNoiseFlag)
+                {
+                    tmp_q1 = (noise_level_exp[k] << 1);
+
+                    if (p_adj_exp < tmp_q1)
+                    {
+                        p_adj_exp = tmp_q1;
+                    }
+                }
+            }
+
+            p_adj_exp += 1; /* overflow bit-guard*/
+
+            p_adj_man = 0;
+
+            for (k = limSbc[limiterBand][c]; k < limSbc[limiterBand][c + 1]; k++)
+            {
+                /*
+                 *  p_adj += nrg_gain[k]*nrg_gain[k]*nrg_est[k];
+                 */
+
+                if (p_adj_exp - (nrg_est_exp[k] + (nrg_gain_exp[k] << 1)) < 59)
+                {
+                    tmp_q1 = fxp_mul32_Q28(nrg_gain_man[k], nrg_gain_man[k]);
+                    tmp_q1 = fxp_mul32_Q28(tmp_q1, nrg_est_man[k]);
+                    p_adj_man += (tmp_q1 >> (p_adj_exp - (nrg_est_exp[k] + (nrg_gain_exp[k] << 1) + 28)));
+                }
+
+                if (nrg_tone_man[k])
+                {
+                    /*
+                     *  p_adj += nrg_tone[k]*nrg_tone[k];
+                     */
+                    if (p_adj_exp - (nrg_tone_exp[k] << 1) < 31)
+                    {
+                        tmp_q1 = fxp_mul32_Q28(nrg_tone_man[k], nrg_tone_man[k]);
+                        p_adj_man += (tmp_q1 >> (p_adj_exp - (nrg_tone_exp[k] << 1)));
+                    }
+                }
+                else if (!noNoiseFlag)
+                {
+                    /*
+                     *  p_adj += noise_level[k]*noise_level[k];
+                     */
+
+                    if (p_adj_exp - (noise_level_exp[k] << 1) < 31)
+                    {
+                        tmp_q1 = fxp_mul32_Q28(noise_level_man[k], noise_level_man[k]);
+                        p_adj_man += (tmp_q1 >> (p_adj_exp - (noise_level_exp[k] << 1)));
+                    }
+
+                }
+            }
+
+
+            if (p_adj_man)
+            {
+                pv_div(p_ref_man, p_adj_man, &quotient);
+                tmp_q2 = p_ref_exp - p_adj_exp - 58 - quotient.shift_factor;   /*  58 <> Q30 + Q28 */
+
+                pv_sqrt(quotient.quotient, tmp_q2, &root_sq, sqrt_cache[7]);
+
+                if (root_sq.shift_factor > -28)
+                {
+                    boost_gain_q = root_sq.root << (root_sq.shift_factor + 28);
+                }
+                else
+                {
+                    boost_gain_q = root_sq.root >> (-28 - root_sq.shift_factor);
+                }
+
+                tmp_q1 = root_sq.shift_factor >= -28 ? root_sq.shift_factor : -28;
+
+                tmp_q2 = root_sq.root >> (tmp_q1 - root_sq.shift_factor);
+                tmp_q1 = Q28fmt(1.584893192f) >> (tmp_q1 + 28);
+
+
+                if (tmp_q2 > tmp_q1)
+                {
+                    boost_gain_q = Q28fmt(1.584893192f);
+                }
+            }
+            else
+            {
+                boost_gain_q = Q28fmt(1.584893192f);
+            }
+
+            if (band_nrg_tone_detector)
+            {
+                for (k = limSbc[limiterBand][c]; k < limSbc[limiterBand][c + 1]; k++)
+                {
+                    nrg_gain_man[k]    = fxp_mul32_Q28(nrg_gain_man[k], boost_gain_q);
+                    noise_level_man[k] = fxp_mul32_Q28(noise_level_man[k], boost_gain_q);
+                    nrg_tone_man[k]    = fxp_mul32_Q28(nrg_tone_man[k], boost_gain_q);
+                }
+            }
+            else
+            {
+
+                for (k = limSbc[limiterBand][c]; k < limSbc[limiterBand][c + 1]; k++)
+                {
+                    nrg_gain_man[k]    = fxp_mul32_Q28(nrg_gain_man[k], boost_gain_q);
+                    noise_level_man[k] = fxp_mul32_Q28(noise_level_man[k], boost_gain_q);
+                }
+
+
+            }
+
+        }   /* Limiter  End for loop (c) */
+
+
+        if (LC_flag == ON)
+        {
+
+            /*
+             *          Aliasing correction
+             */
+
+            sbr_aliasing_reduction(degreeAlias,
+                                   nrg_gain_man,
+                                   nrg_gain_exp,
+                                   nrg_est_man,
+                                   nrg_est_exp,
+                                   dontUseTheseGainValues,
+                                   noSubbands,
+                                   lowSubband,
+                                   sqrt_cache,
+                                   scratch_mem[3]);
+
+            if (*sUp)     /* Init only done once upon reset */
+            {
+                *sUp = 0;
+            }
+
+            envelope_application_LC((Int32 *)aBufR,
+                                    nrg_gain_man,
+                                    nrg_gain_exp,
+                                    noise_level_man,
+                                    noise_level_exp,
+                                    nrg_tone_man,
+                                    nrg_tone_exp,
+                                    band_nrg_tone_detector,
+                                    frame_info,
+                                    harm_index,
+                                    phase_index,
+                                    i,
+                                    lowSubband,
+                                    noSubbands,
+                                    noNoiseFlag);
+        }
+#ifdef HQ_SBR
+        else
+        {
+
+            if (*sUp)     /* Init only done once upon reset */
+            {
+                for (n = 0; n < maxSmoothLength; n++)
+                {
+                    pv_memcpy(fBuf_man[n],     nrg_gain_man, noSubbands*sizeof(*fBuf_man[n]));
+                    pv_memcpy(fBufN_man[n], noise_level_man, noSubbands*sizeof(*fBufN_man[n]));
+                    pv_memcpy(fBuf_exp[n],     nrg_gain_exp, noSubbands*sizeof(*fBuf_exp[n]));
+                    pv_memcpy(fBufN_exp[n], noise_level_exp, noSubbands*sizeof(*fBufN_exp[n]));
+                }
+                *sUp = 0;
+            }
+
+
+            envelope_application((Int32 *)aBufR,
+                                 (Int32 *)aBufI,
+                                 nrg_gain_man,
+                                 nrg_gain_exp,
+                                 noise_level_man,
+                                 noise_level_exp,
+                                 nrg_tone_man,
+                                 nrg_tone_exp,
+                                 fBuf_man,
+                                 fBuf_exp,
+                                 fBufN_man,
+                                 fBufN_exp,
+                                 frame_info,
+                                 harm_index,
+                                 phase_index,
+                                 i,
+                                 lowSubband,
+                                 noSubbands,
+                                 noNoiseFlag,
+                                 band_nrg_tone_detector,
+                                 maxSmoothLength,
+                                 smooth_length);
+
+        }
+#endif
+
+    }   /* -----  Envelope adjustment end for-loop (i) ---- */
+
+
+    pv_memcpy(&hFp[0] + lowSubband,
+              hF,
+              (64 - lowSubband)*sizeof(*hF));
+
+    if (sEnv == nEnv)
+    {
+        frameData->prevEnvIsShort = 0;
+    }
+    else
+    {
+        frameData->prevEnvIsShort = -1;
+    }
+
+
+}
+
+
+
+/*----------------------------------------------------------------------------
+; FUNCTION CODE
+----------------------------------------------------------------------------*/
+
+void envelope_application_LC(Int32  *aBufR,
+                             Int32  *nrg_gain_man,
+                             Int32  *nrg_gain_exp,
+                             Int32  *noise_level_man,
+                             Int32  *noise_level_exp,
+                             Int32  *nrg_tone_man,
+                             Int32  *nrg_tone_exp,
+                             Int32  band_nrg_tone_detector,
+                             const Int32 *frame_info,
+                             Int32  *harm_index,
+                             Int32  *phase_index,
+                             Int32  i,
+                             Int32  lowSubband,
+                             Int32  noSubbands,
+                             Int32  noNoiseFlag)
+{
+
+    Int32 *ptrReal;
+    Int32 sb_gain_man;
+    Int32 sb_noise_man;
+    Int32 sb_noise_exp;
+    Int32 l;
+    Int32 k;
+    Int32 tmp_q1;
+    Int32 tmp_q2;
+    Int32 tone_count;
+    Int16 tmp_16;
+    Int32 indexMinus1;
+    Int32 indexPlus1;
+
+
+    /*
+     *          Application
+     */
+
+    if (band_nrg_tone_detector)     /* Add tone energy only if energy is detected  */
+    {
+
+        /*
+         *  pre-calculate tone application
+         */
+        for (k = 0; k < noSubbands; k++)
+        {
+            tmp_q2 = (-nrg_tone_exp[k]);
+            tmp_q1 = nrg_tone_man[k];
+            tmp_q2 = tmp_q1 >> tmp_q2;
+            tmp_q1 = fxp_mul32_by_16(tmp_q2, Q15fmt(0.0163f));
+            nrg_tone_man[k] = tmp_q2;
+            nrg_tone_exp[k] = tmp_q1;
+            noise_level_exp[k] += 1;
+            nrg_gain_exp[k] += 28;
+        }
+
+        for (l = (frame_info[1+i] << 1); l < (frame_info[2+i] << 1); l++)
+        {
+            ptrReal = (aBufR + l * SBR_NUM_BANDS);
+
+            tone_count = 0;
+
+            indexPlus1  = (*harm_index + 1) & 3;
+
+            if (indexPlus1 & 1)    /*  if indexPlus1 is odd */
+            {
+                for (k = 0; k < noSubbands; k++)
+                {
+
+                    sb_gain_man = nrg_gain_man[k];
+                    tmp_q1 = *ptrReal;
+                    tmp_q2 = nrg_gain_exp[k];
+                    tmp_q1 = fxp_mul32_Q28(tmp_q1, sb_gain_man);
+
+                    if (tmp_q2 < 0)
+                    {
+                        if (tmp_q2 > -32)
+                        {
+                            *ptrReal = tmp_q1 >> (-tmp_q2);
+                        }
+                    }
+                    else
+                    {
+                        *ptrReal = tmp_q1 << tmp_q2;
+                    }
+
+                    *phase_index = (*phase_index + 1) & 511;
+
+                    if (!nrg_tone_man[k] && !noNoiseFlag)
+
+                    {
+                        tmp_16 = rP_LCx[*phase_index];
+                        sb_noise_man = noise_level_man[k];
+                        sb_noise_exp = noise_level_exp[k];
+
+                        tmp_q1 = fxp_mul32_by_16(sb_noise_man, tmp_16);
+
+                        if (sb_noise_exp < 0)
+                        {
+                            if (sb_noise_exp > -32)
+                            {
+                                *ptrReal += tmp_q1 >> (-sb_noise_exp);
+                            }
+                        }
+                        else
+                        {
+                            *ptrReal += tmp_q1 << sb_noise_exp;
+                        }
+                    }
+
+                    tmp_q1 = nrg_tone_man[k];
+
+                    if (*harm_index)
+                    {
+                        *ptrReal -= tmp_q1;
+                    }
+                    else
+                    {
+                        *ptrReal += tmp_q1;
+                    }
+
+                    if (tmp_q1)
+                    {
+                        tone_count++;
+                    }
+
+                    ptrReal++;
+
+                }   /*  for-loop (k) */
+
+            }
+            else        /*  if indexPlus1 is even */
+            {
+                indexMinus1 = (*harm_index - 1) & 3;
+
+                /*  ---  k = 0  ----- */
+
+                sb_gain_man = nrg_gain_man[0];
+                tmp_q1 = *ptrReal;
+                tmp_q2 = nrg_gain_exp[0];
+                tmp_q1 = fxp_mul32_Q28(tmp_q1, sb_gain_man);
+
+                if (tmp_q2 < 0)
+                {
+                    if (tmp_q2 > -32)
+                    {
+                        *ptrReal = tmp_q1 >> (-tmp_q2);
+                    }
+                }
+                else
+                {
+                    *ptrReal = tmp_q1 << tmp_q2;
+                }
+
+                *phase_index = (*phase_index + 1) & 511;
+
+                tmp_q1 = nrg_tone_exp[0];
+                tmp_q2 = nrg_tone_exp[1];
+
+                if ((indexPlus1 != 0) ^((lowSubband & 1) != 0))
+                {
+                    *(ptrReal - 1) -= tmp_q1;
+                    *(ptrReal)   += tmp_q2;
+                }
+                else
+                {
+                    *(ptrReal - 1) += tmp_q1;
+                    *(ptrReal)   -= tmp_q2;
+                }
+
+                if (!nrg_tone_man[0] && !noNoiseFlag)
+                {
+                    tmp_16 = rP_LCx[*phase_index];
+                    sb_noise_man = noise_level_man[0];
+                    sb_noise_exp = noise_level_exp[0];
+
+                    tmp_q1 = fxp_mul32_by_16(sb_noise_man, tmp_16);
+
+                    if (sb_noise_exp < 0)
+                    {
+                        if (sb_noise_exp > -32)
+                        {
+                            *ptrReal += tmp_q1 >> (-sb_noise_exp);
+                        }
+                    }
+                    else
+                    {
+                        *ptrReal += tmp_q1 << sb_noise_exp;
+                    }
+                }
+                else
+                {
+                    tone_count++;
+                }
+
+                ptrReal++;
+
+                /* ----  */
+
+                for (k = 1; k < noSubbands - 1; k++)
+                {
+
+                    sb_gain_man = nrg_gain_man[k];
+                    tmp_q1 = *ptrReal;
+                    tmp_q2 = nrg_gain_exp[k];
+                    tmp_q1 = fxp_mul32_Q28(tmp_q1, sb_gain_man);
+
+                    if (tmp_q2 < 0)
+                    {
+                        if (tmp_q2 > -32)
+                        {
+                            *ptrReal = tmp_q1 >> (-tmp_q2);
+                        }
+                    }
+                    else
+                    {
+                        *ptrReal = tmp_q1 << tmp_q2;
+                    }
+
+                    *phase_index = (*phase_index + 1) & 511;
+
+
+                    if (tone_count < 16)
+                    {
+                        tmp_q1 = nrg_tone_exp[k - 1];
+                        tmp_q2 = nrg_tone_exp[k + 1];
+
+                        tmp_q1 -= tmp_q2;
+
+
+                        if ((indexPlus1 != 0) ^(((k + lowSubband) & 1) != 0))
+                        {
+                            *(ptrReal) -= tmp_q1;
+                        }
+                        else
+                        {
+                            *(ptrReal) += tmp_q1;
+                        }
+                    }   /*   if (tone_count < 16)  */
+
+
+                    if (!nrg_tone_man[k] && !noNoiseFlag)
+                    {
+                        tmp_16 = rP_LCx[*phase_index];
+                        sb_noise_man = noise_level_man[k];
+                        sb_noise_exp = noise_level_exp[k];
+
+                        tmp_q1 = fxp_mul32_by_16(sb_noise_man, tmp_16);
+
+                        if (sb_noise_exp < 0)
+                        {
+                            if (sb_noise_exp > -32)
+                            {
+                                *ptrReal += tmp_q1 >> (-sb_noise_exp);
+                            }
+                        }
+                        else
+                        {
+                            *ptrReal += tmp_q1 << sb_noise_exp;
+                        }
+                    }
+                    else
+                    {
+                        tone_count++;
+                    }
+
+                    ptrReal++;
+
+                }   /*  for-loop (k) */
+
+                sb_gain_man = nrg_gain_man[k];
+                tmp_q1 = *ptrReal;
+                tmp_q2 = nrg_gain_exp[k];
+                tmp_q1 = fxp_mul32_Q28(tmp_q1, sb_gain_man);
+
+                if (tmp_q2 < 0)
+                {
+                    if (tmp_q2 > -31)
+                    {
+                        *ptrReal = tmp_q1 >> (-tmp_q2);
+                    }
+                }
+                else
+                {
+                    *ptrReal = tmp_q1 << tmp_q2;
+                }
+
+                *phase_index = (*phase_index + 1) & 511;
+
+
+                if ((tone_count < 16) && !(indexMinus1 &1))
+                {
+                    tmp_q1 = nrg_tone_exp[k - 1];
+                    tmp_q2 = nrg_tone_exp[k    ];
+
+                    if ((indexMinus1 != 0) ^(((k + lowSubband) & 1) != 0))
+                    {
+                        *(ptrReal)   += tmp_q1;
+
+                        if (k + lowSubband < 62)
+                        {
+                            *(ptrReal + 1) -= tmp_q2;
+                        }
+                    }
+                    else
+                    {
+                        *(ptrReal)   -= tmp_q1;
+
+                        if (k + lowSubband < 62)
+                        {
+                            *(ptrReal + 1) += tmp_q2;
+                        }
+                    }
+                }   /*   if (tone_count < 16)  */
+
+
+                if (!nrg_tone_man[k] && !noNoiseFlag)
+                {
+                    tmp_16 = rP_LCx[*phase_index];
+                    sb_noise_man = noise_level_man[k];
+                    sb_noise_exp = noise_level_exp[k];
+
+                    tmp_q1 = fxp_mul32_by_16(sb_noise_man, tmp_16);
+
+                    if (sb_noise_exp < 0)
+                    {
+                        if (sb_noise_exp > -31)
+                        {
+                            *ptrReal += tmp_q1 >> (-sb_noise_exp);
+                        }
+                    }
+                    else
+                    {
+                        *ptrReal += tmp_q1 << sb_noise_exp;
+                    }
+                }
+
+            }   /*  if indexPlus1 is odd */
+
+            *harm_index = indexPlus1;
+
+
+        }        /*  for-loop (l) */
+
+    }
+    else        /*   if ( band_nrg_tone_detector)   */
+    {
+
+        for (k = 0; k < noSubbands; k++)
+        {
+            tmp_q1 = noise_level_exp[k];
+            tmp_q2 = nrg_gain_exp[k];
+            noise_level_exp[k] =  tmp_q1 + 1;
+            nrg_gain_exp[k] = tmp_q2 + 28;
+        }
+
+        for (l = (frame_info[1+i] << 1); l < (frame_info[2+i] << 1); l++)
+        {
+            ptrReal = (aBufR + l * SBR_NUM_BANDS);
+
+            for (k = 0; k < noSubbands; k++)
+            {
+
+                tmp_q1 = *ptrReal;
+                sb_gain_man = nrg_gain_man[k];
+
+                tmp_q2 = nrg_gain_exp[k];
+
+                tmp_q1 = fxp_mul32_Q28(tmp_q1, sb_gain_man);
+
+                if (tmp_q2 < 0)
+                {
+                    if (tmp_q2 > -31)
+                    {
+                        *ptrReal = tmp_q1 >> (-tmp_q2);
+                    }
+                }
+                else
+                {
+                    *ptrReal = tmp_q1 << tmp_q2;
+                }
+
+                *phase_index = (*phase_index + 1) & 511;
+
+                if (! noNoiseFlag)
+                {
+                    tmp_16 = rP_LCx[*phase_index];
+                    sb_noise_man = noise_level_man[k];
+                    sb_noise_exp = noise_level_exp[k];
+
+                    tmp_q1 = fxp_mul32_by_16(sb_noise_man, tmp_16);
+
+                    if (sb_noise_exp < 0)
+                    {
+                        if (sb_noise_exp > -31)
+                        {
+                            *ptrReal += tmp_q1 >> (-sb_noise_exp);
+                        }
+                    }
+                    else
+                    {
+                        *ptrReal += tmp_q1 << sb_noise_exp;
+                    }
+                }
+
+                ptrReal++;
+
+            }   /*  for-loop (k) */
+
+            *harm_index  = (*harm_index + 1) & 3;
+
+
+        }   /*  for-loop (l) */
+
+    }
+
+}
+
+
+
+/*----------------------------------------------------------------------------
+; FUNCTION CODE
+----------------------------------------------------------------------------*/
+
+
+#define Qfmt15(a)   (Int32)(a*((Int32)1<<15) + (a>=0?0.5F:-0.5F))
+
+
+const Int16 pow2[39] = { 0, 0, 1, 0, 2,
+                         0, Qfmt15(2 / 6.0f), 0, 3, 0, Qfmt15(2 / 10.0f), 0, Qfmt15(2 / 12.0f), 0, Qfmt15(2 / 14.0f), 0, 4,
+                         0, Qfmt15(2 / 18.0f),    0, Qfmt15(2 / 20.0f), 0, Qfmt15(2 / 22.0f), 0, Qfmt15(2 / 24.0f),
+                         0, Qfmt15(2 / 26.0f), 0, Qfmt15(2 / 28.0f), 0, Qfmt15(2 / 30.0f), 0, 5, 0, Qfmt15(2 / 34.0f),
+                         0, Qfmt15(2 / 36.0f), 0, Qfmt15(2 / 38.0f)
+                       };
+
+void energy_estimation_LC(Int32 *aBufR,
+                          Int32 *nrg_est_man,
+                          Int32 *nrg_est_exp,
+                          const Int32 *frame_info,
+                          Int32 i,
+                          Int32 k,
+                          Int32 c,
+                          Int32 ui2)
+{
+
+
+    Int32  aux1;
+    Int32  aux2;
+    Int32  l;
+
+
+    int64_t nrg_h = 0;
+    Int32 tmp1;
+    UInt32 tmp2;
+
+    for (l = ui2; l < (frame_info[2+i] << 1); l++)
+    {
+
+        aux1 = aBufR[l++*SBR_NUM_BANDS + k ];
+        aux2 = aBufR[l  *SBR_NUM_BANDS + k ];
+
+        nrg_h = fxp_mac64_Q31(nrg_h, aux1, aux1);
+        nrg_h = fxp_mac64_Q31(nrg_h, aux2, aux2);
+    }
+
+    /*
+     *  Check for overflow and saturate if needed
+     */
+    if (nrg_h < 0)
+    {
+        nrg_h = 0x7fffffff;
+    }
+
+
+    if (nrg_h)
+    {
+        tmp2 = (UInt32)(nrg_h >> 32);
+        if (tmp2)
+        {
+            aux2 = pv_normalize(tmp2);
+            aux2 -= 1;                  /*  ensure Q30 */
+            nrg_h = (nrg_h << aux2) >> 33;
+            tmp2 = (UInt32)(nrg_h);
+            nrg_est_exp[c] = 33 - aux2;
+        }
+        else
+        {
+            tmp2 = (UInt32)(nrg_h >> 2);
+            aux2 = pv_normalize(tmp2);
+            aux2 -= 1;                  /*  ensure Q30 */
+
+            tmp2 = (tmp2 << aux2);
+            nrg_est_exp[c] =  -aux2 + 2;
+        }
+
+        tmp1 = (l - ui2);
+
+        aux2 = pow2[tmp1];
+        if (tmp1 == (tmp1 & (-tmp1)))
+        {
+            nrg_est_man[c] = tmp2 >> aux2;
+        }
+        else
+        {
+            nrg_est_man[c] = fxp_mul32_by_16(tmp2, aux2);
+        }
+
+    }
+    else
+    {
+        nrg_est_man[c] = 0;
+        nrg_est_exp[c] = -100;
+    }
+
+
+
+
+
+}
+
+
+
+
+
+
+#if HQ_SBR
+
+/*----------------------------------------------------------------------------
+; FUNCTION CODE
+----------------------------------------------------------------------------*/
+
+void envelope_application(Int32  *aBufR,
+                          Int32  *aBufI,
+                          Int32  *nrg_gain_man,
+                          Int32  *nrg_gain_exp,
+                          Int32  *noise_level_man,
+                          Int32  *noise_level_exp,
+                          Int32  *nrg_tone_man,
+                          Int32  *nrg_tone_exp,
+                          Int32  *fBuf_man[64],
+                          Int32  *fBuf_exp[64],
+                          Int32  *fBufN_man[64],
+                          Int32  *fBufN_exp[64],
+                          const  Int32 *frame_info,
+                          Int32  *harm_index,
+                          Int32  *phase_index,
+                          Int32  i,
+                          Int32  lowSubband,
+                          Int32  noSubbands,
+                          Int32  noNoiseFlag,
+                          Int32  band_nrg_tone_detector,
+                          Int32  maxSmoothLength,
+                          Int32  smooth_length)
+{
+
+    Int32 *ptrReal;
+    Int32 *ptrImag;
+    Int32 sb_gain_man;
+    Int32 sb_gain_exp;
+    Int32 sb_noise_man;
+    Int32 sb_noise_exp;
+    Int32 l;
+    Int32 k;
+    Int32 n;
+    Int32 tmp_q1;
+    Int32 tmp_q2;
+    Int32  aux1;
+    Int32  aux2;
+    Int32  filter_history = 0;
+
+
+    if (band_nrg_tone_detector)     /* Add tone energy only if energy is detected  */
+    {
+
+        /*
+         *  pre-calculate tone application
+         */
+
+        ptrReal = nrg_tone_exp;
+        ptrImag = nrg_tone_man;
+        tmp_q1 = - *(ptrReal++);
+        aux1   =   *(ptrImag);
+        for (k = 0; k < noSubbands; k++)
+        {
+            *(ptrImag++) = aux1 >> tmp_q1;
+            tmp_q1 = - *(ptrReal++);
+            aux1   =   *(ptrImag);
+        }
+
+        /*
+         *          Application
+         */
+
+        for (l = (frame_info[1+i] << 1); l < (frame_info[2+i] << 1); l++)
+        {
+            ptrReal = (aBufR + l * SBR_NUM_BANDS);
+            ptrImag = (aBufI + l * SBR_NUM_BANDS);
+
+            if (filter_history <= maxSmoothLength)     /* no more update is needed as buffer will have same info */
+            {
+                pv_memmove(fBuf_man[maxSmoothLength], nrg_gain_man, noSubbands*sizeof(*nrg_gain_man));
+                pv_memmove(fBuf_exp[maxSmoothLength], nrg_gain_exp, noSubbands*sizeof(*nrg_gain_exp));
+                pv_memmove(fBufN_man[maxSmoothLength], noise_level_man, noSubbands*sizeof(*noise_level_man));
+                pv_memmove(fBufN_exp[maxSmoothLength], noise_level_exp, noSubbands*sizeof(*noise_level_exp));
+            }
+
+            /*
+             *  nrg_gain_max bounded to 1.584893192*1e5, which requires (32-bit) Q14 notation
+             */
+            for (k = 0; k < noSubbands; k++)
+            {
+                if (smooth_length == 0)     /* no filter-smooth needed */
+                {
+                    sb_gain_man = nrg_gain_man[k];
+                    sb_gain_exp = nrg_gain_exp[k];
+
+                    sb_noise_man = noise_level_man[k];
+                    sb_noise_exp = noise_level_exp[k];
+
+                }
+                else
+                {   /* else  smooth_length == 4  and fir_4 filter is being used */
+
+                    sb_gain_exp = fBuf_exp[maxSmoothLength][k];
+
+                    sb_noise_exp = fBufN_exp[maxSmoothLength][k];
+
+                    for (n = maxSmoothLength - smooth_length; n < maxSmoothLength; n++)
+                    {
+                        if (sb_gain_exp  < fBuf_exp[n][k])
+                        {
+                            sb_gain_exp = fBuf_exp[n][k];
+                        }
+
+                        if (sb_noise_exp  < fBufN_exp[n][k])
+                        {
+                            sb_noise_exp = fBufN_exp[n][k];
+                        }
+                    }
+
+                    sb_gain_man = fxp_mul32_Q30(fBuf_man[maxSmoothLength][k], Q30fmt(0.33333333333333f));
+                    sb_gain_man  = sb_gain_man >> (sb_gain_exp - fBuf_exp[maxSmoothLength][k]);
+
+                    sb_noise_man = fxp_mul32_Q30(fBufN_man[maxSmoothLength][k], Q30fmt(0.33333333333333f));
+                    sb_noise_man = sb_noise_man >> (sb_noise_exp - fBufN_exp[maxSmoothLength][k]);
+
+                    n = maxSmoothLength - smooth_length;
+
+                    tmp_q1 = fxp_mul32_Q30(fBuf_man[n][k], Q30fmt(0.03183050093751f));
+                    sb_gain_man  += tmp_q1 >> (sb_gain_exp - fBuf_exp[n][k]);
+
+                    tmp_q1 = fxp_mul32_Q30(fBufN_man[n][k], Q30fmt(0.03183050093751f));
+                    sb_noise_man += tmp_q1 >> (sb_noise_exp - fBufN_exp[n++][k]);
+
+                    tmp_q1 = fxp_mul32_Q30(fBuf_man[n][k], Q30fmt(0.11516383427084f));
+                    sb_gain_man  += tmp_q1 >> (sb_gain_exp - fBuf_exp[n][k]);
+
+                    tmp_q1 = fxp_mul32_Q30(fBufN_man[n][k], Q30fmt(0.11516383427084f));
+                    sb_noise_man += tmp_q1 >> (sb_noise_exp - fBufN_exp[n++][k]);
+
+                    tmp_q1 = fxp_mul32_Q30(fBuf_man[n][k], Q30fmt(0.21816949906249f));
+                    sb_gain_man  += tmp_q1 >> (sb_gain_exp - fBuf_exp[n][k]);
+
+                    tmp_q1 = fxp_mul32_Q30(fBufN_man[n][k], Q30fmt(0.21816949906249f));
+                    sb_noise_man += tmp_q1 >> (sb_noise_exp - fBufN_exp[n++][k]);
+
+                    tmp_q1 = fxp_mul32_Q30(fBuf_man[n][k], Q30fmt(0.30150283239582f));
+                    sb_gain_man  += tmp_q1 >> (sb_gain_exp - fBuf_exp[n][k]);
+
+                    tmp_q1 = fxp_mul32_Q30(fBufN_man[n][k], Q30fmt(0.30150283239582f));
+                    sb_noise_man += tmp_q1 >> (sb_noise_exp - fBufN_exp[n][k]);
+
+                }
+
+
+
+                /*
+                 *    *ptrReal  = *ptrReal * sb_gain ;
+                 *    *ptrImag  = *ptrImag * sb_gain;
+                 */
+                aux1 = *ptrReal;
+                aux2 = *ptrImag;
+                sb_gain_exp += 32;
+                aux1 = fxp_mul32_Q31(aux1, sb_gain_man);
+                aux2 = fxp_mul32_Q31(aux2, sb_gain_man);
+
+
+                if (sb_gain_exp < 0)
+                {
+                    sb_gain_exp = -sb_gain_exp;
+                    if (sb_gain_exp < 32)
+                    {
+                        *ptrReal = (aux1 >> sb_gain_exp);
+                        *ptrImag = (aux2 >> sb_gain_exp);
+                    }
+                }
+                else
+                {
+                    *ptrReal = (aux1 << sb_gain_exp);
+                    *ptrImag = (aux2 << sb_gain_exp);
+                }
+
+
+
+                /*
+                 *     if ( sb_noise != 0)
+                 *     {
+                 *         *ptrReal += sb_noise * rP[*phase_index][0];
+                 *         *ptrImag += sb_noise * rP[*phase_index][1];
+                 *     }
+                 */
+                *phase_index = (*phase_index + 1) & 511;
+
+                if (nrg_tone_man[k] || noNoiseFlag)
+                {
+                    sb_noise_man = 0;
+                    sb_noise_exp = 0;
+                }
+                else
+                {
+
+                    Int32 tmp = rPxx[*phase_index];
+                    sb_noise_exp += 1;
+                    tmp_q1 = fxp_mul32_by_16t(sb_noise_man, tmp);
+                    tmp_q2 = fxp_mul32_by_16b(sb_noise_man, tmp);
+
+
+                    if (sb_noise_exp < 0)
+                    {
+                        if (sb_noise_exp > -32)
+                        {
+                            *ptrReal += tmp_q1 >> (-sb_noise_exp);
+                            *ptrImag += tmp_q2 >> (-sb_noise_exp);
+                        }
+                    }
+                    else
+                    {
+                        *ptrReal += tmp_q1 << sb_noise_exp;
+                        *ptrImag += tmp_q2 << sb_noise_exp;
+                    }
+                }
+
+                /*
+                 *      tmp_q1 = nrg_tone[k]
+                 */
+
+                tmp_q1 = nrg_tone_man[k];
+
+                if (*harm_index & 1)
+                {
+                    if ((((k + lowSubband) & 1) != 0) ^(*harm_index != 1))
+                    {
+                        *ptrImag  -=  tmp_q1;
+                    }
+                    else
+                    {
+                        *ptrImag  +=  tmp_q1;
+                    }
+                }
+                else
+                {
+                    *ptrReal += (*harm_index) ? -tmp_q1 : tmp_q1;
+                }
+
+                *ptrReal++ <<= 10;
+                *ptrImag++ <<= 10;
+
+
+            }    /*  for-loop (k) */
+
+
+            *harm_index = (*harm_index + 1) & 3;
+
+            /*
+             *  Update smoothing filter history
+             */
+
+            if (filter_history++ < maxSmoothLength)     /* no more update is needed as buffer will have same info */
+            {
+                /*
+                 *  mantissas
+                 */
+
+                ptrReal = (Int32 *)fBuf_man[0];
+                ptrImag = (Int32 *)fBufN_man[0];
+
+                for (n = 0; n < maxSmoothLength; n++)
+                {
+                    fBuf_man[n]  = fBuf_man[n+1];
+                    fBufN_man[n] = fBufN_man[n+1];
+                }
+
+                fBuf_man[maxSmoothLength]  = ptrReal;
+                fBufN_man[maxSmoothLength] = ptrImag;
+
+                /*
+                 *  exponents
+                 */
+                ptrReal = (Int32 *)fBuf_exp[0];
+                ptrImag = (Int32 *)fBufN_exp[0];
+
+                for (n = 0; n < maxSmoothLength; n++)
+                {
+                    fBuf_exp[n]  = fBuf_exp[n+1];
+                    fBufN_exp[n] = fBufN_exp[n+1];
+                }
+
+                fBuf_exp[maxSmoothLength]  = ptrReal;
+                fBufN_exp[maxSmoothLength] = ptrImag;
+            }
+
+        }   /*  for-loop (l) */
+
+
+    }
+    else        /*   ----  if ( band_nrg_tone_detector) ---- */
+    {
+
+        /*
+         *          Application
+         */
+
+        for (l = (frame_info[1+i] << 1); l < (frame_info[2+i] << 1); l++)
+        {
+            ptrReal = (aBufR + l * SBR_NUM_BANDS);
+            ptrImag = (aBufI + l * SBR_NUM_BANDS);
+
+            if (filter_history <= maxSmoothLength)     /* no more update is needed as buffer will have same info */
+            {
+                pv_memmove(fBuf_man[maxSmoothLength], nrg_gain_man, noSubbands*sizeof(*nrg_gain_man));
+                pv_memmove(fBuf_exp[maxSmoothLength], nrg_gain_exp, noSubbands*sizeof(*nrg_gain_exp));
+                pv_memmove(fBufN_man[maxSmoothLength], noise_level_man, noSubbands*sizeof(*noise_level_man));
+                pv_memmove(fBufN_exp[maxSmoothLength], noise_level_exp, noSubbands*sizeof(*noise_level_exp));
+            }
+
+            /*
+             *  nrg_gain_max bounded to 1.584893192*1e5, which requires (32-bit) Q14 notation
+             */
+            for (k = 0; k < noSubbands; k++)
+            {
+                if (smooth_length == 0)     /* no filter-smooth needed */
+                {
+                    sb_gain_man = nrg_gain_man[k];
+                    sb_gain_exp = nrg_gain_exp[k];
+
+                    sb_noise_man = noise_level_man[k];
+                    sb_noise_exp = noise_level_exp[k];
+
+                }
+                else
+                {   /* else  smooth_length == 4  and fir_4 filter is being used */
+
+                    sb_gain_exp = fBuf_exp[maxSmoothLength][k];
+
+                    sb_noise_exp = fBufN_exp[maxSmoothLength][k];
+
+                    for (n = maxSmoothLength - smooth_length; n < maxSmoothLength; n++)
+                    {
+                        if (sb_gain_exp  < fBuf_exp[n][k])
+                        {
+                            sb_gain_exp = fBuf_exp[n][k];
+                        }
+
+                        if (sb_noise_exp  < fBufN_exp[n][k])
+                        {
+                            sb_noise_exp = fBufN_exp[n][k];
+                        }
+                    }
+
+                    sb_gain_man = fxp_mul32_Q30(fBuf_man[maxSmoothLength][k], Q30fmt(0.33333333333333f));
+                    sb_gain_man  = sb_gain_man >> (sb_gain_exp - fBuf_exp[maxSmoothLength][k]);
+
+                    sb_noise_man = fxp_mul32_Q30(fBufN_man[maxSmoothLength][k], Q30fmt(0.33333333333333f));
+                    sb_noise_man = sb_noise_man >> (sb_noise_exp - fBufN_exp[maxSmoothLength][k]);
+
+                    n = maxSmoothLength - smooth_length;
+
+                    tmp_q1 = fxp_mul32_Q30(fBuf_man[n][k], Q30fmt(0.03183050093751f));
+                    sb_gain_man  += tmp_q1 >> (sb_gain_exp - fBuf_exp[n][k]);
+
+                    tmp_q1 = fxp_mul32_Q30(fBufN_man[n][k], Q30fmt(0.03183050093751f));
+                    sb_noise_man += tmp_q1 >> (sb_noise_exp - fBufN_exp[n++][k]);
+
+                    tmp_q1 = fxp_mul32_Q30(fBuf_man[n][k], Q30fmt(0.11516383427084f));
+                    sb_gain_man  += tmp_q1 >> (sb_gain_exp - fBuf_exp[n][k]);
+
+                    tmp_q1 = fxp_mul32_Q30(fBufN_man[n][k], Q30fmt(0.11516383427084f));
+                    sb_noise_man += tmp_q1 >> (sb_noise_exp - fBufN_exp[n++][k]);
+
+                    tmp_q1 = fxp_mul32_Q30(fBuf_man[n][k], Q30fmt(0.21816949906249f));
+                    sb_gain_man  += tmp_q1 >> (sb_gain_exp - fBuf_exp[n][k]);
+
+                    tmp_q1 = fxp_mul32_Q30(fBufN_man[n][k], Q30fmt(0.21816949906249f));
+                    sb_noise_man += tmp_q1 >> (sb_noise_exp - fBufN_exp[n++][k]);
+
+                    tmp_q1 = fxp_mul32_Q30(fBuf_man[n][k], Q30fmt(0.30150283239582f));
+                    sb_gain_man  += tmp_q1 >> (sb_gain_exp - fBuf_exp[n][k]);
+
+                    tmp_q1 = fxp_mul32_Q30(fBufN_man[n][k], Q30fmt(0.30150283239582f));
+                    sb_noise_man += tmp_q1 >> (sb_noise_exp - fBufN_exp[n][k]);
+
+                }
+
+
+
+                /*
+                 *    *ptrReal  = *ptrReal * sb_gain ;
+                 *    *ptrImag  = *ptrImag * sb_gain;
+                 */
+                aux1 = *ptrReal;
+                aux2 = *ptrImag;
+                sb_gain_exp += 32;
+                aux1 = fxp_mul32_Q31(aux1, sb_gain_man);
+                aux2 = fxp_mul32_Q31(aux2, sb_gain_man);
+
+
+
+                /*
+                 *     if ( sb_noise != 0)
+                 *     {
+                 *         *ptrReal += sb_noise * rP[*phase_index][0];
+                 *         *ptrImag += sb_noise * rP[*phase_index][1];
+                 *     }
+                 */
+
+
+                if (sb_gain_exp < 0)
+                {
+                    if (sb_gain_exp > -32)
+                    {
+                        if (sb_gain_exp > -10)
+                        {
+                            *ptrReal = aux1 << (10 + sb_gain_exp);
+                            *ptrImag = aux2 << (10 + sb_gain_exp);
+                        }
+                        else
+                        {
+                            *ptrReal = aux1 >> (-sb_gain_exp - 10);
+                            *ptrImag = aux2 >> (-sb_gain_exp - 10);
+                        }
+                    }
+                }
+                else
+                {
+                    *ptrReal = aux1 << (sb_gain_exp + 10);
+                    *ptrImag = aux2 << (sb_gain_exp + 10);
+                }
+
+
+
+
+                /*
+                 *     if ( sb_noise != 0)
+                 *     {
+                 *         *ptrReal += sb_noise * rP[*phase_index][0];
+                 *         *ptrImag += sb_noise * rP[*phase_index][1];
+                 *     }
+                 */
+                *phase_index = (*phase_index + 1) & 511;
+
+                if (!noNoiseFlag)
+                {
+
+                    Int32 tmp = rPxx[*phase_index];
+                    sb_noise_exp += 1;
+                    tmp_q1 = fxp_mul32_by_16t(sb_noise_man, tmp);
+                    tmp_q2 = fxp_mul32_by_16b(sb_noise_man, tmp);
+
+                    if (sb_noise_exp < 0)
+                    {
+                        if (sb_noise_exp > -32)
+                        {
+                            if (sb_noise_exp > -10)
+                            {
+                                *ptrReal += tmp_q1 << (10 + sb_noise_exp);
+                                *ptrImag += tmp_q2 << (10 + sb_noise_exp);
+                            }
+                            else
+                            {
+                                *ptrReal += tmp_q1 >> (-sb_noise_exp - 10);
+                                *ptrImag += tmp_q2 >> (-sb_noise_exp - 10);
+                            }
+                        }
+                    }
+                    else
+                    {
+                        *ptrReal += tmp_q1 << (sb_noise_exp + 10);
+                        *ptrImag += tmp_q2 << (sb_noise_exp + 10);
+                    }
+                }
+
+                ptrReal++;
+                ptrImag++;
+
+
+            }    /*  for-loop (k) */
+
+
+            *harm_index = (*harm_index + 1) & 3;
+
+            /*
+             *  Update smoothing filter history
+             */
+
+            if (filter_history++ < maxSmoothLength)     /* no more update is needed as buffer will have same info */
+            {
+                /*
+                 *  mantissas
+                 */
+
+                ptrReal = (Int32 *)fBuf_man[0];
+                ptrImag = (Int32 *)fBufN_man[0];
+
+                for (n = 0; n < maxSmoothLength; n++)
+                {
+                    fBuf_man[n]  = fBuf_man[n+1];
+                    fBufN_man[n] = fBufN_man[n+1];
+                }
+
+                fBuf_man[maxSmoothLength]  = ptrReal;
+                fBufN_man[maxSmoothLength] = ptrImag;
+
+                /*
+                 *  exponents
+                 */
+                ptrReal = (Int32 *)fBuf_exp[0];
+                ptrImag = (Int32 *)fBufN_exp[0];
+
+                for (n = 0; n < maxSmoothLength; n++)
+                {
+                    fBuf_exp[n]  = fBuf_exp[n+1];
+                    fBufN_exp[n] = fBufN_exp[n+1];
+                }
+
+                fBuf_exp[maxSmoothLength]  = ptrReal;
+                fBufN_exp[maxSmoothLength] = ptrImag;
+            }
+
+        }   /*  for-loop (l) */
+
+    }       /*  if ( band_nrg_tone_detector) */
+
+}
+
+
+/*----------------------------------------------------------------------------
+; FUNCTION CODE
+----------------------------------------------------------------------------*/
+
+void energy_estimation(Int32 *aBufR,
+                       Int32 *aBufI,
+                       Int32 *nrg_est_man,
+                       Int32 *nrg_est_exp,
+                       const Int32 *frame_info,
+                       Int32 i,
+                       Int32 k,
+                       Int32 c,
+                       Int32 ui2)
+{
+
+    Int32  aux1;
+    Int32  aux2;
+    Int32  l;
+
+
+
+    int64_t nrg_h = 0;
+    Int32 tmp1;
+    Int32 tmp2;
+
+    aux1 = aBufR[ui2*SBR_NUM_BANDS + k];
+    aux2 = aBufI[ui2*SBR_NUM_BANDS + k];
+    for (l = ui2 + 1; l < (frame_info[2+i] << 1);  l++)
+    {
+        nrg_h = fxp_mac64_Q31(nrg_h, aux1, aux1);
+        nrg_h = fxp_mac64_Q31(nrg_h, aux2, aux2);
+        aux1 = aBufR[l*SBR_NUM_BANDS + k];
+        aux2 = aBufI[l*SBR_NUM_BANDS + k];
+    }
+    nrg_h = fxp_mac64_Q31(nrg_h, aux1, aux1);
+    nrg_h = fxp_mac64_Q31(nrg_h, aux2, aux2);
+
+
+    /*
+     *  Check for overflow and saturate if needed
+     */
+    if (nrg_h < 0)
+    {
+        nrg_h = 0x7fffffff;
+    }
+
+    if (nrg_h)
+    {
+
+        aux1 = (UInt32)(nrg_h >> 32);
+        if (aux1)
+        {
+            aux2 = pv_normalize(aux1);
+            if (aux2)
+            {
+                aux2 -= 1;                  /*  ensure Q30 */
+                nrg_h = (nrg_h << aux2) >> 33;
+                tmp2 = (UInt32)(nrg_h);
+                nrg_est_exp[c] = 33 - aux2;
+            }
+            else
+            {
+                tmp2 = (UInt32)(aux1 >> 1);
+                nrg_est_exp[c] = 33 ;
+
+
+            }
+        }
+        else
+        {
+            aux1 = (UInt32)(nrg_h >> 1);
+            aux2 = pv_normalize(aux1);
+
+            tmp2 = (aux1 << aux2);
+            nrg_est_exp[c] =  -aux2 + 1;
+
+
+        }
+
+
+
+        tmp1 = (l - ui2);
+        aux2 = pow2[tmp1];
+        if (tmp1 == (tmp1 & (-tmp1)))
+        {
+            nrg_est_man[c] = tmp2 >> aux2;
+        }
+        else
+        {
+            nrg_est_man[c] = fxp_mul32_by_16(tmp2, aux2);
+        }
+    }
+    else
+    {
+        nrg_est_man[c] = 0;
+        nrg_est_exp[c] = -100;
+    }
+
+
+}
+
+
+
+
+
+#endif
+
+
+#endif
+
+
+
diff --git a/media/libstagefright/codecs/aacdec/calc_sbr_envelope.h b/media/libstagefright/codecs/aacdec/calc_sbr_envelope.h
new file mode 100644
index 0000000..2a6ae57
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/calc_sbr_envelope.h
@@ -0,0 +1,144 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Filename: calc_sbr_envelope.h
+ Funtions:
+    get_dse
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+
+ Who:                                   Date: MM/DD/YYYY
+ Description:
+------------------------------------------------------------------------------
+SC 29 Software Copyright Licencing Disclaimer:
+
+This software module was originally developed by
+  Coding Technologies
+
+and edited by
+  -
+
+in the course of development of the ISO/IEC 13818-7 and ISO/IEC 14496-3
+standards for reference purposes and its performance may not have been
+optimized. This software module is an implementation of one or more tools as
+specified by the ISO/IEC 13818-7 and ISO/IEC 14496-3 standards.
+ISO/IEC gives users free license to this software module or modifications
+thereof for use in products claiming conformance to audiovisual and
+image-coding related ITU Recommendations and/or ISO/IEC International
+Standards. ISO/IEC gives users the same free license to this software module or
+modifications thereof for research purposes and further ISO/IEC standardisation.
+Those intending to use this software module in products are advised that its
+use may infringe existing patents. ISO/IEC have no liability for use of this
+software module or modifications thereof. Copyright is not released for
+products that do not conform to audiovisual and image-coding related ITU
+Recommendations and/or ISO/IEC International Standards.
+The original developer retains full right to modify and use the code for its
+own purpose, assign or donate the code to a third party and to inhibit third
+parties from using the code for products that do not conform to audiovisual and
+image-coding related ITU Recommendations and/or ISO/IEC International Standards.
+This copyright notice must be included in all copies or derivative works.
+Copyright (c) ISO/IEC 2002.
+
+ $Id: ct_envcalc.h,v 1.3 2002/11/29 16:11:49 kaehleof Exp $
+*/
+
+/*----------------------------------------------------------------------------
+; CONTINUE ONLY IF NOT ALREADY DEFINED
+----------------------------------------------------------------------------*/
+#ifndef CALCULATE_SBR_ENVELOPE_H
+#define CALCULATE_SBR_ENVELOPE_H
+
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+#include    "s_sbr_frame_data.h"
+#include    "sbr_generate_high_freq.h"
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+    /*----------------------------------------------------------------------------
+    ; DEFINES
+    ; Include all pre-processor statements here.
+    ----------------------------------------------------------------------------*/
+
+    /*----------------------------------------------------------------------------
+    ; EXTERNAL VARIABLES REFERENCES
+    ; Declare variables used in this module but defined elsewhere
+    ----------------------------------------------------------------------------*/
+
+    /*----------------------------------------------------------------------------
+    ; SIMPLE TYPEDEF'S
+    ----------------------------------------------------------------------------*/
+    /*----------------------------------------------------------------------------
+    ; ENUMERATED TYPEDEF'S
+    ----------------------------------------------------------------------------*/
+
+    /*----------------------------------------------------------------------------
+    ; STRUCTURES TYPEDEF'S
+    ----------------------------------------------------------------------------*/
+
+    /*----------------------------------------------------------------------------
+    ; GLOBAL FUNCTION DEFINITIONS
+    ; Function Prototype declaration
+    ----------------------------------------------------------------------------*/
+
+    void calc_sbr_envelope(SBR_FRAME_DATA *frameData,
+    Int32 *aBufR,
+    Int32 *aBufI,
+    Int    freqBandTable1[2][MAX_FREQ_COEFFS + 1],
+    const Int32 *nSfb,
+    Int32   freqBandTable2[MAX_NOISE_COEFFS + 1],
+    Int32   nNBands,
+    Int32   reset,
+    Int32 *degreeAlias,
+    Int32 *harm_index,
+    Int32 *phase_index,
+    Int32 hFp[64],
+    Int32 *sUp,
+    Int32 limSbc[][13],
+    Int32 *gateMode,
+#ifdef HQ_SBR
+    Int32 *fBuf_man[64],
+    Int32 *fBuf_exp[64],
+    Int32 *fBufN_man[64],
+    Int32 *fBufN_exp[64],
+#endif
+    Int32 scratch_mem[][64],
+    struct PATCH Patch,
+    Int32  sqrt_cache[][4],
+    Int32  LC_flag);
+#ifdef __cplusplus
+}
+#endif
+
+/*----------------------------------------------------------------------------
+; END
+----------------------------------------------------------------------------*/
+#endif   /*  CALCULATE_SBR_ENVELOPE_H */
+
+
diff --git a/media/libstagefright/codecs/aacdec/calc_sbr_synfilterbank.cpp b/media/libstagefright/codecs/aacdec/calc_sbr_synfilterbank.cpp
new file mode 100644
index 0000000..e557aa1
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/calc_sbr_synfilterbank.cpp
@@ -0,0 +1,639 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+  Filename: calc_sbr_synfilterbank.c
+
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+
+ Who:                                   Date: MM/DD/YYYY
+ Description:
+
+------------------------------------------------------------------------------
+ INPUT AND OUTPUT DEFINITIONS
+
+
+
+------------------------------------------------------------------------------
+ FUNCTION DESCRIPTION
+
+
+------------------------------------------------------------------------------
+ REQUIREMENTS
+
+
+------------------------------------------------------------------------------
+ REFERENCES
+
+SC 29 Software Copyright Licencing Disclaimer:
+
+This software module was originally developed by
+  Coding Technologies
+
+and edited by
+  -
+
+in the course of development of the ISO/IEC 13818-7 and ISO/IEC 14496-3
+standards for reference purposes and its performance may not have been
+optimized. This software module is an implementation of one or more tools as
+specified by the ISO/IEC 13818-7 and ISO/IEC 14496-3 standards.
+ISO/IEC gives users free license to this software module or modifications
+thereof for use in products claiming conformance to audiovisual and
+image-coding related ITU Recommendations and/or ISO/IEC International
+Standards. ISO/IEC gives users the same free license to this software module or
+modifications thereof for research purposes and further ISO/IEC standardisation.
+Those intending to use this software module in products are advised that its
+use may infringe existing patents. ISO/IEC have no liability for use of this
+software module or modifications thereof. Copyright is not released for
+products that do not conform to audiovisual and image-coding related ITU
+Recommendations and/or ISO/IEC International Standards.
+The original developer retains full right to modify and use the code for its
+own purpose, assign or donate the code to a third party and to inhibit third
+parties from using the code for products that do not conform to audiovisual and
+image-coding related ITU Recommendations and/or ISO/IEC International Standards.
+This copyright notice must be included in all copies or derivative works.
+Copyright (c) ISO/IEC 2002.
+
+------------------------------------------------------------------------------
+ PSEUDO-CODE
+
+------------------------------------------------------------------------------
+*/
+
+#ifdef AAC_PLUS
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+#include    "calc_sbr_synfilterbank.h"
+#include    "qmf_filterbank_coeff.h"
+#include    "synthesis_sub_band.h"
+#include    "fxp_mul32.h"
+#include    "aac_mem_funcs.h"
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here. Include conditional
+; compile variables also.
+----------------------------------------------------------------------------*/
+
+
+#if defined (PV_ARM_V5)
+
+
+__inline Int16 sat(Int32 y)
+{
+    Int32 x;
+    __asm
+    {
+        qdadd y, y, y
+        mov y, y, asr #16
+    }
+
+    return((Int16)y);
+}
+
+#define saturate2( a, b, c, d)      *c = sat( a);   \
+                                    *d = sat( b);   \
+                                    c += 2;         \
+                                    d -= 2;
+
+
+#elif defined (PV_ARM_V4)
+
+
+__inline Int16 sat(Int32 y)
+{
+    Int32 x;
+    Int32 z = 31; /* rvct compiler problem */
+    __asm
+    {
+        sub y, y, y, asr 2
+        mov y, y, asr N
+        mov x, y, asr #15
+        teq x, y, asr z
+        eorne  y, INT16_MAX, y, asr #31
+    }
+
+    return((Int16)y);
+}
+
+#define saturate2( a, b, c, d)      *c = sat( a);   \
+                                    *d = sat( b);   \
+                                    c += 2;         \
+                                    d -= 2;
+
+#elif defined(PV_ARM_GCC_V5)
+
+__inline Int16 sat(Int32 y)
+{
+    register Int32 x;
+    register Int32 ra = y;
+
+
+    asm volatile(
+        "qdadd %0, %1, %1\n\t"
+        "mov %0, %0, asr #16"
+    : "=&r*i"(x)
+                : "r"(ra));
+
+    return ((Int16)x);
+}
+
+
+#define saturate2( a, b, c, d)      *c = sat( a);   \
+                                    *d = sat( b);   \
+                                    c += 2;         \
+                                    d -= 2;
+
+
+#elif defined(PV_ARM_MSC_EVC_V5)
+
+#include "armintr.h"
+
+#define saturate2( a, b, c, d)      *c = _DAddSatInt( a, a)>>16;   \
+                                    *d = _DAddSatInt( b, b)>>16;   \
+                                    c += 2;         \
+                                    d -= 2;
+
+#else
+
+
+#define   saturate2( a, b, c, d)    a -= (a>>2);                             \
+                                    a  = (a>>N);                     \
+                                    if((a>>15) != (a>>31))                   \
+                                    {                                        \
+                                        a = ((a >> 31) ^ INT16_MAX); \
+                                    }                                        \
+                                    *c = (Int16)a;                           \
+                                    c += 2;                                  \
+                                    b -= (b>>2);                             \
+                                    b =  (b>>N);                      \
+                                    if((b>>15) != (b>>31))                   \
+                                    {                                        \
+                                        b = ((b >> 31) ^ INT16_MAX); \
+                                    }                                        \
+                                    *d = (Int16)b;                           \
+                                    d -= 2;
+
+
+#endif
+
+/*----------------------------------------------------------------------------
+; LOCAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+
+
+/*----------------------------------------------------------------------------
+; LOCAL STORE/BUFFER/POINTER DEFINITIONS
+; Variable declaration - defined here and used outside this module
+----------------------------------------------------------------------------*/
+
+
+
+
+/*----------------------------------------------------------------------------
+; EXTERNAL FUNCTION REFERENCES
+; Declare functions defined elsewhere and referenced in this module
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL GLOBAL STORE/BUFFER/POINTER REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; FUNCTION CODE
+----------------------------------------------------------------------------*/
+
+void calc_sbr_synfilterbank_LC(Int32 * Sr,
+                               Int16 * timeSig,
+                               Int16   V[1280],
+                               bool bDownSampleSBR)
+{
+    Int32 i;
+
+    Int32   realAccu1;
+    Int32   realAccu2;
+    const Int32 *pt_C2;
+
+    Int16 *pt_V1;
+    Int16 *pt_V2;
+
+
+    Int16 *pt_timeSig;
+
+    Int16 *pt_timeSig_2;
+    Int32  test1;
+    Int16  tmp1;
+    Int16  tmp2;
+
+    /* shift filterstates */
+
+    Int32 * pt_Sr = Sr;
+
+
+    if (bDownSampleSBR == false)
+    {
+
+        synthesis_sub_band_LC(pt_Sr, V);
+
+        /* content of V[] is at most 16 bits */
+
+        pt_timeSig   = &timeSig[0];
+        pt_timeSig_2 = &timeSig[64];
+
+
+        tmp1 = V[ 704];
+        tmp2 = V[ 768];
+        realAccu1 =  fxp_mac_16_by_16(tmp1, Qfmt(0.853738560F), ROUND_SYNFIL);
+        realAccu1 =  fxp_mac_16_by_16(tmp2, Qfmt(-0.361158990F), realAccu1);
+        tmp1 = -V[ 512];
+        tmp2 =  V[ 960];
+        realAccu1 =  fxp_mac_16_by_16(tmp1, Qfmt(-0.361158990F), realAccu1);
+        realAccu1 =  fxp_mac_16_by_16(tmp2, Qfmt(0.070353307F), realAccu1);
+        tmp1 =  V[ 448];
+        tmp2 =  V[1024];
+        realAccu1 =  fxp_mac_16_by_16(tmp1, Qfmt(0.070353307F), realAccu1);
+        realAccu1 =  fxp_mac_16_by_16(tmp2, Qfmt(-0.013271822F), realAccu1);
+        tmp1 =  -V[ 256];
+        tmp2 =   V[ 192];
+        realAccu1 =  fxp_mac_16_by_16(tmp1, Qfmt(-0.013271822F), realAccu1);
+        realAccu1 =  fxp_mac_16_by_16(tmp2, Qfmt(0.002620176F), realAccu1);
+        realAccu1 =  fxp_mac_16_by_16(V[1216], Qfmt(0.002620176F), realAccu1);
+
+        tmp1 = V[  32];
+        tmp2 = V[1248];
+        realAccu2 =  fxp_mac_16_by_16(tmp1, Qfmt(-0.000665042F), ROUND_SYNFIL);
+        realAccu2 =  fxp_mac_16_by_16(tmp2, Qfmt(-0.000665042F), realAccu2);
+        tmp1 = V[ 224];
+        tmp2 = V[1056];
+        realAccu2 =  fxp_mac_16_by_16(tmp1, Qfmt(0.005271576F), realAccu2);
+        realAccu2 =  fxp_mac_16_by_16(tmp2, Qfmt(0.005271576F), realAccu2);
+        tmp1 = V[ 992];
+        tmp2 = V[ 288];
+        realAccu2 =  fxp_mac_16_by_16(tmp1, Qfmt(0.058591568F), realAccu2);
+        realAccu2 =  fxp_mac_16_by_16(tmp2, Qfmt(0.058591568F), realAccu2);
+        tmp1 = V[ 480];
+        tmp2 = V[ 800];
+        realAccu2 =  fxp_mac_16_by_16(tmp1, Qfmt(-0.058370533F), realAccu2);
+        realAccu2 =  fxp_mac_16_by_16(tmp2, Qfmt(-0.058370533F), realAccu2);
+        tmp1 = V[ 736];
+        tmp2 = V[ 544];
+        realAccu2 =  fxp_mac_16_by_16(tmp1, Qfmt(0.702238872F), realAccu2);
+        realAccu2 =  fxp_mac_16_by_16(tmp2, Qfmt(0.702238872F), realAccu2);
+
+
+
+        saturate2(realAccu1, realAccu2, pt_timeSig, pt_timeSig_2);
+
+        pt_timeSig_2 = &timeSig[126];
+
+        pt_V1 = &V[1];
+        pt_V2 = &V[1279];
+
+        pt_C2 = &sbrDecoderFilterbankCoefficients[0];
+
+        for (i = 31; i != 0; i--)
+        {
+            test1 = *(pt_C2++);
+            tmp1 = *(pt_V1++);
+            tmp2 = *(pt_V2--);
+            realAccu1 =  fxp_mac_16_by_16_bt(tmp1 , test1, ROUND_SYNFIL);
+            realAccu2 =  fxp_mac_16_by_16_bt(tmp2 , test1, ROUND_SYNFIL);
+            tmp1 = pt_V1[  191];
+            tmp2 = pt_V2[ -191];
+            realAccu1 =  fxp_mac_16_by_16_bb(tmp1, test1, realAccu1);
+            realAccu2 =  fxp_mac_16_by_16_bb(tmp2, test1, realAccu2);
+
+            test1 = *(pt_C2++);
+            tmp1 = pt_V1[  255];
+            tmp2 = pt_V2[ -255];
+            realAccu1 =  fxp_mac_16_by_16_bt(tmp1 , test1, realAccu1);
+            realAccu2 =  fxp_mac_16_by_16_bt(tmp2 , test1, realAccu2);
+            tmp1 = pt_V1[  447];
+            tmp2 = pt_V2[ -447];
+            realAccu1 =  fxp_mac_16_by_16_bb(tmp1, test1, realAccu1);
+            realAccu2 =  fxp_mac_16_by_16_bb(tmp2, test1, realAccu2);
+
+            test1 = *(pt_C2++);
+            tmp1 = pt_V1[  511];
+            tmp2 = pt_V2[ -511];
+            realAccu1 =  fxp_mac_16_by_16_bt(tmp1 , test1, realAccu1);
+            realAccu2 =  fxp_mac_16_by_16_bt(tmp2 , test1, realAccu2);
+            tmp1 = pt_V1[  703];
+            tmp2 = pt_V2[ -703];
+            realAccu1 =  fxp_mac_16_by_16_bb(tmp1, test1, realAccu1);
+            realAccu2 =  fxp_mac_16_by_16_bb(tmp2, test1, realAccu2);
+
+            test1 = *(pt_C2++);
+            tmp1 = pt_V1[  767];
+            tmp2 = pt_V2[ -767];
+            realAccu1 =  fxp_mac_16_by_16_bt(tmp1 , test1, realAccu1);
+            realAccu2 =  fxp_mac_16_by_16_bt(tmp2 , test1, realAccu2);
+            tmp1 = pt_V1[  959];
+            tmp2 = pt_V2[ -959];
+            realAccu1 =  fxp_mac_16_by_16_bb(tmp1, test1, realAccu1);
+            realAccu2 =  fxp_mac_16_by_16_bb(tmp2, test1, realAccu2);
+
+            test1 = *(pt_C2++);
+            tmp1 = pt_V1[  1023];
+            tmp2 = pt_V2[ -1023];
+            realAccu1 =  fxp_mac_16_by_16_bt(tmp1 , test1, realAccu1);
+            realAccu2 =  fxp_mac_16_by_16_bt(tmp2 , test1, realAccu2);
+            tmp1 = pt_V1[  1215];
+            tmp2 = pt_V2[ -1215];
+            realAccu1 =  fxp_mac_16_by_16_bb(tmp1, test1, realAccu1);
+            realAccu2 =  fxp_mac_16_by_16_bb(tmp2, test1, realAccu2);
+
+            saturate2(realAccu1, realAccu2, pt_timeSig, pt_timeSig_2);
+
+        }
+    }
+    else
+    {
+
+        synthesis_sub_band_LC_down_sampled(Sr, V);
+
+        /*
+         *    window signal
+         *    calculate output samples
+         */
+
+
+        pt_V1 = &V[0];
+        pt_V2 = &V[96];
+
+
+        Int32 * pt_out = Sr;
+
+        for (i = 0; i < 8; i++)
+        {
+            *(pt_out++) = 0;
+            *(pt_out++) = 0;
+            *(pt_out++) = 0;
+            *(pt_out++) = 0;
+        }
+
+        const Int32* pt_C1 = &sbrDecoderFilterbankCoefficients_down_smpl[0];
+        pt_C2 = &sbrDecoderFilterbankCoefficients_down_smpl[16];
+
+        for (int k = 0; k < 5; k++)
+        {
+            pt_out -= 32;
+            for (i = 0; i < 16; i++)
+            {
+                realAccu1   = fxp_mul_16_by_16bt(*(pt_V1++), *(pt_C1));
+                realAccu2   = fxp_mul_16_by_16bb(*(pt_V1++), *(pt_C1++));
+                realAccu1   = fxp_mac_16_by_16_bt(*(pt_V2++), *(pt_C2), realAccu1);
+                realAccu2   = fxp_mac_16_by_16_bb(*(pt_V2++), *(pt_C2++), realAccu2);
+                *(pt_out++) += realAccu1 >> 5;
+                *(pt_out++) += realAccu2 >> 5;
+
+            }
+            pt_V1 += 96;
+            pt_V2 += 96;
+            pt_C1 += 16;
+            pt_C2 += 16;
+        }
+        pt_out -= 32;
+
+        for (i = 0; i < 32; i++)
+        {
+            timeSig[2*i] = (Int16)((*(pt_out++) + 512) >> 10);
+        }
+
+    }
+
+}
+
+
+
+#ifdef HQ_SBR
+
+void calc_sbr_synfilterbank(Int32 * Sr,
+                            Int32 * Si,
+                            Int16 * timeSig,
+                            Int16   V[1280],
+                            bool bDownSampleSBR)
+{
+    Int32 i;
+
+    const Int32 *pt_C2;
+
+    Int32   realAccu1;
+    Int32   realAccu2;
+
+    Int16 *pt_V1;
+    Int16 *pt_V2;
+
+    Int16 *pt_timeSig;
+
+    Int16 *pt_timeSig_2;
+    Int32  test1;
+    Int16  tmp1;
+    Int16  tmp2;
+
+
+    if (bDownSampleSBR == false)
+    {
+        synthesis_sub_band(Sr, Si, V);
+
+        /* content of V[] is at most 16 bits */
+        pt_timeSig   = &timeSig[0];
+        pt_timeSig_2 = &timeSig[64];
+
+        tmp1 = V[ 704];
+        tmp2 = V[ 768];
+        realAccu1 =  fxp_mac_16_by_16(tmp1, Qfmt(0.853738560F), ROUND_SYNFIL);
+        realAccu1 =  fxp_mac_16_by_16(tmp2, Qfmt(-0.361158990F), realAccu1);
+        tmp1 = -V[ 512];
+        tmp2 =  V[ 960];
+        realAccu1 =  fxp_mac_16_by_16(tmp1, Qfmt(-0.361158990F), realAccu1);
+        realAccu1 =  fxp_mac_16_by_16(tmp2, Qfmt(0.070353307F), realAccu1);
+        tmp1 =  V[ 448];
+        tmp2 =  V[1024];
+        realAccu1 =  fxp_mac_16_by_16(tmp1, Qfmt(0.070353307F), realAccu1);
+        realAccu1 =  fxp_mac_16_by_16(tmp2, Qfmt(-0.013271822F), realAccu1);
+        tmp1 =  -V[ 256];
+        tmp2 =   V[ 192];
+        realAccu1 =  fxp_mac_16_by_16(tmp1, Qfmt(-0.013271822F), realAccu1);
+        realAccu1 =  fxp_mac_16_by_16(tmp2, Qfmt(0.002620176F), realAccu1);
+        realAccu1 =  fxp_mac_16_by_16(V[1216], Qfmt(0.002620176F), realAccu1);
+
+        tmp1 = V[  32];
+        tmp2 = V[1248];
+        realAccu2 =  fxp_mac_16_by_16(tmp1, Qfmt(-0.000665042F), ROUND_SYNFIL);
+        realAccu2 =  fxp_mac_16_by_16(tmp2, Qfmt(-0.000665042F), realAccu2);
+        tmp1 = V[ 224];
+        tmp2 = V[1056];
+        realAccu2 =  fxp_mac_16_by_16(tmp1, Qfmt(0.005271576F), realAccu2);
+        realAccu2 =  fxp_mac_16_by_16(tmp2, Qfmt(0.005271576F), realAccu2);
+        tmp1 = V[ 992];
+        tmp2 = V[ 288];
+        realAccu2 =  fxp_mac_16_by_16(tmp1, Qfmt(0.058591568F), realAccu2);
+        realAccu2 =  fxp_mac_16_by_16(tmp2, Qfmt(0.058591568F), realAccu2);
+        tmp1 = V[ 480];
+        tmp2 = V[ 800];
+        realAccu2 =  fxp_mac_16_by_16(tmp1, Qfmt(-0.058370533F), realAccu2);
+        realAccu2 =  fxp_mac_16_by_16(tmp2, Qfmt(-0.058370533F), realAccu2);
+        tmp1 = V[ 736];
+        tmp2 = V[ 544];
+        realAccu2 =  fxp_mac_16_by_16(tmp1, Qfmt(0.702238872F), realAccu2);
+        realAccu2 =  fxp_mac_16_by_16(tmp2, Qfmt(0.702238872F), realAccu2);
+
+
+        saturate2(realAccu1, realAccu2, pt_timeSig, pt_timeSig_2);
+
+        pt_timeSig_2 = &timeSig[126];
+
+        pt_V1 = &V[1];
+        pt_V2 = &V[1279];
+
+        pt_C2 = &sbrDecoderFilterbankCoefficients[0];
+
+        for (i = 31; i != 0; i--)
+        {
+            test1 = *(pt_C2++);
+            tmp1 = *(pt_V1++);
+            tmp2 = *(pt_V2--);
+            realAccu1 =  fxp_mac_16_by_16_bt(tmp1 , test1, ROUND_SYNFIL);
+            realAccu2 =  fxp_mac_16_by_16_bt(tmp2 , test1, ROUND_SYNFIL);
+            tmp1 = pt_V1[  191];
+            tmp2 = pt_V2[ -191];
+            realAccu1 =  fxp_mac_16_by_16_bb(tmp1, test1, realAccu1);
+            realAccu2 =  fxp_mac_16_by_16_bb(tmp2, test1, realAccu2);
+
+            test1 = *(pt_C2++);
+            tmp1 = pt_V1[  255];
+            tmp2 = pt_V2[ -255];
+            realAccu1 =  fxp_mac_16_by_16_bt(tmp1 , test1, realAccu1);
+            realAccu2 =  fxp_mac_16_by_16_bt(tmp2 , test1, realAccu2);
+            tmp1 = pt_V1[  447];
+            tmp2 = pt_V2[ -447];
+            realAccu1 =  fxp_mac_16_by_16_bb(tmp1, test1, realAccu1);
+            realAccu2 =  fxp_mac_16_by_16_bb(tmp2, test1, realAccu2);
+
+            test1 = *(pt_C2++);
+            tmp1 = pt_V1[  511];
+            tmp2 = pt_V2[ -511];
+            realAccu1 =  fxp_mac_16_by_16_bt(tmp1 , test1, realAccu1);
+            realAccu2 =  fxp_mac_16_by_16_bt(tmp2 , test1, realAccu2);
+            tmp1 = pt_V1[  703];
+            tmp2 = pt_V2[ -703];
+            realAccu1 =  fxp_mac_16_by_16_bb(tmp1, test1, realAccu1);
+            realAccu2 =  fxp_mac_16_by_16_bb(tmp2, test1, realAccu2);
+
+            test1 = *(pt_C2++);
+            tmp1 = pt_V1[  767];
+            tmp2 = pt_V2[ -767];
+            realAccu1 =  fxp_mac_16_by_16_bt(tmp1 , test1, realAccu1);
+            realAccu2 =  fxp_mac_16_by_16_bt(tmp2 , test1, realAccu2);
+            tmp1 = pt_V1[  959];
+            tmp2 = pt_V2[ -959];
+            realAccu1 =  fxp_mac_16_by_16_bb(tmp1, test1, realAccu1);
+            realAccu2 =  fxp_mac_16_by_16_bb(tmp2, test1, realAccu2);
+
+            test1 = *(pt_C2++);
+            tmp1 = pt_V1[  1023];
+            tmp2 = pt_V2[ -1023];
+            realAccu1 =  fxp_mac_16_by_16_bt(tmp1 , test1, realAccu1);
+            realAccu2 =  fxp_mac_16_by_16_bt(tmp2 , test1, realAccu2);
+            tmp1 = pt_V1[  1215];
+            tmp2 = pt_V2[ -1215];
+            realAccu1 =  fxp_mac_16_by_16_bb(tmp1, test1, realAccu1);
+            realAccu2 =  fxp_mac_16_by_16_bb(tmp2, test1, realAccu2);
+
+            saturate2(realAccu1, realAccu2, pt_timeSig, pt_timeSig_2);
+        }
+
+    }
+    else
+    {
+
+        synthesis_sub_band_down_sampled(Sr,  Si,  V);
+
+
+        Int32 * pt_out = Sr;
+
+        for (i = 0; i < 8; i++)
+        {
+            *(pt_out++) = 0;
+            *(pt_out++) = 0;
+            *(pt_out++) = 0;
+            *(pt_out++) = 0;
+        }
+
+
+        /*
+         *    window signal
+         *    calculate output samples
+         */
+
+        pt_V1 = &V[0];
+        pt_V2 = &V[96];
+
+
+        const Int32* pt_C1 = &sbrDecoderFilterbankCoefficients_down_smpl[0];
+        pt_C2 = &sbrDecoderFilterbankCoefficients_down_smpl[16];
+
+        for (Int k = 0; k < 5; k++)
+        {
+            pt_out -= 32;
+            for (i = 0; i < 16; i++)
+            {
+                realAccu1   = fxp_mul_16_by_16bt(*(pt_V1++), *(pt_C1));
+                realAccu2   = fxp_mul_16_by_16bb(*(pt_V1++), *(pt_C1++));
+                realAccu1   = fxp_mac_16_by_16_bt(*(pt_V2++), *(pt_C2), realAccu1);
+                realAccu2   = fxp_mac_16_by_16_bb(*(pt_V2++), *(pt_C2++), realAccu2);
+                *(pt_out++) += realAccu1 >> 5;
+                *(pt_out++) += realAccu2 >> 5;
+            }
+            pt_V1 += 96;
+            pt_V2 += 96;
+            pt_C1 += 16;
+            pt_C2 += 16;
+        }
+        pt_out -= 32;
+
+        for (i = 0; i < 32; i++)
+        {
+            timeSig[2*i] = (Int16)((*(pt_out++) + 512) >> 10);
+        }
+
+    }
+}
+
+
+#endif      /* --- HQ_SBR --- */
+
+
+#endif      /* --- AAC_PLUS --- */
+
+
+
diff --git a/media/libstagefright/codecs/aacdec/calc_sbr_synfilterbank.h b/media/libstagefright/codecs/aacdec/calc_sbr_synfilterbank.h
new file mode 100644
index 0000000..28bd6de
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/calc_sbr_synfilterbank.h
@@ -0,0 +1,94 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*----------------------------------------------------------------------------
+; CONTINUE ONLY IF NOT ALREADY DEFINED
+----------------------------------------------------------------------------*/
+#ifndef CALC_SBR_SYNFILTERBANK_H
+#define CALC_SBR_SYNFILTERBANK_H
+
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+#include "pv_audio_type_defs.h"
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+    /*----------------------------------------------------------------------------
+    ; DEFINES
+    ; Include all pre-processor statements here.
+    ----------------------------------------------------------------------------*/
+#define N  14
+
+#define ROUND_SYNFIL  (32768 + 4096)
+
+    /*----------------------------------------------------------------------------
+    ; EXTERNAL VARIABLES REFERENCES
+    ; Declare variables used in this module but defined elsewhere
+    ----------------------------------------------------------------------------*/
+
+    /*----------------------------------------------------------------------------
+    ; SIMPLE TYPEDEF'S
+    ----------------------------------------------------------------------------*/
+
+    /*----------------------------------------------------------------------------
+    ; ENUMERATED TYPEDEF'S
+    ----------------------------------------------------------------------------*/
+
+    /*----------------------------------------------------------------------------
+    ; STRUCTURES TYPEDEF'S
+    ----------------------------------------------------------------------------*/
+
+    /*----------------------------------------------------------------------------
+    ; GLOBAL FUNCTION DEFINITIONS
+    ; Function Prototype declaration
+    ----------------------------------------------------------------------------*/
+
+
+    void calc_sbr_synfilterbank_LC(Int32 * Sr,
+    Int16 * timeSig,
+    Int16   V[1280],
+    bool bDownSampleSBR);
+
+#ifdef HQ_SBR
+
+
+    void calc_sbr_synfilterbank(Int32 * Sr,
+                                Int32 * Si,
+                                Int16 * timeSig,
+                                Int16   V[1280],
+                                bool bDownSampleSBR);
+
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+
+/*----------------------------------------------------------------------------
+; END
+----------------------------------------------------------------------------*/
+#endif
+
diff --git a/media/libstagefright/codecs/aacdec/chans.h b/media/libstagefright/codecs/aacdec/chans.h
new file mode 100644
index 0000000..325b5cd
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/chans.h
@@ -0,0 +1,107 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Pathname:   chans.h
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+ Description: Placed file in the correct template format.
+
+------------------------------------------------------------------------------
+ INCLUDE DESCRIPTION
+
+------------------------------------------------------------------------------
+*/
+
+/*----------------------------------------------------------------------------
+; CONTINUE ONLY IF NOT ALREADY DEFINED
+----------------------------------------------------------------------------*/
+#ifndef CHANS_H
+#define CHANS_H
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+    /*----------------------------------------------------------------------------
+    ; INCLUDES
+    ----------------------------------------------------------------------------*/
+#include "pv_audio_type_defs.h"
+
+    /*----------------------------------------------------------------------------
+    ; MACROS
+    ; Define module specific macros here
+    ----------------------------------------------------------------------------*/
+
+    /*----------------------------------------------------------------------------
+    ; DEFINES
+    ; Include all pre-processor statements here.
+    ----------------------------------------------------------------------------*/
+    /* #define is required in order to use these args in #if () directive */
+#define ICChans 0
+#define DCChans 0
+#define XCChans 0
+#define CChans  0
+
+    /*----------------------------------------------------------------------------
+    ; EXTERNAL VARIABLES REFERENCES
+    ; Declare variables used in this module but defined elsewhere
+    ----------------------------------------------------------------------------*/
+
+    /*----------------------------------------------------------------------------
+    ; SIMPLE TYPEDEF'S
+    ----------------------------------------------------------------------------*/
+
+    /*----------------------------------------------------------------------------
+    ; ENUMERATED TYPEDEF'S
+    ----------------------------------------------------------------------------*/
+    enum
+    {
+        /*
+         * channels for 5.1 main profile configuration
+         * (modify for any desired decoder configuration)
+         */
+        FChans  = 2,    /* front channels: left, center, right */
+        FCenter = 0,    /* 1 if decoder has front center channel */
+        SChans  = 0,    /* side channels: */
+        BChans  = 0,    /* back channels: left surround, right surround */
+        BCenter = 0,    /* 1 if decoder has back center channel */
+        LChans  = 0,    /* LFE channels */
+        XChans  = 0,    /* scratch space for parsing unused channels */
+
+        Chans   = FChans + SChans + BChans + LChans + XChans
+    };
+    /*----------------------------------------------------------------------------
+    ; STRUCTURES TYPEDEF'S
+    ----------------------------------------------------------------------------*/
+
+
+    /*----------------------------------------------------------------------------
+    ; GLOBAL FUNCTION DEFINITIONS
+    ; Function Prototype declaration
+    ----------------------------------------------------------------------------*/
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* CHANS_H */
+
diff --git a/media/libstagefright/codecs/aacdec/check_crc.cpp b/media/libstagefright/codecs/aacdec/check_crc.cpp
new file mode 100644
index 0000000..17f3b87
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/check_crc.cpp
@@ -0,0 +1,144 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Filename: check_crc.c
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+
+ Who:                                   Date: MM/DD/YYYY
+ Description:
+
+------------------------------------------------------------------------------
+ INPUT AND OUTPUT DEFINITIONS
+
+    INPUT
+
+
+    OUTPUT
+
+    errorCode, noError if successful
+
+------------------------------------------------------------------------------
+ FUNCTION DESCRIPTION
+
+
+------------------------------------------------------------------------------
+ REQUIREMENTS
+
+
+------------------------------------------------------------------------------
+ REFERENCES
+
+SC 29 Software Copyright Licencing Disclaimer:
+
+This software module was originally developed by
+  Coding Technologies
+
+and edited by
+  -
+
+in the course of development of the ISO/IEC 13818-7 and ISO/IEC 14496-3
+standards for reference purposes and its performance may not have been
+optimized. This software module is an implementation of one or more tools as
+specified by the ISO/IEC 13818-7 and ISO/IEC 14496-3 standards.
+ISO/IEC gives users free license to this software module or modifications
+thereof for use in products claiming conformance to audiovisual and
+image-coding related ITU Recommendations and/or ISO/IEC International
+Standards. ISO/IEC gives users the same free license to this software module or
+modifications thereof for research purposes and further ISO/IEC standardisation.
+Those intending to use this software module in products are advised that its
+use may infringe existing patents. ISO/IEC have no liability for use of this
+software module or modifications thereof. Copyright is not released for
+products that do not conform to audiovisual and image-coding related ITU
+Recommendations and/or ISO/IEC International Standards.
+The original developer retains full right to modify and use the code for its
+own purpose, assign or donate the code to a third party and to inhibit third
+parties from using the code for products that do not conform to audiovisual and
+image-coding related ITU Recommendations and/or ISO/IEC International Standards.
+This copyright notice must be included in all copies or derivative works.
+Copyright (c) ISO/IEC 2002.
+
+------------------------------------------------------------------------------
+ PSEUDO-CODE
+
+------------------------------------------------------------------------------
+*/
+
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+#include "check_crc.h"
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here. Include conditional
+; compile variables also.
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; LOCAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; LOCAL STORE/BUFFER/POINTER DEFINITIONS
+; Variable declaration - defined here and used outside this module
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL FUNCTION REFERENCES
+; Declare functions defined elsewhere and referenced in this module
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL GLOBAL STORE/BUFFER/POINTER REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; FUNCTION CODE
+----------------------------------------------------------------------------*/
+
+void check_crc(HANDLE_CRC hCrcBuf, UInt32 bValue, Int32 nBits)
+{
+    Int32 i;
+    UInt32 bMask = (1UL << (nBits - 1));
+
+    for (i = 0; i < nBits; i++, bMask >>= 1)
+    {
+        UInt16 flag  = (UInt16)((hCrcBuf->crcState & hCrcBuf->crcMask) ? 1 : 0);
+        UInt16 flag1 = (UInt16)((bMask & bValue) ? 1 : 0);
+
+        flag ^= flag1;
+        hCrcBuf->crcState <<= 1;
+        if (flag)
+            hCrcBuf->crcState ^= hCrcBuf->crcPoly;
+    }
+
+}
+
diff --git a/media/libstagefright/codecs/aacdec/check_crc.h b/media/libstagefright/codecs/aacdec/check_crc.h
new file mode 100644
index 0000000..9293d47
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/check_crc.h
@@ -0,0 +1,124 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+ Filename: check_crc.h
+ Funtions:
+    get_dse
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+
+ Who:                                   Date: MM/DD/YYYY
+ Description:
+------------------------------------------------------------------------------
+SC 29 Software Copyright Licencing Disclaimer:
+
+This software module was originally developed by
+  Coding Technologies
+
+and edited by
+  -
+
+in the course of development of the ISO/IEC 13818-7 and ISO/IEC 14496-3
+standards for reference purposes and its performance may not have been
+optimized. This software module is an implementation of one or more tools as
+specified by the ISO/IEC 13818-7 and ISO/IEC 14496-3 standards.
+ISO/IEC gives users free license to this software module or modifications
+thereof for use in products claiming conformance to audiovisual and
+image-coding related ITU Recommendations and/or ISO/IEC International
+Standards. ISO/IEC gives users the same free license to this software module or
+modifications thereof for research purposes and further ISO/IEC standardisation.
+Those intending to use this software module in products are advised that its
+use may infringe existing patents. ISO/IEC have no liability for use of this
+software module or modifications thereof. Copyright is not released for
+products that do not conform to audiovisual and image-coding related ITU
+Recommendations and/or ISO/IEC International Standards.
+The original developer retains full right to modify and use the code for its
+own purpose, assign or donate the code to a third party and to inhibit third
+parties from using the code for products that do not conform to audiovisual and
+image-coding related ITU Recommendations and/or ISO/IEC International Standards.
+This copyright notice must be included in all copies or derivative works.
+Copyright (c) ISO/IEC 2002.
+
+ $Id: ct_envcalc.h,v 1.3 2002/11/29 16:11:49 kaehleof Exp $
+*/
+
+/*----------------------------------------------------------------------------
+; CONTINUE ONLY IF NOT ALREADY DEFINED
+----------------------------------------------------------------------------*/
+#ifndef CHECK_CRC_H
+#define CHECK_CRC_H
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+#include "pv_audio_type_defs.h"
+#include "s_crc_buffer.h"
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+    /*----------------------------------------------------------------------------
+    ; DEFINES
+    ; Include all pre-processor statements here.
+    ----------------------------------------------------------------------------*/
+
+    /*----------------------------------------------------------------------------
+    ; EXTERNAL VARIABLES REFERENCES
+    ; Declare variables used in this module but defined elsewhere
+    ----------------------------------------------------------------------------*/
+
+    /*----------------------------------------------------------------------------
+    ; SIMPLE TYPEDEF'S
+    ----------------------------------------------------------------------------*/
+
+    /*----------------------------------------------------------------------------
+    ; ENUMERATED TYPEDEF'S
+    ----------------------------------------------------------------------------*/
+
+    /*----------------------------------------------------------------------------
+    ; STRUCTURES TYPEDEF'S
+    ----------------------------------------------------------------------------*/
+
+    /*----------------------------------------------------------------------------
+    ; GLOBAL FUNCTION DEFINITIONS
+    ; Function Prototype declaration
+    ----------------------------------------------------------------------------*/
+
+    void check_crc(HANDLE_CRC hCrcBuf,
+    UInt32 bValue,
+    Int32 nBits);
+
+
+#ifdef __cplusplus
+}
+#endif
+
+/*----------------------------------------------------------------------------
+; END
+----------------------------------------------------------------------------*/
+#endif
+
+
diff --git a/media/libstagefright/codecs/aacdec/dct16.cpp b/media/libstagefright/codecs/aacdec/dct16.cpp
new file mode 100644
index 0000000..75bd4ba
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/dct16.cpp
@@ -0,0 +1,266 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+ Filename: dct16.c
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+
+ Who:                                   Date: MM/DD/YYYY
+ Description:
+
+------------------------------------------------------------------------------
+ INPUT AND OUTPUT DEFINITIONS
+
+    Int32 x             32-bit integer input length 16
+
+    Int32 flag           1  forward dct16, 0 modified dct-16
+
+------------------------------------------------------------------------------
+ FUNCTION DESCRIPTION
+
+    Implement dct of lenght 16
+
+------------------------------------------------------------------------------
+ REQUIREMENTS
+
+
+------------------------------------------------------------------------------
+ REFERENCES
+
+------------------------------------------------------------------------------
+ PSEUDO-CODE
+
+------------------------------------------------------------------------------
+*/
+
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+
+#ifdef AAC_PLUS
+
+#include "dct16.h"
+#include "fxp_mul32.h"
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here. Include conditional
+; compile variables also.
+----------------------------------------------------------------------------*/
+
+#define Qfmt_31(a)   (Int32)(a*0x7FFFFFFF + (a>=0?0.5F:-0.5F))
+
+#define Qfmt15(x)   (Int16)(x*((Int32)1<<15) + (x>=0?0.5F:-0.5F))
+
+/*----------------------------------------------------------------------------
+; LOCAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; LOCAL STORE/BUFFER/POINTER DEFINITIONS
+; Variable declaration - defined here and used outside this module
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL FUNCTION REFERENCES
+; Declare functions defined elsewhere and referenced in this module
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL GLOBAL STORE/BUFFER/POINTER REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; FUNCTION CODE
+----------------------------------------------------------------------------*/
+
+
+void dct_16(Int32 vec[], Int flag)
+{
+    Int32 tmp0;
+    Int32 tmp1;
+    Int32 tmp2;
+    Int32 tmp3;
+    Int32 tmp4;
+    Int32 tmp5;
+    Int32 tmp6;
+    Int32 tmp7;
+    Int32 tmp_o0;
+    Int32 tmp_o1;
+    Int32 tmp_o2;
+    Int32 tmp_o3;
+    Int32 tmp_o4;
+    Int32 tmp_o5;
+    Int32 tmp_o6;
+    Int32 tmp_o7;
+    Int32 itmp_e0;
+    Int32 itmp_e1;
+    Int32 itmp_e2;
+
+    /*  split input vector */
+
+
+    tmp_o0 = fxp_mul32_by_16((vec[ 0] - vec[15]), Qfmt15(0.50241928618816F));
+    tmp0   =  vec[ 0] + vec[15];
+
+    tmp_o7 = fxp_mul32_Q31((vec[ 7] - vec[ 8]) << 3, Qfmt_31(0.63764357733614F));
+    tmp7   =  vec[ 7] + vec[ 8];
+
+    itmp_e0 = (tmp0 + tmp7);
+    tmp7    = fxp_mul32_by_16((tmp0 - tmp7), Qfmt15(0.50979557910416F));
+
+    tmp_o1 = fxp_mul32_by_16((vec[ 1] - vec[14]), Qfmt15(0.52249861493969F));
+    tmp1   =  vec[ 1] + vec[14];
+    tmp_o6 = fxp_mul32_by_16((vec[ 6] - vec[ 9]) << 1, Qfmt15(0.86122354911916F));
+    tmp6   =  vec[ 6] + vec[ 9];
+
+    itmp_e1 = (tmp1 + tmp6);
+    tmp6    = fxp_mul32_by_16((tmp1 - tmp6), Qfmt15(0.60134488693505F));
+
+    tmp_o2 = fxp_mul32_by_16((vec[ 2] - vec[13]), Qfmt15(0.56694403481636F));
+    tmp2   =  vec[ 2] + vec[13];
+    tmp_o5 = fxp_mul32_by_16((vec[ 5] - vec[10]) << 1, Qfmt15(0.53033884299517F));
+    tmp5   =  vec[ 5] + vec[10];
+
+    itmp_e2 = (tmp2 + tmp5);
+    tmp5    = fxp_mul32_by_16((tmp2 - tmp5), Qfmt15(0.89997622313642F));
+
+    tmp_o3 = fxp_mul32_by_16((vec[ 3] - vec[12]), Qfmt15(0.64682178335999F));
+    tmp3   =  vec[ 3] + vec[12];
+    tmp_o4 = fxp_mul32_by_16((vec[ 4] - vec[11]), Qfmt15(0.78815462345125F));
+    tmp4   =  vec[ 4] + vec[11];
+
+    tmp1   = (tmp3 + tmp4);
+    tmp4   =  fxp_mul32_Q31((tmp3 - tmp4) << 2, Qfmt_31(0.64072886193538F));
+
+    /*  split even part of tmp_e */
+
+    tmp0 = (itmp_e0 + tmp1);
+    tmp1 = fxp_mul32_by_16((itmp_e0 - tmp1), Qfmt15(0.54119610014620F));
+
+
+    tmp3 = fxp_mul32_by_16((itmp_e1 - itmp_e2) << 1, Qfmt15(0.65328148243819F));
+    tmp2 = (itmp_e1 + itmp_e2);
+
+    vec[ 0]  = (tmp0 + tmp2) >> 1;
+    vec[ 8]  = fxp_mul32_by_16((tmp0 - tmp2), Qfmt15(0.70710678118655F));
+    vec[12]  = fxp_mul32_by_16((tmp1 - tmp3) << 1, Qfmt15(0.70710678118655F));
+    vec[ 4]  =  tmp1 + tmp3;
+    vec[ 4] +=  vec[12];
+
+    /*  split odd part of tmp_e */
+
+    tmp1 = fxp_mul32_by_16((tmp7 - tmp4) << 1, Qfmt15(0.54119610014620F));
+    tmp7 += tmp4;
+    tmp3 = fxp_mul32_Q31((tmp6 - tmp5) << 2, Qfmt_31(0.65328148243819F));
+
+    tmp6 += tmp5;
+
+    vec[10]  = fxp_mul32_by_16((tmp7 - tmp6) << 1, Qfmt15(0.70710678118655F));
+    vec[ 2]  =  tmp7 + tmp6;
+    vec[14]  = fxp_mul32_by_16((tmp1 - tmp3) << 1, Qfmt15(0.70710678118655F));
+
+    tmp1    +=  tmp3 + vec[14];
+    vec[ 2] +=  tmp1;
+    vec[ 6]  =  tmp1 + vec[10];
+
+    vec[10] += vec[14];
+
+
+    // dct8;
+
+    tmp7 = tmp_o0 + tmp_o7;
+    tmp_o7 = fxp_mul32_by_16((tmp_o0 - tmp_o7) << 1, Qfmt15(0.50979557910416F));
+
+    tmp6 = tmp_o1 + tmp_o6;
+    tmp_o1 = fxp_mul32_by_16((tmp_o1 - tmp_o6) << 1, Qfmt15(0.60134488693505F));
+
+    tmp5 = tmp_o2 + tmp_o5;
+    tmp_o5 = fxp_mul32_by_16((tmp_o2 - tmp_o5) << 1, Qfmt15(0.89997622313642F));
+
+    tmp4 = tmp_o3 + tmp_o4;
+
+    tmp_o3 = fxp_mul32_Q31((tmp_o3 - tmp_o4) << 3, Qfmt_31(0.6407288619354F));
+
+    if (!flag)
+    {
+        tmp7   = -tmp7;
+        tmp_o7 = -tmp_o7;
+        tmp6   = -tmp6;
+        tmp_o1 = -tmp_o1;
+        tmp5   = -tmp5;
+        tmp_o5 = -tmp_o5;
+        tmp4   = -tmp4;
+        tmp_o3 = -tmp_o3;
+    }
+
+    // even part
+
+    tmp1 = fxp_mul32_by_16((tmp7 - tmp4) << 1, Qfmt15(0.54119610014620F));
+    tmp0 =  tmp7 + tmp4;
+    tmp3 = fxp_mul32_Q31((tmp6 - tmp5) << 2, Qfmt_31(0.65328148243819F));
+    tmp2 =  tmp6 + tmp5;
+
+    vec[ 9]  = fxp_mul32_Q31((tmp0 - tmp2) << 1, Qfmt_31(0.70710678118655F));
+    vec[ 1]  =  tmp0 + tmp2;
+    vec[13]  = fxp_mul32_Q31((tmp1 - tmp3) << 1, Qfmt_31(0.70710678118655F));
+
+    vec[ 5]  =  tmp1 + tmp3 + vec[13];
+
+    // odd part
+
+    tmp0 =  tmp_o7 + tmp_o3;
+    tmp1 = fxp_mul32_by_16((tmp_o7 - tmp_o3) << 1, Qfmt15(0.54119610014620F));
+    tmp2 =  tmp_o1 + tmp_o5;
+    tmp3 = fxp_mul32_Q31((tmp_o1 - tmp_o5) << 2, Qfmt_31(0.65328148243819F));
+
+    vec[11]  = fxp_mul32_Q31((tmp0 - tmp2) << 1, Qfmt_31(0.70710678118655F));
+    vec[ 3]  =  tmp0 + tmp2;
+    vec[15]  = fxp_mul32_Q31((tmp1 - tmp3) << 1, Qfmt_31(0.70710678118655F));
+    vec[ 7]  =  tmp1 + tmp3 + vec[15];
+
+
+    vec[ 3] += vec[ 7];
+    vec[ 7] += vec[11];
+    vec[11] += vec[15];
+
+    vec[ 1] += vec[ 3];
+    vec[ 3] += vec[ 5];
+    vec[ 5] += vec[ 7];
+    vec[ 7] += vec[ 9];
+    vec[ 9] += vec[11];
+    vec[11] += vec[13];
+    vec[13] += vec[15];
+
+
+}
+
+
+#endif
+
diff --git a/media/libstagefright/codecs/aacdec/dct16.h b/media/libstagefright/codecs/aacdec/dct16.h
new file mode 100644
index 0000000..6f8fcb2
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/dct16.h
@@ -0,0 +1,68 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Pathname: ./c/include/dct16.h
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+ Who:                                       Date:
+ Description:
+------------------------------------------------------------------------------
+ INCLUDE DESCRIPTION
+
+------------------------------------------------------------------------------
+*/
+
+#ifndef DCT16_H
+#define DCT16_H
+
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+
+#include "pv_audio_type_defs.h"
+
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+    /*----------------------------------------------------------------------------
+    ; EXTERNAL VARIABLES REFERENCES
+    ----------------------------------------------------------------------------*/
+
+    /*----------------------------------------------------------------------------
+    ; DEFINES AND SIMPLE TYPEDEF'S
+    ----------------------------------------------------------------------------*/
+
+    void dct_16(Int32 vec[], Int flag);
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif  /* DCT16_H */
diff --git a/media/libstagefright/codecs/aacdec/dct64.cpp b/media/libstagefright/codecs/aacdec/dct64.cpp
new file mode 100644
index 0000000..a21a814
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/dct64.cpp
@@ -0,0 +1,569 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Filename: dct64.c
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+
+ Who:                                   Date: MM/DD/YYYY
+ Description:
+
+------------------------------------------------------------------------------
+ INPUT AND OUTPUT DEFINITIONS
+
+    Int32 x             32-bit integer input length 64
+
+
+------------------------------------------------------------------------------
+ FUNCTION DESCRIPTION
+
+    Implement dct of lenght 64
+
+------------------------------------------------------------------------------
+ REQUIREMENTS
+
+
+------------------------------------------------------------------------------
+ REFERENCES
+
+------------------------------------------------------------------------------
+ PSEUDO-CODE
+
+------------------------------------------------------------------------------
+*/
+
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+
+#ifdef AAC_PLUS
+
+
+#include "dct16.h"
+#include "dct64.h"
+
+#include "pv_audio_type_defs.h"
+#include "synthesis_sub_band.h"
+
+#include "fxp_mul32.h"
+
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here. Include conditional
+; compile variables also.
+----------------------------------------------------------------------------*/
+
+#define Qfmt(a)   (Int32)(a*((Int32)1<<26) + (a>=0?0.5F:-0.5F))
+#define Qfmt31(a)   (Int32)(a*0x7FFFFFFF)
+
+const Int32 CosTable_48[48] =
+{
+    Qfmt31(0.50015063602065F) ,  Qfmt31(0.50135845244641F) ,
+    Qfmt31(0.50378872568104F) ,  Qfmt31(0.50747117207256F) ,
+    Qfmt31(0.51245147940822F) ,  Qfmt31(0.51879271310533F) ,
+    Qfmt31(0.52657731515427F) ,  Qfmt31(0.53590981690799F) ,
+    Qfmt31(0.54692043798551F) ,  Qfmt31(0.55976981294708F) ,
+    Qfmt31(0.57465518403266F) ,  Qfmt31(0.59181853585742F) ,
+    Qfmt31(0.61155734788251F) ,  Qfmt31(0.63423893668840F) ,
+    Qfmt31(0.66031980781371F) ,  Qfmt31(0.69037212820021F) ,
+    Qfmt31(0.72512052237720F) ,  Qfmt31(0.76549416497309F) ,
+    Qfmt31(0.81270209081449F) ,  Qfmt31(0.86834471522335F) ,
+    Qfmt(0.93458359703641F) ,  Qfmt(1.01440826499705F) ,
+    Qfmt(1.11207162057972F) ,  Qfmt(1.23383273797657F) ,
+    Qfmt(1.38929395863283F) ,  Qfmt(1.59397228338563F) ,
+    Qfmt(1.87467598000841F) ,  Qfmt(2.28205006800516F) ,
+    Qfmt(2.92462842815822F) ,  Qfmt(4.08461107812925F) ,
+    Qfmt(6.79675071167363F) ,  Qfmt(20.37387816723145F) , /* 32 */
+    Qfmt(0.50060299823520F) ,  Qfmt(0.50547095989754F) ,
+    Qfmt(0.51544730992262F) ,  Qfmt(0.53104259108978F) ,
+    Qfmt(0.55310389603444F) ,  Qfmt(0.58293496820613F) ,
+    Qfmt(0.62250412303566F) ,  Qfmt(0.67480834145501F) ,
+    Qfmt(0.74453627100230F) ,  Qfmt(0.83934964541553F) ,
+    Qfmt(0.97256823786196F) ,  Qfmt(1.16943993343288F) ,
+    Qfmt(1.48416461631417F) ,  Qfmt(2.05778100995341F) ,
+    Qfmt(3.40760841846872F) ,  Qfmt(10.19000812354803F)
+};
+
+
+
+
+/*----------------------------------------------------------------------------
+; LOCAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; LOCAL STORE/BUFFER/POINTER DEFINITIONS
+; Variable declaration - defined here and used outside this module
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL FUNCTION REFERENCES
+; Declare functions defined elsewhere and referenced in this module
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL GLOBAL STORE/BUFFER/POINTER REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; FUNCTION CODE
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; dct_64
+----------------------------------------------------------------------------*/
+
+void pv_split_LC(Int32 *vector,
+                 Int32 *temp_o)
+{
+
+    Int32 i;
+    Int32 *pt_vector     = &vector[0];
+    Int32 *pt_vector_N_1 = &vector[31];
+    const Int32 *pt_cosTerms = &CosTable_48[32];
+    Int32 *pt_temp_o = temp_o;
+    Int32 tmp1;
+    Int32 tmp2;
+    Int32 tmp3;
+
+
+    tmp1 = *(pt_vector);
+    tmp2 = *(pt_vector_N_1--);
+    for (i = 16; i != 0; i--)
+    {
+        tmp3 = *(pt_cosTerms++);
+        *(pt_vector++) =   tmp1  + tmp2;
+        *(pt_temp_o++) = fxp_mul32_Q26((tmp1 - tmp2), tmp3);
+        tmp1 = *(pt_vector);
+        tmp2 = *(pt_vector_N_1--);
+    }
+
+}
+
+
+#ifdef HQ_SBR
+
+
+void dct_64(Int32 vec[], Int32 *scratch_mem)
+{
+    Int32 *temp_e1;
+    Int32 *temp_o1;
+
+    Int32 *pt_vec;
+
+    Int   i;
+
+    Int32 aux1;
+    Int32 aux2;
+    Int32 aux3;
+    Int32 aux4;
+
+    const Int32 *cosTerms = &CosTable_48[31];
+
+    temp_o1 = &vec[32];
+    temp_e1 = temp_o1 - 1;
+
+
+    for (i = 6; i != 0; i--)
+    {
+        aux1 = *(temp_e1);
+        aux2 = *(temp_o1);
+        aux3 = *(cosTerms--);
+        *(temp_e1--) =   aux1  + aux2;
+        *(temp_o1++) = fxp_mul32_Q26((aux1 - aux2), aux3);
+        aux1 = *(temp_e1);
+        aux2 = *(temp_o1);
+        aux3 = *(cosTerms--);
+        *(temp_e1--) =   aux1  + aux2;
+        *(temp_o1++) = fxp_mul32_Q26((aux1 - aux2), aux3);
+    }
+
+
+    for (i = 10; i != 0; i--)
+    {
+        aux1 = *(temp_e1);
+        aux2 = *(temp_o1);
+        aux3 = *(cosTerms--);
+        *(temp_e1--) =   aux1  + aux2;
+        *(temp_o1++) = fxp_mul32_Q31((aux1 - aux2), aux3) << 1;
+        aux1 = *(temp_e1);
+        aux2 = *(temp_o1);
+        aux3 = *(cosTerms--);
+        *(temp_e1--) =   aux1  + aux2;
+        *(temp_o1++) = fxp_mul32_Q31((aux1 - aux2), aux3) << 1;
+    }
+
+
+    pv_split(&vec[16]);
+
+    dct_16(&vec[16], 0);
+    dct_16(vec,     1);      // Even terms
+
+    pv_merge_in_place_N32(vec);
+
+    pv_split_z(&vec[32]);
+
+    dct_16(&vec[32], 1);     // Even terms
+    dct_16(&vec[48], 0);
+
+    pv_merge_in_place_N32(&vec[32]);
+
+
+
+    aux1   = vec[32];
+    aux3   = vec[33];
+    aux4   = vec[ 1];  /* vec[ 1] */
+
+    /* -----------------------------------*/
+    aux1     = vec[32] + vec[33];
+    vec[ 0] +=  aux1;
+    vec[ 1] +=  aux1;
+
+    aux1        = vec[34];
+    aux2        = vec[ 2];   /* vec[ 2] */
+    aux3        += aux1;
+    vec[ 2] = aux4 + aux3;
+    aux4        = vec[ 3];  /* vec[ 3] */
+    vec[ 3] = aux2 + aux3;
+
+    aux3        = vec[35];
+
+    /* -----------------------------------*/
+    aux1        += aux3;
+    vec[32] = vec[ 4];
+    vec[33] = vec[ 5];
+    vec[ 4] = aux2 + aux1;
+    vec[ 5] = aux4 + aux1;
+
+    aux1        = vec[36];
+    aux2        = vec[32];  /* vec[ 4] */
+    aux3        += aux1;
+    vec[34] = vec[ 6];
+    vec[35] = vec[ 7];
+    vec[ 6] = aux4 + aux3;
+    vec[ 7] = aux2 + aux3;
+
+    aux3        = vec[37];
+    aux4        = vec[33];  /* vec[ 5] */
+
+    /* -----------------------------------*/
+    aux1        += aux3;
+    vec[32] = vec[ 8];
+    vec[33] = vec[ 9];
+    vec[ 8] = aux2 + aux1;
+    vec[ 9] = aux4 + aux1;
+
+    aux1        = vec[38];
+    aux2        = vec[34];  /* vec[ 6] */
+    aux3        += aux1;
+    vec[34] = vec[10];
+    vec[10] = aux4 + aux3;
+    aux4        = vec[35];  /* vec[ 7] */
+    vec[35] = vec[11];
+    vec[11] = aux2 + aux3;
+
+    aux3        = vec[39];
+
+    /* -----------------------------------*/
+    aux1        += aux3;
+    vec[36] = vec[12];
+    vec[37] = vec[13];
+    vec[12] = aux2 + aux1;
+    vec[13] = aux4 + aux1;
+
+    aux1        = vec[40];
+    aux2        = vec[32];  /* vec[ 8] */
+    aux3        += aux1;
+    vec[32] = vec[14];
+    vec[14] = aux4 + aux3;
+    aux4        = vec[33];  /* vec[ 9] */
+    vec[33] = vec[15];
+    vec[15] = aux2 + aux3;
+
+    aux3        = vec[41];
+
+    /* -----------------------------------*/
+    aux1        += aux3;
+    vec[38] = vec[16];
+    vec[39] = vec[17];
+    vec[16] = aux2 + aux1;
+    vec[17] = aux4 + aux1;
+
+    aux1        = vec[42];
+    aux2        = vec[34];  /* vec[10] */
+    aux3        += aux1;
+    vec[34] = vec[18];
+    vec[18] = aux4 + aux3;
+    aux4        = vec[35];  /* vec[11] */
+    vec[35] = vec[19];
+    vec[19] = aux2 + aux3;
+
+    aux3        = vec[43];
+
+    /* -----------------------------------*/
+    aux1        += aux3;
+    vec[40] = vec[20];
+    vec[41] = vec[21];
+    vec[20] = aux2 + aux1;
+    vec[21] = aux4 + aux1;
+
+    aux1        = vec[44];
+    aux2        = vec[36];  /* vec[12] */
+    aux3        += aux1;
+    vec[42] = vec[22];
+    vec[43] = vec[23];
+    vec[22] = aux4 + aux3;
+    vec[23] = aux2 + aux3;
+
+    aux3        = vec[45];
+    aux4        = vec[37];  /* vec[13] */
+
+    /* -----------------------------------*/
+
+
+    scratch_mem[0] = vec[24];
+    scratch_mem[1] = vec[25];
+    aux1        += aux3;
+    vec[24] = aux2 + aux1;
+    vec[25] = aux4 + aux1;
+
+    aux1        = vec[46];
+    aux2        = vec[32];  /* vec[14] */
+    scratch_mem[2] = vec[26];
+    scratch_mem[3] = vec[27];
+    aux3        += aux1;
+    vec[26] = aux4 + aux3;
+    vec[27] = aux2 + aux3;
+
+    aux3        = vec[47];
+    aux4        = vec[33];  /* vec[15] */
+
+    /* -----------------------------------*/
+    scratch_mem[4] = vec[28];
+    scratch_mem[5] = vec[29];
+    aux1        += aux3;
+    vec[28] = aux2 + aux1;
+    vec[29] = aux4 + aux1;
+
+    aux1        = vec[48];
+    aux2        = vec[38];  /* vec[16] */
+    scratch_mem[6] = vec[30];
+    scratch_mem[7] = vec[31];
+    aux3        += aux1;
+    vec[30] = aux4 + aux3;
+    vec[31] = aux2 + aux3;
+
+    aux3        = vec[49];
+    aux4        = vec[39];  /* vec[17] */
+
+    /* -----------------------------------*/
+    aux1        += aux3;
+    vec[32] = aux2 + aux1;
+    vec[33] = aux4 + aux1;
+
+    aux1        = vec[50];
+    aux2        = vec[34];  /* vec[18] */
+    aux3        += aux1;
+    vec[34] = aux4 + aux3;
+    aux4        = vec[35];  /* vec[19] */
+    vec[35] = aux2 + aux3;
+
+    aux3        = vec[51];
+
+
+    /* -----------------------------------*/
+    aux1        += aux3;
+    vec[36] = aux2 + aux1;
+    vec[37] = aux4 + aux1;
+
+    aux1        = vec[52];
+    aux2        = vec[40];  /* vec[20] */
+    aux3        += aux1;
+    vec[38] = aux4 + aux3;
+    vec[39] = aux2 + aux3;
+
+    aux3        = vec[53];
+    aux4        = vec[41];  /* vec[21] */
+
+    /* -----------------------------------*/
+    aux1        += aux3;
+    vec[40] = aux2 + aux1;
+    vec[41] = aux4 + aux1;
+
+    aux1        = vec[54];
+    aux2        = vec[42];  /* vec[22] */
+    aux3        += aux1;
+    vec[42] = aux4 + aux3;
+    aux4        = vec[43];  /* vec[23] */
+    vec[43] = aux2 + aux3;
+
+    aux3        = vec[55];
+
+    /* -----------------------------------*/
+
+    pt_vec = &vec[44];
+    temp_o1 = &vec[56];
+    temp_e1 = &scratch_mem[0];
+
+    for (i = 4; i != 0; i--)
+    {
+        aux1        += aux3;
+        *(pt_vec++) = aux2 + aux1;
+        *(pt_vec++) = aux4 + aux1;
+
+        aux1        = *(temp_o1++);
+        aux3        += aux1;
+        aux2        = *(temp_e1++);
+        *(pt_vec++) = aux4 + aux3;
+        *(pt_vec++) = aux2 + aux3;
+
+        aux3        = *(temp_o1++);
+        aux4        = *(temp_e1++);
+    }
+
+    aux1       += aux3;
+    vec[60] = aux2 + aux1;
+    vec[61] = aux4 + aux1;
+    vec[62] = aux4 + aux3;
+
+}
+
+
+#endif
+
+/*----------------------------------------------------------------------------
+; pv_split
+----------------------------------------------------------------------------*/
+
+
+void pv_split(Int32 *temp_o)
+{
+
+    Int32 i;
+    const Int32 *pt_cosTerms = &CosTable_48[47];
+    Int32 *pt_temp_o = temp_o;
+    Int32 *pt_temp_e = pt_temp_o - 1;
+    Int32 tmp1;
+    Int32 tmp2;
+    Int32 cosx;
+
+    for (i = 8; i != 0; i--)
+    {
+        tmp2 = *(pt_temp_o);
+        tmp1 = *(pt_temp_e);
+        cosx = *(pt_cosTerms--);
+        *(pt_temp_e--) =   tmp1  + tmp2;
+        *(pt_temp_o++) = fxp_mul32_Q26((tmp1 - tmp2), cosx);
+        tmp1 = *(pt_temp_e);
+        tmp2 = *(pt_temp_o);
+        cosx = *(pt_cosTerms--);
+        *(pt_temp_e--) =   tmp1  + tmp2;
+        *(pt_temp_o++) = fxp_mul32_Q26((tmp1 - tmp2), cosx);
+    }
+}
+
+
+
+void pv_split_z(Int32 *vector)
+{
+    Int32 i;
+    Int32 *pt_vector     = &vector[31];
+    const Int32 *pt_cosTerms = &CosTable_48[32];
+    Int32 *pt_temp_e = vector;
+    Int32 tmp1;
+    Int32 tmp2;
+    Int32 cosx;
+
+    for (i = 8; i != 0; i--)
+    {
+        tmp1 = *(pt_vector);
+        tmp2 = *(pt_temp_e);
+        cosx = *(pt_cosTerms++);
+        *(pt_temp_e++) =   tmp1  + tmp2;
+        *(pt_vector--) = fxp_mul32_Q26((tmp1 - tmp2), cosx);
+        tmp2 = *(pt_temp_e);
+        tmp1 = *(pt_vector);
+        cosx = *(pt_cosTerms++);
+        *(pt_temp_e++) =   tmp1  + tmp2;
+        *(pt_vector--) = fxp_mul32_Q26((tmp1 - tmp2), cosx);
+    }
+}
+
+
+void pv_merge_in_place_N32(Int32 vec[])
+{
+
+    Int32 temp[4];
+
+    temp[0] = vec[14];
+    vec[14] = vec[ 7];
+    temp[1] = vec[12];
+    vec[12] = vec[ 6];
+    temp[2] = vec[10];
+    vec[10] = vec[ 5];
+    temp[3] = vec[ 8];
+    vec[ 8] = vec[ 4];
+    vec[ 6] = vec[ 3];
+    vec[ 4] = vec[ 2];
+    vec[ 2] = vec[ 1];
+
+    vec[ 1] = vec[16] + vec[17];
+    vec[16] = temp[3];
+    vec[ 3] = vec[18] + vec[17];
+    vec[ 5] = vec[19] + vec[18];
+    vec[18] = vec[9];
+    temp[3] = vec[11];
+
+    vec[ 7] = vec[20] + vec[19];
+    vec[ 9] = vec[21] + vec[20];
+    vec[20] = temp[2];
+    temp[2] = vec[13];
+    vec[11] = vec[22] + vec[21];
+    vec[13] = vec[23] + vec[22];
+    vec[22] = temp[3];
+    temp[3] = vec[15];
+    vec[15] = vec[24] + vec[23];
+    vec[17] = vec[25] + vec[24];
+    vec[19] = vec[26] + vec[25];
+    vec[21] = vec[27] + vec[26];
+    vec[23] = vec[28] + vec[27];
+    vec[25] = vec[29] + vec[28];
+    vec[27] = vec[30] + vec[29];
+    vec[29] = vec[30] + vec[31];
+    vec[24] = temp[1];
+    vec[26] = temp[2];
+    vec[28] = temp[0];
+    vec[30] = temp[3];
+}
+
+#endif
+
+
diff --git a/media/libstagefright/codecs/aacdec/dct64.h b/media/libstagefright/codecs/aacdec/dct64.h
new file mode 100644
index 0000000..3d5e82b
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/dct64.h
@@ -0,0 +1,81 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Pathname: ./c/include/dct64.h
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+ Who:                                       Date:
+ Description:
+------------------------------------------------------------------------------
+ INCLUDE DESCRIPTION
+
+------------------------------------------------------------------------------
+*/
+
+#ifndef DCT64_H
+#define DCT64_H
+
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+
+#include "pv_audio_type_defs.h"
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+    /*----------------------------------------------------------------------------
+    ; EXTERNAL VARIABLES REFERENCES
+    ----------------------------------------------------------------------------*/
+    extern const Int32 CosTable_48[48];
+
+    /*----------------------------------------------------------------------------
+    ; DEFINES AND SIMPLE TYPEDEF'S
+    ----------------------------------------------------------------------------*/
+
+    void pv_split_LC(Int32 *vector,
+                     Int32 *temp_o);
+
+
+#ifdef HQ_SBR
+
+    void dct_64(Int32 vec[], Int32 *scratch_mem);
+
+#endif
+
+    void pv_split(Int32 *temp_o);
+
+    void pv_split_z(Int32 *vector);
+
+    void pv_merge_in_place_N32(Int32 vec[]);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif  /* DCT64_H */
diff --git a/media/libstagefright/codecs/aacdec/decode_huff_cw_binary.cpp b/media/libstagefright/codecs/aacdec/decode_huff_cw_binary.cpp
new file mode 100644
index 0000000..0d1561b
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/decode_huff_cw_binary.cpp
@@ -0,0 +1,708 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Pathname: ./src/decode_huff_cw_binary.c
+ Funtions:
+    decode_huff_cw_tab1
+    decode_huff_cw_tab2
+    decode_huff_cw_tab3
+    decode_huff_cw_tab4
+    decode_huff_cw_tab5
+    decode_huff_cw_tab6
+    decode_huff_cw_tab7
+    decode_huff_cw_tab8
+    decode_huff_cw_tab9
+    decode_huff_cw_tab10
+    decode_huff_cw_tab11
+    decode_huff_cw_scl
+
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+ Description: Updated per review comments
+              (1) make cw sgined and change "if(cw&0x80000000)" to if(cw<0)
+              (2)
+
+ Description: Create specific functions for different huffman tables.
+
+
+ Description: Added ( Int16) castings to eliminate several compiler warnings
+
+
+ Description: Modified huffman tables to allocate int32 variables instead of
+              int16, which lead to data missaligned for some compiler.
+              Eliminated casting and unused variables
+
+
+ Who:                                   Date:
+ Description:
+
+------------------------------------------------------------------------------
+ INPUT AND OUTPUT DEFINITIONS
+
+ Inputs:
+    BITS          *pInputStream = pointer to input bit stream
+
+ Local Stores/Buffers/Pointers Needed:
+
+
+ Global Stores/Buffers/Pointers Needed:
+
+
+ Outputs:
+    idx = bit field extracted from a leaf entry of packed Huffman Tables
+
+ Pointers and Buffers Modified:
+
+ Local Stores Modified:
+
+ Global Stores Modified:
+
+
+------------------------------------------------------------------------------
+ FUNCTION DESCRIPTION
+
+   These functions are used to decode huffman codewords from the input
+   bitstream using combined binary search and look-up table approach.
+
+   First the codewords are grouped and the input symbol is determined
+   which group it belongs. Then within that group, a look-up table is
+   used to determine which codeword the symbol is.
+   The table is created by ordering the codeword in the table according to their
+   normalized shifted binary value, i.e., all the codewords are left
+   shifted to meet the maximum codelength. Example, max codelength is
+   10, the codeword with lenth 3 will left shift by 7.
+   The binary values of after the shift are sorted.
+   Then the sorted table is divided into several partition.
+   At the VLC decoding period, input is read in at max codelenght.
+   The partition is decided using if-else logic.
+   Inside each partition, a look-up table is used to map the input value
+   to a correct symbol. Table entries can appear to be repeated according
+   to the humming distance between adjacent codewords.
+
+------------------------------------------------------------------------------
+ REQUIREMENTS
+
+
+------------------------------------------------------------------------------
+ REFERENCES
+
+ (1) MPEG-2 NBC Audio Decoder
+   "This software module was originally developed by AT&T, Dolby
+   Laboratories, Fraunhofer Gesellschaft IIS in the course of development
+   of the MPEG-2 NBC/MPEG-4 Audio standard ISO/IEC 13818-7, 14496-1,2 and
+   3. This software module is an implementation of a part of one or more
+   MPEG-2 NBC/MPEG-4 Audio tools as specified by the MPEG-2 NBC/MPEG-4
+   Audio standard. ISO/IEC  gives users of the MPEG-2 NBC/MPEG-4 Audio
+   standards free license to this software module or modifications thereof
+   for use in hardware or software products claiming conformance to the
+   MPEG-2 NBC/MPEG-4 Audio  standards. Those intending to use this software
+   module in hardware or software products are advised that this use may
+   infringe existing patents. The original developer of this software
+   module and his/her company, the subsequent editors and their companies,
+   and ISO/IEC have no liability for use of this software module or
+   modifications thereof in an implementation. Copyright is not released
+   for non MPEG-2 NBC/MPEG-4 Audio conforming products.The original
+   developer retains full right to use the code for his/her own purpose,
+   assign or donate the code to a third party and to inhibit third party
+   from using the code for non MPEG-2 NBC/MPEG-4 Audio conforming products.
+   This copyright notice must be included in all copies or derivative
+   works."
+   Copyright(c)1996.
+
+ (2) Introduction to Algorithms,
+     Thomas H. Cormen, Charles E. Leiserson, Ronald L. Rivest.
+     The MIT press, 1990
+
+ (3) "Selecting an Optimal Huffman Decoder for AAC",
+     Vladimir Z. Mesarovic, et al.
+     AES 111th Convention, September 21-24, 2001, New York, USA
+
+------------------------------------------------------------------------------
+ PSEUDO-CODE
+
+
+------------------------------------------------------------------------------
+ RESOURCES USED
+   When the code is written for a specific target processor the
+     the resources used should be documented below.
+
+ STACK USAGE:
+
+ DATA MEMORY USED: x words
+
+ PROGRAM MEMORY USED: x words
+
+ CLOCK CYCLES:
+
+
+------------------------------------------------------------------------------
+*/
+
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+#include    "pv_audio_type_defs.h"
+#include    "huffman.h"
+
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here. Include conditional
+; compile variables also.
+----------------------------------------------------------------------------*/
+#define    MAX_CW_LEN  (19)
+#define    MASK_IDX    (0x1FF)
+#define    MASK_RIGHT  (0xFE00)
+
+#define    UPPER16      (16)
+#define    MASK_LOW16   (0xFFFF)
+/*----------------------------------------------------------------------------
+; LOCAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+
+
+/*----------------------------------------------------------------------------
+; LOCAL STORE/BUFFER/POINTER DEFINITIONS
+; Variable declaration - defined here and used outside this module
+----------------------------------------------------------------------------*/
+
+
+/*----------------------------------------------------------------------------
+; EXTERNAL FUNCTION REFERENCES
+; Declare functions defined elsewhere and referenced in this module
+----------------------------------------------------------------------------*/
+
+
+/*----------------------------------------------------------------------------
+; EXTERNAL GLOBAL STORE/BUFFER/POINTER REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; FUNCTION CODE
+----------------------------------------------------------------------------*/
+
+Int decode_huff_cw_tab1(
+    BITS          *pInputStream)
+{
+    Int32  tab;
+    Int32  cw;
+
+    cw  = get17_n_lessbits(
+              11,
+              pInputStream);
+    if ((cw >> 10) == 0)
+    {
+        pInputStream->usedBits -= (11 - 1);
+        return 40; /* idx is 40 */
+    }
+    else if ((cw >> 6) <= 23)
+    {
+        tab = (cw >> 6) - 16;
+    }
+    else if ((cw >> 4) <= 119)
+    {
+        tab = (cw >> 4) - 96 + 8;
+    }
+    else if ((cw >> 2) <= 503)
+    {
+        tab = (cw >> 2) - 480 + 32;
+    }
+    else
+    {
+        tab = cw - 2016 + 56;
+    }
+
+    tab = *(huff_tab1 + tab);
+
+    pInputStream->usedBits -= (11 - (tab & MASK_LOW16));
+    return ((Int)(tab >> UPPER16));
+}
+
+
+Int decode_huff_cw_tab2(
+    BITS          *pInputStream)
+{
+    Int32  tab;
+    Int32  cw;
+
+    cw  = get9_n_lessbits(
+              9,
+              pInputStream);
+    if ((cw >> 6) == 0)
+    {
+        pInputStream->usedBits -= (9 - 3); /* used 3 bits */
+        return 40; /* idx is 40 */
+    }
+    else if ((cw >> 3) <= 49)
+    {
+        tab = (cw >> 3) - 8;
+    }
+    else if ((cw >> 2) <= 114)
+    {
+        tab = (cw >> 2) - 100 + 42;
+    }
+    else if ((cw >> 1) <= 248)
+    {
+        tab = (cw >> 1) - 230 + 57;
+    }
+    else
+    {
+        tab = cw - 498 + 76;
+    }
+
+    tab = *(huff_tab2 + tab);
+
+    pInputStream->usedBits -= (9 - (tab & MASK_LOW16));
+    return ((Int)(tab >> UPPER16));
+}
+
+
+Int decode_huff_cw_tab3(
+    BITS          *pInputStream)
+{
+    Int32  tab;
+    Int32  cw;
+
+    cw  = get17_n_lessbits(
+              16,
+              pInputStream);
+    if ((cw >> 15) == 0)
+    {
+        pInputStream->usedBits -= (16 - 1); /* used 1 bits */
+        return 0; /* idx is 0 */
+    }
+    else if ((cw >> 10) <= 57)
+    {
+        tab = (cw >> 10) - 32;
+    }
+    else if ((cw >> 7) <= 500)
+    {
+        tab = (cw >> 7) - 464 + 26;
+    }
+    else if ((cw >> 6) <= 1016)
+    {
+        tab = (cw >> 6) - 1002 + 63;
+    }
+    else if ((cw >> 4) <= 4092)
+    {
+        tab = (cw >> 4) - 4068 + 78;
+    }
+    else
+    {
+        tab = cw - 65488 + 103;
+    }
+
+    tab = *(huff_tab3 + tab);
+
+    pInputStream->usedBits -= (16 - (tab & MASK_LOW16));
+    return ((Int)(tab >> UPPER16));
+}
+
+
+Int decode_huff_cw_tab4(
+    BITS          *pInputStream)
+{
+    Int32  tab;
+    Int32  cw;
+
+    cw  = get17_n_lessbits(
+              12,
+              pInputStream);
+
+    if ((cw >> 7) <= 25)
+    {
+        tab = (cw >> 7);
+    }
+    else if ((cw >> 4) <= 246)
+    {
+        tab = (cw >> 4) - 208 + 26;
+    }
+    else if ((cw >> 2) <= 1017)
+    {
+        tab = (cw >> 2) - 988 + 65;
+    }
+    else
+    {
+        tab = cw - 4072 + 95;
+    }
+
+    tab = *(huff_tab4 + tab);
+
+    pInputStream->usedBits -= (12 - (tab & MASK_LOW16));
+    return ((Int)(tab >> UPPER16));
+}
+
+
+
+Int decode_huff_cw_tab5(
+    BITS          *pInputStream)
+{
+    Int32  tab;
+    Int32  cw;
+
+    cw  = get17_n_lessbits(
+              13,
+              pInputStream);
+
+    if ((cw >> 12) == 0)
+    {
+        pInputStream->usedBits -= (13 - 1); /* used 1 bits */
+        return 40; /* idx is 40 */
+    }
+    else if ((cw >> 8) <= 27)
+    {
+        tab = (cw >> 8) - 16;
+    }
+    else if ((cw >> 5) <= 243)
+    {
+        tab = (cw >> 5) - 224 + 12;
+    }
+    else if ((cw >> 3) <= 1011)
+    {
+        tab = (cw >> 3) - 976 + 32;
+    }
+    else if ((cw >> 2) <= 2041)
+    {
+        tab = (cw >> 2) - 2024 + 68;
+    }
+    else
+    {
+        tab = cw - 8168 + 86;
+    }
+
+    tab = *(huff_tab5 + tab);
+
+    pInputStream->usedBits -= (13 - (tab & MASK_LOW16));
+    return ((Int)(tab >> UPPER16));
+}
+
+
+
+Int decode_huff_cw_tab6(
+    BITS          *pInputStream)
+{
+    Int32  tab;
+    Int32  cw;
+
+    cw  = get17_n_lessbits(
+              11,
+              pInputStream);
+
+    if ((cw >> 7) <= 8)
+    {
+        tab = (cw >> 7);
+    }
+    else if ((cw >> 4) <= 116)
+    {
+        tab = (cw >> 4) - 72 + 9;
+    }
+    else if ((cw >> 2) <= 506)
+    {
+        tab = (cw >> 2) - 468 + 54;
+    }
+    else
+    {
+        tab = cw - 2028 + 93;
+    }
+
+    tab = *(huff_tab6 + tab);
+
+    pInputStream->usedBits -= (11 - (tab & MASK_LOW16));
+    return ((Int)(tab >> UPPER16));
+}
+
+
+
+Int decode_huff_cw_tab7(
+    BITS          *pInputStream)
+{
+    Int32  tab;
+    Int32  cw;
+
+    cw  = get17_n_lessbits(
+              12,
+              pInputStream);
+
+    if ((cw >> 11) == 0)
+    {
+        pInputStream->usedBits -= (12 - 1); /* used 1 bits */
+        return 0; /* idx is 0 */
+    }
+    else if ((cw >> 6) <= 55)
+    {
+        tab = (cw >> 6) - 32;
+    }
+    else if ((cw >> 4) <= 243)
+    {
+        tab = (cw >> 4) - 224 + 24;
+    }
+    else if ((cw >> 2) <= 1018)
+    {
+        tab = (cw >> 2) - 976 + 44;
+    }
+    else
+    {
+        tab = cw - 4076 + 87;
+    }
+
+    tab = *(huff_tab7 + tab);
+
+    pInputStream->usedBits -= (12 - (tab & MASK_LOW16));
+    return ((Int)(tab >> UPPER16));
+}
+
+
+
+Int decode_huff_cw_tab8(
+    BITS          *pInputStream)
+{
+    Int32  tab;
+    Int32  cw;
+
+    cw  = get17_n_lessbits(
+              10,
+              pInputStream);
+
+    if ((cw >> 5) <= 20)
+    {
+        tab = (cw >> 5);
+    }
+    else if ((cw >> 3) <= 117)
+    {
+        tab = (cw >> 3) - 84 + 21;
+    }
+    else if ((cw >> 2) <= 250)
+    {
+        tab = (cw >> 2) - 236 + 55;
+    }
+    else
+    {
+        tab = cw - 1004 + 70;
+    }
+
+    tab = *(huff_tab8 + tab);
+
+    pInputStream->usedBits -= (10 - (tab & MASK_LOW16));
+    return ((Int)(tab >> UPPER16));
+}
+
+
+Int decode_huff_cw_tab9(
+    BITS          *pInputStream)
+{
+    Int32  tab;
+    Int32  cw;
+
+    cw  = get17_n_lessbits(
+              15,
+              pInputStream);
+
+    if ((cw >> 11) <= 12)
+    {
+        tab = (cw >> 11);
+    }
+    else if ((cw >> 8) <= 114)
+    {
+        tab = (cw >> 8) - 104 + 13;
+    }
+    else if ((cw >> 6) <= 486)
+    {
+        tab = (cw >> 6) - 460 + 24;
+    }
+    else if ((cw >> 5) <= 993)
+    {
+        tab = (cw >> 5) - 974 + 51;
+    }
+    else if ((cw >> 4) <= 2018)
+    {
+        tab = (cw >> 4) - 1988 + 71;
+    }
+    else if ((cw >> 3) <= 4075)
+    {
+        tab = (cw >> 3) - 4038 + 102;
+    }
+    else if ((cw >> 2) <= 8183)
+    {
+        tab = (cw >> 2) - 8152 + 140;
+    }
+    else
+    {
+        tab = cw - 32736 + 172;
+    }
+
+    tab = *(huff_tab9 + tab);
+
+    pInputStream->usedBits -= (15 - (tab & MASK_LOW16));
+    return ((Int)(tab >> UPPER16));
+}
+
+
+Int decode_huff_cw_tab10(
+    BITS          *pInputStream)
+{
+    Int32  tab;
+    Int32  cw;
+
+    cw  = get17_n_lessbits(
+              12,
+              pInputStream);
+
+    if ((cw >> 6) <= 41)
+    {
+        tab = (cw >> 6);
+    }
+    else if ((cw >> 5) <= 100)
+    {
+        tab = (cw >> 5) - 84 + 42;
+    }
+    else if ((cw >> 4) <= 226)
+    {
+        tab = (cw >> 4) - 202 + 59;
+    }
+    else if ((cw >> 3) <= 484)
+    {
+        tab = (cw >> 3) - 454 + 84;
+    }
+    else if ((cw >> 2) <= 1010)
+    {
+        tab = (cw >> 2) - 970 + 115;
+    }
+    else if ((cw >> 1) <= 2043)
+    {
+        tab = (cw >> 1) - 2022 + 156;
+    }
+    else
+    {
+        tab = cw - 4088 + 178;
+    }
+
+    tab = *(huff_tab10 + tab);
+
+    pInputStream->usedBits -= (12 - (tab & MASK_LOW16));
+    return ((Int)(tab >> UPPER16));
+}
+
+
+Int decode_huff_cw_tab11(
+    BITS          *pInputStream)
+{
+    Int32  tab;
+    Int32  cw;
+
+    cw  = get17_n_lessbits(
+              12,
+              pInputStream);
+
+    if ((cw >> 6) <= 26)
+    {
+        tab = (cw >> 6);
+    }
+    else if ((cw >> 5) <= 69)
+    {
+        tab = (cw >> 5) - 54 + 27;
+    }
+    else if ((cw >> 4) <= 198)
+    {
+        tab = (cw >> 4) - 140 + 43;
+    }
+    else if ((cw >> 3) <= 452)
+    {
+        tab = (cw >> 3) - 398 + 102;
+    }
+    else if ((cw >> 2) <= 1000)
+    {
+        tab = (cw >> 2) - 906 + 157;
+    }
+    else if ((cw >> 1) <= 2044)
+    {
+        tab = (cw >> 1) - 2002 + 252;
+    }
+    else
+    {
+        tab = cw - 4090 + 295;
+    }
+
+    tab = *(huff_tab11 + tab);
+
+    pInputStream->usedBits -= (12 - (tab & MASK_LOW16));
+    return ((Int)(tab >> UPPER16));
+}
+
+
+Int decode_huff_scl(
+    BITS          *pInputStream)
+{
+    Int32  tab;
+    Int32  cw;
+
+    cw  = getbits(
+              19,
+              pInputStream);
+
+    if ((cw >> 18) == 0)
+    {
+        pInputStream->usedBits -= (19 - 1); /* used 1 bits */
+        return 60; /* idx is 60 */
+    }
+    else if ((cw >> 13) <= 59)
+    {
+        tab = (cw >> 13) - 32;
+    }
+    else if ((cw >> 10) <= 505)
+    {
+        tab = (cw >> 10) - 480 + 28;
+    }
+    else if ((cw >> 7) <= 4089)
+    {
+        tab = (cw >> 7) - 4048 + 54;
+    }
+    else if ((cw >> 5) <= 16377)
+    {
+        tab = (cw >> 5) - 16360 + 96;
+    }
+    else if ((cw >> 3) <= 65526)
+    {
+        tab = (cw >> 3) - 65512 + 114;
+    }
+    else if ((cw >> 1) <= 262120)
+    {
+        tab = (cw >> 1) - 262108 + 129;
+    }
+    else
+    {
+        tab = cw - 524242 + 142;
+    }
+
+    tab = *(huff_tab_scl + tab);
+
+    pInputStream->usedBits -= (19 - (tab & MASK_LOW16));
+    return ((Int)(tab >> UPPER16));
+}
+
diff --git a/media/libstagefright/codecs/aacdec/decode_noise_floorlevels.cpp b/media/libstagefright/codecs/aacdec/decode_noise_floorlevels.cpp
new file mode 100644
index 0000000..41cd187
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/decode_noise_floorlevels.cpp
@@ -0,0 +1,163 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Filename: decode_noise_floorlevels.c
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+
+ Who:                                   Date: MM/DD/YYYY
+ Description:
+
+------------------------------------------------------------------------------
+ INPUT AND OUTPUT DEFINITIONS
+
+
+
+------------------------------------------------------------------------------
+ FUNCTION DESCRIPTION
+
+
+------------------------------------------------------------------------------
+ REQUIREMENTS
+
+
+------------------------------------------------------------------------------
+ REFERENCES
+
+SC 29 Software Copyright Licencing Disclaimer:
+
+This software module was originally developed by
+  Coding Technologies
+
+and edited by
+  -
+
+in the course of development of the ISO/IEC 13818-7 and ISO/IEC 14496-3
+standards for reference purposes and its performance may not have been
+optimized. This software module is an implementation of one or more tools as
+specified by the ISO/IEC 13818-7 and ISO/IEC 14496-3 standards.
+ISO/IEC gives users free license to this software module or modifications
+thereof for use in products claiming conformance to audiovisual and
+image-coding related ITU Recommendations and/or ISO/IEC International
+Standards. ISO/IEC gives users the same free license to this software module or
+modifications thereof for research purposes and further ISO/IEC standardisation.
+Those intending to use this software module in products are advised that its
+use may infringe existing patents. ISO/IEC have no liability for use of this
+software module or modifications thereof. Copyright is not released for
+products that do not conform to audiovisual and image-coding related ITU
+Recommendations and/or ISO/IEC International Standards.
+The original developer retains full right to modify and use the code for its
+own purpose, assign or donate the code to a third party and to inhibit third
+parties from using the code for products that do not conform to audiovisual and
+image-coding related ITU Recommendations and/or ISO/IEC International Standards.
+This copyright notice must be included in all copies or derivative works.
+Copyright (c) ISO/IEC 2002.
+
+------------------------------------------------------------------------------
+ PSEUDO-CODE
+
+------------------------------------------------------------------------------
+*/
+
+#ifdef AAC_PLUS
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+#include    "decode_noise_floorlevels.h"
+#include    "sbr_constants.h"
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here. Include conditional
+; compile variables also.
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; LOCAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; LOCAL STORE/BUFFER/POINTER DEFINITIONS
+; Variable declaration - defined here and used outside this module
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL FUNCTION REFERENCES
+; Declare functions defined elsewhere and referenced in this module
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL GLOBAL STORE/BUFFER/POINTER REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; FUNCTION CODE
+----------------------------------------------------------------------------*/
+
+void decode_noise_floorlevels(SBR_FRAME_DATA * hFrameData)
+
+{
+    Int32 env;
+    Int32 i;
+
+    Int32 * frameInfo           = hFrameData->frameInfo;
+    Int32   nNfb                = hFrameData->nNfb;
+    Int32 * domain_vec          = hFrameData->domain_vec2;
+
+    Int32 * sbrNoiseFloorLevel_man = hFrameData->sbrNoiseFloorLevel_man;
+    Int32 * prevNoiseLevel_man     = hFrameData->prevNoiseLevel_man;
+
+    Int32 nEnv = frameInfo[(frameInfo[0] << 1) + 3];
+
+    for (env = 0; env < nEnv; env++)
+    {
+        if (domain_vec[env] == 0)
+        {
+            prevNoiseLevel_man[0] = *(sbrNoiseFloorLevel_man++);
+
+            for (i = 1; i < nNfb; i++)
+            {
+                *sbrNoiseFloorLevel_man += *(sbrNoiseFloorLevel_man - 1);
+                prevNoiseLevel_man[i] = *(sbrNoiseFloorLevel_man++);
+            }
+        }
+        else
+        {
+            for (i = 0; i < nNfb; i++)
+            {
+                *sbrNoiseFloorLevel_man += prevNoiseLevel_man[i];
+                prevNoiseLevel_man[i] = *(sbrNoiseFloorLevel_man++);
+            }
+        }
+
+    }
+}
+
+#endif
diff --git a/media/libstagefright/codecs/aacdec/decode_noise_floorlevels.h b/media/libstagefright/codecs/aacdec/decode_noise_floorlevels.h
new file mode 100644
index 0000000..a9c3551
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/decode_noise_floorlevels.h
@@ -0,0 +1,92 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Filename: decode_noise_floorlevels.h
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+
+ Who:                                   Date: MM/DD/YYYY
+ Description:
+------------------------------------------------------------------------------
+
+
+----------------------------------------------------------------------------
+; CONTINUE ONLY IF NOT ALREADY DEFINED
+----------------------------------------------------------------------------*/
+#ifndef DECODENOISEFLOORLEVELS_H
+#define DECODENOISEFLOORLEVELS_H
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+#include    "pv_audio_type_defs.h"
+#include    "s_sbr_frame_data.h"
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here.
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL VARIABLES REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; SIMPLE TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; ENUMERATED TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; STRUCTURES TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+
+/*----------------------------------------------------------------------------
+; GLOBAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+    void decode_noise_floorlevels(SBR_FRAME_DATA * hFrameData);
+
+#ifdef __cplusplus
+}
+#endif
+
+/*----------------------------------------------------------------------------
+; END
+----------------------------------------------------------------------------*/
+#endif
+
+
diff --git a/media/libstagefright/codecs/aacdec/deinterleave.cpp b/media/libstagefright/codecs/aacdec/deinterleave.cpp
new file mode 100644
index 0000000..5298b19
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/deinterleave.cpp
@@ -0,0 +1,287 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Pathname: ./src/deinterleave.c
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+ Description:  Modified from original shareware code
+
+ Description: (1) Modified with new template, rename variables
+              (2) Removed for-loop to calculate win_inc, win_inc = SN2 (128)
+              (3) Replaced for-loop with memcpy
+              (4) Converted Int16 -> Int
+
+ Description: Modified per review comments
+
+ Who:                       Date:
+ Description:
+
+------------------------------------------------------------------------------
+ INPUT AND OUTPUT DEFINITIONS
+
+ Inputs:
+    interleaved   = input array that contains interleaved coefficients
+                    Data Type Int
+
+    deinterleaved = output array that will be updated with de-interleaved
+                    coefficients of input array. Data Type Int
+
+    pFrameInfo = pointer to structure that holds information of current
+                 frame. Data Type FrameInfo
+
+ Local Stores/Buffers/Pointers Needed:
+    None
+
+ Global Stores/Buffers/Pointers Needed:
+    None
+
+ Outputs:
+    None
+
+ Pointers and Buffers Modified:
+    deinterleaved  contents updated with de-interleaved coefficients from
+                   the input array: interleaved
+
+ Local Stores Modified:
+    None
+
+ Global Stores Modified:
+    None
+
+------------------------------------------------------------------------------
+ FUNCTION DESCRIPTION
+
+ This function performs the deinterleaving across all short windows in
+ each group
+
+------------------------------------------------------------------------------
+ REQUIREMENTS
+
+ This function should replace the contents of pDeinterleaved with the
+ de-interleaved 1024 coefficients of one frame
+
+------------------------------------------------------------------------------
+ REFERENCES
+
+ (1) MPEG-2 NBC Audio Decoder
+   "This software module was originally developed by AT&T, Dolby
+   Laboratories, Fraunhofer Gesellschaft IIS in the course of development
+   of the MPEG-2 NBC/MPEG-4 Audio standard ISO/IEC 13818-7, 14496-1,2 and
+   3. This software module is an implementation of a part of one or more
+   MPEG-2 NBC/MPEG-4 Audio tools as specified by the MPEG-2 NBC/MPEG-4
+   Audio standard. ISO/IEC  gives users of the MPEG-2 NBC/MPEG-4 Audio
+   standards free license to this software module or modifications thereof
+   for use in hardware or software products claiming conformance to the
+   MPEG-2 NBC/MPEG-4 Audio  standards. Those intending to use this software
+   module in hardware or software products are advised that this use may
+   infringe existing patents. The original developer of this software
+   module and his/her company, the subsequent editors and their companies,
+   and ISO/IEC have no liability for use of this software module or
+   modifications thereof in an implementation. Copyright is not released
+   for non MPEG-2 NBC/MPEG-4 Audio conforming products.The original
+   developer retains full right to use the code for his/her own purpose,
+   assign or donate the code to a third party and to inhibit third party
+   from using the code for non MPEG-2 NBC/MPEG-4 Audio conforming products.
+   This copyright notice must be included in all copies or derivative
+   works."
+   Copyright(c)1996.
+
+ (2) ISO/IEC 14496-3: 1999(E)
+    Subpart 4           p78     quant_to_spec
+
+------------------------------------------------------------------------------
+ PSEUDO-CODE
+
+    pInterleaved   = interleaved;
+    pDeinterleaved = deinterleaved;
+
+    pSfbPerWin  = pFrameInfo->sfb_per_win;
+    ngroups     = pFrameInfo->num_groups;
+    pGroupLen   = pFrameInfo->group_len;
+
+    pGroup = pDeinterleaved;
+
+    FOR (group = ngroups; group > 0; group--)
+
+        pSfbWidth   = pFrameInfo->sfb_width_128;
+        sfb_inc = 0;
+        pStart = pInterleaved;
+
+        FOR (sfb = pSfbPerWin[ngroups-group]; sfb > 0; sfb--)
+
+            pWin = pGroup;
+
+            FOR (win = pGroupLen[ngroups-group]; win > 0; win--)
+
+                pDeinterleaved = pWin + sfb_inc;
+
+                pv_memcpy(
+                     pDeinterleaved,
+                     pInterleaved,
+                    *pSfbWidth*sizeof(*pInterleaved));
+
+                pInterleaved += *pSfbWidth;
+
+                pWin += SN2;
+
+            ENDFOR (win)
+
+            sfb_inc += *pSfbWidth++;
+
+        ENDFOR (sfb)
+
+    pGroup += (pInterleaved - pStart);
+
+    ENDFOR (group)
+
+------------------------------------------------------------------------------
+ RESOURCES USED
+   When the code is written for a specific target processor the
+     the resources used should be documented below.
+
+ STACK USAGE: [stack count for this module] + [variable to represent
+          stack usage for each subroutine called]
+
+     where: [stack usage variable] = stack usage for [subroutine
+         name] (see [filename].ext)
+
+ DATA MEMORY USED: x words
+
+ PROGRAM MEMORY USED: x words
+
+ CLOCK CYCLES: [cycle count equation for this module] + [variable
+           used to represent cycle count for each subroutine
+           called]
+
+     where: [cycle count variable] = cycle count for [subroutine
+        name] (see [filename].ext)
+
+------------------------------------------------------------------------------
+*/
+
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+#include    "pv_audio_type_defs.h"
+#include    "huffman.h"
+#include    "aac_mem_funcs.h"
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here. Include conditional
+; compile variables also.
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; LOCAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; LOCAL STORE/BUFFER/POINTER DEFINITIONS
+; Variable declaration - defined here and used outside this module
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL FUNCTION REFERENCES
+; Declare functions defined elsewhere and referenced in this module
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL GLOBAL STORE/BUFFER/POINTER REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; FUNCTION CODE
+----------------------------------------------------------------------------*/
+void deinterleave(
+    Int16        interleaved[],
+    Int16        deinterleaved[],
+    FrameInfo   *pFrameInfo)
+{
+
+    Int      group;  /* group index */
+    Int      sfb;    /* scalefactor band index */
+    Int      win;    /* window index */
+    Int16    *pGroup;
+    Int16    *pWin;
+    Int16    *pStart;
+    Int16    *pInterleaved;
+    Int16    *pDeinterleaved;
+    Int      sfb_inc;
+
+    Int      ngroups;
+    Int     *pGroupLen;
+    Int     *pSfbPerWin;
+    Int     *pSfbWidth;
+
+    pInterleaved   = interleaved;
+    pDeinterleaved = deinterleaved;
+
+    pSfbPerWin  = pFrameInfo->sfb_per_win;
+    ngroups     = pFrameInfo->num_groups;
+    pGroupLen   = pFrameInfo->group_len;
+
+    pGroup = pDeinterleaved;
+
+    for (group = ngroups; group > 0; group--)
+    {
+        pSfbWidth   = pFrameInfo->sfb_width_128;
+        sfb_inc = 0;
+        pStart = pInterleaved;
+
+        /* Perform the deinterleaving across all windows in a group */
+
+        for (sfb = pSfbPerWin[ngroups-group]; sfb > 0; sfb--)
+        {
+            pWin = pGroup;
+
+            for (win = pGroupLen[ngroups-group]; win > 0; win--)
+            {
+                pDeinterleaved = pWin + sfb_inc;
+
+                pv_memcpy(
+                    pDeinterleaved,
+                    pInterleaved,
+                    *pSfbWidth*sizeof(*pInterleaved));
+
+                pInterleaved += *pSfbWidth;
+
+                pWin += SN2;
+
+            } /* for (win) */
+
+            sfb_inc += *pSfbWidth++;
+
+        } /* for (sfb) */
+
+        pGroup += (pInterleaved - pStart);
+
+    } /* for (group) */
+
+} /* deinterleave */
diff --git a/media/libstagefright/codecs/aacdec/digit_reversal_tables.cpp b/media/libstagefright/codecs/aacdec/digit_reversal_tables.cpp
new file mode 100644
index 0000000..ffa980d
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/digit_reversal_tables.cpp
@@ -0,0 +1,279 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Pathname: ./src/digit_reversal_tables.c
+ Funtions:
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+ Who:                       Date:
+ Description:
+
+  ------------------------------------------------------------------------------
+ MODULE DESCRIPTION
+
+  Tables for digit reverse operation
+
+------------------------------------------------------------------------------
+*/
+
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+
+#include "digit_reversal_tables.h"
+#include "imdct_fxp.h"
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here. Include conditional
+; compile variables also.
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; LOCAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; LOCAL VARIABLE DEFINITIONS
+; Variable declaration - defined here and used outside this module
+----------------------------------------------------------------------------*/
+
+
+/*----------------------------------------------------------------------------
+; EXTERNAL FUNCTION REFERENCES
+; Declare functions defined elsewhere and referenced in this module
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL VARIABLES REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+/*
+------------------------------------------------------------------------------
+ Digit Reverse tables
+------------------------------------------------------------------------------
+*/
+
+const Int16 digit_reverse_64[ 64] =
+{
+    + 0,  + 32,  + 64,  + 96,
+    + 8,  + 40,  + 72, + 104,
+    + 16,  + 48,  + 80, + 112,
+    + 24,  + 56,  + 88, + 120,
+    + 2,  + 34,  + 66,  + 98,
+    + 10,  + 42,  + 74, + 106,
+    + 18,  + 50,  + 82, + 114,
+    + 26,  + 58,  + 90, + 122,
+    + 4,  + 36,  + 68, + 100,
+    + 12,  + 44,  + 76, + 108,
+    + 20,  + 52,  + 84, + 116,
+    + 28,  + 60,  + 92, + 124,
+    + 6,  + 38,  + 70, + 102,
+    + 14,  + 46,  + 78, + 110,
+    + 22,  + 54,  + 86, + 118,
+    + 30,  + 62,  + 94, + 126
+};
+
+
+const Int16 digit_reverse_256[ 256] =
+{
+    + 0, + 128, + 256, + 384,
+    + 32, + 160, + 288, + 416,
+    + 64, + 192, + 320, + 448,
+    + 96, + 224, + 352, + 480,
+    + 8, + 136, + 264, + 392,
+    + 40, + 168, + 296, + 424,
+    + 72, + 200, + 328, + 456,
+    + 104, + 232, + 360, + 488,
+    + 16, + 144, + 272, + 400,
+    + 48, + 176, + 304, + 432,
+    + 80, + 208, + 336, + 464,
+    + 112, + 240, + 368, + 496,
+    + 24, + 152, + 280, + 408,
+    + 56, + 184, + 312, + 440,
+    + 88, + 216, + 344, + 472,
+    + 120, + 248, + 376, + 504,
+    + 2, + 130, + 258, + 386,
+    + 34, + 162, + 290, + 418,
+    + 66, + 194, + 322, + 450,
+    + 98, + 226, + 354, + 482,
+    + 10, + 138, + 266, + 394,
+    + 42, + 170, + 298, + 426,
+    + 74, + 202, + 330, + 458,
+    + 106, + 234, + 362, + 490,
+    + 18, + 146, + 274, + 402,
+    + 50, + 178, + 306, + 434,
+    + 82, + 210, + 338, + 466,
+    + 114, + 242, + 370, + 498,
+    + 26, + 154, + 282, + 410,
+    + 58, + 186, + 314, + 442,
+    + 90, + 218, + 346, + 474,
+    + 122, + 250, + 378, + 506,
+    + 4, + 132, + 260, + 388,
+    + 36, + 164, + 292, + 420,
+    + 68, + 196, + 324, + 452,
+    + 100, + 228, + 356, + 484,
+    + 12, + 140, + 268, + 396,
+    + 44, + 172, + 300, + 428,
+    + 76, + 204, + 332, + 460,
+    + 108, + 236, + 364, + 492,
+    + 20, + 148, + 276, + 404,
+    + 52, + 180, + 308, + 436,
+    + 84, + 212, + 340, + 468,
+    + 116, + 244, + 372, + 500,
+    + 28, + 156, + 284, + 412,
+    + 60, + 188, + 316, + 444,
+    + 92, + 220, + 348, + 476,
+    + 124, + 252, + 380, + 508,
+    + 6, + 134, + 262, + 390,
+    + 38, + 166, + 294, + 422,
+    + 70, + 198, + 326, + 454,
+    + 102, + 230, + 358, + 486,
+    + 14, + 142, + 270, + 398,
+    + 46, + 174, + 302, + 430,
+    + 78, + 206, + 334, + 462,
+    + 110, + 238, + 366, + 494,
+    + 22, + 150, + 278, + 406,
+    + 54, + 182, + 310, + 438,
+    + 86, + 214, + 342, + 470,
+    + 118, + 246, + 374, + 502,
+    + 30, + 158, + 286, + 414,
+    + 62, + 190, + 318, + 446,
+    + 94, + 222, + 350, + 478,
+    + 126, + 254, + 382, + 510
+};
+
+
+
+
+const Int16 digit_reverse_swap_256[ 241] =
+{
+    + 2, + 128,   + 4, + 256,
+    + 6, + 384,   + 8,  + 32,
+    + 10, + 160,  + 12, + 288,
+    + 14, + 416,  + 16,  + 64,
+    + 18, + 192,  + 20, + 320,
+    + 22, + 448,  + 24,  + 96,
+    + 26, + 224,  + 28, + 352,
+    + 30, + 480,  + 34, + 136,
+    + 36, + 264,  + 38, + 392,
+    + 42, + 168,  + 44, + 296,
+    + 46, + 424,  + 48,  + 72,
+    + 50, + 200,  + 52, + 328,
+    + 54, + 456,  + 56, + 104,
+    + 58, + 232,  + 60, + 360,
+    + 62, + 488,  + 66, + 144,
+    + 68, + 272,  + 70, + 400,
+    + 74, + 176,  + 76, + 304,
+    + 78, + 432,  + 82, + 208,
+    + 84, + 336,  + 86, + 464,
+    + 88, + 112,  + 90, + 240,
+    + 92, + 368,  + 94, + 496,
+    + 98, + 152, + 100, + 280,
+    + 102, + 408, + 106, + 184,
+    + 108, + 312, + 110, + 440,
+    + 114, + 216, + 116, + 344,
+    + 118, + 472, + 122, + 248,
+    + 124, + 376, + 126, + 504,
+    + 132, + 258, + 134, + 386,
+    + 138, + 162, + 140, + 290,
+    + 142, + 418, + 146, + 194,
+    + 148, + 322, + 150, + 450,
+    + 154, + 226, + 156, + 354,
+    + 158, + 482, + 164, + 266,
+    + 166, + 394, + 172, + 298,
+    + 174, + 426, + 178, + 202,
+    + 180, + 330, + 182, + 458,
+    + 186, + 234, + 188, + 362,
+    + 190, + 490, + 196, + 274,
+    + 198, + 402, + 204, + 306,
+    + 206, + 434, + 212, + 338,
+    + 214, + 466, + 218, + 242,
+    + 220, + 370, + 222, + 498,
+    + 228, + 282, + 230, + 410,
+    + 236, + 314, + 238, + 442,
+    + 244, + 346, + 246, + 474,
+    + 252, + 378, + 254, + 506,
+    + 262, + 388, + 268, + 292,
+    + 270, + 420, + 276, + 324,
+    + 278, + 452, + 284, + 356,
+    + 286, + 484, + 294, + 396,
+    + 302, + 428, + 308, + 332,
+    + 310, + 460, + 316, + 364,
+    + 318, + 492, + 326, + 404,
+    + 334, + 436, + 342, + 468,
+    + 348, + 372, + 350, + 500,
+    + 358, + 412, + 366, + 444,
+    + 374, + 476, + 382, + 508,
+    + 398, + 422, + 406, + 454,
+    + 414, + 486, + 438, + 462,
+    + 446, + 494, + 478, + 502
+};
+
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+    void digit_reversal_swapping(Int32 *y, Int32 *x);
+
+#ifdef __cplusplus
+}
+#endif
+
+void digit_reversal_swapping(Int32 *y, Int32 *x)
+{
+    Int16 i, j;
+    Int32 tmp[2];
+    const Int16 *pTable;
+
+    pTable = digit_reverse_swap_256;
+
+    for (Int k = 120; k != 0; k--)
+    {
+        i = *pTable++;
+        j = *pTable++;
+        tmp[0] = y[i];
+        tmp[1] = y[i+1];
+        y[i]   = y[j];
+        y[i+1] = y[j+1];
+        y[j]   = tmp[0];
+        y[j+1] = tmp[1];
+
+        tmp[0] = x[j];
+        tmp[1] = x[j+1];
+        x[j]   = x[i];
+        x[j+1] = x[i+1];
+        x[i]   = tmp[0];
+        x[i+1] = tmp[1];
+
+    }
+
+}
diff --git a/media/libstagefright/codecs/aacdec/digit_reversal_tables.h b/media/libstagefright/codecs/aacdec/digit_reversal_tables.h
new file mode 100644
index 0000000..7fdaaf7
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/digit_reversal_tables.h
@@ -0,0 +1,86 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Pathname: ./include/DIGIT_REVERSAL_TABLES.h
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+
+ Who:                   Date:
+ Description:
+
+------------------------------------------------------------------------------
+ INCLUDE DESCRIPTION
+
+ Header file for functions digit_reversal_tables
+
+
+------------------------------------------------------------------------------
+*/
+
+/*----------------------------------------------------------------------------
+; CONTINUE ONLY IF NOT ALREADY DEFINED
+----------------------------------------------------------------------------*/
+#ifndef DIGIT_REVERSAL_TABLES_H
+#define DIGIT_REVERSAL_TABLES_H
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+#include "pv_audio_type_defs.h"
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here.
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL VARIABLES REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+extern const Int16 digit_reverse_64[];
+extern const Int16 digit_reverse_256[];
+
+/*----------------------------------------------------------------------------
+; SIMPLE TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; ENUMERATED TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; STRUCTURES TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; GLOBAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; END
+----------------------------------------------------------------------------*/
+#endif  /* DIGIT_REVERSAL_TABLES_H */
diff --git a/media/libstagefright/codecs/aacdec/dst16.cpp b/media/libstagefright/codecs/aacdec/dst16.cpp
new file mode 100644
index 0000000..41c9259
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/dst16.cpp
@@ -0,0 +1,172 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Filename: dst16.c
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+
+ Who:                                   Date: MM/DD/YYYY
+ Description:
+
+------------------------------------------------------------------------------
+ INPUT AND OUTPUT DEFINITIONS
+
+    Int32 x             32-bit integer input length 16
+
+
+------------------------------------------------------------------------------
+ FUNCTION DESCRIPTION
+
+    Implement discrete sine transform of lenght 16
+
+------------------------------------------------------------------------------
+ REQUIREMENTS
+
+
+------------------------------------------------------------------------------
+ REFERENCES
+
+------------------------------------------------------------------------------
+ PSEUDO-CODE
+
+------------------------------------------------------------------------------
+*/
+
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+
+#ifdef AAC_PLUS
+
+#include "dst16.h"
+#include "dst8.h"
+#include "fxp_mul32.h"
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here. Include conditional
+; compile variables also.
+----------------------------------------------------------------------------*/
+
+
+#define R_SHIFT     28
+#define Qfmt(x)   (Int32)(x*((Int32)1<<R_SHIFT) + (x>=0?0.5F:-0.5F))
+
+const Int32 CosTable_8[8] =
+{
+    Qfmt(0.50241928618816F),   Qfmt(0.52249861493969F),
+    Qfmt(0.56694403481636F),   Qfmt(0.64682178335999F),
+    Qfmt(0.78815462345125F),   Qfmt(1.06067768599035F),
+    Qfmt(1.72244709823833F),   Qfmt(5.10114861868916F)
+};
+
+/*----------------------------------------------------------------------------
+; LOCAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; LOCAL STORE/BUFFER/POINTER DEFINITIONS
+; Variable declaration - defined here and used outside this module
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL FUNCTION REFERENCES
+; Declare functions defined elsewhere and referenced in this module
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL GLOBAL STORE/BUFFER/POINTER REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; FUNCTION CODE
+----------------------------------------------------------------------------*/
+
+
+void dst_16(Int32 vec[], Int32 scratch_mem[])     /* scratch_mem size 8 */
+{
+    Int32 *temp_even = scratch_mem;
+
+    Int i;
+    const Int32 *pt_cos = &CosTable_8[7];
+    Int32 tmp0 = vec[15] >> 1;
+    Int32 tmp1, tmp2;
+    Int32 *pt_even = temp_even;
+    Int32 *pt_odd  = vec;
+    Int32 *pt_vec  = vec;
+    Int32 *pt_vecN_1;
+    Int32 tmp3;
+
+
+    *(pt_even++) = *(pt_vec++);
+    tmp1         = *(pt_vec++);
+    *(pt_odd++) = tmp1;
+
+    for (i = 3; i != 0; i--)
+    {
+        *(pt_even++) = *(pt_vec++);
+        tmp2         = *(pt_vec++);
+        *(pt_even++) = *(pt_vec++);
+        tmp3         = *(pt_vec++);
+        *(pt_odd++) = tmp2 + tmp1;
+        *(pt_odd++) = tmp3 + tmp2;
+        tmp1         = tmp3;
+
+    }
+
+    *(pt_even)   = *(pt_vec++);
+    *(pt_odd++) = *(pt_vec) + tmp1;
+
+
+    dst_8(temp_even);
+    dst_8(vec);
+
+    pt_vec  = &vec[7];
+
+    pt_even = &temp_even[7];
+    pt_vecN_1  = &vec[8];
+
+    tmp1 = *(pt_even--);
+
+    for (i = 4; i != 0; i--)
+    {
+        tmp3  = fxp_mul32_Q28((*(pt_vec) - tmp0), *(pt_cos--));
+        tmp2 = *(pt_even--);
+        *(pt_vec--)     = tmp3 + tmp1;
+        *(pt_vecN_1++)  = tmp3 - tmp1;
+        tmp3  = fxp_mul32_Q28((*(pt_vec) + tmp0), *(pt_cos--));
+        tmp1 = *(pt_even--);
+        *(pt_vecN_1++)  = tmp3 - tmp2;
+        *(pt_vec--)     = tmp3 + tmp2;
+    }
+
+}
+
+#endif
diff --git a/media/libstagefright/codecs/aacdec/dst16.h b/media/libstagefright/codecs/aacdec/dst16.h
new file mode 100644
index 0000000..bce73ba
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/dst16.h
@@ -0,0 +1,68 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Pathname: ./c/include/dst16.h
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+ Who:                                       Date:
+ Description:
+------------------------------------------------------------------------------
+ INCLUDE DESCRIPTION
+
+------------------------------------------------------------------------------
+*/
+
+#ifndef DST16_H
+#define DST16_H
+
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+
+#include "pv_audio_type_defs.h"
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+
+    /*----------------------------------------------------------------------------
+    ; MACROS
+    ; Define module specific macros here
+    ----------------------------------------------------------------------------*/
+
+    /*----------------------------------------------------------------------------
+    ; EXTERNAL VARIABLES REFERENCES
+    ----------------------------------------------------------------------------*/
+
+    /*----------------------------------------------------------------------------
+    ; DEFINES AND SIMPLE TYPEDEF'S
+    ----------------------------------------------------------------------------*/
+
+    void dst_16(Int32 vec[], Int32 scratch_mem[]);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif  /* DST16_H */
diff --git a/media/libstagefright/codecs/aacdec/dst32.cpp b/media/libstagefright/codecs/aacdec/dst32.cpp
new file mode 100644
index 0000000..5edecf1
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/dst32.cpp
@@ -0,0 +1,200 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Filename: dst32.c
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+
+ Who:                                   Date: MM/DD/YYYY
+ Description:
+
+------------------------------------------------------------------------------
+ INPUT AND OUTPUT DEFINITIONS
+
+    Int32 x             32-bit integer input length 32
+
+
+------------------------------------------------------------------------------
+ FUNCTION DESCRIPTION
+
+    Implement discrete sine transform of lenght 32
+
+------------------------------------------------------------------------------
+ REQUIREMENTS
+
+
+------------------------------------------------------------------------------
+ REFERENCES
+
+------------------------------------------------------------------------------
+ PSEUDO-CODE
+
+------------------------------------------------------------------------------
+*/
+
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+
+#ifdef AAC_PLUS
+
+
+#include "dst32.h"
+#include "dst16.h"
+
+#include "fxp_mul32.h"
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here. Include conditional
+; compile variables also.
+----------------------------------------------------------------------------*/
+
+
+#define R_SHIFT1     29
+#define Qfmt29(x)   (Int32)(x*((Int32)1<<R_SHIFT1) + (x>=0?0.5F:-0.5F))
+#define Qfmt31(a)   (Int32)(a*0x7FFFFFFF + (a>=0?0.5F:-0.5F))
+
+const Int32 CosTable_16[14] =
+{
+    Qfmt31(0.50060299823520F),   Qfmt31(0.50547095989754F),
+    Qfmt31(0.51544730992262F),   Qfmt31(0.53104259108978F),
+    Qfmt31(0.55310389603444F),   Qfmt31(0.58293496820613F),
+    Qfmt31(0.62250412303566F),   Qfmt31(0.67480834145501F),
+    Qfmt31(0.74453627100230F),   Qfmt31(0.83934964541553F),
+    Qfmt29(0.97256823786196F),   Qfmt29(1.16943993343288F),
+    Qfmt29(1.48416461631417F),   Qfmt29(2.05778100995341F)
+};
+
+/*----------------------------------------------------------------------------
+; LOCAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; LOCAL STORE/BUFFER/POINTER DEFINITIONS
+; Variable declaration - defined here and used outside this module
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL FUNCTION REFERENCES
+; Declare functions defined elsewhere and referenced in this module
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL GLOBAL STORE/BUFFER/POINTER REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; FUNCTION CODE
+----------------------------------------------------------------------------*/
+
+
+void dst_32(Int32 vec[], Int32 scratch_mem[])   /* scratch_mem size 32 */
+{
+    Int32 *temp_even = scratch_mem;
+
+    Int32 i;
+    const Int32 *pt_cos = &CosTable_16[13];
+    Int32 tmp0 = vec[31] >> 1;
+    Int32 tmp1, tmp2;
+    Int32 *pt_even = temp_even;
+    Int32 *pt_odd  = vec;
+    Int32 *pt_vec  = vec;
+    Int32 *pt_vecN_1  = vec;
+    Int32 tmp3;
+
+
+    tmp1 = 0;
+
+    for (i = 5; i != 0; i--)
+    {
+        *(pt_even++) = *(pt_vec++);
+        tmp2         = *(pt_vec++);
+        *(pt_even++) = *(pt_vec++);
+        tmp3         = *(pt_vec++);
+        *(pt_even++) = *(pt_vec++);
+        *(pt_odd++) = tmp2 + tmp1;
+        *(pt_odd++) = tmp3 + tmp2;
+        tmp1         = *(pt_vec++);
+        *(pt_odd++) = tmp1 + tmp3;
+    }
+
+    *(pt_even) = *(pt_vec++);
+    *(pt_odd)  = *(pt_vec) + tmp1;
+
+
+    dst_16(temp_even, &scratch_mem[16]);
+    dst_16(vec, &scratch_mem[24]);
+
+
+    pt_vecN_1  = &vec[16];
+
+    tmp1 = temp_even[15];
+
+    tmp3  = fxp_mul32_Q31((vec[15] - tmp0) << 3, Qfmt31(0.63687550772175F)) << 2;
+    tmp2  = temp_even[14];
+    *(pt_vecN_1++)  = tmp3 - tmp1;
+    vec[15]         = tmp3 + tmp1;
+    tmp1  = temp_even[13];
+    tmp3  = fxp_mul32_Q31((vec[14] + tmp0) << 3, Qfmt31(0.85190210461718F));
+    *(pt_vecN_1++)  = tmp3 - tmp2;
+    vec[14]         = tmp3 + tmp2;
+
+    pt_even = &temp_even[12];
+    pt_vec  = &vec[13];
+
+    for (i = 2; i != 0; i--)
+    {
+        tmp3  = fxp_mul32_Q29((*(pt_vec) - tmp0), *(pt_cos--));
+        tmp2 = *(pt_even--);
+        *(pt_vec--)     = tmp3 + tmp1;
+        *(pt_vecN_1++)  = tmp3 - tmp1;
+        tmp3  = fxp_mul32_Q29((*(pt_vec) + tmp0), *(pt_cos--));
+        tmp1 = *(pt_even--);
+        *(pt_vec--)     = tmp3 + tmp2;
+        *(pt_vecN_1++)  = tmp3 - tmp2;
+    }
+
+    for (i = 5; i != 0; i--)
+    {
+        tmp3  = fxp_mul32_Q31((*(pt_vec) - tmp0) << 1, *(pt_cos--));
+        tmp2 = *(pt_even--);
+        *(pt_vec--)     = tmp3 + tmp1;
+        *(pt_vecN_1++)  = tmp3 - tmp1;
+        tmp3  = fxp_mul32_Q31((*(pt_vec) + tmp0) << 1, *(pt_cos--));
+        tmp1 = *(pt_even--);
+        *(pt_vec--)     = tmp3 + tmp2;
+        *(pt_vecN_1++)  = tmp3 - tmp2;
+    }
+
+
+}
+
+#endif
diff --git a/media/libstagefright/codecs/aacdec/dst32.h b/media/libstagefright/codecs/aacdec/dst32.h
new file mode 100644
index 0000000..c2bf1d2
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/dst32.h
@@ -0,0 +1,69 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Pathname: ./c/include/dst32.h
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+ Who:                                       Date:
+ Description:
+------------------------------------------------------------------------------
+ INCLUDE DESCRIPTION
+
+------------------------------------------------------------------------------
+*/
+
+#ifndef DST32_H
+#define DST32_H
+
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+
+#include "pv_audio_type_defs.h"
+
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+    /*----------------------------------------------------------------------------
+    ; EXTERNAL VARIABLES REFERENCES
+    ----------------------------------------------------------------------------*/
+    extern const Int32 CosTable_16[];
+
+    /*----------------------------------------------------------------------------
+    ; DEFINES AND SIMPLE TYPEDEF'S
+    ----------------------------------------------------------------------------*/
+
+    void dst_32(Int32 vec[], Int32 scratch_mem[]);
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif  /* DST32_H */
diff --git a/media/libstagefright/codecs/aacdec/dst8.cpp b/media/libstagefright/codecs/aacdec/dst8.cpp
new file mode 100644
index 0000000..eaf8280
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/dst8.cpp
@@ -0,0 +1,179 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Filename: dst8.c
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+
+ Who:                                   Date: MM/DD/YYYY
+ Description:
+
+------------------------------------------------------------------------------
+ INPUT AND OUTPUT DEFINITIONS
+
+    Int32 x             32-bit integer input length 8
+
+
+------------------------------------------------------------------------------
+ FUNCTION DESCRIPTION
+
+    Implement discrete sine transform of lenght 8
+
+------------------------------------------------------------------------------
+ REQUIREMENTS
+
+
+------------------------------------------------------------------------------
+ REFERENCES
+
+------------------------------------------------------------------------------
+ PSEUDO-CODE
+
+------------------------------------------------------------------------------
+*/
+
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+
+#ifdef AAC_PLUS
+
+
+#include "dst8.h"
+
+#include "fxp_mul32.h"
+
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here. Include conditional
+; compile variables also.
+----------------------------------------------------------------------------*/
+
+#define Qfmt15(x)   (Int16)(x*((Int32)1<<15) + (x>=0?0.5F:-0.5F))
+
+/*----------------------------------------------------------------------------
+; LOCAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; LOCAL STORE/BUFFER/POINTER DEFINITIONS
+; Variable declaration - defined here and used outside this module
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL FUNCTION REFERENCES
+; Declare functions defined elsewhere and referenced in this module
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL GLOBAL STORE/BUFFER/POINTER REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; FUNCTION CODE
+----------------------------------------------------------------------------*/
+
+
+#define R_SHIFT     29
+#define Qfmt(x)   (Int32)(x*((Int32)1<<R_SHIFT) + (x>=0?0.5F:-0.5F))
+
+#define Qfmt31(x)   (Int32)(x*0x7FFFFFFF + (x>=0?0.5F:-0.5F))
+
+
+void dst_8(Int32 vec[])
+{
+
+    Int32 temp1;
+    Int32 temp2;
+    Int32 temp3;
+    Int32 temp4;
+    Int32 temp5;
+    Int32 temp6;
+    Int32 temp7;
+    Int32 tmp_a;
+    Int32 tmp_aa;
+    Int32 tmp_b;
+    Int32 tmp_bb;
+    Int32 tmp_c;
+    Int32 tmp_cc;
+    Int32 tmp_d;
+    Int32 tmp_dd;
+
+    temp1 = fxp_mul32_by_16(vec[1], Qfmt15(0.50979557910416F));         /* (1/(2*cos(  phi)));*/
+    temp2 = fxp_mul32_by_16(vec[2], Qfmt15(0.54119610014620F));         /* (1/(2*cos(2*phi)));*/
+    temp3 = fxp_mul32_by_16(vec[3], Qfmt15(0.60134488693505F));         /* (1/(2*cos(3*phi)));*/
+    temp5 = fxp_mul32_by_16(vec[5], Qfmt15(0.89997622313642F));         /* (1/(2*cos(5*phi)));*/
+    temp6 = fxp_mul32_by_16(vec[6] << 1, Qfmt15(0.65328148243819F));        /* (1/(2*cos(6*phi)));*/
+    temp7 = vec[7] + fxp_mul32_Q31(vec[7], Qfmt31(0.56291544774152F));          /* (1/(2*cos(7*phi)));*/
+
+    /*  even  */
+    tmp_a = fxp_mul32_Q31((temp2 + temp6) << 1, Qfmt31(0.70710678118655F));
+    tmp_b = (temp2 - temp6) + tmp_a;
+
+    temp4 = fxp_mul32_by_16(vec[4], Qfmt15(0.70710678118655F));
+    vec[0] =   tmp_a + temp4;
+    vec[1] =   tmp_b + temp4;
+    vec[2] =   tmp_b - temp4;
+    vec[3] =   tmp_a - temp4;
+
+
+    /* odd */
+
+    tmp_a  = fxp_mul32_by_16((temp1 + temp7) << 1, Qfmt15(0.54119610014620F));  /* (1/(2*cos(2*phi)));  */
+    tmp_aa = (temp1 - temp7);
+    tmp_bb = (temp5 - temp3);
+    temp5  = fxp_mul32_Q29((temp5 + temp3), Qfmt(1.30656296487638F));   /* (1/(2*cos(6*phi)));  */
+
+
+    tmp_c  = fxp_mul32_by_16((tmp_a + temp5) << 1, Qfmt15(0.70710678118655F));
+    tmp_cc =  tmp_a - temp5;
+
+    tmp_d  = fxp_mac32_by_16((tmp_aa - tmp_bb) << 1, Qfmt15(0.70710678118655F), tmp_c);
+    tmp_dd = (tmp_aa + tmp_bb);
+
+    tmp_dd +=  tmp_c;
+    tmp_a   =  tmp_d  + tmp_cc;
+    vec[5]  =  tmp_a  - vec[2];
+    vec[2] +=  tmp_a;
+
+    temp5   =  tmp_dd + tmp_cc;
+
+    vec[4]  =  temp5  - vec[3];
+    vec[3] +=  temp5;
+    vec[7]  =  tmp_c  - vec[0];
+    vec[0] +=  tmp_c;
+    vec[6]  =  tmp_d  - vec[1];
+    vec[1] +=  tmp_d;
+
+}
+
+
+#endif
diff --git a/media/libstagefright/codecs/aacdec/dst8.h b/media/libstagefright/codecs/aacdec/dst8.h
new file mode 100644
index 0000000..2738e80
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/dst8.h
@@ -0,0 +1,68 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Pathname: ./c/include/dst8.h
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+ Who:                                       Date:
+ Description:
+------------------------------------------------------------------------------
+ INCLUDE DESCRIPTION
+
+------------------------------------------------------------------------------
+*/
+
+#ifndef DST8_H
+#define DST8_H
+
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+
+#include "pv_audio_type_defs.h"
+
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+    /*----------------------------------------------------------------------------
+    ; EXTERNAL VARIABLES REFERENCES
+    ----------------------------------------------------------------------------*/
+
+    /*----------------------------------------------------------------------------
+    ; DEFINES AND SIMPLE TYPEDEF'S
+    ----------------------------------------------------------------------------*/
+
+    void dst_8(Int32 vec[]);
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif  /* DST8_H */
diff --git a/media/libstagefright/codecs/aacdec/e_adif_const.h b/media/libstagefright/codecs/aacdec/e_adif_const.h
new file mode 100644
index 0000000..08b5415
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/e_adif_const.h
@@ -0,0 +1,97 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Pathname: ./include/e_ADIF_Const.h
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+ Who:                       Date:
+ Description:
+
+------------------------------------------------------------------------------
+ INCLUDE DESCRIPTION
+
+ enum for ADIF header related constants
+
+------------------------------------------------------------------------------
+*/
+
+/*----------------------------------------------------------------------------
+; CONTINUE ONLY IF NOT ALREADY DEFINED
+----------------------------------------------------------------------------*/
+#ifndef E_ADIF_CONST_H
+#define E_ADIF_CONST_H
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here.
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL VARIABLES REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; SIMPLE TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; ENUMERATED TYPEDEF'S
+----------------------------------------------------------------------------*/
+typedef enum
+{
+    /*
+     * audio data interchange format header
+     */
+    LEN_ADIF_ID     = (32 / 8),
+    LEN_COPYRT_PRES = 1,
+    LEN_COPYRT_ID   = (72 / 8),
+    LEN_ORIG        = 1,
+    LEN_HOME        = 1,
+    LEN_BS_TYPE     = 1,
+    LEN_BIT_RATE    = 23,
+    LEN_NUM_PCE     = 4,
+    LEN_ADIF_BF     = 20
+
+} eADIF_Const;
+
+/*----------------------------------------------------------------------------
+; STRUCTURES TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; GLOBAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; END
+----------------------------------------------------------------------------*/
+#endif
diff --git a/media/libstagefright/codecs/aacdec/e_blockswitching.h b/media/libstagefright/codecs/aacdec/e_blockswitching.h
new file mode 100644
index 0000000..bf6ad15
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/e_blockswitching.h
@@ -0,0 +1,112 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Pathname: ./include/e_BlockSwitching.h
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+ Who:                       Date:
+ Description:
+
+------------------------------------------------------------------------------
+ INCLUDE DESCRIPTION
+
+ enum for BlockSwitching related constants
+
+------------------------------------------------------------------------------
+*/
+
+/*----------------------------------------------------------------------------
+; CONTINUE ONLY IF NOT ALREADY DEFINED
+----------------------------------------------------------------------------*/
+#ifndef E_BLOCK_SWITCHING_H
+#define E_BLOCK_SWITCHING_H
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here.
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL VARIABLES REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; SIMPLE TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; ENUMERATED TYPEDEF'S
+----------------------------------------------------------------------------*/
+typedef enum
+{
+    /*
+     * block switching
+     */
+    LN          = 2048,
+    SN          = 256,
+    LN2         = LN / 2,
+    SN2         = SN / 2,
+    LN4         = LN / 4,
+    SN4         = SN / 4,
+    NSHORT      = LN / SN,
+    MAX_SBK     = NSHORT,
+    MAX_WIN     = MAX_SBK,
+
+    ONLY_LONG_WINDOW    = 0,
+    LONG_START_WINDOW,
+    EIGHT_SHORT_WINDOW,
+    LONG_STOP_WINDOW,
+    NUM_WIN_SEQ,
+
+    WLONG       = ONLY_LONG_WINDOW,
+    WSTART,
+    WSHORT,
+    WSTOP,
+
+    MAXBANDS        = 16 * NSHORT,  /* max number of scale factor bands */
+    MAXFAC      = 121,      /* maximum scale factor */
+    MIDFAC      = (MAXFAC - 1) / 2,
+    SF_OFFSET       = 100       /* global gain must be positive */
+} eBlockSwitching;
+
+/*----------------------------------------------------------------------------
+; STRUCTURES TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; GLOBAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; END
+----------------------------------------------------------------------------*/
+#endif
diff --git a/media/libstagefright/codecs/aacdec/e_coupling_mode.h b/media/libstagefright/codecs/aacdec/e_coupling_mode.h
new file mode 100644
index 0000000..68244bb
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/e_coupling_mode.h
@@ -0,0 +1,88 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Filename: e_coupling_mode.h
+ Funtions:
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+
+ Who:                                   Date: MM/DD/YYYY
+ Description:
+------------------------------------------------------------------------------
+
+
+----------------------------------------------------------------------------
+; CONTINUE ONLY IF NOT ALREADY DEFINED
+----------------------------------------------------------------------------*/
+#ifndef E_COUPLING_MODE_H
+#define E_COUPLING_MODE_H
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+#include "pv_audio_type_defs.h"
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here.
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL VARIABLES REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; SIMPLE TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; ENUMERATED TYPEDEF'S
+----------------------------------------------------------------------------*/
+typedef enum
+{
+    COUPLING_OFF,
+    COUPLING_LEVEL,
+    COUPLING_BAL
+}
+COUPLING_MODE;
+
+/*----------------------------------------------------------------------------
+; STRUCTURES TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; GLOBAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+
+
+/*----------------------------------------------------------------------------
+; END
+----------------------------------------------------------------------------*/
+#endif
+
+
diff --git a/media/libstagefright/codecs/aacdec/e_elementid.h b/media/libstagefright/codecs/aacdec/e_elementid.h
new file mode 100644
index 0000000..5f84643
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/e_elementid.h
@@ -0,0 +1,99 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+ Pathname: ./include/e_BLOCKTYPE.h
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+ Who:                       Date:
+ Description:
+
+------------------------------------------------------------------------------
+ INCLUDE DESCRIPTION
+
+ enum for BlockType related constants
+
+------------------------------------------------------------------------------
+*/
+
+/*----------------------------------------------------------------------------
+; CONTINUE ONLY IF NOT ALREADY DEFINED
+----------------------------------------------------------------------------*/
+#ifndef E_ELEMENTID_H
+#define E_ELEMENTID_H
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here.
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL VARIABLES REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; SIMPLE TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; ENUMERATED TYPEDEF'S
+----------------------------------------------------------------------------*/
+typedef enum
+{
+    /* sfb 40, coef 672, pred bw of 15.75 kHz at 48 kHz
+     * this is also the highest number of bins used
+     * by predictor for any sampling rate
+     */
+    MAX_PRED_SFB    = 40,   /* 48 kHz only, now obsolete */
+    MAX_PRED_BINS   = 672,
+
+    ID_SCE      = 0,
+    ID_CPE,
+    ID_CCE,
+    ID_LFE,
+    ID_DSE,
+    ID_PCE,
+    ID_FIL,
+    ID_END
+}
+ElementId;
+
+/*----------------------------------------------------------------------------
+; STRUCTURES TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; GLOBAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; END
+----------------------------------------------------------------------------*/
+#endif
diff --git a/media/libstagefright/codecs/aacdec/e_huffmanconst.h b/media/libstagefright/codecs/aacdec/e_huffmanconst.h
new file mode 100644
index 0000000..5d0e628
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/e_huffmanconst.h
@@ -0,0 +1,119 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Pathname: ./include/e_HuffmanConst.h
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+ Who:                       Date:
+ Description:
+
+------------------------------------------------------------------------------
+ INCLUDE DESCRIPTION
+
+ enum for Huffman related constants
+
+------------------------------------------------------------------------------
+*/
+
+/*----------------------------------------------------------------------------
+; CONTINUE ONLY IF NOT ALREADY DEFINED
+----------------------------------------------------------------------------*/
+#ifndef E_HUFFMAN_CONST_H
+#define E_HUFFMAN_CONST_H
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here.
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL VARIABLES REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; SIMPLE TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; ENUMERATED TYPEDEF'S
+----------------------------------------------------------------------------*/
+typedef enum
+{
+    /*
+     * specify huffman tables as signed (1) or unsigned (0)
+     */
+    HUF1SGN     = 1,
+    HUF2SGN     = 1,
+    HUF3SGN     = 0,
+    HUF4SGN     = 0,
+    HUF5SGN     = 1,
+    HUF6SGN     = 1,
+    HUF7SGN     = 0,
+    HUF8SGN     = 0,
+    HUF9SGN     = 0,
+    HUF10SGN        = 0,
+    HUF11SGN        = 0,
+
+    ZERO_HCB        = 0,
+    BY4BOOKS        = 4,
+    ESCBOOK     = 11,
+    NSPECBOOKS      = ESCBOOK + 1,
+    BOOKSCL     = NSPECBOOKS,
+    NBOOKS      = NSPECBOOKS + 1,
+    INTENSITY_HCB2  = 14,
+    INTENSITY_HCB   = 15,
+    NOISE_HCB       = 13,
+    NOISE_HCB2      = 113,
+
+    NOISE_PCM_BITS      = 9,
+    NOISE_PCM_OFFSET    = (1 << (NOISE_PCM_BITS - 1)),
+
+    NOISE_OFFSET        = 90,
+
+    LONG_SECT_BITS  = 5,
+    SHORT_SECT_BITS = 3
+} eHuffmanConst;
+
+/*----------------------------------------------------------------------------
+; STRUCTURES TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; GLOBAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; END
+----------------------------------------------------------------------------*/
+#endif
+
+
diff --git a/media/libstagefright/codecs/aacdec/e_infoinitconst.h b/media/libstagefright/codecs/aacdec/e_infoinitconst.h
new file mode 100644
index 0000000..788b5e9
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/e_infoinitconst.h
@@ -0,0 +1,96 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Pathname: ./include/e_infoinitConst.h
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+ Who:                       Date:
+ Description:
+
+------------------------------------------------------------------------------
+ INCLUDE DESCRIPTION
+
+ enum for Infoinit related constants
+
+------------------------------------------------------------------------------
+*/
+
+/*----------------------------------------------------------------------------
+; CONTINUE ONLY IF NOT ALREADY DEFINED
+----------------------------------------------------------------------------*/
+#ifndef E_INFOINIT_CONST_H
+#define E_INFOINIT_CONST_H
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+#include "chans.h"
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here.
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL VARIABLES REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; SIMPLE TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; ENUMERATED TYPEDEF'S
+----------------------------------------------------------------------------*/
+typedef enum
+{
+    /* block switch windows for single channels or channel pairs */
+    Winds   = Chans,
+
+    /* average channel block length, bytes */
+    Avjframe    = 341,
+
+    TEXP    = 128,      /* size of exp cache table */
+    MAX_IQ_TBL  = 128,      /* size of inv quant table */
+    MAXFFT  = LN4
+
+} infoinitConst;
+
+
+/*----------------------------------------------------------------------------
+; STRUCTURES TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; GLOBAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; END
+----------------------------------------------------------------------------*/
+#endif
diff --git a/media/libstagefright/codecs/aacdec/e_invf_mode.h b/media/libstagefright/codecs/aacdec/e_invf_mode.h
new file mode 100644
index 0000000..57b3281
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/e_invf_mode.h
@@ -0,0 +1,91 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Filename: e_invf_mode.h
+ Funtions:
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+
+ Who:                                   Date: MM/DD/YYYY
+ Description:
+------------------------------------------------------------------------------
+
+
+----------------------------------------------------------------------------
+; CONTINUE ONLY IF NOT ALREADY DEFINED
+----------------------------------------------------------------------------*/
+#ifndef E_INVF_MODE_H
+#define E_INVF_MODE_H
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+#include "pv_audio_type_defs.h"
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here.
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL VARIABLES REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; SIMPLE TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; ENUMERATED TYPEDEF'S
+----------------------------------------------------------------------------*/
+typedef enum
+{
+    INVF_OFF,
+    INVF_LOW_LEVEL,
+    INVF_MID_LEVEL,
+    INVF_HIGH_LEVEL,
+
+    INVF_NO_OVERRIDE
+}
+INVF_MODE;
+
+/*----------------------------------------------------------------------------
+; STRUCTURES TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; GLOBAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+
+
+/*----------------------------------------------------------------------------
+; END
+----------------------------------------------------------------------------*/
+#endif
+
+
diff --git a/media/libstagefright/codecs/aacdec/e_maskstatus.h b/media/libstagefright/codecs/aacdec/e_maskstatus.h
new file mode 100644
index 0000000..010b6f8
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/e_maskstatus.h
@@ -0,0 +1,91 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+   Pathname: ./include/e_MaskStatus.h
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+ Who:                       Date:
+ Description:
+
+------------------------------------------------------------------------------
+ INCLUDE DESCRIPTION
+
+ This file gives the enum of mask_present value used in getmask.c
+
+------------------------------------------------------------------------------
+*/
+
+/*----------------------------------------------------------------------------
+; CONTINUE ONLY IF NOT ALREADY DEFINED
+----------------------------------------------------------------------------*/
+#ifndef E_MASKSTATUS_H
+#define E_MASKSTATUS_H
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here.
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL VARIABLES REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; SIMPLE TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; ENUMERATED TYPEDEF'S
+----------------------------------------------------------------------------*/
+enum
+{
+    MASK_NOT_PRESENT,
+    MASK_FROM_BITSTREAM,
+    MASK_ALL_FRAME,
+    MASK_ERROR
+};
+
+/*----------------------------------------------------------------------------
+; STRUCTURES TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; GLOBAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; END
+----------------------------------------------------------------------------*/
+#endif
+
+
diff --git a/media/libstagefright/codecs/aacdec/e_mp4ff_const.h b/media/libstagefright/codecs/aacdec/e_mp4ff_const.h
new file mode 100644
index 0000000..1006406
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/e_mp4ff_const.h
@@ -0,0 +1,105 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Pathname: e_MP4FF_const.h
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+ Who:                       Date:
+ Description:
+
+------------------------------------------------------------------------------
+ INCLUDE DESCRIPTION
+
+ This file enums the constants used by MP4FF header
+
+------------------------------------------------------------------------------
+*/
+
+/*----------------------------------------------------------------------------
+; CONTINUE ONLY IF NOT ALREADY DEFINED
+----------------------------------------------------------------------------*/
+#ifndef E_MP4FF_CONST_H
+#define E_MP4FF_CONST_H
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+#include    "pv_audio_type_defs.h"
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here.
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL VARIABLES REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; SIMPLE TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; ENUMERATED TYPEDEF'S
+----------------------------------------------------------------------------*/
+typedef enum
+{
+    LEN_OBJ_TYPE = 5,
+    LEN_SAMP_RATE_IDX = 4,
+    LEN_SAMP_RATE   = 24,
+    LEN_CHAN_CONFIG = 4,
+    LEN_SYNC_EXTENSION_TYPE = 11,
+    LEN_FRAME_LEN_FLAG = 1,
+    LEN_DEPEND_ON_CORE = 1,
+    LEN_CORE_DELAY = 14,
+    LEN_EXT_FLAG = 1,
+    LEN_EP_CONFIG = 2,
+    LEN_LAYER_NUM = 3,
+    LEN_SUB_FRAME = 5,
+    LEN_LAYER_LEN = 11,
+    LEN_SECT_RES_FLAG = 1,
+    LEN_SCF_RES_FLAG = 1,
+    LEN_SPEC_RES_FLAG = 1,
+    LEN_EXT_FLAG3 = 1
+} eMP4FF_const;
+
+/*----------------------------------------------------------------------------
+; STRUCTURES TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; GLOBAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+
+
+/*----------------------------------------------------------------------------
+; END
+----------------------------------------------------------------------------*/
+#endif
+
+
diff --git a/media/libstagefright/codecs/aacdec/e_progconfigconst.h b/media/libstagefright/codecs/aacdec/e_progconfigconst.h
new file mode 100644
index 0000000..b5fdc08
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/e_progconfigconst.h
@@ -0,0 +1,110 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Pathname: e_ProgConfigConst.h
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+ Who:                       Date:
+ Description:
+
+------------------------------------------------------------------------------
+ INCLUDE DESCRIPTION
+
+ enum for ProgConfig related constants
+
+------------------------------------------------------------------------------
+*/
+
+/*----------------------------------------------------------------------------
+; CONTINUE ONLY IF NOT ALREADY DEFINED
+----------------------------------------------------------------------------*/
+#ifndef E_PROG_CONFIG_CONST_H
+#define E_PROG_CONFIG_CONST_H
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here.
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL VARIABLES REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; SIMPLE TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; ENUMERATED TYPEDEF'S
+----------------------------------------------------------------------------*/
+typedef enum
+{
+    /*
+     * Program Configuration
+     */
+    Main_Profile    = 0,
+    LC_Profile      = 1,
+
+    Fs_48       = 3,
+    Fs_44       = 4,
+    Fs_32       = 5,
+
+    LEN_PROFILE     = 2,
+    LEN_SAMP_IDX    = 4,
+    LEN_NUM_ELE     = 4,
+    LEN_NUM_LFE     = 2,
+    LEN_NUM_DAT     = 3,
+    LEN_NUM_CCE     = 4,
+    LEN_MIX_PRES    = 1,
+    LEN_MMIX_IDX    = 2,
+    LEN_PSUR_ENAB   = 1,
+    LEN_ELE_IS_CPE  = 1,
+    LEN_IND_SW_CCE  = 1,
+    LEN_COMMENT_BYTES   = 8
+
+} eProgConfigConst;
+
+/*----------------------------------------------------------------------------
+; STRUCTURES TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+
+/*----------------------------------------------------------------------------
+; GLOBAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; END
+----------------------------------------------------------------------------*/
+#endif
+
+
diff --git a/media/libstagefright/codecs/aacdec/e_rawbitstreamconst.h b/media/libstagefright/codecs/aacdec/e_rawbitstreamconst.h
new file mode 100644
index 0000000..a460d13
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/e_rawbitstreamconst.h
@@ -0,0 +1,130 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+   Pathname: e_RawBitstreamConst.h
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+ Who:                       Date:
+ Description:
+
+------------------------------------------------------------------------------
+ INCLUDE DESCRIPTION
+
+ enum for the Raw Bitstream related constants
+
+------------------------------------------------------------------------------
+*/
+
+/*----------------------------------------------------------------------------
+; CONTINUE ONLY IF NOT ALREADY DEFINED
+----------------------------------------------------------------------------*/
+#ifndef E_RAW_BITSTREAM_CONST_H
+#define E_RAW_BITSTREAM_CONST_H
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here.
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL VARIABLES REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; SIMPLE TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; ENUMERATED TYPEDEF'S
+----------------------------------------------------------------------------*/
+typedef enum
+{
+    LEN_SE_ID       = 3,
+    LEN_TAG     = 4,
+    LEN_COM_WIN     = 1,
+    LEN_ICS_RESERV  = 1,
+    LEN_WIN_SEQ     = 2,
+    LEN_WIN_SH      = 1,
+    LEN_MAX_SFBL    = 6,
+    LEN_MAX_SFBS    = 4,
+    LEN_CB          = 4,
+    LEN_SCL_PCM     = 8,
+    LEN_PRED_PRES   = 1,
+    LEN_PRED_RST    = 1,
+    LEN_PRED_RSTGRP = 5,
+    LEN_PRED_ENAB   = 1,
+    LEN_MASK_PRES   = 2,
+    LEN_MASK        = 1,
+    LEN_PULSE_PRES  = 1,
+    LEN_TNS_PRES    = 1,
+    LEN_GAIN_PRES   = 1,
+
+    LEN_PULSE_NPULSE    = 2,
+    LEN_PULSE_ST_SFB    = 6,
+    LEN_PULSE_POFF      = 5,
+    LEN_PULSE_PAMP      = 4,
+    NUM_PULSE_LINES     = 4,
+    PULSE_OFFSET_AMP    = 4,
+
+    LEN_IND_CCE_FLG = 1,
+    LEN_NCC         = 3,
+    LEN_IS_CPE      = 1,
+    LEN_CC_LR       = 1,
+    LEN_CC_DOM      = 1,
+    LEN_CC_SGN      = 1,
+    LEN_CCH_GES     = 2,
+    LEN_CCH_CGP     = 1,
+
+    LEN_D_ALIGN     = 1,
+    LEN_D_CNT       = 8,
+    LEN_D_ESC       = 8,
+    LEN_F_CNT       = 4,
+    LEN_F_ESC       = 8,
+    LEN_BYTE        = 8,
+    LEN_PAD_DATA    = 8,
+
+    LEN_PC_COMM     = 9
+
+} eRawBitstreamConst;
+
+/*----------------------------------------------------------------------------
+; STRUCTURES TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; GLOBAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; END
+----------------------------------------------------------------------------*/
+#endif
diff --git a/media/libstagefright/codecs/aacdec/e_sbr_element_id.h b/media/libstagefright/codecs/aacdec/e_sbr_element_id.h
new file mode 100644
index 0000000..1b021ff
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/e_sbr_element_id.h
@@ -0,0 +1,87 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Filename: e_sbr_element_id.h
+ Funtions:
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+
+ Who:                                   Date: MM/DD/YYYY
+ Description:
+------------------------------------------------------------------------------
+
+
+----------------------------------------------------------------------------
+; CONTINUE ONLY IF NOT ALREADY DEFINED
+----------------------------------------------------------------------------*/
+#ifndef E_SBR_ELEMENT_ID_H
+#define E_SBR_ELEMENT_ID_H
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+#include "pv_audio_type_defs.h"
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here.
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL VARIABLES REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; SIMPLE TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; ENUMERATED TYPEDEF'S
+----------------------------------------------------------------------------*/
+typedef enum
+{
+    SBR_ID_SCE = 0,
+    SBR_ID_CPE
+}
+SBR_ELEMENT_ID;
+
+/*----------------------------------------------------------------------------
+; STRUCTURES TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; GLOBAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+
+
+/*----------------------------------------------------------------------------
+; END
+----------------------------------------------------------------------------*/
+#endif
+
+
diff --git a/media/libstagefright/codecs/aacdec/e_sbr_error.h b/media/libstagefright/codecs/aacdec/e_sbr_error.h
new file mode 100644
index 0000000..b6c8a90
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/e_sbr_error.h
@@ -0,0 +1,106 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Filename: e_sbr_error.h
+ Funtions:
+
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+
+ Who:                                   Date: MM/DD/YYYY
+ Description:
+------------------------------------------------------------------------------
+
+
+----------------------------------------------------------------------------
+; CONTINUE ONLY IF NOT ALREADY DEFINED
+----------------------------------------------------------------------------*/
+#ifndef E_SBR_ERROR_H
+#define E_SBR_ERROR_H
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here.
+----------------------------------------------------------------------------*/
+#define HANDLE_ERROR_INFO Int32
+#define noError 0
+
+
+/*----------------------------------------------------------------------------
+; EXTERNAL VARIABLES REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; SIMPLE TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; ENUMERATED TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+typedef enum
+{
+    SBRDEC_OK = 0,
+    SBRDEC_NOSYNCH,
+    SBRDEC_ILLEGAL_PROGRAM,
+    SBRDEC_ILLEGAL_TAG,
+    SBRDEC_ILLEGAL_CHN_CONFIG,
+    SBRDEC_ILLEGAL_SECTION,
+    SBRDEC_ILLEGAL_SCFACTORS,
+    SBRDEC_ILLEGAL_PULSE_DATA,
+    SBRDEC_MAIN_PROFILE_NOT_IMPLEMENTED,
+    SBRDEC_GC_NOT_IMPLEMENTED,
+    SBRDEC_ILLEGAL_PLUS_ELE_ID,
+    SBRDEC_CREATE_ERROR,
+    SBRDEC_NOT_INITIALIZED,
+    SBRDEC_TOO_MANY_SBR_ENVELOPES,
+    SBRDEC_INVALID_BITSTREAM
+}
+SBR_ERROR;
+
+/*----------------------------------------------------------------------------
+; STRUCTURES TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+
+/*----------------------------------------------------------------------------
+; GLOBAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+
+
+/*----------------------------------------------------------------------------
+; END
+----------------------------------------------------------------------------*/
+#endif
+
+
diff --git a/media/libstagefright/codecs/aacdec/e_sbr_header_status.h b/media/libstagefright/codecs/aacdec/e_sbr_header_status.h
new file mode 100644
index 0000000..5b2a43f
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/e_sbr_header_status.h
@@ -0,0 +1,88 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Filename: e_sbr_header_status.h
+ Funtions:
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+
+ Who:                                   Date: MM/DD/YYYY
+ Description:
+------------------------------------------------------------------------------
+
+
+----------------------------------------------------------------------------
+; CONTINUE ONLY IF NOT ALREADY DEFINED
+----------------------------------------------------------------------------*/
+#ifndef E_SBR_HEADER_STATUS_H
+#define E_SBR_HEADER_STATUS_H
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+#include "pv_audio_type_defs.h"
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here.
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL VARIABLES REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; SIMPLE TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; ENUMERATED TYPEDEF'S
+----------------------------------------------------------------------------*/
+typedef enum
+{
+    HEADER_OK,
+    HEADER_RESET,
+    HEADER_NOT_INITIALIZED
+}
+SBR_HEADER_STATUS;
+
+/*----------------------------------------------------------------------------
+; STRUCTURES TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; GLOBAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+
+
+/*----------------------------------------------------------------------------
+; END
+----------------------------------------------------------------------------*/
+#endif
+
+
diff --git a/media/libstagefright/codecs/aacdec/e_sbr_master_status.h b/media/libstagefright/codecs/aacdec/e_sbr_master_status.h
new file mode 100644
index 0000000..16e43a4
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/e_sbr_master_status.h
@@ -0,0 +1,87 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Filename: e_sbr_master_status.h
+ Funtions:
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+
+ Who:                                   Date: MM/DD/YYYY
+ Description:
+------------------------------------------------------------------------------
+
+
+----------------------------------------------------------------------------
+; CONTINUE ONLY IF NOT ALREADY DEFINED
+----------------------------------------------------------------------------*/
+#ifndef E_SBR_MASTER_STATUS_H
+#define E_SBR_MASTER_STATUS_H
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+#include "pv_audio_type_defs.h"
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here.
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL VARIABLES REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; SIMPLE TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; ENUMERATED TYPEDEF'S
+----------------------------------------------------------------------------*/
+typedef enum
+{
+    MASTER_OK,
+    MASTER_RESET
+}
+SBR_MASTER_STATUS;
+
+/*----------------------------------------------------------------------------
+; STRUCTURES TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; GLOBAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+
+
+/*----------------------------------------------------------------------------
+; END
+----------------------------------------------------------------------------*/
+#endif
+
+
diff --git a/media/libstagefright/codecs/aacdec/e_sbr_sync_state.h b/media/libstagefright/codecs/aacdec/e_sbr_sync_state.h
new file mode 100644
index 0000000..d9f8669
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/e_sbr_sync_state.h
@@ -0,0 +1,88 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Filename: e_sbr_sync_state.h
+ Funtions:
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+
+ Who:                                   Date: MM/DD/YYYY
+ Description:
+------------------------------------------------------------------------------
+
+
+----------------------------------------------------------------------------
+; CONTINUE ONLY IF NOT ALREADY DEFINED
+----------------------------------------------------------------------------*/
+#ifndef E_SBR_SYNC_STATE_H
+#define E_SBR_SYNC_STATE_H
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here.
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL VARIABLES REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; SIMPLE TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; ENUMERATED TYPEDEF'S
+----------------------------------------------------------------------------*/
+typedef enum
+{
+    SBR_NOT_INITIALIZED,
+    UPSAMPLING,
+    SBR_ACTIVE
+}
+SBR_SYNC_STATE;
+
+/*----------------------------------------------------------------------------
+; STRUCTURES TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+
+/*----------------------------------------------------------------------------
+; GLOBAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+
+
+/*----------------------------------------------------------------------------
+; END
+----------------------------------------------------------------------------*/
+#endif
+
+
diff --git a/media/libstagefright/codecs/aacdec/e_sr_mode.h b/media/libstagefright/codecs/aacdec/e_sr_mode.h
new file mode 100644
index 0000000..eff00dd
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/e_sr_mode.h
@@ -0,0 +1,88 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Filename: e_sr_mode.h
+ Funtions:
+
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+
+ Who:                                   Date: MM/DD/YYYY
+ Description:
+------------------------------------------------------------------------------
+
+
+----------------------------------------------------------------------------
+; CONTINUE ONLY IF NOT ALREADY DEFINED
+----------------------------------------------------------------------------*/
+#ifndef E_SR_MODE_H
+#define E_SR_MODE_H
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+#include "pv_audio_type_defs.h"
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here.
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL VARIABLES REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; SIMPLE TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; ENUMERATED TYPEDEF'S
+----------------------------------------------------------------------------*/
+typedef enum
+{
+    SINGLE_RATE = 1,
+    UP_BY_2
+}
+SR_MODE;
+
+/*----------------------------------------------------------------------------
+; STRUCTURES TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; GLOBAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+
+
+/*----------------------------------------------------------------------------
+; END
+----------------------------------------------------------------------------*/
+#endif
+
+
diff --git a/media/libstagefright/codecs/aacdec/e_tmp4audioobjecttype.h b/media/libstagefright/codecs/aacdec/e_tmp4audioobjecttype.h
new file mode 100644
index 0000000..83cccce
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/e_tmp4audioobjecttype.h
@@ -0,0 +1,118 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Pathname: ./include/e_tMP4AudioObjectType.h
+
+ This file contains enumerated types for MP4 Audio Object Types, as defined
+ in ISO/IEC 14496-3, AMMENDMENT 1 Dated 2000-09-15
+
+------------------------------------------------------------------------------
+*/
+
+/*----------------------------------------------------------------------------
+; CONTINUE ONLY IF NOT ALREADY DEFINED
+----------------------------------------------------------------------------*/
+#ifndef E_TMP4AUDIOOBJECTTYPE_H
+#define E_TMP4AUDIOOBJECTTYPE_H
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+    /*----------------------------------------------------------------------------
+    ; INCLUDES
+    ----------------------------------------------------------------------------*/
+
+    /*----------------------------------------------------------------------------
+    ; MACROS
+    ; Define module specific macros here
+    ----------------------------------------------------------------------------*/
+
+    /*----------------------------------------------------------------------------
+    ; DEFINES
+    ; Include all pre-processor statements here.
+    ----------------------------------------------------------------------------*/
+
+    /*----------------------------------------------------------------------------
+    ; EXTERNAL VARIABLES REFERENCES
+    ; Declare variables used in this module but defined elsewhere
+    ----------------------------------------------------------------------------*/
+
+    /*----------------------------------------------------------------------------
+    ; SIMPLE TYPEDEF'S
+    ----------------------------------------------------------------------------*/
+
+    /*----------------------------------------------------------------------------
+    ; ENUMERATED TYPEDEF'S
+    ----------------------------------------------------------------------------*/
+
+    typedef enum eMP4AudioObjectType
+    {
+        MP4AUDIO_NULL            =  0, /*                                       */
+        MP4AUDIO_AAC_MAIN        =  1, /*                                       */
+        MP4AUDIO_AAC_LC          =  2, /* LC = Low Complexity                   */
+        MP4AUDIO_AAC_SSR         =  3, /* SSR = Scalable Sampling Rate          */
+        MP4AUDIO_LTP             =  4, /* LTP = Long Term Prediction            */
+        MP4AUDIO_SBR             =  5, /* SBR = Spectral Band Replication       */
+        MP4AUDIO_AAC_SCALABLE    =  6, /* scales both bitrate and sampling rate */
+        MP4AUDIO_TWINVQ          =  7, /* low bit rate                          */
+        MP4AUDIO_CELP            =  8,
+        MP4AUDIO_HVXC            =  9,
+        /* 10 is reserved                        */
+        /* 11 is reserved                        */
+        MP4AUDIO_TTSI            = 12,
+        /* 13-16 are synthesis and MIDI types    */
+        MP4AUDIO_ER_AAC_LC       = 17, /*                                       */
+        /* 18 is reserved                        */
+        MP4AUDIO_ER_AAC_LTP      = 19, /*                                       */
+        MP4AUDIO_ER_AAC_SCALABLE = 20, /*                                       */
+        MP4AUDIO_ER_TWINVQ       = 21, /*                                       */
+        MP4AUDIO_ER_BSAC         = 22, /*                                       */
+        MP4AUDIO_ER_AAC_LD       = 23, /*                                       */
+        MP4AUDIO_ER_CELP         = 24, /*                                       */
+        MP4AUDIO_ER_HVXC         = 25, /*                                       */
+        MP4AUDIO_ER_HILN         = 26, /*                                       */
+        MP4AUDIO_PARAMETRIC      = 27, /*                                       */
+        MP4AUDIO_PS              = 29  /*  Explicit Parametric Stereo           */
+
+    } tMP4AudioObjectType;
+
+    /*----------------------------------------------------------------------------
+    ; STRUCTURES TYPEDEF'S
+    ----------------------------------------------------------------------------*/
+
+    /*----------------------------------------------------------------------------
+    ; GLOBAL FUNCTION DEFINITIONS
+    ; Function Prototype declaration
+    ----------------------------------------------------------------------------*/
+
+    /* Should not be any function declarations in this file */
+
+    /*----------------------------------------------------------------------------
+    ; END
+    ----------------------------------------------------------------------------*/
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif  /* E_TMP4AUDIOOBJECTTYPE_H */
+
+
diff --git a/media/libstagefright/codecs/aacdec/e_tns_const.h b/media/libstagefright/codecs/aacdec/e_tns_const.h
new file mode 100644
index 0000000..157d471
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/e_tns_const.h
@@ -0,0 +1,91 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+  Pathname: ./include/e_TNS_Const.h
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+ Who:                       Date:
+ Description:
+
+------------------------------------------------------------------------------
+ INCLUDE DESCRIPTION
+
+ enum for TNS related constants
+
+------------------------------------------------------------------------------
+*/
+
+/*----------------------------------------------------------------------------
+; CONTINUE ONLY IF NOT ALREADY DEFINED
+----------------------------------------------------------------------------*/
+#ifndef E_TNS_CONST_H
+#define E_TNS_CONST_H
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here.
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL VARIABLES REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; SIMPLE TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; ENUMERATED TYPEDEF'S
+----------------------------------------------------------------------------*/
+typedef enum
+{
+    TNS_MAX_BANDS = 49,
+    TNS_MAX_ORDER = 20,
+    TNS_MAX_WIN   =  8,
+    TNS_MAX_FILT  =  3,
+    Q_SPEC        = 11,
+    Q_LPC         = 19
+
+} eTNS_Const;
+
+/*----------------------------------------------------------------------------
+; STRUCTURES TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; GLOBAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; END
+----------------------------------------------------------------------------*/
+#endif
diff --git a/media/libstagefright/codecs/aacdec/e_window_sequence.h b/media/libstagefright/codecs/aacdec/e_window_sequence.h
new file mode 100644
index 0000000..c4b933e
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/e_window_sequence.h
@@ -0,0 +1,90 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Pathname: ./include/e_WINDOW_SEQUENCE.h
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+ Who:                       Date:
+ Description:
+
+------------------------------------------------------------------------------
+ INCLUDE DESCRIPTION
+
+ enum for Window Sequence related constants
+
+------------------------------------------------------------------------------
+*/
+
+/*----------------------------------------------------------------------------
+; CONTINUE ONLY IF NOT ALREADY DEFINED
+----------------------------------------------------------------------------*/
+#ifndef E_WINDOW_SEQUENCE_H
+#define E_WINDOW_SEQUENCE_H
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here.
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL VARIABLES REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; SIMPLE TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; ENUMERATED TYPEDEF'S
+----------------------------------------------------------------------------*/
+typedef enum
+{
+    ONLY_LONG_SEQUENCE,
+    LONG_START_SEQUENCE,
+    EIGHT_SHORT_SEQUENCE,
+    LONG_STOP_SEQUENCE,
+    NUM_WINDOW_SEQUENCE,
+    ENSURE_WINDOW_SEQUENCE_INT_SIZE = 0x7FFFFF
+}
+WINDOW_SEQUENCE;
+/*----------------------------------------------------------------------------
+; STRUCTURES TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; GLOBAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; END
+----------------------------------------------------------------------------*/
+#endif
diff --git a/media/libstagefright/codecs/aacdec/e_window_shape.h b/media/libstagefright/codecs/aacdec/e_window_shape.h
new file mode 100644
index 0000000..3eca438
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/e_window_shape.h
@@ -0,0 +1,89 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Pathname: e_Window_shape.h
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+ Who:                       Date:
+ Description:
+
+------------------------------------------------------------------------------
+ INCLUDE DESCRIPTION
+
+ enum for Window Sequence related constants
+
+------------------------------------------------------------------------------
+*/
+
+/*----------------------------------------------------------------------------
+; CONTINUE ONLY IF NOT ALREADY DEFINED
+----------------------------------------------------------------------------*/
+#ifndef E_WINDOW_SHAPE_H
+#define E_WINDOW_SHAPE_H
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here.
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL VARIABLES REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; SIMPLE TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; ENUMERATED TYPEDEF'S
+----------------------------------------------------------------------------*/
+typedef enum
+{
+    SINE_WINDOW = 0,
+    KAISER_BESSEL_WINDOW,
+    NUM_WINDOW_SHAPES,
+    ENSURE_WINDOW_SHAPE_INT_SIZE = 0x7FFFFF
+}
+WINDOW_SHAPE;
+
+/*----------------------------------------------------------------------------
+; STRUCTURES TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; GLOBAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; END
+----------------------------------------------------------------------------*/
+#endif
diff --git a/media/libstagefright/codecs/aacdec/esc_iquant_scaling.cpp b/media/libstagefright/codecs/aacdec/esc_iquant_scaling.cpp
new file mode 100644
index 0000000..778c88c
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/esc_iquant_scaling.cpp
@@ -0,0 +1,789 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Pathname: ./src/esc_iquant_scaling.c
+ Funtions:  esc_iquant_scaling
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+ Description:  Modified from esc_iquant_fxp.c code
+
+ Description:  Eliminated unused variables to avoid warnings, changed header
+
+ Who:                                   Date:
+ Description:
+
+------------------------------------------------------------------------------
+ INPUT AND OUTPUT DEFINITIONS
+
+ Inputs:
+    quantSpec[] = array of quantized compressed spectral coefficients, of
+                  data type Int and length sfbWidth.
+
+    sfbWidth    = number of array elements in quantSpec and the output array
+                  coef, data type Int.
+
+    coef[]      = output array of uncompressed coefficients, stored in a
+                  variable Q format, depending on the maximum value found
+                  for the group, array of Int32, length sfbWdith to be
+                  overwritten.
+
+    QFormat     = the output Q format for the array coef[].
+
+
+    scale       = scaling factor after separating power of 2 factor out from
+                  0.25*(sfb_scale - 100), i.e., 0.25*sfb_scale.
+
+    maxInput    = maximum absolute value of quantSpec.
+
+ Local Stores/Buffers/Pointers Needed: None.
+
+ Global Stores/Buffers/Pointers Needed:
+    inverseQuantTable = lookup table of const integer values to the one third
+                power stored in Q27 format, in file iquant_table.c, const
+                array of UInt32, of size 1025.
+
+ Outputs: None
+
+ Pointers and Buffers Modified:
+    coef[] contents are overwritten with the uncompressed values from
+    quantSpec[]
+
+
+
+
+ Local Stores Modified: None.
+
+ Global Stores Modified: None.
+
+------------------------------------------------------------------------------
+ FUNCTION DESCRIPTION
+
+ This function performs the inverse quantization of the spectral coeficients
+ read from huffman decoding. It takes each input array value to the four
+ thirds power, then scales it according to the scaling factor input argument
+ ,and stores the result in the output array in a variable Q format
+ depending upon the maximum input value found.
+
+------------------------------------------------------------------------------
+ REQUIREMENTS
+
+ This function shall not have static or global variables.
+
+------------------------------------------------------------------------------
+ REFERENCES
+
+ (1) ISO/IEC 13818-7:1997 Titled "Information technology - Generic coding
+   of moving pictures and associated audio information - Part 7: Advanced
+   Audio Coding (AAC)", Section 10.3, "Decoding process", page 43.
+
+ (2) MPEG-2 NBC Audio Decoder
+   "This software module was originally developed by AT&T, Dolby
+   Laboratories, Fraunhofer Gesellschaft IIS in the course of development
+   of the MPEG-2 NBC/MPEG-4 Audio standard ISO/IEC 13818-7, 14496-1,2 and
+   3. This software module is an implementation of a part of one or more
+   MPEG-2 NBC/MPEG-4 Audio tools as specified by the MPEG-2 NBC/MPEG-4
+   Audio standard. ISO/IEC gives users of the MPEG-2 NBC/MPEG-4 Audio
+   standards free license to this software module or modifications thereof
+   for use in hardware or software products claiming conformance to the
+   MPEG-2 NBC/MPEG-4 Audio  standards. Those intending to use this software
+   module in hardware or software products are advised that this use may
+   infringe existing patents. The original developer of this software
+   module and his/her company, the subsequent editors and their companies,
+   and ISO/IEC have no liability for use of this software module or
+   modifications thereof in an implementation. Copyright is not released
+   for non MPEG-2 NBC/MPEG-4 Audio conforming products.The original
+   developer retains full right to use the code for his/her own purpose,
+   assign or donate the code to a third party and to inhibit third party
+   from using the code for non MPEG-2 NBC/MPEG-4 Audio conforming products.
+   This copyright notice must be included in all copies or derivative
+   works."
+   Copyright(c)1996.
+
+------------------------------------------------------------------------------
+ PSEUDO-CODE
+
+    maxInput = 0;
+
+    FOR (i = sfbWidth - 1; i >= 0; i--)
+        x = quantSpec[i];
+
+        IF ( x >= 0)
+            absX = x;
+        ELSE
+            absX = -x;
+        ENDIF
+
+        coef[i] = absX;
+
+        IF (absX > maxInput)
+            maxInput = absX;
+        ENDIF
+    ENDFOR
+
+    IF (maxInput == 0)
+        *pQFormat = QTABLE;
+    ELSE
+        temp = inverseQuantTable[(maxInput >> ORDER) + 1];
+
+        temp += ((1 << (QTABLE))-1);
+
+        temp >>= (QTABLE-1);
+
+        temp *= maxInput;
+
+        binaryDigits = 0;
+        WHILE( temp != 0)
+            temp >>= 1;
+            binaryDigits++;
+        WEND
+
+        IF (binaryDigits < (SIGNED32BITS - QTABLE))
+            binaryDigits = SIGNED32BITS - QTABLE;
+        ENDIF
+
+        *pQFormat = SIGNED32BITS - binaryDigits;
+        shift = QTABLE - *pQFormat;
+
+        IF (maxInput < TABLESIZE)
+            FOR (i = sfbWidth - 1; i >= 0; i--)
+                x = quantSpec[i];
+
+                absX = coef[i];
+
+                tmp_coef = x * (inverseQuantTable[absX] >> shift);
+
+                b_low  = (tmp_coef & 0xFFFF);
+                b_high = (tmp_coef >> 16);
+
+                mult_low  = ( (UInt32) b_low * scale );
+                mult_high = ( (Int32) b_high * scale );
+
+                mult_low >>= 16;
+
+                coef[i]  = (Int32) (mult_high + mult_low);
+
+            ENDFOR
+        ELSE
+            FOR (i = sfbWidth; i >= 0 ; i--)
+                x    = quantSpec[i];
+                absX = coef[i];
+
+                IF (absX < TABLESIZE)
+                    tmp_coef = x * (inverseQuantTable[absX] >> shift);
+                ELSE
+                    index = absX >> ORDER;
+                    w1 = inverseQuantTable[index];
+
+                    approxOneThird = (w1 * FACTOR) >> shift;
+
+
+                    x1 = index * SPACING;
+                    w2 = inverseQuantTable[index+1];
+
+                    deltaOneThird = (w2 - w1) * (absX - x1);
+
+                    deltaOneThird >>= (shift + ORDER - 1);
+
+                    tmp_coef = x * (approxOneThird + deltaOneThird);
+
+                ENDIF
+
+                b_low  = (mult_high & 0xFFFF);
+                b_high = (mult_high >> 16);
+
+                mult_low  = ( (UInt32) b_low * scale );
+                mult_high = ( (Int32) b_high * scale );
+
+                mult_low >>= 16;
+
+                coef[i]  = (Int32) (mult_high + mult_low);
+
+            ENDFOR
+        ENDIF
+    ENDIF
+
+    RETURN
+
+
+------------------------------------------------------------------------------
+ RESOURCES USED
+   When the code is written for a specific target processor the
+     the resources used should be documented below.
+
+ STACK USAGE: [stack count for this module] + [variable to represent
+          stack usage for each subroutine called]
+
+     where: [stack usage variable] = stack usage for [subroutine
+         name] (see [filename].ext)
+
+ DATA MEMORY USED: x words
+
+ PROGRAM MEMORY USED: x words
+
+ CLOCK CYCLES: [cycle count equation for this module] + [variable
+           used to represent cycle count for each subroutine
+           called]
+
+     where: [cycle count variable] = cycle count for [subroutine
+        name] (see [filename].ext)
+
+------------------------------------------------------------------------------
+*/
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+#include "pv_audio_type_defs.h"
+#include "iquant_table.h"
+#include "esc_iquant_scaling.h"
+#include "aac_mem_funcs.h"         /* For pv_memset                         */
+
+#include "fxp_mul32.h"
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here. Include conditional
+; compile variables also.
+----------------------------------------------------------------------------*/
+/*
+ * Read further on what order is.
+ * Note: If ORDER is not a multiple of 3, FACTOR is not an integer.
+ * Note: Portions of this function assume ORDER is 3, and so does the table
+ *       in iquant_table.c
+ */
+#define ORDER        (3)
+/*
+ * For input values > TABLESIZE, multiply by FACTOR to get x ^ (1/3)
+ * FACTOR = 2 ^ (ORDER/3)
+ */
+#define FACTOR       (2)
+
+/*
+ * This is one more than the range of expected inputs.
+ */
+#define INPUTRANGE   (8192)
+
+/*
+ * SPACING is 2 ^ ORDER, and is the spacing between points when in the
+ * interpolation range.
+ */
+#define SPACING      (1<<ORDER)
+
+/*
+ * The actual table size is one more than TABLESIZE, to allow for
+ * interpolation for numbers near 8191
+ */
+#define TABLESIZE    (INPUTRANGE/SPACING)
+
+/*
+ * Format the table is stored in.
+ */
+#define QTABLE       (27)
+
+/*
+ * Number of bits for data in a signed 32 bit integer.
+ */
+#define SIGNED32BITS  (31)
+
+/*
+ * Round up value for intermediate values obtained from the table
+ */
+#define ROUND_UP (( ((UInt32) 1) << (QTABLE) )-1)
+
+#define     MASK_LOW16  0xffff
+#define     UPPER16     16
+
+/*----------------------------------------------------------------------------
+; LOCAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; LOCAL VARIABLE DEFINITIONS
+; Variable declaration - defined here and used outside this module
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL FUNCTION REFERENCES
+; Declare functions defined elsewhere and referenced in this module
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL VARIABLES REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+/*
+ * Processing in this function is performed in these steps:
+ *
+ * 1) Find the overall Q format for the entire group of inputs. This consists
+ *    of:
+ *    a) Finding the maximum input
+ *    b) estimate the maximum output
+ *    c) Using the table, get max ^ (4/3), taking into account the table is
+ *       in q format.
+ * 2) For each array element, see if the value is directly inside the table.
+ *    a) If yes, just multiply by table value by itself, then shift as
+ *       appropriate.
+ *    b) If no, get an approximation (described below) for x ^ (1/3) by linearly
+ *       interpolating using lower values in the table, then multiply by a
+ *       correction factor, then multiply by x (see below).
+ *
+ * It more accurate to interpolate x ^ (1/3) then x ^ (4/3), so that is stored
+ * in the lookup table. For values not in the table, interpolation is used:
+ *
+ *  We want y = x ^ (4/3) = x * (x ^ (1/3))
+ *
+ *  Let     x = w * (2 ^ m)  where m is a constant, = ORDER
+ *
+ *  then     x ^ (1/3) = w ^ (1/3) * (2 ^ (m/3))
+ *
+ *  w is most likely not an integer, so an interpolation with floor(w) and
+ *  ceil(w) can be performed to approximate w ^ (1/3) by getting values out of
+ *  the table. Then to get x ^ (1/3), multiply by FACTOR. If m = 0, 3, 6,
+ *  then FACTOR is a simple power of 2, so a shift can do the job.
+ *
+ *  The actual code employs some more tricks to speed things up, and because
+ *  the table is stored in Q format.
+ *
+ *  Rather than saving the sign of each input, the unsigned value of
+ *  abs(x) ^ (1/3) is multiplied by the signed input value.
+ */
+
+
+
+#if ( defined(_ARM) || defined(_ARM_V4))
+
+/*
+ *  Absolute value for 16 bit-numbers
+ */
+__inline Int32 abs2(Int32 x)
+{
+    Int32 z;
+    /*
+        z = x - (x<0);
+        x = z ^ sign(z)
+     */
+    __asm
+    {
+        sub  z, x, x, lsr #31
+        eor  x, z, z, asr #31
+    }
+    return (x);
+}
+
+
+#define pv_abs(x)   abs2(x)
+
+
+#elif (defined(PV_ARM_GCC_V5)||defined(PV_ARM_GCC_V4))
+
+/*
+ *  Absolute value for 16 bit-numbers
+ */
+__inline Int32 abs2(Int32 x)
+{
+    register Int32 z;
+    register Int32 y;
+    register Int32 ra = x;
+    asm volatile(
+        "sub  %0, %2, %2, lsr #31\n\t"
+        "eor  %1, %0, %0, asr #31"
+    : "=&r*i"(z),
+        "=&r*i"(y)
+                : "r"(ra));
+
+    return (y);
+}
+
+#define pv_abs(x)   abs2(x)
+
+
+#else
+
+#define pv_abs(x)   ((x) > 0)? (x) : (-x)
+
+#endif
+
+
+
+
+
+void esc_iquant_scaling(
+    const Int16     quantSpec[],
+    Int32         coef[],
+    const Int     sfbWidth,
+    Int const      QFormat,
+    UInt16        scale,
+    Int           maxInput)
+{
+    Int    i;
+    Int    x;
+    Int    y;
+    Int    index;
+    Int    shift;
+    UInt   absX;
+    UInt32 w1, w2;
+    UInt32 deltaOneThird;
+    UInt32 x1;
+    UInt32 approxOneThird;
+    Int32   mult_high;
+
+
+#if ( defined(_ARM) || defined(_ARM_V4))
+
+    {
+        Int32   *temp;
+        Int32   R12, R11, R10, R9;
+
+        deltaOneThird = sizeof(Int32) * sfbWidth;
+        temp = coef;
+
+        // from standard library call for __rt_memset
+        __asm
+        {
+            MOV     R12, #0x0
+            MOV     R11, #0x0
+            MOV     R10, #0x0
+            MOV     R9, #0x0
+            SUBS    deltaOneThird, deltaOneThird, #0x20
+loop:
+            STMCSIA temp!, {R12, R11, R10, R9}
+            STMCSIA temp!, {R12, R11, R10, R9}
+            SUBCSS  deltaOneThird, deltaOneThird, #0x20
+            BCS     loop
+
+            MOVS    deltaOneThird, deltaOneThird, LSL #28
+            STMCSIA temp!, {R12, R11, R10, R9}
+            STMMIIA temp!, {R12, R11}
+        }
+    }
+
+#else
+    pv_memset(coef, 0, sizeof(Int32) * sfbWidth);
+#endif
+
+    if (maxInput > 0)
+    {
+
+        shift = QTABLE - QFormat;
+
+        if (scale != 0)
+        {
+            if (maxInput < TABLESIZE)
+            {
+
+                for (i = sfbWidth - 1; i >= 0; i -= 4)
+                {
+                    x = quantSpec[i];
+                    y = quantSpec[i-1];
+                    if (x)
+                    {
+                        absX = pv_abs(x);
+                        mult_high = (x * (inverseQuantTable[absX] >> shift));
+                        coef[i] = fxp_mul32_by_16(mult_high, scale) << 1;
+                    }
+
+                    if (y)
+                    {
+                        absX = pv_abs(y);
+                        mult_high = y * (inverseQuantTable[absX] >> shift);
+                        coef[i-1] = fxp_mul32_by_16(mult_high, scale) << 1;
+                    }
+
+                    x = quantSpec[i-2];
+                    y = quantSpec[i-3];
+                    if (x)
+                    {
+                        absX = pv_abs(x);
+                        mult_high = x * (inverseQuantTable[absX] >> shift);
+                        coef[i-2] = fxp_mul32_by_16(mult_high, scale) << 1;
+                    }
+
+                    if (y)
+                    {
+                        absX = pv_abs(y);
+                        mult_high = y * (inverseQuantTable[absX] >> shift);
+                        coef[i-3] = fxp_mul32_by_16(mult_high, scale) << 1;
+                    }
+                } /* end for (i = sfbWidth - 1; i >= 0; i--) */
+
+            } /* end if (maxInput < TABLESIZE)*/
+
+            else /* maxInput >= TABLESIZE) */
+            {
+                for (i = sfbWidth - 1; i >= 0; i -= 4)
+                {
+                    x    = quantSpec[i];
+                    if (x)
+                    {
+                        absX = pv_abs(x);
+                        if (absX < TABLESIZE)
+                        {
+                            mult_high = x * (inverseQuantTable[absX] >> shift);
+                            coef[i] = fxp_mul32_by_16(mult_high, scale) << 1;
+
+                        }
+                        else
+                        {
+                            index = absX >> ORDER;
+                            w1 = inverseQuantTable[index];
+                            w2 = inverseQuantTable[index+1];
+                            approxOneThird = (w1 * FACTOR) >> shift;
+                            x1 = index << ORDER;
+                            deltaOneThird = (w2 - w1) * (absX - x1);
+                            deltaOneThird >>= (shift + 2);
+                            mult_high = x * (approxOneThird + deltaOneThird);
+                            coef[i] = fxp_mul32_by_16(mult_high, scale) << 1;
+
+                        }
+                    } /* if(x) */
+
+
+                    x    = quantSpec[i-1];
+                    if (x)
+                    {
+                        absX = pv_abs(x);
+                        if (absX < TABLESIZE)
+                        {
+                            mult_high = (x * (inverseQuantTable[absX] >> shift));
+                            coef[i-1] = fxp_mul32_by_16(mult_high, scale) << 1;
+
+                        }
+                        else
+                        {
+                            index = absX >> ORDER;
+                            w1 = inverseQuantTable[index];
+                            w2 = inverseQuantTable[index+1];
+                            approxOneThird = (w1 * FACTOR) >> shift;
+                            x1 = index << ORDER;
+                            deltaOneThird = (w2 - w1) * (absX - x1);
+                            deltaOneThird >>= (shift + 2);
+                            mult_high = x * (approxOneThird + deltaOneThird);
+                            coef[i-1] = fxp_mul32_by_16(mult_high, scale) << 1;
+                        }
+                    } /* if(x) */
+
+                    x    = quantSpec[i-2];
+                    if (x)
+                    {
+                        absX = pv_abs(x);
+                        if (absX < TABLESIZE)
+                        {
+                            mult_high = x * (inverseQuantTable[absX] >> shift);
+                            coef[i-2] = fxp_mul32_by_16(mult_high, scale) << 1;
+                        }
+                        else
+                        {
+                            index = absX >> ORDER;
+                            w1 = inverseQuantTable[index];
+                            w2 = inverseQuantTable[index+1];
+                            approxOneThird = (w1 * FACTOR) >> shift;
+                            x1 = index << ORDER;
+                            deltaOneThird = (w2 - w1) * (absX - x1);
+                            deltaOneThird >>= (shift + 2);
+                            mult_high = x * (approxOneThird + deltaOneThird);
+                            coef[i-2] = fxp_mul32_by_16(mult_high, scale) << 1;
+                        }
+                    } /* if(x) */
+
+                    x    = quantSpec[i-3];
+                    if (x)
+                    {
+                        absX = pv_abs(x);
+                        if (absX < TABLESIZE)
+                        {
+                            mult_high = x * (inverseQuantTable[absX] >> shift);
+                            coef[i-3] = fxp_mul32_by_16(mult_high, scale) << 1;
+
+                        }
+                        else
+                        {
+                            index = absX >> ORDER;
+                            w1 = inverseQuantTable[index];
+                            w2 = inverseQuantTable[index+1];
+                            approxOneThird = (w1 * FACTOR) >> shift;
+                            x1 = index << ORDER;
+                            deltaOneThird = (w2 - w1) * (absX - x1);
+                            deltaOneThird >>= (shift + 2);
+                            mult_high = x * (approxOneThird + deltaOneThird);
+                            coef[i-3] = fxp_mul32_by_16(mult_high, scale) << 1;
+
+                        }
+                    } /* if(x) */
+
+                }  /* end for (i = sfbWidth - 1; i >= 0; i--) */
+            } /* end else for if (maxInput < TABLESIZE)*/
+        }
+        else /* scale == 0 */
+        {
+            if (maxInput < TABLESIZE)
+            {
+                for (i = sfbWidth - 1; i >= 0; i -= 4)
+                {
+                    x = quantSpec[i];
+                    y = quantSpec[i-1];
+                    if (x)
+                    {
+                        absX = pv_abs(x);
+                        mult_high = x * (inverseQuantTable[absX] >> shift);
+                        coef[i] = mult_high >> 1;
+                    }
+
+                    if (y)
+                    {
+                        absX = pv_abs(y);
+                        mult_high = y * (inverseQuantTable[absX] >> shift);
+                        coef[i-1] = mult_high >> 1;
+                    }
+
+                    x = quantSpec[i-2];
+                    y = quantSpec[i-3];
+                    if (x)
+                    {
+                        absX = pv_abs(x);
+                        mult_high = x * (inverseQuantTable[absX] >> shift);
+                        coef[i-2] = mult_high >> 1;
+                    }
+
+                    if (y)
+                    {
+                        absX = pv_abs(y);
+                        mult_high = y * (inverseQuantTable[absX] >> shift);
+                        coef[i-3] = mult_high >> 1;
+                    }
+                }
+
+            } /* end if (maxInput < TABLESIZE)*/
+
+            else /* maxInput >= TABLESIZE) */
+            {
+                for (i = sfbWidth - 1; i >= 0; i -= 4)
+                {
+                    x    = quantSpec[i];
+                    if (x)
+                    {
+                        absX = pv_abs(x);
+                        if (absX < TABLESIZE)
+                        {
+                            mult_high = x * (inverseQuantTable[absX] >> shift);
+                            coef[i] = (mult_high >> 1);
+                        } /* end if (absX < TABLESIZE) */
+                        else
+                        {
+                            index = absX >> ORDER;
+                            w1 = inverseQuantTable[index];
+                            w2 = inverseQuantTable[index+1];
+                            approxOneThird = (w1 * FACTOR) >> shift;
+                            x1 = index << ORDER;
+                            deltaOneThird = (w2 - w1) * (absX - x1);
+                            deltaOneThird >>= (shift + 2);
+                            mult_high = x * (approxOneThird + deltaOneThird);
+                            coef[i] = (mult_high >> 1);
+                        }
+                    } /* if(x) */
+
+                    x    = quantSpec[i-1];
+                    if (x)
+                    {
+                        absX = pv_abs(x);
+                        if (absX < TABLESIZE)
+                        {
+                            mult_high = x * (inverseQuantTable[absX] >> shift);
+                            coef[i-1] = (mult_high >> 1);
+                        } /* end if (absX < TABLESIZE) */
+                        else
+                        {
+                            index = absX >> ORDER;
+                            w1 = inverseQuantTable[index];
+                            w2 = inverseQuantTable[index+1];
+                            approxOneThird = (w1 * FACTOR) >> shift;
+                            x1 = index << ORDER;
+                            deltaOneThird = (w2 - w1) * (absX - x1);
+                            deltaOneThird >>= (shift + 2);
+                            mult_high = x * (approxOneThird + deltaOneThird);
+                            coef[i-1] = (mult_high >> 1);
+                        }
+                    } /* if(x) */
+
+                    x    = quantSpec[i-2];
+                    if (x)
+                    {
+                        absX = pv_abs(x);
+                        if (absX < TABLESIZE)
+                        {
+                            mult_high = x * (inverseQuantTable[absX] >> shift);
+                            coef[i-2] = (mult_high >> 1);
+                        } /* end if (absX < TABLESIZE) */
+                        else
+                        {
+                            index = absX >> ORDER;
+                            w1 = inverseQuantTable[index];
+                            w2 = inverseQuantTable[index+1];
+                            approxOneThird = (w1 * FACTOR) >> shift;
+                            x1 = index << ORDER;
+                            deltaOneThird = (w2 - w1) * (absX - x1);
+                            deltaOneThird >>= (shift + 2);
+                            mult_high = x * (approxOneThird + deltaOneThird);
+                            coef[i-2] = (mult_high >> 1);
+                        }
+                    } /* if(x) */
+
+                    x    = quantSpec[i-3];
+                    if (x)
+                    {
+                        absX = pv_abs(x);
+                        if (absX < TABLESIZE)
+                        {
+                            mult_high = x * (inverseQuantTable[absX] >> shift);
+                            coef[i-3] = (mult_high >> 1);
+                        } /* end if (absX < TABLESIZE) */
+                        else
+                        {
+                            index = absX >> ORDER;
+                            w1 = inverseQuantTable[index];
+                            w2 = inverseQuantTable[index+1];
+                            approxOneThird = (w1 * FACTOR) >> shift;
+                            x1 = index << ORDER;
+                            deltaOneThird = (w2 - w1) * (absX - x1);
+                            deltaOneThird >>= (shift + 2);
+                            mult_high = x * (approxOneThird + deltaOneThird);
+                            coef[i-3] = (mult_high >> 1);
+                        }
+
+                    } /* if(x) */
+
+                }  /* end for (i = sfbWidth - 1; i >= 0; i--) */
+
+            } /* end else for if (maxInput < TABLESIZE)*/
+
+        } /* end else for if(scale!=0) */
+
+    }  /* end else for if(maxInput == 0) */
+
+} /* end esc_iquant_fxp */
+
+
diff --git a/media/libstagefright/codecs/aacdec/esc_iquant_scaling.h b/media/libstagefright/codecs/aacdec/esc_iquant_scaling.h
new file mode 100644
index 0000000..a846b9f
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/esc_iquant_scaling.h
@@ -0,0 +1,102 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Pathname: ./include/esc_iquant_scaling.h
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+ Who:                       Date:
+ Description:
+
+------------------------------------------------------------------------------
+ INCLUDE DESCRIPTION
+
+ Header file for esc_iquant_scaling.c
+
+------------------------------------------------------------------------------
+*/
+
+/*----------------------------------------------------------------------------
+; CONTINUE ONLY IF NOT ALREADY DEFINED
+----------------------------------------------------------------------------*/
+#ifndef ESC_IQUANT_SCALING_H
+#define ESC_IQUANT_SCALING_H
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+#include "pv_audio_type_defs.h"
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here.
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL VARIABLES REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; SIMPLE TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; ENUMERATED TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; STRUCTURES TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; GLOBAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+
+    void esc_iquant_scaling(
+        const Int16   quantSpec[],
+        Int32       coef[],
+        const Int   sfbWidth,
+        Int  const pQFormat,
+        UInt16      scale,
+        Int           maxInput);
+
+#ifdef __cplusplus
+}
+#endif
+
+/*----------------------------------------------------------------------------
+; END
+----------------------------------------------------------------------------*/
+#endif /* ESC_IQUANT_SCALING_H */
+
+
diff --git a/media/libstagefright/codecs/aacdec/extractframeinfo.cpp b/media/libstagefright/codecs/aacdec/extractframeinfo.cpp
new file mode 100644
index 0000000..571cc98
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/extractframeinfo.cpp
@@ -0,0 +1,487 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+  Filename: extractframeInfo.c
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+
+ Who:                                   Date: MM/DD/YYYY
+ Description:
+
+------------------------------------------------------------------------------
+ INPUT AND OUTPUT DEFINITIONS
+
+ Arguments:   hBitBuf      - bitbuffer handle
+              v_frame_info - pointer to memorylocation where the frame-info will
+                             be stored.
+
+ Return:     none.
+
+
+------------------------------------------------------------------------------
+ FUNCTION DESCRIPTION
+
+Extracts a frame_info vector from control data read from the bitstream.
+
+------------------------------------------------------------------------------
+ REQUIREMENTS
+
+
+------------------------------------------------------------------------------
+ REFERENCES
+
+SC 29 Software Copyright Licencing Disclaimer:
+
+This software module was originally developed by
+  Coding Technologies
+
+and edited by
+  -
+
+in the course of development of the ISO/IEC 13818-7 and ISO/IEC 14496-3
+standards for reference purposes and its performance may not have been
+optimized. This software module is an implementation of one or more tools as
+specified by the ISO/IEC 13818-7 and ISO/IEC 14496-3 standards.
+ISO/IEC gives users free license to this software module or modifications
+thereof for use in products claiming conformance to audiovisual and
+image-coding related ITU Recommendations and/or ISO/IEC International
+Standards. ISO/IEC gives users the same free license to this software module or
+modifications thereof for research purposes and further ISO/IEC standardisation.
+Those intending to use this software module in products are advised that its
+use may infringe existing patents. ISO/IEC have no liability for use of this
+software module or modifications thereof. Copyright is not released for
+products that do not conform to audiovisual and image-coding related ITU
+Recommendations and/or ISO/IEC International Standards.
+The original developer retains full right to modify and use the code for its
+own purpose, assign or donate the code to a third party and to inhibit third
+parties from using the code for products that do not conform to audiovisual and
+image-coding related ITU Recommendations and/or ISO/IEC International Standards.
+This copyright notice must be included in all copies or derivative works.
+Copyright (c) ISO/IEC 2002.
+
+------------------------------------------------------------------------------
+ PSEUDO-CODE
+
+------------------------------------------------------------------------------
+*/
+
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+
+#ifdef AAC_PLUS
+
+
+#include    "extractframeinfo.h"
+#include    "buf_getbits.h"
+#include    "aac_mem_funcs.h"
+
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here. Include conditional
+; compile variables also.
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; LOCAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; LOCAL STORE/BUFFER/POINTER DEFINITIONS
+; Variable declaration - defined here and used outside this module
+----------------------------------------------------------------------------*/
+
+
+/*
+ *  (int) ceil (log (bs_num_env + 1) / log (2))
+ *  ceil(log([0:5]+1)/log(2))
+ */
+
+const Int32 bs_pointer_bits_tbl[MAX_ENVELOPES + 1] = { 0, 1, 2, 2, 3, 3};
+
+/*
+ *  (int)((float)numTimeSlots/bs_num_env + 0.5f)
+ *  floor(16./[0:5] + 0.5)
+ */
+
+const Int32 T_16_ov_bs_num_env_tbl[MAX_ENVELOPES + 1] = { 2147483647, 16, 8,
+        5,  4, 3
+                                                        };
+
+
+/*----------------------------------------------------------------------------
+; EXTERNAL FUNCTION REFERENCES
+; Declare functions defined elsewhere and referenced in this module
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL GLOBAL STORE/BUFFER/POINTER REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; FUNCTION CODE
+----------------------------------------------------------------------------*/
+
+
+SBR_ERROR extractFrameInfo(BIT_BUFFER     * hBitBuf,
+                           SBR_FRAME_DATA * h_frame_data)
+{
+
+    Int32 absBordLead = 0;
+    Int32 nRelLead = 0;
+    Int32 nRelTrail = 0;
+    Int32 bs_num_env = 0;
+    Int32 bs_num_rel = 0;
+    Int32 bs_var_bord = 0;
+    Int32 bs_var_bord_0 = 0;
+    Int32 bs_var_bord_1 = 0;
+    Int32 bs_pointer = 0;
+    Int32 bs_pointer_bits;
+    Int32 frameClass;
+    Int32 temp;
+    Int32 env;
+    Int32 k;
+    Int32 bs_num_rel_0 = 0;
+    Int32 bs_num_rel_1 = 0;
+    Int32 absBordTrail = 0;
+    Int32 middleBorder = 0;
+    Int32 bs_num_noise;
+    Int32 lA = 0;
+
+    Int32 tE[MAX_ENVELOPES + 1];
+    Int32 tQ[2 + 1];
+    Int32 f[MAX_ENVELOPES + 1];
+    Int32 bs_rel_bord[3];
+    Int32 bs_rel_bord_0[3];
+    Int32 bs_rel_bord_1[3];
+    Int32 relBordLead[3];
+    Int32 relBordTrail[3];
+
+
+    Int32 *v_frame_info = h_frame_data->frameInfo;
+
+    SBR_ERROR err =  SBRDEC_OK;
+
+
+    /*
+     * First read from the bitstream.
+     */
+
+    /* Read frame class */
+    h_frame_data->frameClass = frameClass = buf_getbits(hBitBuf, SBR_CLA_BITS);
+
+
+    switch (frameClass)
+    {
+
+        case FIXFIX:
+            temp = buf_getbits(hBitBuf, SBR_ENV_BITS);   /* 2 bits */
+
+            bs_num_env = 1 << temp;
+
+
+            f[0] = buf_getbits(hBitBuf, SBR_RES_BITS);   /* 1 bit */
+
+            for (env = 1; env < bs_num_env; env++)
+            {
+                f[env] = f[0];
+            }
+
+            nRelLead     = bs_num_env - 1;
+            absBordTrail  = 16;
+
+
+            break;
+
+        case FIXVAR:
+            bs_var_bord = buf_getbits(hBitBuf, SBR_ABS_BITS);   /* 2 bits */
+            bs_num_rel  = buf_getbits(hBitBuf, SBR_NUM_BITS);   /* 2 bits */
+            bs_num_env  = bs_num_rel + 1;
+
+            for (k = 0; k < bs_num_env - 1; k++)
+            {
+                bs_rel_bord[k] = (buf_getbits(hBitBuf, SBR_REL_BITS) + 1) << 1;
+            }
+
+            bs_pointer_bits = bs_pointer_bits_tbl[bs_num_env];
+
+            bs_pointer = buf_getbits(hBitBuf, bs_pointer_bits);
+
+            for (env = 0; env < bs_num_env; env++)
+            {                                                    /* 1 bit */
+                f[bs_num_env - 1 - env] = buf_getbits(hBitBuf, SBR_RES_BITS);
+            }
+
+            absBordTrail  = 16 + bs_var_bord;
+            nRelTrail     = bs_num_rel;
+
+            break;
+
+        case VARFIX:
+            bs_var_bord = buf_getbits(hBitBuf, SBR_ABS_BITS);   /* 2 bits */
+            bs_num_rel  = buf_getbits(hBitBuf, SBR_NUM_BITS);   /* 2 bits */
+            bs_num_env  = bs_num_rel + 1;
+
+            for (k = 0; k < bs_num_env - 1; k++)
+            {
+                bs_rel_bord[k] = (buf_getbits(hBitBuf, SBR_REL_BITS) + 1) << 1;
+            }
+
+            bs_pointer_bits = bs_pointer_bits_tbl[bs_num_env];
+
+            bs_pointer = buf_getbits(hBitBuf, bs_pointer_bits);
+
+            for (env = 0; env < bs_num_env; env++)
+            {                                  /* 1 bit */
+                f[env] = buf_getbits(hBitBuf, SBR_RES_BITS);
+            }
+
+            absBordTrail = 16;
+            absBordLead  = bs_var_bord;
+            nRelLead     = bs_num_rel;
+
+            break;
+
+        case VARVAR:
+            bs_var_bord_0 = buf_getbits(hBitBuf, SBR_ABS_BITS);   /* 2 bits */
+            bs_var_bord_1 = buf_getbits(hBitBuf, SBR_ABS_BITS);
+            bs_num_rel_0  = buf_getbits(hBitBuf, SBR_NUM_BITS);   /* 2 bits */
+            bs_num_rel_1  = buf_getbits(hBitBuf, SBR_NUM_BITS);
+
+            bs_num_env = bs_num_rel_0 + bs_num_rel_1 + 1;
+
+            for (k = 0; k < bs_num_rel_0; k++)
+            {                                                 /* 2 bits */
+                bs_rel_bord_0[k] = (buf_getbits(hBitBuf, SBR_REL_BITS) + 1) << 1;
+            }
+
+            for (k = 0; k < bs_num_rel_1; k++)
+            {                                                 /* 2 bits */
+                bs_rel_bord_1[k] = (buf_getbits(hBitBuf, SBR_REL_BITS) + 1) << 1;
+            }
+
+
+            bs_pointer_bits = bs_pointer_bits_tbl[bs_num_env];
+
+            bs_pointer = buf_getbits(hBitBuf, bs_pointer_bits);
+
+            for (env = 0; env < bs_num_env; env++)
+            {                                  /* 1 bit */
+                f[env] = buf_getbits(hBitBuf, SBR_RES_BITS);
+            }
+
+            absBordLead   = bs_var_bord_0;
+            absBordTrail  = 16 + bs_var_bord_1;
+            nRelLead      = bs_num_rel_0;
+            nRelTrail     = bs_num_rel_1;
+
+            break;
+
+    };
+
+
+    /*
+     * Calculate the framing.
+     */
+
+
+    switch (frameClass)
+    {
+        case FIXFIX:
+            for (k = 0; k < nRelLead; k++)
+            {
+                relBordLead[k] = T_16_ov_bs_num_env_tbl[bs_num_env];
+            }
+            break;
+        case VARFIX:
+            for (k = 0; k < nRelLead; k++)
+            {
+                relBordLead[k] = bs_rel_bord[k];
+            }
+            break;
+        case VARVAR:
+            for (k = 0; k < nRelLead; k++)
+            {
+                relBordLead[k] = bs_rel_bord_0[k];
+            }
+            for (k = 0; k < nRelTrail; k++)
+            {
+                relBordTrail[k] = bs_rel_bord_1[k];
+            }
+            break;
+        case FIXVAR:
+            for (k = 0; k < nRelTrail; k++)
+            {
+                relBordTrail[k] = bs_rel_bord[k];
+            }
+            break;
+    }
+
+
+    tE[0]          = absBordLead;
+    tE[bs_num_env] = absBordTrail;
+
+    for (env = 1; env <= nRelLead; env++)
+    {
+        tE[env] = absBordLead;
+        for (k = 0; k <= env - 1; k++)
+        {
+            tE[env] += relBordLead[k];
+        }
+    }
+
+    for (env = nRelLead + 1; env < bs_num_env; env++)
+    {
+        tE[env] = absBordTrail;
+        for (k = 0; k <= bs_num_env - env - 1; k++)
+        {
+            tE[env] -= relBordTrail[k];
+        }
+    }
+
+
+
+    switch (frameClass)
+    {
+        case  FIXFIX:
+            middleBorder = bs_num_env >> 1;
+            break;
+        case VARFIX:
+            switch (bs_pointer)
+            {
+                case 0:
+                    middleBorder = 1;
+                    break;
+                case 1:
+                    middleBorder = bs_num_env - 1;
+                    break;
+                default:
+                    middleBorder = bs_pointer - 1;
+                    break;
+            };
+            break;
+        case FIXVAR:
+        case VARVAR:
+            switch (bs_pointer)
+            {
+                case 0:
+                case 1:
+                    middleBorder = bs_num_env - 1;
+                    break;
+                default:
+                    middleBorder = bs_num_env + 1 - bs_pointer;
+                    break;
+            };
+            break;
+    };
+
+
+    tQ[0] = tE[0];
+    if (bs_num_env > 1)
+    {
+        tQ[1] = tE[middleBorder];
+        tQ[2] = tE[bs_num_env];
+        bs_num_noise = 2;
+    }
+    else
+    {
+        tQ[1] = tE[bs_num_env];
+        bs_num_noise = 1;
+    }
+
+    /*
+     *  Check consistency on freq bands
+     */
+
+    if ((tE[bs_num_env] < tE[0]) || (tE[0] < 0))
+    {
+        err = SBRDEC_INVALID_BITSTREAM;
+    }
+
+
+    switch (frameClass)
+    {
+        case  FIXFIX:
+            lA = -1;
+            break;
+        case VARFIX:
+            switch (bs_pointer)
+            {
+                case 0:
+                case 1:
+                    lA = -1;
+                    break;
+                default:
+                    lA = bs_pointer - 1;
+                    break;
+            };
+            break;
+        case FIXVAR:
+        case VARVAR:
+            switch (bs_pointer)
+            {
+                case 0:
+                    lA = - 1;
+                    break;
+                default:
+                    lA = bs_num_env + 1 - bs_pointer;
+                    break;
+            };
+            break;
+    };
+
+    /*
+     * Build the frameInfo vector...
+     */
+
+    v_frame_info[0] = bs_num_env;   /* Number of envelopes*/
+    pv_memcpy(v_frame_info + 1, tE, (bs_num_env + 1)*sizeof(Int32));    /* time borders*/
+    /* frequency resolution */
+    pv_memcpy(v_frame_info + 1 + bs_num_env + 1, f, bs_num_env*sizeof(Int32));
+
+    temp = (1 + bs_num_env) << 1;
+    v_frame_info[temp] = lA;                     /* transient envelope*/
+    v_frame_info[temp + 1] = bs_num_noise;       /* Number of noise envelopes */
+    /* noise borders */
+    pv_memcpy(v_frame_info + temp + 2, tQ, (bs_num_noise + 1)*sizeof(Int32));
+
+
+    return (err);
+
+}
+
+
+
+
+
+
+#endif
+
diff --git a/media/libstagefright/codecs/aacdec/extractframeinfo.h b/media/libstagefright/codecs/aacdec/extractframeinfo.h
new file mode 100644
index 0000000..2fcfe37
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/extractframeinfo.h
@@ -0,0 +1,96 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Filename: extractFrameInfo.h
+
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+
+ Who:                                   Date: MM/DD/YYYY
+ Description:
+------------------------------------------------------------------------------
+
+
+----------------------------------------------------------------------------
+; CONTINUE ONLY IF NOT ALREADY DEFINED
+----------------------------------------------------------------------------*/
+#ifndef EXTRACTFRAMEINFO_H
+#define EXTRACTFRAMEINFO_H
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+#include    "pv_audio_type_defs.h"
+#include    "s_bit_buffer.h"
+#include    "s_sbr_frame_data.h"
+#include    "e_sbr_error.h"
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here.
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL VARIABLES REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; SIMPLE TYPEDEF'S
+----------------------------------------------------------------------------*/
+typedef Int32 FRAME_INFO[LENGTH_FRAME_INFO];
+
+/*----------------------------------------------------------------------------
+; ENUMERATED TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; STRUCTURES TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; GLOBAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+    SBR_ERROR extractFrameInfo(BIT_BUFFER     * hBitBuf,
+    SBR_FRAME_DATA * h_frame_data);
+
+#ifdef __cplusplus
+}
+#endif
+
+/*----------------------------------------------------------------------------
+; END
+----------------------------------------------------------------------------*/
+#endif
+
+
diff --git a/media/libstagefright/codecs/aacdec/fft_rx4.h b/media/libstagefright/codecs/aacdec/fft_rx4.h
new file mode 100644
index 0000000..8e7acb3
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/fft_rx4.h
@@ -0,0 +1,110 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Pathname: ./include/fft_rx4.h
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+        (1) modified definition of w_64rx4 from Int to Int16
+
+ Who:                   Date:
+ Description:
+
+------------------------------------------------------------------------------
+ INCLUDE DESCRIPTION
+
+ Header file for functions fft_rx4()
+
+
+------------------------------------------------------------------------------
+*/
+
+/*----------------------------------------------------------------------------
+; CONTINUE ONLY IF NOT ALREADY DEFINED
+----------------------------------------------------------------------------*/
+#ifndef FFT_RX4_H
+#define FFT_RX4_H
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+#include "pv_audio_type_defs.h"
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here.
+----------------------------------------------------------------------------*/
+#define     FFT_RX4_LONG                256
+#define     ONE_FOURTH_FFT_RX4_LONG     ((FFT_RX4_LONG)>>2)
+#define     FFT_RX4_SHORT               64
+#define     ONE_FOURTH_FFT_RX4_SHORT    ((FFT_RX4_SHORT)>>2)
+
+/*----------------------------------------------------------------------------
+; EXTERNAL VARIABLES REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+extern const Int16 w_64rx4[];
+extern const Int32 W_64rx4[];
+extern const Int32 W_256rx4[];
+extern const Int32 w_512rx2[];
+
+/*----------------------------------------------------------------------------
+; SIMPLE TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; ENUMERATED TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; STRUCTURES TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; GLOBAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+    void fft_rx4_long(
+        Int32      Data[],
+        Int32      *peak_value);
+
+    Int fft_rx4_short(
+        Int32      Data[],
+        Int32      *peak_value);
+
+#ifdef __cplusplus
+}
+#endif
+
+/*----------------------------------------------------------------------------
+; END
+----------------------------------------------------------------------------*/
+#endif  /* FFT_RX4_H */
diff --git a/media/libstagefright/codecs/aacdec/fft_rx4_long.cpp b/media/libstagefright/codecs/aacdec/fft_rx4_long.cpp
new file mode 100644
index 0000000..c517e7e
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/fft_rx4_long.cpp
@@ -0,0 +1,428 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Pathname: ./src/fft_rx4_long.c
+ Funtions: fft_rx4_long
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+ Description:
+            (1) Eliminated search for max in the main loop.
+            (2) Reduced precision on w_256rx4 from Q15 to Q10
+
+ Description:
+            (1) Created function fft_rx4_long_no_max to overcome LTP problem.
+
+ Description:
+            (1) Modified shift so the accumulation growths faster than the
+                downshift, so now the input can be as high as 1.0 and saturation
+                will not occurre. The accumulation times the Q10 format will
+                never exceed 31 bits. This increases precision
+            (2) Eliminated unneeded data moves, used before for max search.
+            (3) Eliminated function fft_rx4_long_no_max.
+
+ Description:
+            (1) Added comment to explain max search elimination and
+                Q format during multiplications
+
+ Who:                       Date:
+ Description:
+
+------------------------------------------------------------------------------
+ INPUT AND OUTPUT DEFINITIONS
+
+ Inputs:
+    Data       =  Input complex vector, arranged in the following order:
+                  real, imag, real, imag...
+                  This is a complex vector whose elements (real and Imag) are
+                  Int32.
+                  type Int32 *
+
+    peak_value =  Input,  peak value of the input vector
+                  Output,  peak value of the resulting vector
+                  type Int32 *
+
+ Local Stores/Buffers/Pointers Needed:
+    None
+
+ Global Stores/Buffers/Pointers Needed:
+    None
+
+ Outputs:
+    None
+
+ Pointers and Buffers Modified:
+    calculation are done in-place and returned in Data
+
+ Local Stores Modified:
+    None
+
+ Global Stores Modified:
+    None
+
+------------------------------------------------------------------------------
+ FUNCTION DESCRIPTION
+
+    Fast Fourier Transform, radix 4 with Decimation in Frequency and block
+    floating point arithmetic.
+    The radix-4 FFT  simply divides the FFT into four smaller FFTs. Each of
+    the smaller FFTs is then further divided into smaller ones and so on.
+    It consists of log 4 N stages and each stage consists of N/4 dragonflies.
+
+    An FFT is nothing but a bundle of multiplications and summations which
+    may overflow during calculations.
+
+
+    This routine uses a scheme to test and scale the result output from
+    each FFT stage in order to fix the accumulation overflow.
+
+    The Input Data should be in Q13 format to get the highest precision.
+    At the end of each dragonfly calculation, a test for possible bit growth
+    is made, if bit growth is possible the Data is scale down back to Q13.
+
+------------------------------------------------------------------------------
+ REQUIREMENTS
+
+    This function should provide a fixed point FFT for an input array
+    of size 256.
+
+------------------------------------------------------------------------------
+ REFERENCES
+
+    [1] Advance Digital Signal Processing, J. Proakis, C. Rader, F. Ling,
+        C. Nikias, Macmillan Pub. Co.
+
+------------------------------------------------------------------------------
+ PSEUDO-CODE
+
+
+   MODIFY( x[] )
+   RETURN( exponent )
+
+------------------------------------------------------------------------------
+ RESOURCES USED
+   When the code is written for a specific target processor the
+     the resources used should be documented below.
+
+ STACK USAGE: [stack count for this module] + [variable to represent
+          stack usage for each subroutine called]
+
+     where: [stack usage variable] = stack usage for [subroutine
+         name] (see [filename].ext)
+
+ DATA MEMORY USED: x words
+
+ PROGRAM MEMORY USED: x words
+
+ CLOCK CYCLES: [cycle count equation for this module] + [variable
+           used to represent cycle count for each subroutine
+           called]
+
+     where: [cycle count variable] = cycle count for [subroutine
+        name] (see [filename].ext)
+
+------------------------------------------------------------------------------
+*/
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+
+#include "pv_audio_type_defs.h"
+#include "fft_rx4.h"
+
+#include "fxp_mul32.h"
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here. Include conditional
+; compile variables also.
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; LOCAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; LOCAL VARIABLE DEFINITIONS
+; Variable declaration - defined here and used outside this module
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL FUNCTION REFERENCES
+; Declare functions defined elsewhere and referenced in this module
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL VARIABLES REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL GLOBAL STORE/BUFFER/POINTER REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; FUNCTION CODE
+----------------------------------------------------------------------------*/
+
+
+void fft_rx4_long(
+    Int32      Data[],
+    Int32      *peak_value)
+
+{
+    Int     n1;
+    Int     n2;
+    Int     j;
+    Int     k;
+    Int     i;
+
+    Int32   t1;
+    Int32   t2;
+    Int32   r1;
+    Int32   r2;
+    Int32   r3;
+    Int32   r4;
+    Int32   s1;
+    Int32   s2;
+    Int32   s3;
+    Int32   *pData1;
+    Int32   *pData2;
+    Int32   *pData3;
+    Int32   *pData4;
+    Int32   temp1;
+    Int32   temp2;
+    Int32   temp3;
+    Int32   temp4;
+    Int32   max;
+
+    Int32   exp_jw1;
+    Int32   exp_jw2;
+    Int32   exp_jw3;
+
+
+
+    const Int32  *pw = W_256rx4;
+
+    n2 = FFT_RX4_LONG;
+
+    for (k = FFT_RX4_LONG; k > 4; k >>= 2)
+    {
+
+        n1 = n2;
+        n2 >>= 2;
+
+        for (i = 0; i < FFT_RX4_LONG; i += n1)
+        {
+            pData1 = &Data[ i<<1];
+            pData2 = pData1 + n1;
+
+            temp1   = *pData1;
+            temp2   = *pData2;
+
+            r1      = temp1 + temp2;
+            r2      = temp1 - temp2;
+
+            pData3 = pData1 + (n1 >> 1);
+            pData4 = pData3 + n1;
+            temp3   = *pData3++;
+            temp4   = *pData4++;
+
+            t1      = temp3 + temp4;
+
+            *(pData1++) = (r1 + t1);
+            t2      = temp3 - temp4;
+            *(pData2++) = (r1 - t1);
+
+            temp1   = *pData1;
+            temp2   = *pData2;
+
+            s1      = temp1 + temp2;
+            temp3   = *pData3;
+            s2      = temp1 - temp2;
+            temp4   = *pData4;
+            *pData3--  = (s2 - t2);
+            *pData4--  = (s2 + t2);
+
+            t1      = temp3 + temp4;
+
+            *pData1    = (s1 + t1);
+            *pData2    = (s1 - t1);
+
+            r1      = temp3 - temp4;
+
+            *pData4    = (r2 - r1);
+            *pData3    = (r2 + r1);
+
+        }  /* i */
+
+
+
+        for (j = 1; j < n2; j++)
+        {
+
+            exp_jw1 = (*pw++);
+            exp_jw2 = (*pw++);
+            exp_jw3 = (*pw++);
+
+
+            for (i = j; i < FFT_RX4_LONG; i += n1)
+            {
+                pData1 = &Data[ i<<1];
+                pData2 = pData1 + n1;
+
+                temp1   = *pData1;
+                temp2   = *pData2++;
+
+                r1      = temp1 + temp2;
+                r2      = temp1 - temp2;
+
+                pData3 = pData1 + (n1 >> 1);
+                pData4 = pData3 + n1;
+                temp3   = *pData3++;
+                temp4   = *pData4++;
+
+                r3      = temp3 + temp4;
+                r4      = temp3 - temp4;
+
+                *(pData1++) = (r1 + r3);
+                r1          = (r1 - r3) << 1;
+
+                temp2   = *pData2;
+                temp1   = *pData1;
+
+                s1      = temp1 + temp2;
+                s2      = temp1 - temp2;
+                s3      = (s2 + r4) << 1;
+                s2      = (s2 - r4) << 1;
+
+                temp3   = *pData3;
+                temp4   = *pData4;
+
+                t1      = temp3 + temp4;
+                t2      = temp3 - temp4;
+
+                *pData1  = (s1 + t1);
+                s1       = (s1 - t1) << 1;
+
+                *pData2--  = cmplx_mul32_by_16(s1, -r1, exp_jw2);
+                r3      = (r2 - t2) << 1;
+                *pData2    = cmplx_mul32_by_16(r1,  s1, exp_jw2);
+
+                r2      = (r2 + t2) << 1;
+
+                *pData3--  = cmplx_mul32_by_16(s2, -r2, exp_jw1);
+                *pData3    = cmplx_mul32_by_16(r2,  s2, exp_jw1);
+
+                *pData4--  = cmplx_mul32_by_16(s3, -r3, exp_jw3);
+                *pData4    = cmplx_mul32_by_16(r3,  s3, exp_jw3);
+
+            }  /* i */
+
+        }  /*  j */
+
+    } /* k */
+
+
+    max = 0;
+
+    pData1 = Data - 7;
+
+
+    for (i = ONE_FOURTH_FFT_RX4_LONG; i != 0 ; i--)
+    {
+        pData1 += 7;
+        pData2 = pData1 + 4;
+
+
+        temp1   = *pData1;
+        temp2   = *pData2++;
+
+        r1      = temp1 + temp2;
+        r2      = temp1 - temp2;
+
+        pData3 = pData1 + 2;
+        pData4 = pData1 + 6;
+        temp1   = *pData3++;
+        temp2   = *pData4++;
+
+        t1      = temp1 + temp2;
+        t2      = temp1 - temp2;
+
+        temp1       = (r1 + t1);
+        r1          = (r1 - t1);
+        *(pData1++) = temp1;
+        max        |= (temp1 >> 31) ^ temp1;
+
+
+
+        temp2   = *pData2;
+        temp1   = *pData1;
+
+        s1      = temp1 + temp2;
+        s2      = temp1 - temp2;
+
+
+        temp1   = *pData3;
+        temp2   = *pData4;
+
+        s3      = (s2 + t2);
+        s2      = (s2 - t2);
+
+        t1      = temp1 + temp2;
+        t2      = temp1 - temp2;
+
+        temp1      = (s1 + t1);
+        *pData1    = temp1;
+        temp2      = (s1 - t1);
+
+        max       |= (temp1 >> 31) ^ temp1;
+        *pData2--  = temp2;
+        max       |= (temp2 >> 31) ^ temp2;
+
+        *pData2    = r1;
+        max       |= (r1 >> 31) ^ r1;
+        *pData3--  = s2;
+        max       |= (s2 >> 31) ^ s2;
+        *pData4--  = s3;
+        max       |= (s3 >> 31) ^ s3;
+
+        temp1      = (r2 - t2);
+        *pData4    = temp1;
+        temp2      = (r2 + t2);
+        *pData3    = temp2;
+        max       |= (temp1 >> 31) ^ temp1;
+        max       |= (temp2 >> 31) ^ temp2;
+
+    }  /* i */
+
+    *peak_value = max;
+
+    return ;
+
+}
+
diff --git a/media/libstagefright/codecs/aacdec/fft_rx4_short.cpp b/media/libstagefright/codecs/aacdec/fft_rx4_short.cpp
new file mode 100644
index 0000000..4a8a0d6
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/fft_rx4_short.cpp
@@ -0,0 +1,468 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Pathname: ./src/fft_rx4_short.c
+ Funtions: fft_rx4_short
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+ Description:
+            (1) Eliminated search for max in the main loop.
+            (2) Simplified the function by eliminating different conditions
+                for exp.
+            (3) Reduced precision on w_64rx4 from Q15 to Q12, so now the
+                input can be as high as 1.0 and saturation will not occurre
+                because the accumulation times the new Q12 format will never
+                exceed 31 bits.
+
+ Description:
+            (1) Added comment to explain max search elimination and
+                Q format during multiplications
+            (2) Increased down shift from 1 to 2, to ensure that 32-bit
+                numbers will not overflow when 2 consecutive adds are done
+                This was found during code review.
+
+ Who:                                   Date:
+ Description:
+
+------------------------------------------------------------------------------
+ INPUT AND OUTPUT DEFINITIONS
+
+ Inputs:
+    Data       =  Input complex vector, arranged in the following order:
+                  real, imag, real, imag...
+                  This is a complex vector whose elements (real and Imag) are
+                  Int32.
+                  type Int32 *
+
+    peak_value =  Input,  peak value of the input vector
+                  Output,  peak value of the resulting vector
+                  type Int32 *
+
+ Local Stores/Buffers/Pointers Needed:
+    None
+
+ Global Stores/Buffers/Pointers Needed:
+    None
+
+ Outputs:
+    exponent returns a shift to compensate the scaling introduced by
+    overflow protection
+
+ Pointers and Buffers Modified:
+    calculation are done in-place and returned in Data
+
+ Local Stores Modified:
+    None
+
+ Global Stores Modified:
+    None
+
+------------------------------------------------------------------------------
+ FUNCTION DESCRIPTION
+
+    Fast Fourier Transform, radix 4 with Decimation in Frequency and block
+    floating point arithmetic.
+    The radix-4 FFT  simply divides the FFT into four smaller FFTs. Each of
+    the smaller FFTs is then further divided into smaller ones and so on.
+    It consists of log 4 N stages and each stage consists of N/4 dragonflies.
+
+    An FFT is nothing but a bundle of multiplications and summations which
+    may overflow during calculations.
+
+
+    This routine uses a scheme to test and scale the result output from
+    each FFT stage in order to fix the accumulation overflow.
+
+    The Input Data should be in Q13 format to get the highest precision.
+    At the end of each dragonfly calculation, a test for possible bit growth
+    is made, if bit growth is possible the Data is scale down back to Q13.
+
+
+------------------------------------------------------------------------------
+ REQUIREMENTS
+
+    This function should provide a fixed point FFT for an input array
+    of size 64.
+
+------------------------------------------------------------------------------
+ REFERENCES
+
+    [1] Advance Digital Signal Processing, J. Proakis, C. Rader, F. Ling,
+        C. Nikias, Macmillan Pub. Co.
+
+------------------------------------------------------------------------------
+ PSEUDO-CODE
+
+
+   MODIFY( x[] )
+   RETURN( exponent )
+
+------------------------------------------------------------------------------
+ RESOURCES USED
+   When the code is written for a specific target processor the
+     the resources used should be documented below.
+
+ STACK USAGE: [stack count for this module] + [variable to represent
+          stack usage for each subroutine called]
+
+     where: [stack usage variable] = stack usage for [subroutine
+         name] (see [filename].ext)
+
+ DATA MEMORY USED: x words
+
+ PROGRAM MEMORY USED: x words
+
+ CLOCK CYCLES: [cycle count equation for this module] + [variable
+           used to represent cycle count for each subroutine
+           called]
+
+     where: [cycle count variable] = cycle count for [subroutine
+        name] (see [filename].ext)
+
+------------------------------------------------------------------------------
+*/
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+
+#include "pv_audio_type_defs.h"
+#include "fft_rx4.h"
+#include "pv_normalize.h"
+#include "fxp_mul32.h"
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here. Include conditional
+; compile variables also.
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; LOCAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; LOCAL VARIABLE DEFINITIONS
+; Variable declaration - defined here and used outside this module
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL FUNCTION REFERENCES
+; Declare functions defined elsewhere and referenced in this module
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL VARIABLES REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL GLOBAL STORE/BUFFER/POINTER REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; FUNCTION CODE
+----------------------------------------------------------------------------*/
+
+Int fft_rx4_short(
+    Int32      Data[],
+    Int32      *peak_value)
+
+{
+    Int     n1;
+    Int     n2;
+    Int     n3;
+    Int     j;
+    Int     k;
+    Int     i;
+    Int32   exp_jw1;
+    Int32   exp_jw2;
+    Int32   exp_jw3;
+
+
+    Int32   t1;
+    Int32   t2;
+    Int32   r1;
+    Int32   r2;
+    Int32   r3;
+    Int32   s1;
+    Int32   s2;
+    Int32   s3;
+
+    Int32   *pData1;
+    Int32   *pData2;
+    Int32   *pData3;
+    Int32   *pData4;
+    const Int32  *pw;
+    Int32   temp1;
+    Int32   temp2;
+    Int32   temp3;
+    Int32   temp4;
+    Int32   max;
+    Int     exp;
+    Int     exponent = 0;
+    Int     shift;
+
+
+    max = *peak_value;
+    exp = 0;
+
+    if (max > 0x008000)
+    {
+        exp = 8 - pv_normalize(max);   /* use 24 bits  */
+
+        exponent = exp;        /* keeps track of # of shifts */
+
+    }
+
+    n2 = FFT_RX4_SHORT;
+
+    pw = W_64rx4;
+
+
+    /* shift down to avoid possible overflow in first pass of the loop */
+    shift = 2;
+
+    for (k = FFT_RX4_SHORT; k > 4; k >>= 2)
+    {
+
+        n1 = n2;
+        n2 >>= 2;
+        n3 = n1 >> 1;
+
+        exp -= 2;
+
+        for (i = 0; i < FFT_RX4_SHORT; i += n1)
+        {
+            pData1 = &Data[ i<<1];
+            pData3 = pData1 + n3;
+            pData2 = pData1 + n1;
+            pData4 = pData3 + n1;
+
+            temp1   = *(pData1);
+            temp2   = *(pData2);
+            temp1   >>= shift;
+            temp2   >>= shift;
+
+            r1      = temp1 + temp2;
+            r2      = temp1 - temp2;
+
+            temp3   = *(pData3++);
+            temp4   = *(pData4++);
+            temp3   >>= shift;
+            temp4   >>= shift;
+
+            t1      = temp3 + temp4;
+            t2      = temp3 - temp4;
+
+            *(pData1++) = (r1 + t1) >> exp;
+            *(pData2++) = (r1 - t1) >> exp;
+
+            temp1   = *pData1;
+            temp2   = *pData2;
+            temp1   >>= shift;
+            temp2   >>= shift;
+
+            s1      = temp1 + temp2;
+            s2      = temp1 - temp2;
+
+            temp3   = *pData3;
+            temp4   = *pData4;
+            temp3   >>= shift;
+            temp4   >>= shift;
+
+            t1      = temp3 + temp4;
+            r1      = temp3 - temp4;
+
+            *pData1   = (s1 + t1) >> exp;
+            *pData2   = (s1 - t1) >> exp;
+
+            *pData4--    = (s2 + t2) >> exp;
+            *pData4      = (r2 - r1) >> exp;
+
+            *pData3--    = (s2 - t2) >> exp;
+            *pData3      = (r2 + r1) >> exp;
+
+
+        }  /* i */
+
+        for (j = 1; j < n2; j++)
+        {
+            exp_jw1 = *pw++;
+            exp_jw2 = *pw++;
+            exp_jw3 = *pw++;
+
+
+            for (i = j; i < FFT_RX4_SHORT; i += n1)
+            {
+                pData1 = &Data[ i<<1];
+                pData3 = pData1 + n3;
+                pData2 = pData1 + n1;
+                pData4 = pData3 + n1;
+
+                temp1   = *(pData1);
+                temp2   = *(pData2++);
+                temp1   >>= shift;
+                temp2   >>= shift;
+
+                r1      = temp1 + temp2;
+                r2      = temp1 - temp2;
+                temp3   = *(pData3++);
+                temp4   = *(pData4++);
+                temp3   >>= shift;
+                temp4   >>= shift;
+
+                t1      = temp3 + temp4;
+                t2      = temp3 - temp4;
+
+                *(pData1++) = (r1 + t1) >> exp;
+                r1          = (r1 - t1) >> exp;
+
+                temp1   = *pData1;
+                temp2   = *pData2;
+                temp1   >>= shift;
+                temp2   >>= shift;
+
+                s1      = temp1 + temp2;
+                s2      = temp1 - temp2;
+
+                s3      = (s2 + t2) >> exp;
+                s2      = (s2 - t2) >> exp;
+
+                temp3   = *pData3;
+                temp4   = *pData4 ;
+                temp3   >>= shift;
+                temp4   >>= shift;
+
+                t1      = temp3 + temp4;
+                t2      = temp3 - temp4;
+
+                *pData1  = (s1 + t1) >> exp;
+                s1       = (s1 - t1) >> exp;
+
+
+                *pData2--  = cmplx_mul32_by_16(s1, -r1, exp_jw2) << 1;
+                *pData2    = cmplx_mul32_by_16(r1,  s1, exp_jw2) << 1;
+
+                r3       = ((r2 - t2) >> exp);
+                r2       = ((r2 + t2) >> exp);
+
+                *pData3--  = cmplx_mul32_by_16(s2, -r2, exp_jw1) << 1;
+                *pData3    = cmplx_mul32_by_16(r2,  s2, exp_jw1) << 1;
+
+                *pData4--  = cmplx_mul32_by_16(s3, -r3, exp_jw3) << 1;
+                *pData4    = cmplx_mul32_by_16(r3,  s3, exp_jw3) << 1;
+
+            }  /* i */
+
+        }  /*  j */
+
+        /*
+         *  this will reset exp and shift to zero for the second pass of the
+         *  loop
+         */
+        exp   = 2;
+        shift = 0;
+
+    } /* k */
+
+
+    max = 0;
+
+    pData1 = Data - 7;
+
+    for (i = ONE_FOURTH_FFT_RX4_SHORT; i != 0 ; i--)
+    {
+        pData1 += 7;
+
+        pData3 = pData1 + 2;
+        pData2 = pData1 + 4;
+        pData4 = pData1 + 6;
+
+        temp1   = *pData1;
+        temp2   = *pData2++;
+
+        r1      = temp1 + temp2;
+        r2      = temp1 - temp2;
+
+        temp1   = *pData3++;
+        temp2   = *pData4++;
+
+        t1      = temp1 + temp2;
+        t2      = temp1 - temp2;
+
+        temp1       = (r1 + t1);
+        r1          = (r1 - t1);
+        *(pData1++) = temp1;
+        max        |= (temp1 >> 31) ^ temp1;
+
+
+
+        temp1   = *pData1;
+        temp2   = *pData2;
+
+        s1      = temp1 + temp2;
+        s2      = temp1 - temp2;
+
+        s3      = (s2 + t2);
+        s2      = (s2 - t2);
+
+        temp1   = *pData3;
+        temp2   = *pData4;
+
+        t1      = temp1 + temp2;
+        t2      = temp1 - temp2;
+
+        temp1      = (s1 + t1);
+        temp2      = (s1 - t1);
+        *pData1    = temp1;
+        *pData2--  = temp2;
+        max       |= (temp1 >> 31) ^ temp1;
+        max       |= (temp2 >> 31) ^ temp2;
+
+        *pData2    = r1;
+        *pData3--  = s2;
+        *pData4--  = s3;
+        max       |= (r1 >> 31) ^ r1;
+        max       |= (s2 >> 31) ^ s2;
+        max       |= (s3 >> 31) ^ s3;
+
+        temp1      = (r2 - t2);
+        temp2      = (r2 + t2);
+        *pData4    = temp1;
+        *pData3    = temp2;
+        max       |= (temp1 >> 31) ^ temp1;
+        max       |= (temp2 >> 31) ^ temp2;
+
+    }  /* i */
+
+    *peak_value = max;
+
+
+    return (exponent);
+
+}
diff --git a/media/libstagefright/codecs/aacdec/fft_rx4_tables_fxp.cpp b/media/libstagefright/codecs/aacdec/fft_rx4_tables_fxp.cpp
new file mode 100644
index 0000000..2476b87
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/fft_rx4_tables_fxp.cpp
@@ -0,0 +1,269 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Pathname: ./src/fft_rx4_tables_fxp.c
+ Funtions:
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+ Description:  Reduce the accuracy of w_256rx4 and w_512rx2 to Q10 format.
+            Try to to pack sin and cos into one 32-bit number to reduce the
+            memory access, but doesn't help in speed, so commented out for now.
+
+ Description:
+        (1) Reduced precision of w_64rx4 from Q15 to Q12.
+        (2) Increased precision of w_512rx2 from Q10 to Q13, Both changes
+            increase overall decoder precision
+
+ Description:
+        (1) per code review comment, added description for table generation
+        (2) modified definition of w_64rx4 from Int to Int16
+
+
+ Who:                           Date:
+ Description:
+
+  ----------------------------------------------------------------------------
+ MODULE DESCRIPTION
+
+  Table generation
+
+ n = 256  or  64;
+ M = precision; 2^10, 2^12, 2^13
+
+ for j=1; j<log4(n); j *= 4
+
+    for i=0; i<n/4; i +=j
+
+        phi_1 = 2*pi*i/n;
+        phi_2 = 4*pi*i/n;
+        phi_3 = 6*pi*i/n;
+        M*[cos(phi_1) sin(phi_1) cos(phi_2) sin(phi_2) cos(phi_3) sin(phi_4)];
+
+    end
+
+ end
+
+------------------------------------------------------------------------------
+*/
+
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+
+#include "fft_rx4.h"
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here. Include conditional
+; compile variables also.
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; LOCAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; LOCAL VARIABLE DEFINITIONS
+; Variable declaration - defined here and used outside this module
+----------------------------------------------------------------------------*/
+
+
+/*----------------------------------------------------------------------------
+; EXTERNAL FUNCTION REFERENCES
+; Declare functions defined elsewhere and referenced in this module
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL VARIABLES REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+/*
+------------------------------------------------------------------------------
+ Forward FFT radix-4 tables
+------------------------------------------------------------------------------
+*/
+
+
+const Int32 W_64rx4[60] =            /* 2 Q15  */
+{
+
+    0x7F610C8C,  0x7D8918F9,  0x7A7C2528,
+    0x7D8918F9,  0x764130FB,  0x6A6D471C,
+    0x7A7C2528,  0x6A6D471C,  0x513362F1,
+    0x764130FB,  0x5A825A82,  0x30FB7641,
+    0x70E23C56,  0x471C6A6D,  0x0C8C7F61,
+    0x6A6D471C,  0x30FB7641,  0xE7057D89,
+    0x62F15133,  0x18F97D89,  0xC3A870E2,
+    0x5A825A82,  0x00007FFF,  0xA57C5A82,
+    0x513362F1,  0xE7057D89,  0x8F1C3C56,
+    0x471C6A6D,  0xCF037641,  0x827518F9,
+    0x3C5670E2,  0xB8E26A6D,  0x809DF372,
+    0x30FB7641,  0xA57C5A82,  0x89BDCF03,
+    0x25287A7C,  0x9591471C,  0x9D0DAECB,
+    0x18F97D89,  0x89BD30FB,  0xB8E29591,
+    0x0C8C7F61,  0x827518F9,  0xDAD68582,
+    0x764130FB,  0x5A825A82,  0x30FB7641,
+    0x5A825A82,  0x00007FFF,  0xA57C5A82,
+    0x30FB7641,  0xA57C5A82,  0x89BDCF03,
+};
+
+
+
+const Int32 W_256rx4[495] =            /* 2 Q15  */
+{
+
+    0x7FF50324,  0x7FD80648,  0x7FA6096A,
+    0x7FD80648,  0x7F610C8C,  0x7E9C12C8,
+    0x7FA6096A,  0x7E9C12C8,  0x7CE31C0B,
+    0x7F610C8C,  0x7D8918F9,  0x7A7C2528,
+    0x7F090FAB,  0x7C291F1A,  0x776B2E11,
+    0x7E9C12C8,  0x7A7C2528,  0x73B536BA,
+    0x7E1D15E2,  0x78842B1F,  0x6F5E3F17,
+    0x7D8918F9,  0x764130FB,  0x6A6D471C,
+    0x7CE31C0B,  0x73B536BA,  0x64E84EBF,
+    0x7C291F1A,  0x70E23C56,  0x5ED755F5,
+    0x7B5C2223,  0x6DC941CE,  0x58425CB3,
+    0x7A7C2528,  0x6A6D471C,  0x513362F1,
+    0x79892826,  0x66CF4C3F,  0x49B468A6,
+    0x78842B1F,  0x62F15133,  0x41CE6DC9,
+    0x776B2E11,  0x5ED755F5,  0x398C7254,
+    0x764130FB,  0x5A825A82,  0x30FB7641,
+    0x750433DF,  0x55F55ED7,  0x28267989,
+    0x73B536BA,  0x513362F1,  0x1F1A7C29,
+    0x7254398C,  0x4C3F66CF,  0x15E27E1D,
+    0x70E23C56,  0x471C6A6D,  0x0C8C7F61,
+    0x6F5E3F17,  0x41CE6DC9,  0x03247FF5,
+    0x6DC941CE,  0x3C5670E2,  0xF9B67FD8,
+    0x6C23447A,  0x36BA73B5,  0xF0537F09,
+    0x6A6D471C,  0x30FB7641,  0xE7057D89,
+    0x68A649B4,  0x2B1F7884,  0xDDDB7B5C,
+    0x66CF4C3F,  0x25287A7C,  0xD4DF7884,
+    0x64E84EBF,  0x1F1A7C29,  0xCC1F7504,
+    0x62F15133,  0x18F97D89,  0xC3A870E2,
+    0x60EB539B,  0x12C87E9C,  0xBB846C23,
+    0x5ED755F5,  0x0C8C7F61,  0xB3BF66CF,
+    0x5CB35842,  0x06487FD8,  0xAC6360EB,
+    0x5A825A82,  0x00007FFF,  0xA57C5A82,
+    0x58425CB3,  0xF9B67FD8,  0x9F13539B,
+    0x55F55ED7,  0xF3727F61,  0x992F4C3F,
+    0x539B60EB,  0xED367E9C,  0x93DB447A,
+    0x513362F1,  0xE7057D89,  0x8F1C3C56,
+    0x4EBF64E8,  0xE0E47C29,  0x8AFA33DF,
+    0x4C3F66CF,  0xDAD67A7C,  0x877A2B1F,
+    0x49B468A6,  0xD4DF7884,  0x84A22223,
+    0x471C6A6D,  0xCF037641,  0x827518F9,
+    0x447A6C23,  0xC94473B5,  0x80F50FAB,
+    0x41CE6DC9,  0xC3A870E2,  0x80260648,
+    0x3F176F5E,  0xBE306DC9,  0x8009FCDA,
+    0x3C5670E2,  0xB8E26A6D,  0x809DF372,
+    0x398C7254,  0xB3BF66CF,  0x81E1EA1C,
+    0x36BA73B5,  0xAECB62F1,  0x83D5E0E4,
+    0x33DF7504,  0xAA095ED7,  0x8675D7D8,
+    0x30FB7641,  0xA57C5A82,  0x89BDCF03,
+    0x2E11776B,  0xA12755F5,  0x8DAAC672,
+    0x2B1F7884,  0x9D0D5133,  0x9235BE30,
+    0x28267989,  0x992F4C3F,  0x9758B64A,
+    0x25287A7C,  0x9591471C,  0x9D0DAECB,
+    0x22237B5C,  0x923541CE,  0xA34BA7BC,
+    0x1F1A7C29,  0x8F1C3C56,  0xAA09A127,
+    0x1C0B7CE3,  0x8C4936BA,  0xB13F9B16,
+    0x18F97D89,  0x89BD30FB,  0xB8E29591,
+    0x15E27E1D,  0x877A2B1F,  0xC0E790A0,
+    0x12C87E9C,  0x85822528,  0xC9448C49,
+    0x0FAB7F09,  0x83D51F1A,  0xD1ED8893,
+    0x0C8C7F61,  0x827518F9,  0xDAD68582,
+    0x096A7FA6,  0x816212C8,  0xE3F3831B,
+    0x06487FD8,  0x809D0C8C,  0xED368162,
+    0x03247FF5,  0x80260648,  0xF6948058,
+    0x7F610C8C,  0x7D8918F9,  0x7A7C2528,
+    0x7D8918F9,  0x764130FB,  0x6A6D471C,
+    0x7A7C2528,  0x6A6D471C,  0x513362F1,
+    0x764130FB,  0x5A825A82,  0x30FB7641,
+    0x70E23C56,  0x471C6A6D,  0x0C8C7F61,
+    0x6A6D471C,  0x30FB7641,  0xE7057D89,
+    0x62F15133,  0x18F97D89,  0xC3A870E2,
+    0x5A825A82,  0x00007FFF,  0xA57C5A82,
+    0x513362F1,  0xE7057D89,  0x8F1C3C56,
+    0x471C6A6D,  0xCF037641,  0x827518F9,
+    0x3C5670E2,  0xB8E26A6D,  0x809DF372,
+    0x30FB7641,  0xA57C5A82,  0x89BDCF03,
+    0x25287A7C,  0x9591471C,  0x9D0DAECB,
+    0x18F97D89,  0x89BD30FB,  0xB8E29591,
+    0x0C8C7F61,  0x827518F9,  0xDAD68582,
+    0x764130FB,  0x5A825A82,  0x30FB7641,
+    0x5A825A82,  0x00007FFF,  0xA57C5A82,
+    0x30FB7641,  0xA57C5A82,  0x89BDCF03
+};
+
+
+
+/*
+------------------------------------------------------------------------------
+ Forward FFT radix-2 table
+------------------------------------------------------------------------------
+*/
+
+
+const Int32 w_512rx2[127] =
+{
+    /* Q15  */
+    0x7FFE0192, 0x7FF60324, 0x7FEA04B6,
+    0x7FD90648,  0x7FC207D9, 0x7FA7096B, 0x7F870AFB,
+    0x7F620C8C,  0x7F380E1C, 0x7F0A0FAB, 0x7ED6113A,
+    0x7E9D12C8,  0x7E601455, 0x7E1E15E2, 0x7DD6176E,
+    0x7D8A18F9,  0x7D3A1A83, 0x7CE41C0C, 0x7C891D93,
+    0x7C2A1F1A,  0x7BC6209F, 0x7B5D2224, 0x7AEF23A7,
+    0x7A7D2528,  0x7A0626A8, 0x798A2827, 0x790A29A4,
+    0x78852B1F,  0x77FB2C99, 0x776C2E11, 0x76D92F87,
+    0x764230FC,  0x75A6326E, 0x750533DF, 0x7460354E,
+    0x73B636BA,  0x73083825, 0x7255398D, 0x719E3AF3,
+    0x70E33C57,  0x70233DB8, 0x6F5F3F17, 0x6E974074,
+    0x6DCA41CE,  0x6CF94326, 0x6C24447B, 0x6B4B45CD,
+    0x6A6E471D,  0x698C486A, 0x68A749B4, 0x67BD4AFB,
+    0x66D04C40,  0x65DE4D81, 0x64E94EC0, 0x63EF4FFB,
+    0x62F25134,  0x61F15269, 0x60EC539B, 0x5FE454CA,
+    0x5ED755F6,  0x5DC8571E, 0x5CB45843, 0x5B9D5964,
+    0x5A825A82,  0x59645B9D, 0x58435CB4, 0x571E5DC8,
+    0x55F65ED7,  0x54CA5FE4, 0x539B60EC, 0x526961F1,
+    0x513462F2,  0x4FFB63EF, 0x4EC064E9, 0x4D8165DE,
+    0x4C4066D0,  0x4AFB67BD, 0x49B468A7, 0x486A698C,
+    0x471D6A6E,  0x45CD6B4B, 0x447B6C24, 0x43266CF9,
+    0x41CE6DCA,  0x40746E97, 0x3F176F5F, 0x3DB87023,
+    0x3C5770E3,  0x3AF3719E, 0x398D7255, 0x38257308,
+    0x36BA73B6,  0x354E7460, 0x33DF7505, 0x326E75A6,
+    0x30FC7642,  0x2F8776D9, 0x2E11776C, 0x2C9977FB,
+    0x2B1F7885,  0x29A4790A, 0x2827798A, 0x26A87A06,
+    0x25287A7D,  0x23A77AEF, 0x22247B5D, 0x209F7BC6,
+    0x1F1A7C2A,  0x1D937C89, 0x1C0C7CE4, 0x1A837D3A,
+    0x18F97D8A,  0x176E7DD6, 0x15E27E1E, 0x14557E60,
+    0x12C87E9D,  0x113A7ED6, 0x0FAB7F0A, 0x0E1C7F38,
+    0x0C8C7F62,  0x0AFB7F87, 0x096B7FA7, 0x07D97FC2,
+    0x06487FD9,  0x04B67FEA, 0x03247FF6, 0x01927FFE
+};
+
diff --git a/media/libstagefright/codecs/aacdec/find_adts_syncword.cpp b/media/libstagefright/codecs/aacdec/find_adts_syncword.cpp
new file mode 100644
index 0000000..535f177
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/find_adts_syncword.cpp
@@ -0,0 +1,305 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Pathname: ./src/find_adts_syncword.c
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+ Description: Fixed error in logic that determines whether there are enough
+ bits available to conduct a search for the syncword.  The plus sign in
+ the following condition should be a minus.
+
+    if (pInputStream->usedBits <
+            (pInputStream->availableBits + syncword_length)
+
+ The length of the syncword should subtract from the number of available
+ bits, not add.
+
+ Description:  Fixed condition when the end of file was found, unsigned
+   comparison produced a undesired search. Fixed by casting comparison
+     if ((Int)pInputStream->usedBits <
+            ((Int)pInputStream->availableBits - syncword_length) )
+
+ Description:
+
+------------------------------------------------------------------------------
+ INPUT AND OUTPUT DEFINITIONS
+
+ Inputs:
+    pSyncword     = Pointer to variable containing the syncword that the
+                    function should be scanning for in the buffer. [ UInt32 * ]
+
+    pInputStream  = Pointer to a BITS structure, used by the function getbits
+                    to retrieve data from the bitstream.  [ BITS * ]
+
+    syncword_length = The length of the syncword. [ Int ]
+
+    syncword_mask   = A mask to be applied to the bitstream before comparison
+                      with the value pointed to by pSyncword. [ UInt32 ]
+
+ Local Stores/Buffers/Pointers Needed:
+    None
+
+ Global Stores/Buffers/Pointers Needed:
+    None
+
+ Outputs:
+    None
+
+ Pointers and Buffers Modified:
+    None
+
+ Local Stores Modified:
+    None
+
+ Global Stores Modified:
+    None
+
+------------------------------------------------------------------------------
+ FUNCTION DESCRIPTION
+
+ This module scans the bitstream for a syncword of any length between 1 and 32.
+ If certain bits in the syncword are to be ignored, that bit position should
+ be set to 0 in both parameters *(pSyncword) and syncword_mask.  This allows
+ for a syncword to be constructed out of non-contiguous bits.
+
+ Upon finding the syncword's position in the bitstream, a value denoting the
+ syncword's degree of deviance from being byte-aligned (byte_align_offset)
+ is set in the structure pointed to by pInputStream.
+ This is a value between 0 and 7.
+
+ If no syncword is found, the function returns status == ERROR.
+
+------------------------------------------------------------------------------
+ REQUIREMENTS
+
+ "Don't care" bits must be set to '0' in both *(pSyncword) and syncword_mask.
+
+ This function should not be called if there are less than
+ (8 + syncword_length) bits in the buffer.
+
+------------------------------------------------------------------------------
+ REFERENCES
+ (1) ISO/IEC 13818-7:1997(E)
+     Part 7
+        Subpart 6.2 (Audio_Data_Transport_Stream frame, ADTS)
+
+ (2) ISO/IEC 11172-3:1993(E)
+     Part 3
+        Subpart 2.4.3 The audio decoding process
+
+------------------------------------------------------------------------------
+ PSEUDO-CODE
+
+    IF (pInputStream->usedBits <
+            (pInputStream->availableBits + syncword_length) )
+
+        max_search_length = (pInputStream->availableBits - pInputStream->usedBits);
+
+        max_search_length = max_search_length - syncword_length;
+
+        search_length = 0;
+
+        adts_header =
+        CALL getbits(syncword_length, pInputStream);
+            MODIFYING pInputStream->usedBits
+            RETURNING bits from bitstream of length (syncword_length)
+
+        test_for_syncword = adts_header AND syncword_mask;
+        test_for_syncword = test_for_syncword XOR syncword;
+
+        WHILE ( (test_for_syncword != 0) && (search_length > 0) )
+
+            search_length = search_length - 1;
+
+            adts_header = adts_header << 1;
+            adts_header = adts_header OR ...
+
+            CALL getbits(syncword_length, pInputStream);
+                MODIFYING pInputStream->usedBits
+                RETURNING 1 bit from the bitstream
+
+            test_for_syncword = adts_header AND syncword_mask;
+            test_for_syncword = test_for_syncword XOR syncword;
+
+        ENDWHILE
+
+        IF (search_length == 0)
+            status = ERROR;
+        ENDIF
+
+        *(pSyncword) = adts_header;
+
+         pInputStream->byteAlignOffset =
+             (pInputStream->usedBits - syncwordlength) AND 0x7;
+
+    ELSE
+        status = ERROR;
+    ENDIF
+
+    return (status);
+
+
+------------------------------------------------------------------------------
+ RESOURCES USED
+   When the code is written for a specific target processor the
+     the resources used should be documented below.
+
+ STACK USAGE: [stack count for this module] + [variable to represent
+          stack usage for each subroutine called]
+
+     where: [stack usage variable] = stack usage for [subroutine
+         name] (see [filename].ext)
+
+ DATA MEMORY USED: x words
+
+ PROGRAM MEMORY USED: x words
+
+ CLOCK CYCLES: [cycle count equation for this module] + [variable
+           used to represent cycle count for each subroutine
+           called]
+
+     where: [cycle count variable] = cycle count for [subroutine
+        name] (see [filename].ext)
+
+------------------------------------------------------------------------------
+*/
+
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+#include "pv_audio_type_defs.h"
+#include "s_bits.h"
+#include "ibstream.h"
+#include "find_adts_syncword.h"
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here. Include conditional
+; compile variables also.
+----------------------------------------------------------------------------*/
+#define FIND_ADTS_ERROR -1
+
+/*----------------------------------------------------------------------------
+; LOCAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; LOCAL STORE/BUFFER/POINTER DEFINITIONS
+; Variable declaration - defined here and used outside this module
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL FUNCTION REFERENCES
+; Declare functions defined elsewhere and referenced in this module
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL GLOBAL STORE/BUFFER/POINTER REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; FUNCTION CODE
+----------------------------------------------------------------------------*/
+Int find_adts_syncword(
+    UInt32 *pSyncword,
+    BITS   *pInputStream,
+    Int     syncword_length,
+    UInt32  syncword_mask)
+{
+
+    Int    status = SUCCESS;
+    UInt   search_length;
+    UInt32 adts_header = 0;
+    UInt32 test_for_syncword;
+    UInt32 syncword = *(pSyncword);
+
+    /*
+     * Determine the maximum number of bits available to this function for
+     * the syncword search.
+     */
+    if ((Int)pInputStream->usedBits <
+            ((Int)pInputStream->availableBits - syncword_length))
+    {
+        search_length = (pInputStream->availableBits - pInputStream->usedBits);
+
+        search_length -= syncword_length;
+
+        adts_header  = getbits(syncword_length, pInputStream);
+
+        /*
+         * Mask the result in adts_header with the syncword_mask, so only the
+         * bits relevant to syncword detection are compared to *(pSyncword).
+         */
+        test_for_syncword  = adts_header & syncword_mask;
+        test_for_syncword ^= syncword;
+
+        /*
+         * Scan bit-by-bit through the bitstream, until the function either
+         * runs out of bits, or finds the syncword.
+         */
+
+        while ((test_for_syncword != 0) && (search_length > 0))
+        {
+            search_length--;
+
+            adts_header <<= 1;
+            adts_header |= getbits(1, pInputStream);
+
+            test_for_syncword  = adts_header & syncword_mask;
+            test_for_syncword ^= syncword;
+        }
+
+        if (search_length == 0)
+        {
+            status = FIND_ADTS_ERROR;
+        }
+
+        /*
+         * Return the syncword's position in the bitstream.  Correct placement
+         * of the syncword will result in byte_align_offset == 0.
+         * If the syncword is found not to be byte-aligned, then return
+         * the degree of disalignment, so further decoding can
+         * be shifted as necessary.
+         *
+         */
+        pInputStream->byteAlignOffset =
+            (pInputStream->usedBits - syncword_length) & 0x7;
+
+    } /* END if (pInputStream->usedBits < ...) */
+
+    else
+    {
+        status = FIND_ADTS_ERROR;
+    }
+
+    *(pSyncword) = adts_header;
+
+    return (status);
+
+} /* find_adts_syncword() */
diff --git a/media/libstagefright/codecs/aacdec/find_adts_syncword.h b/media/libstagefright/codecs/aacdec/find_adts_syncword.h
new file mode 100644
index 0000000..d147bc5
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/find_adts_syncword.h
@@ -0,0 +1,87 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Pathname: ./include/find_adts_syncword.h
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+ Who:                       Date:
+ Description:
+
+------------------------------------------------------------------------------
+ INCLUDE DESCRIPTION
+
+ This function includes the function declaration for find_adts_syncword()
+
+------------------------------------------------------------------------------
+*/
+
+/*----------------------------------------------------------------------------
+; CONTINUE ONLY IF NOT ALREADY DEFINED
+----------------------------------------------------------------------------*/
+#ifndef FIND_ADTS_SYNCWORD_H
+#define FIND_ADTS_SYNCWORD_H
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+#include "s_bits.h"
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here.
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL VARIABLES REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; SIMPLE TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; ENUMERATED TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; STRUCTURES TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; GLOBAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+Int find_adts_syncword(
+    UInt32 *pSyncword,
+    BITS   *pInputStream,
+    Int     syncword_length,
+    UInt32  syncword_mask);
+
+/*----------------------------------------------------------------------------
+; END
+----------------------------------------------------------------------------*/
+#endif
diff --git a/media/libstagefright/codecs/aacdec/fwd_long_complex_rot.cpp b/media/libstagefright/codecs/aacdec/fwd_long_complex_rot.cpp
new file mode 100644
index 0000000..b85c7df
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/fwd_long_complex_rot.cpp
@@ -0,0 +1,284 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Pathname: ./src/fwd_long_complex_rot.c
+ Funtions: fwd_long_complex_rot
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+ Date: 10/18/2002
+ Description:
+            (1) Change the input arguments, no shifts information from
+                long_fft_rx4 is passed, only a single max is passed.
+            (2) Eliminate search for max, a fixed shift has replaced the
+                search for max with minimal loss of precision.
+            (3) Eliminated unused variables
+
+ Date: 10/28/2002
+ Description:
+            (1) Added comments per code review
+            (2) Eliminated hardly used condition on if-else (exp==0)
+
+ Description:
+
+ ------------------------------------------------------------------------------
+ INPUT AND OUTPUT DEFINITIONS
+
+ Inputs:
+
+    Data_in   = Input vector (sized for long windows
+                TWICE_FWD_LONG_CX_ROT_LENGTH), with time domain samples
+                type Int32 *
+
+    Data_out  = Output vector with a post-rotation by exp(-j(2pi/N)(k+1/8)),
+                (sized for long windows TWICE_FWD_LONG_CX_ROT_LENGTH)
+                type Int32 *
+
+    max       = Input, carries the maximum value of the input vector
+                "Data_in"
+                type Int32
+
+
+ Local Stores/Buffers/Pointers Needed:
+    None
+
+ Global Stores/Buffers/Pointers Needed:
+    None
+
+ Outputs:
+    exp = shift factor to reflect signal scaling
+
+ Pointers and Buffers Modified:
+    Results are return in "Data_out"
+
+ Local Stores Modified:
+    None
+
+ Global Stores Modified:
+    None
+------------------------------------------------------------------------------
+ FUNCTION DESCRIPTION
+
+    fwd_long_complex_rot() performs the pre complex rotation for the MDCT
+    for the case of long windows. It also performs digit reverse ordering of
+    the first and second halves of the input vector "Data_in", as well as
+    reordering of the two half vectors (following radix-2 decomposition)
+    Word normalization is also done to ensure 16 by 16 bit multiplications.
+
+------------------------------------------------------------------------------
+ REQUIREMENTS
+
+    fwd_long_complex_rot() should execute a pre-rotation by
+    exp(-j(2pi/N)(k+1/8)), digit reverse ordering and normalization
+------------------------------------------------------------------------------
+ REFERENCES
+
+------------------------------------------------------------------------------
+ RESOURCES USED
+   When the code is written for a specific target processor the
+     the resources used should be documented below.
+
+ STACK USAGE: [stack count for this module] + [variable to represent
+          stack usage for each subroutine called]
+
+     where: [stack usage variable] = stack usage for [subroutine
+         name] (see [filename].ext)
+
+ DATA MEMORY USED: x words
+
+ PROGRAM MEMORY USED: x words
+
+ CLOCK CYCLES: [cycle count equation for this module] + [variable
+           used to represent cycle count for each subroutine
+           called]
+
+     where: [cycle count variable] = cycle count for [subroutine
+        name] (see [filename].ext)
+
+------------------------------------------------------------------------------
+*/
+
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+
+#include "fwd_long_complex_rot.h"
+#include "digit_reversal_tables.h"
+#include "imdct_fxp.h"
+#include "pv_normalize.h"
+
+#include "fxp_mul32.h"
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here. Include conditional
+; compile variables also.
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; LOCAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; LOCAL VARIABLE DEFINITIONS
+; Variable declaration - defined here and used outside this module
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL FUNCTION REFERENCES
+; Declare functions defined elsewhere and referenced in this module
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL VARIABLES REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+Int fwd_long_complex_rot(
+    Int32 *Data_in,
+    Int32 *Data_out,
+    Int32  max)
+{
+    Int     i;
+    const   Int32 *p_rotate;
+    Int32   temp_re;
+    Int32   temp_im;
+    Int32   *pData_in_ref1;
+    Int32   *pData_in_ref2;
+    Int32   exp_jw;
+    Int32   temp_re_32;
+    Int32   temp_im_32;
+
+    Int32   *pData_out_1;
+    Int32   *pData_out_2;
+    Int32   *pData_out_3;
+    Int32   *pData_out_4;
+
+    Int32 *pData_in_1;
+    Int32 *pData_in_2;
+
+    Int     exp;
+
+    p_rotate       =  exp_rotation_N_2048;
+
+    pData_in_ref1  =  Data_in;
+    pData_in_ref2  = &Data_in[TWICE_FWD_LONG_CX_ROT_LENGTH];
+
+    pData_out_1 = Data_out;
+    pData_out_2 = &Data_out[LONG_WINDOW_LENGTH_m_1];
+    pData_out_3 = &Data_out[LONG_WINDOW_LENGTH];
+    pData_out_4 = &Data_out[TWICE_LONG_WINDOW_LENGTH_m_1];
+
+    /*
+     *  Data_out
+     *                                   >>>>                   <<<<
+     *                                pData_out_3             pData_out_4
+     *      |             |             |             |             |
+     * pData_out_1               pData_out_2
+     *      >>>>                     <<<<
+     */
+
+
+    exp = 16 - pv_normalize(max);
+
+    if (exp < 0)
+    {
+        exp = 0;
+    }
+
+    /*
+     *  Apply  A/2^(diff) + B
+     */
+
+
+    pData_in_1 = pData_in_ref1;
+    pData_in_2 = pData_in_ref2;
+
+    for (i = FWD_LONG_CX_ROT_LENGTH; i != 0; i--)
+    {
+
+        /*
+         * cos_n + j*sin_n == exp(j(2pi/N)(k+1/8))
+         */
+
+        exp_jw = *p_rotate++;
+
+        /*
+         *  Use auxiliary variables to avoid double accesses to memory.
+         *  Data in is scaled to use only lower 16 bits.
+         */
+
+        temp_re =  *(pData_in_1++) >> exp;
+        temp_im =  *(pData_in_1++) >> exp;
+
+        /*
+         *   Pre-rotation
+         */
+
+        temp_re_32  = (cmplx_mul32_by_16(temp_re,   temp_im,  exp_jw));
+        temp_im_32  = (cmplx_mul32_by_16(temp_im,  -temp_re,  exp_jw));
+
+        *(pData_out_1++) = - temp_re_32;
+        *(pData_out_2--) =   temp_im_32;
+        *(pData_out_3++) = - temp_im_32;
+        *(pData_out_4--) =   temp_re_32;
+
+        /*
+         *   Pointer increment to jump over imag (1 & 4) or real parts
+         *   (2 & 3)
+         */
+        pData_out_1++;
+        pData_out_2--;
+        pData_out_3++;
+        pData_out_4--;
+
+        /*
+         *   Repeat procedure for odd index at the output
+         */
+
+        exp_jw = *p_rotate++;
+
+        temp_re =  *(pData_in_2++) >> exp;
+        temp_im =  *(pData_in_2++) >> exp;
+
+        temp_re_32  = (cmplx_mul32_by_16(temp_re,   temp_im,  exp_jw));
+        temp_im_32  = (cmplx_mul32_by_16(temp_im,  -temp_re,  exp_jw));
+
+        *(pData_out_1++) = - temp_re_32;
+        *(pData_out_2--) =   temp_im_32;
+        *(pData_out_3++) = - temp_im_32;
+        *(pData_out_4--) =   temp_re_32;
+
+        pData_out_1++;
+        pData_out_2--;
+        pData_out_3++;
+        pData_out_4--;
+
+    }
+
+    return (exp + 1);
+}
diff --git a/media/libstagefright/codecs/aacdec/fwd_long_complex_rot.h b/media/libstagefright/codecs/aacdec/fwd_long_complex_rot.h
new file mode 100644
index 0000000..5978906
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/fwd_long_complex_rot.h
@@ -0,0 +1,96 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Pathname: ./include/fwd_long_complex_rot.h
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+
+ Who:                   Date:
+ Description:
+
+------------------------------------------------------------------------------
+ INCLUDE DESCRIPTION
+
+ Header file for functions fwd_long_complex_rot
+
+
+------------------------------------------------------------------------------
+*/
+
+/*----------------------------------------------------------------------------
+; CONTINUE ONLY IF NOT ALREADY DEFINED
+----------------------------------------------------------------------------*/
+#ifndef FWD_LONG_COMPLEX_ROT_H
+#define FWD_LONG_COMPLEX_ROT_H
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+#include "pv_audio_type_defs.h"
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here.
+----------------------------------------------------------------------------*/
+#define FWD_LONG_CX_ROT_LENGTH              256
+#define TWICE_FWD_LONG_CX_ROT_LENGTH        (FWD_LONG_CX_ROT_LENGTH<<1)
+#define LONG_WINDOW_LENGTH                  1024
+#define LONG_WINDOW_LENGTH_m_1              (LONG_WINDOW_LENGTH - 1)
+#define TWICE_LONG_WINDOW_LENGTH_m_1        ((LONG_WINDOW_LENGTH<<1) - 1)
+
+/*----------------------------------------------------------------------------
+; EXTERNAL VARIABLES REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; SIMPLE TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; ENUMERATED TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; STRUCTURES TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; GLOBAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+
+
+
+Int fwd_long_complex_rot(
+    Int32 *Data_in,
+    Int32 *Data_out,
+    Int32  max);
+
+/*----------------------------------------------------------------------------
+; END
+----------------------------------------------------------------------------*/
+#endif  /* FWD_LONG_COMPLEX_ROT_H */
diff --git a/media/libstagefright/codecs/aacdec/fwd_short_complex_rot.cpp b/media/libstagefright/codecs/aacdec/fwd_short_complex_rot.cpp
new file mode 100644
index 0000000..964f766
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/fwd_short_complex_rot.cpp
@@ -0,0 +1,261 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+ Pathname: ./src/fwd_short_complex_rot.c
+ Funtions:  fwd_short_complex_rot
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+ Date: 10/18/2002
+ Description:
+            (1) Change the input argument, only a single max is passed.
+            (2) Eliminate search for max, a fixed shift has replaced the
+                search for max with minimal loss of precision.
+            (3) Eliminated unused variables
+
+ Date: 10/28/2002
+ Description:
+            (1) Added comments per code review
+            (2) Eliminated hardly used condition on if-else (exp==0)
+
+ Description:
+
+ ------------------------------------------------------------------------------
+ INPUT AND OUTPUT DEFINITIONS
+
+ Inputs:
+
+    Data_in   = Input vector (sized for short windows
+                2*FWD_SHORT_CX_ROT_LENGTH elements), with freq. domain samples
+                type Int32 *
+
+    Data_out  = Output vector with a post-rotation by exp(-j(2pi/N)(k+1/8)),
+                (sized for short windows 2*FWD_SHORT_CX_ROT_LENGTH)
+                type Int32 *
+
+    max       = Input, carries the maximum value of the input vector
+                "Data_in"
+                type Int32
+
+
+ Local Stores/Buffers/Pointers Needed:
+    None
+
+ Global Stores/Buffers/Pointers Needed:
+    None
+
+ Outputs:
+    exp = shift factor to reflect signal scaling
+
+ Pointers and Buffers Modified:
+    Results are return in "Data_out"
+
+ Local Stores Modified:
+    None
+
+ Global Stores Modified:
+    None
+------------------------------------------------------------------------------
+ FUNCTION DESCRIPTION
+
+    fwd_short_complex_rot() performs the complex rotation for the MDCT
+    for the case of short windows. It performs digit reverse ordering as well
+    word normalization to ensure 16 by 16 bit multiplications.
+
+------------------------------------------------------------------------------
+ REQUIREMENTS
+
+    fwd_short_complex_rot() should execute a pre-rotation by
+    exp(-j(2pi/N)(k+1/8)), digit reverse ordering and word normalization
+------------------------------------------------------------------------------
+ REFERENCES
+
+------------------------------------------------------------------------------
+ RESOURCES USED
+   When the code is written for a specific target processor the
+     the resources used should be documented below.
+
+ STACK USAGE: [stack count for this module] + [variable to represent
+          stack usage for each subroutine called]
+
+     where: [stack usage variable] = stack usage for [subroutine
+         name] (see [filename].ext)
+
+ DATA MEMORY USED: x words
+
+ PROGRAM MEMORY USED: x words
+
+ CLOCK CYCLES: [cycle count equation for this module] + [variable
+           used to represent cycle count for each subroutine
+           called]
+
+     where: [cycle count variable] = cycle count for [subroutine
+        name] (see [filename].ext)
+
+------------------------------------------------------------------------------
+*/
+
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+
+#include "fwd_short_complex_rot.h"
+#include "digit_reversal_tables.h"
+#include "imdct_fxp.h"
+#include "pv_normalize.h"
+
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here. Include conditional
+; compile variables also.
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; LOCAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; LOCAL VARIABLE DEFINITIONS
+; Variable declaration - defined here and used outside this module
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL FUNCTION REFERENCES
+; Declare functions defined elsewhere and referenced in this module
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL VARIABLES REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+Int fwd_short_complex_rot(
+    Int32 *Data_in,
+    Int32 *Data_out,
+    Int32  max)
+
+{
+    Int     i;
+    Int16     I;
+    const   Int16 *pTable;
+    const   Int32 *p_rotate;
+
+    Int32   *pData_in_1;
+    Int     exp;
+    Int32   temp_re;
+    Int32   temp_im;
+
+    Int32   cos_n;
+    Int32   sin_n;
+    Int32   temp_re_32;
+    Int32   temp_im_32;
+
+    Int32   *pData_in_ref;
+
+    Int32   *pData_out_1;
+    Int32   *pData_out_2;
+    Int32   *pData_out_3;
+    Int32   *pData_out_4;
+
+    pTable    =  digit_reverse_64;
+    p_rotate  =  exp_rotation_N_256;
+
+    pData_in_ref  =  Data_in;
+
+    exp = 16 - pv_normalize(max);
+
+    if (exp < 0)
+    {
+        exp = 0;
+    }
+
+    pData_out_1 = Data_out;
+    pData_out_2 = &Data_out[TWICE_FWD_SHORT_CX_ROT_LENGTH_m_1];
+    pData_out_3 = &Data_out[TWICE_FWD_SHORT_CX_ROT_LENGTH];
+    pData_out_4 = &Data_out[FOUR_FWD_SHORT_CX_ROT_LENGTH_m_1];
+
+    /*
+     *  Data_out
+     *                                   >>>>                   <<<<
+     *                                pData_out_3             pData_out_4
+     *      |             |             |             |             |
+     * pData_out_1               pData_out_2
+     *      >>>>                     <<<<
+     */
+
+
+    for (i = FWD_SHORT_CX_ROT_LENGTH; i != 0; i--)
+    {
+        /*
+         *   Perform digit reversal by accessing index I from table
+         */
+
+        I = *pTable++;
+        pData_in_1 = pData_in_ref + I;
+
+        /*
+         * cos_n + j*sin_n == exp(j(2pi/N)(k+1/8))
+         */
+
+        sin_n = *p_rotate++;
+        cos_n = sin_n >> 16;
+        sin_n = sin_n & 0xFFFF;
+
+        /*
+         *  Use auxiliary variables to avoid double accesses to memory.
+         *  Data in is scaled to use only lower 16 bits.
+         */
+
+        temp_re =  *(pData_in_1++) >> exp;
+        temp_im =  *(pData_in_1) >> exp;
+
+        /*
+         *   Pre-rotation
+         */
+
+        temp_re_32 = (temp_re * cos_n + temp_im * sin_n) >> 16;
+        temp_im_32 = (temp_im * cos_n - temp_re * sin_n) >> 16;
+
+        *(pData_out_1++) = - temp_re_32;
+        *(pData_out_2--) =   temp_im_32;
+        *(pData_out_3++) = - temp_im_32;
+        *(pData_out_4--) =   temp_re_32;
+
+        /*
+         *   Pointer increment to jump over imag (1 & 4) or real parts
+         *   (2 & 3)
+         */
+
+        pData_out_1++;
+        pData_out_2--;
+        pData_out_3++;
+        pData_out_4--;
+
+    } /* for(i) */
+
+    return (exp);
+}
diff --git a/media/libstagefright/codecs/aacdec/fwd_short_complex_rot.h b/media/libstagefright/codecs/aacdec/fwd_short_complex_rot.h
new file mode 100644
index 0000000..3d1e1f1
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/fwd_short_complex_rot.h
@@ -0,0 +1,92 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Pathname: .fwd_short_complex_rot.h
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+
+ Who:                   Date:
+ Description:
+
+------------------------------------------------------------------------------
+ INCLUDE DESCRIPTION
+
+ Header file for functions fwd_short_complex_rot
+
+
+------------------------------------------------------------------------------
+*/
+
+/*----------------------------------------------------------------------------
+; CONTINUE ONLY IF NOT ALREADY DEFINED
+----------------------------------------------------------------------------*/
+#ifndef FWD_SHORT_COMPLEX_ROT_H
+#define FWD_SHORT_COMPLEX_ROT_H
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+#include "pv_audio_type_defs.h"
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here.
+----------------------------------------------------------------------------*/
+#define FWD_SHORT_CX_ROT_LENGTH             64
+#define TWICE_FWD_SHORT_CX_ROT_LENGTH       (FWD_SHORT_CX_ROT_LENGTH<<1)
+#define TWICE_FWD_SHORT_CX_ROT_LENGTH_m_1   ((FWD_SHORT_CX_ROT_LENGTH<<1) - 1)
+#define FOUR_FWD_SHORT_CX_ROT_LENGTH_m_1    ((FWD_SHORT_CX_ROT_LENGTH<<2) - 1)
+/*----------------------------------------------------------------------------
+; EXTERNAL VARIABLES REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; SIMPLE TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; ENUMERATED TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; STRUCTURES TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; GLOBAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+
+Int fwd_short_complex_rot(
+    Int32 *Data_in,
+    Int32 *Data_out,
+    Int32  max);
+
+/*----------------------------------------------------------------------------
+; END
+----------------------------------------------------------------------------*/
+#endif  /* FWD_SHORT_COMPLEX_ROT_H */
diff --git a/media/libstagefright/codecs/aacdec/fxp_mul32.h b/media/libstagefright/codecs/aacdec/fxp_mul32.h
new file mode 100644
index 0000000..230cef5
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/fxp_mul32.h
@@ -0,0 +1,72 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Pathname: ./c/include/fxp_mul32.h
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+ Who:                                       Date:
+ Description:
+------------------------------------------------------------------------------
+ INCLUDE DESCRIPTION
+
+------------------------------------------------------------------------------
+*/
+
+#ifndef FXP_MUL32
+#define FXP_MUL32
+
+#if   defined(PV_ARM_V5)
+
+#include "fxp_mul32_arm_v5.h"
+
+#elif defined(PV_ARM_V4)
+
+#include "fxp_mul32_arm_v4.h"
+
+#elif defined(PV_ARM_MSC_EVC_V4)
+
+#include "fxp_mul32_c_msc_evc.h"
+
+#elif defined(PV_ARM_MSC_EVC_V5)
+
+#include "fxp_mul32_c_msc_evc_armv5.h"
+
+#elif defined(PV_ARM_GCC_V5)
+
+#include "fxp_mul32_arm_gcc.h"
+
+#elif defined(PV_ARM_GCC_V4)
+
+#include "fxp_mul32_arm_v4_gcc.h"
+
+#else
+
+#ifndef C_EQUIVALENT
+#define C_EQUIVALENT
+#endif
+
+#include "fxp_mul32_c_equivalent.h"
+
+#endif
+
+
+#endif   /*  FXP_MUL32  */
+
diff --git a/media/libstagefright/codecs/aacdec/fxp_mul32_arm_gcc.h b/media/libstagefright/codecs/aacdec/fxp_mul32_arm_gcc.h
new file mode 100644
index 0000000..dc58976
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/fxp_mul32_arm_gcc.h
@@ -0,0 +1,547 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Pathname: ./c/include/fxp_mul32_arm_gcc.h
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+ Who:                                       Date:
+ Description:
+------------------------------------------------------------------------------
+ INCLUDE DESCRIPTION
+
+------------------------------------------------------------------------------
+*/
+
+#ifndef FXP_MUL32_ARM_GCC
+#define FXP_MUL32_ARM_GCC
+
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+
+#include "pv_audio_type_defs.h"
+
+
+#if (defined (PV_ARM_GCC_V4) || defined(PV_ARM_GCC_V5)) /* ARM GNU COMPILER  */
+
+
+
+#define preload_cache( a)
+
+
+    static inline Int32 shft_lft_1(Int32 y)
+    {
+        register Int32 x;
+        register Int32 ra = y;
+
+
+        asm volatile(
+            "qadd %0, %1, %1\n\t"
+    : "=&r*i"(x)
+                    : "r"(ra));
+
+        return (x);
+    }
+
+    static inline Int32 fxp_mul_16_by_16bb(Int32 L_var1, const Int32 L_var2)
+    {
+
+        register Int32 tmp;
+        register Int32 ra = (Int32)L_var1;
+        register Int32 rb = (Int32)L_var2;
+
+        asm volatile(
+            "smulbb %0, %1, %2"
+    : "=&r*i"(tmp)
+                    : "r"(ra),
+                    "r"(rb));
+
+        return (tmp);
+    }
+
+
+#define fxp_mul_16_by_16(a, b)  fxp_mul_16_by_16bb(  a, b)
+
+
+    static inline Int32 fxp_mul_16_by_16tb(Int32 L_var1, const Int32 L_var2)
+{
+
+        register Int32 tmp;
+        register Int32 ra = (Int32)L_var1;
+        register Int32 rb = (Int32)L_var2;
+
+        asm volatile(
+            "smultb %0, %1, %2"
+    : "=&r*i"(tmp)
+                    : "r"(ra),
+                    "r"(rb));
+
+        return (tmp);
+    }
+
+    static inline Int32 fxp_mul_16_by_16bt(Int32 L_var1, const Int32 L_var2)
+{
+
+        register Int32 tmp;
+        register Int32 ra = (Int32)L_var1;
+        register Int32 rb = (Int32)L_var2;
+
+        asm volatile(
+            "smulbt %0, %1, %2"
+    : "=&r*i"(tmp)
+                    : "r"(ra),
+                    "r"(rb));
+
+        return (tmp);
+    }
+
+    static inline Int32 fxp_mul_16_by_16tt(Int32 L_var1, const Int32 L_var2)
+{
+
+        register Int32 tmp;
+        register Int32 ra = (Int32)L_var1;
+        register Int32 rb = (Int32)L_var2;
+
+        asm volatile(
+            "smultt %0, %1, %2"
+    : "=&r*i"(tmp)
+                    : "r"(ra),
+                    "r"(rb));
+
+        return (tmp);
+    }
+
+    static inline Int32 fxp_mac_16_by_16(const Int32 L_var1, const Int32 L_var2, Int32 L_add)
+{
+        register Int32 tmp;
+        register Int32 ra = (Int32)L_var1;
+        register Int32 rb = (Int32)L_var2;
+        register Int32 rc = (Int32)L_add;
+
+        asm volatile(
+            "smlabb %0, %1, %2, %3"
+    : "=&r*i"(tmp)
+                    : "r"(ra),
+                    "r"(rb),
+                    "r"(rc));
+
+        return (tmp);
+    }
+
+
+
+    static inline Int32 fxp_mac_16_by_16_bb(const Int32 L_var1, const Int32 L_var2, Int32 L_add)
+{
+        register Int32 tmp;
+        register Int32 ra = (Int32)L_var1;
+        register Int32 rb = (Int32)L_var2;
+        register Int32 rc = (Int32)L_add;
+
+        asm volatile(
+            "smlabb %0, %1, %2, %3"
+    : "=&r*i"(tmp)
+                    : "r"(ra),
+                    "r"(rb),
+                    "r"(rc));
+
+        return (tmp);
+    }
+
+
+    static inline Int32 fxp_mac_16_by_16_bt(const Int32 L_var1, const Int32 L_var2, Int32 L_add)
+{
+        register Int32 tmp;
+        register Int32 ra = (Int32)L_var1;
+        register Int32 rb = (Int32)L_var2;
+        register Int32 rc = (Int32)L_add;
+
+        asm volatile(
+            "smlabt %0, %1, %2, %3"
+    : "=&r*i"(tmp)
+                    : "r"(ra),
+                    "r"(rb),
+                    "r"(rc));
+
+        return (tmp);
+    }
+
+
+
+    static inline Int32 cmplx_mul32_by_16(Int32 x, const Int32 y, Int32 exp_jw)
+{
+        register Int32 cx_sum;
+        register Int32 rx = (Int32)x;
+        register Int32 ry = (Int32)y;
+        register Int32 rexp = (Int32)exp_jw;
+        asm volatile(
+            "smulwt %0, %1, %3\n\t"
+            "smlawb %0, %2, %3, %0"
+    : "=&r*i"(cx_sum)
+                    : "r"(rx),
+                    "r"(ry),
+                    "r"(rexp));
+
+        return (cx_sum);
+    }
+
+
+    static inline Int32 fxp_mul32_by_16(Int32 L_var1, const Int32 L_var2)
+{
+
+        register Int32 tmp;
+        register Int32 ra = (Int32)L_var1;
+        register Int32 rb = (Int32)L_var2;
+
+        asm volatile(
+            "smulwb %0, %1, %2"
+    : "=&r*i"(tmp)
+                    : "r"(ra),
+                    "r"(rb));
+
+        return (tmp);
+    }
+
+#define fxp_mul32_by_16b( a, b)   fxp_mul32_by_16( a, b)
+
+
+    static inline Int32 fxp_mul32_by_16t(Int32 L_var1, const Int32 L_var2)
+{
+
+        register Int32 tmp;
+        register Int32 ra = (Int32)L_var1;
+        register Int32 rb = (Int32)L_var2;
+
+        asm volatile(
+            "smulwt %0, %1, %2"
+    : "=&r*i"(tmp)
+                    : "r"(ra),
+                    "r"(rb));
+
+        return (tmp);
+    }
+
+
+
+    static inline Int32 fxp_mac32_by_16(const Int32 L_var1, const Int32 L_var2, Int32 L_add)
+{
+
+        register Int32 tmp;
+        register Int32 ra = (Int32)L_var1;
+        register Int32 rb = (Int32)L_var2;
+        register Int32 rc = (Int32)L_add;
+
+        asm volatile(
+            "smlawb %0, %1, %2, %3"
+    : "=&r*i"(tmp)
+                    : "r"(ra),
+                    "r"(rb),
+                    "r"(rc));
+
+        return (tmp);
+    }
+
+
+    __inline  int64 fxp_mac64_Q31(int64 sum, const Int32 L_var1, const Int32 L_var2)
+{
+        sum += (int64)L_var1 * L_var2;
+        return (sum);
+    }
+
+
+
+
+    static inline Int32 fxp_mac32_Q30(const Int32 a, const Int32 b, Int32 L_add)
+    {
+        Int32 result64_hi;
+        Int32 result64_lo;
+        register Int32 ra = (Int32)a;
+        register Int32 rb = (Int32)b;
+        register Int32 rc = (Int32)L_add;
+
+        asm volatile("smull %1, %0, %2, %3\n\t"
+                     "add %4, %4, %0, asl #2\n\t"
+                     "add %0, %4, %1, lsr #30"
+             : "=&r*i"(result64_hi),
+                     "=&r*i"(result64_lo)
+                             : "r"(ra),
+                             "r"(rb),
+                             "r"(rc));
+
+        return (result64_hi);
+    }
+
+
+    static inline Int32 fxp_mac32_Q31(Int32 L_add, const Int32 a, const Int32 b)
+{
+
+        Int32 result64_hi;
+        Int32 result64_lo;
+        register Int32 ra = (Int32)a;
+        register Int32 rb = (Int32)b;
+        register Int32 rc = (Int32)L_add;
+
+        asm volatile("smull %1, %0, %2, %3\n\t"
+                     "add %0, %0, %4"
+             : "=&r*i"(result64_hi),
+                     "=&r*i"(result64_lo)
+                             : "r"(ra),
+                             "r"(rb),
+                             "r"(rc));
+
+        return (result64_hi);
+    }
+
+
+
+    static inline Int32 fxp_msu32_Q31(Int32 L_sub, const Int32 a, const Int32 b)
+{
+        Int32 result64_hi;
+        Int32 result64_lo;
+        register Int32 ra = (Int32)a;
+        register Int32 rb = (Int32)b;
+        register Int32 rc = (Int32)L_sub;
+
+        asm volatile("smull %1, %0, %2, %3\n\t"
+                     "sub %0, %4, %0"
+             : "=&r*i"(result64_hi),
+                     "=&r*i"(result64_lo)
+                             : "r"(ra),
+                             "r"(rb),
+                             "r"(rc));
+
+
+        return (result64_hi);
+    }
+
+
+    static inline Int32 fxp_mul32_Q31(const Int32 a, const Int32 b)
+{
+        Int32 result64_hi;
+        Int32 result64_lo;
+        register Int32 ra = (Int32)a;
+        register Int32 rb = (Int32)b;
+        asm volatile(
+            "smull %1, %0, %2, %3"
+    : "=&r*i"(result64_hi),
+            "=&r*i"(result64_lo)
+                    : "r"(ra),
+                    "r"(rb));
+
+        return (result64_hi);
+    }
+
+
+    static inline Int32 fxp_mul32_Q30(const Int32 a, const Int32 b)
+{
+        Int32 result64_hi;
+        Int32 result64_lo;
+        register Int32 ra = (Int32)a;
+        register Int32 rb = (Int32)b;
+        asm volatile("smull %1, %0, %2, %3\n\t"
+                     "mov %0, %0, lsl #2\n\t"
+                     "orr   %0, %0, %1, lsr #30"
+             : "=&r*i"(result64_hi),
+                     "=&r*i"(result64_lo)
+                             : "r"(ra),
+                             "r"(rb));
+        return (result64_hi);
+    }
+
+
+
+    static inline Int32 fxp_mac32_Q29(const Int32 a, const Int32 b, Int32 L_add)
+{
+        Int32 result64_hi;
+        Int32 result64_lo;
+        register Int32 ra = (Int32)a;
+        register Int32 rb = (Int32)b;
+        register Int32 rc = (Int32)L_add;
+
+        asm volatile("smull %1, %0, %2, %3\n\t"
+                     "add   %4, %4, %0, lsl #3\n\t"
+                     "add   %0, %4, %1, lsr #29"
+             : "=&r*i"(result64_hi),
+                     "=&r*i"(result64_lo)
+                             : "r"(ra),
+                             "r"(rb),
+                             "r"(rc));
+
+        return (result64_hi);
+    }
+
+
+    static inline Int32 fxp_msu32_Q29(const Int32 a, const Int32 b, Int32 L_sub)
+{
+        Int32 result64_hi;
+        Int32 result64_lo;
+        register Int32 ra = (Int32)a;
+        register Int32 rb = (Int32)b;
+        register Int32 rc = (Int32)L_sub;
+
+        asm volatile("smull %1, %0, %2, %3\n\t"
+                     "sub   %4, %4, %0, lsl #3\n\t"
+                     "sub   %0, %4, %1, lsr #29"
+             : "=&r*i"(result64_hi),
+                     "=&r*i"(result64_lo)
+                             : "r"(ra),
+                             "r"(rb),
+                             "r"(rc));
+
+        return (result64_hi);
+    }
+
+    static inline Int32 fxp_mul32_Q29(const Int32 a, const Int32 b)
+{
+        Int32 result64_hi;
+        Int32 result64_lo;
+        register Int32 ra = (Int32)a;
+        register Int32 rb = (Int32)b;
+        asm volatile("smull %1, %0, %2, %3\n\t"
+                     "mov %0, %0, lsl #3\n\t"
+                     "orr   %0, %0, %1, lsr #29"
+             : "=&r*i"(result64_hi),
+                     "=&r*i"(result64_lo)
+                             : "r"(ra),
+                             "r"(rb));
+        return (result64_hi);
+    }
+
+
+
+    static inline Int32 fxp_mul32_Q28(const Int32 a, const Int32 b)
+{
+        Int32 result64_hi;
+        Int32 result64_lo;
+        register Int32 ra = (Int32)a;
+        register Int32 rb = (Int32)b;
+        asm volatile("smull %1, %0, %2, %3\n\t"
+                     "mov %0, %0, lsl #4\n\t"
+                     "orr   %0, %0, %1, lsr #28"
+             : "=&r*i"(result64_hi),
+                     "=&r*i"(result64_lo)
+                             : "r"(ra),
+                             "r"(rb));
+        return (result64_hi);
+    }
+
+    static inline Int32 fxp_mul32_Q27(const Int32 a, const Int32 b)
+{
+        Int32 result64_hi;
+        Int32 result64_lo;
+        register Int32 ra = (Int32)a;
+        register Int32 rb = (Int32)b;
+        asm volatile("smull %1, %0, %2, %3\n\t"
+                     "mov %0, %0, lsl #5\n\t"
+                     "orr   %0, %0, %1, lsr #27"
+             : "=&r*i"(result64_hi),
+                     "=&r*i"(result64_lo)
+                             : "r"(ra),
+                             "r"(rb));
+
+        return (result64_hi);
+    }
+
+
+    static inline Int32 fxp_mul32_Q26(const Int32 a, const Int32 b)
+{
+        Int32 result64_hi;
+        Int32 result64_lo;
+        register Int32 ra = (Int32)a;
+        register Int32 rb = (Int32)b;
+        asm volatile("smull %1, %0, %2, %3\n\t"
+                     "mov %0, %0, lsl #6\n\t"
+                     "orr   %0, %0, %1, lsr #26"
+             : "=&r*i"(result64_hi),
+                     "=&r*i"(result64_lo)
+                             : "r"(ra),
+                             "r"(rb));
+
+        return (result64_hi);
+    }
+
+
+    static inline Int32 fxp_mul32_Q20(const Int32 a, const Int32 b)
+{
+        Int32 result64_hi;
+        Int32 result64_lo;
+        register Int32 ra = (Int32)a;
+        register Int32 rb = (Int32)b;
+        asm volatile("smull %1, %0, %2, %3\n\t"
+                     "mov %0, %0, lsl #12\n\t"
+                     "orr   %0, %0, %1, lsr #20"
+             : "=&r*i"(result64_hi),
+                     "=&r*i"(result64_lo)
+                             : "r"(ra),
+                             "r"(rb));
+
+        return (result64_hi);
+    }
+
+
+    static inline Int32 fxp_mul32_Q15(const Int32 a, const Int32 b)
+{
+        Int32 result64_hi;
+        Int32 result64_lo;
+        register Int32 ra = (Int32)a;
+        register Int32 rb = (Int32)b;
+        asm volatile("smull %1, %0, %2, %3\n\t"
+                     "mov %0, %0, lsl #17\n\t"
+                     "orr   %0, %0, %1, lsr #15"
+             : "=&r*i"(result64_hi),
+                     "=&r*i"(result64_lo)
+                             : "r"(ra),
+                             "r"(rb));
+
+        return (result64_hi);
+    }
+
+
+
+    static inline Int32 fxp_mul32_Q14(const Int32 a, const Int32 b)
+{
+        Int32 result64_hi;
+        Int32 result64_lo;
+        register Int32 ra = (Int32)a;
+        register Int32 rb = (Int32)b;
+        asm volatile("smull %1, %0, %2,  %3\n\t"
+                     "mov   %0, %0, lsl #18\n\t"
+                     "orr   %0, %0, %1, lsr #14"
+             : "=&r*i"(result64_hi),
+                     "=&r*i"(result64_lo)
+                             : "r"(ra),
+                             "r"(rb));
+
+        return (result64_hi);
+    }
+
+#endif
+
+
+#ifdef __cplusplus
+}
+#endif
+
+
+#endif   /*  FXP_MUL32  */
+
diff --git a/media/libstagefright/codecs/aacdec/fxp_mul32_arm_v4.h b/media/libstagefright/codecs/aacdec/fxp_mul32_arm_v4.h
new file mode 100644
index 0000000..6869c54
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/fxp_mul32_arm_v4.h
@@ -0,0 +1,429 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Pathname: fxp_mul32_c_equivalent.h
+
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+ Who:                                       Date:
+ Description:
+------------------------------------------------------------------------------
+ INCLUDE DESCRIPTION
+
+------------------------------------------------------------------------------
+*/
+
+#ifndef FXP_MUL32_ARM_V4
+#define FXP_MUL32_ARM_V4
+
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+
+#include "pv_audio_type_defs.h"
+
+
+#if defined(PV_ARM_V4)
+
+#define preload_cache( a)
+
+
+    __inline  Int32 shft_lft_1(Int32 L_var1)
+    {
+        Int32 x;
+        Int32 z = 1; /* rvct compiler problem */
+        __asm
+        {
+            mov x, L_var1, asl 1
+            teq L_var1, x, asr z
+            eorne  x, INT32_MAX, L_var1, asr #31
+        }
+
+        return(x);
+    }
+
+
+    __inline  Int32 fxp_mul_16_by_16bb(Int32 L_var1,  Int32 L_var2)
+    {
+        __asm
+        {
+
+            mov L_var2, L_var2, asl #16
+            mov L_var2, L_var2, asr #16
+            mov L_var1, L_var1, asl #16
+            mov L_var1, L_var1, asr #16
+
+
+            mul L_var1, L_var2, L_var1
+        }
+
+        return L_var1;
+
+    }
+
+
+#define fxp_mul_16_by_16(a, b)  fxp_mul_16_by_16bb(  a, b)
+
+
+    __inline  Int32 fxp_mul_16_by_16tb(Int32 L_var1,  Int32 L_var2)
+    {
+        __asm
+        {
+            mov L_var2, L_var2, asl #16
+            mov L_var2, L_var2, asr #16
+            mov L_var1, L_var1, asr #16
+
+            mul L_var1, L_var2, L_var1
+        }
+        return L_var1;
+    }
+
+    __inline  Int32 fxp_mul_16_by_16bt(Int32 L_var1,  Int32 L_var2)
+    {
+        __asm
+        {
+            mov L_var2, L_var2, asr #16
+            mov L_var1, L_var1, asl #16
+            mov L_var1, L_var1, asr #16
+
+            mul L_var1, L_var2, L_var1
+        }
+
+        return L_var1;
+
+    }
+
+
+    __inline  Int32 fxp_mul_16_by_16tt(Int32 L_var1,  Int32 L_var2)
+    {
+        __asm
+        {
+            mov L_var2, L_var2, asr #16
+            mov L_var1, L_var1, asr #16
+
+            mul L_var1, L_var2, L_var1
+        }
+
+        return L_var1;
+
+    }
+
+    __inline  Int32 fxp_mac_16_by_16(const Int32 L_var1, const Int32 L_var2, Int32 L_add)
+    {
+        __asm
+        {
+            mla L_add, L_var1, L_var2, L_add
+        }
+        return (L_add);
+    }
+
+
+    __inline  Int32 fxp_mac_16_by_16_bb(const Int32 L_var1,  Int32 L_var2, Int32 L_add)
+    {
+        __asm
+        {
+            mov L_var2, L_var2, asl #16
+            mov L_var2, L_var2, asr #16
+            mla L_add, L_var1, L_var2, L_add
+        }
+        return L_add;
+    }
+
+    __inline  Int32 fxp_mac_16_by_16_bt(Int16 L_var1,  Int32 L_var2, Int32 L_add)
+    {
+        __asm
+        {
+            mov L_var2, L_var2, asr #16
+            mla L_add, L_var1, L_var2, L_add
+        }
+        return L_add;
+    }
+
+
+    __inline  Int32 cmplx_mul32_by_16(Int32 x, const Int32 y, Int32 exp_jw)
+    {
+
+        Int32 result64_hi;
+        Int32 rTmp0;
+        Int32 iTmp0;
+        __asm
+        {
+            mov rTmp0, exp_jw, asr #16
+            mov rTmp0, rTmp0, asl #16
+            mov iTmp0, exp_jw, asl #16
+            smull rTmp0, result64_hi, x, rTmp0
+            smlal iTmp0, result64_hi, y, iTmp0
+        }
+
+        return (result64_hi);
+    }
+
+
+    __inline  Int32 fxp_mul32_by_16(Int32 L_var1, Int32 L_var2)
+    {
+        Int32 result64_hi;
+        __asm
+        {
+            mov L_var2, L_var2, asl #16
+            smull L_var1, result64_hi, L_var2, L_var1
+        }
+        return (result64_hi);
+    }
+
+
+
+#define fxp_mul32_by_16b( a, b)   fxp_mul32_by_16( a, b)
+
+
+
+    __inline  Int32 fxp_mul32_by_16t(Int32 L_var1, Int32 L_var2)
+    {
+
+        Int32 result64_hi;
+        __asm
+        {
+            mov L_var2, L_var2, asr #16
+            mov L_var2, L_var2, asl #16
+            smull L_var1, result64_hi, L_var2, L_var1
+        }
+        return (result64_hi);
+
+    }
+
+    __inline  Int32 fxp_mac32_by_16(Int32 L_var1, Int32 L_var2, Int32 L_add)
+    {
+
+        __asm
+        {
+            mov L_var2, L_var2, asl #16
+            smlal L_var1, L_add, L_var2, L_var1
+        }
+
+        return (L_add);
+    }
+
+
+    __inline  int64 fxp_mac64_Q31(int64 sum, const Int32 L_var1, const Int32 L_var2)
+    {
+        uint32 b = (UInt32)(sum);
+        int32 c = Int32(sum >> 32);
+        __asm
+        {
+            smlal b, c, L_var1, L_var2
+        }
+        return (((int64(c)) << 32) | b);
+    }
+
+
+    __inline  Int32 fxp_mul32_Q31(Int32 L_var1, const Int32 L_var2)
+    {
+        Int32 result64_hi;
+        __asm
+        {
+            smull L_var1, result64_hi, L_var2, L_var1
+        }
+        return (result64_hi);
+    }
+
+
+    __inline  Int32 fxp_mac32_Q31(Int32 L_add,  Int32 L_var1, const Int32 L_var2)
+    {
+        __asm
+        {
+            smlal L_var1, L_add, L_var2, L_var1
+        }
+        return L_add;
+    }
+
+    __inline  Int32 fxp_msu32_Q31(Int32 L_sub,  Int32 L_var1, const Int32 L_var2)
+    {
+        __asm
+        {
+            rsb   L_var1, L_var1, #0
+            smlal L_var1, L_sub, L_var2, L_var1
+        }
+        return L_sub;
+    }
+
+
+    __inline  Int32 fxp_mul32_Q30(const Int32 L_var1, const Int32 L_var2)
+    {
+        Int32 result64_hi;
+        Int32 result64_lo;
+        __asm
+        {
+            smull result64_lo, result64_hi, L_var2, L_var1
+            mov result64_hi, result64_hi, asl  #2
+            orr  result64_hi, result64_hi, result64_lo, lsr #30
+        }
+        return (result64_hi);
+    }
+
+
+    __inline  Int32 fxp_mac32_Q30(const Int32 L_var1, const Int32 L_var2, Int32 L_add)
+    {
+        Int32 result64_hi;
+        Int32 result64_lo;
+        __asm
+        {
+            smull result64_lo, result64_hi, L_var2, L_var1
+            add L_add, L_add, result64_hi, asl  #2
+            add L_add, L_add, result64_lo, lsr  #30
+        }
+        return (L_add);
+    }
+
+
+    __inline  Int32 fxp_mul32_Q29(const Int32 L_var1, const Int32 L_var2)
+    {
+        Int32 result64_hi;
+        Int32 result64_lo;
+        __asm
+        {
+            smull result64_lo, result64_hi, L_var2, L_var1
+            mov result64_hi, result64_hi, asl  #3
+            orr  result64_hi, result64_hi, result64_lo, lsr #29
+        }
+        return (result64_hi);
+    }
+
+    __inline  Int32 fxp_mac32_Q29(const Int32 L_var1, const Int32 L_var2, Int32 L_add)
+    {
+        Int32 result64_hi;
+        Int32 result64_lo;
+        __asm
+        {
+            smull result64_lo, result64_hi, L_var2, L_var1
+            add L_add, L_add, result64_hi, asl  #3
+            add L_add, L_add, result64_lo, lsr  #29
+        }
+        return (L_add);
+    }
+
+    __inline  Int32 fxp_msu32_Q29(const Int32 L_var1, const Int32 L_var2, Int32 L_sub)
+    {
+        Int32 result64_hi;
+        Int32 result64_lo;
+        __asm
+        {
+            smull result64_lo, result64_hi, L_var2, L_var1
+            sub L_sub, L_sub, result64_hi, asl  #3
+            sub L_sub, L_sub, result64_lo, lsr  #29
+        }
+        return (L_sub);
+    }
+
+    __inline  Int32 fxp_mul32_Q28(const Int32 L_var1, const Int32 L_var2)
+    {
+        Int32 result64_hi;
+        Int32 result64_lo;
+        __asm
+        {
+            smull result64_lo, result64_hi, L_var2, L_var1
+            mov result64_hi, result64_hi, asl  #4
+            orr  result64_hi, result64_hi, result64_lo, lsr #28
+        }
+        return (result64_hi);
+    }
+
+    __inline  Int32 fxp_mul32_Q27(const Int32 L_var1, const Int32 L_var2)
+    {
+        Int32 result64_hi;
+        Int32 result64_lo;
+        __asm
+        {
+            smull result64_lo, result64_hi, L_var2, L_var1
+            mov result64_hi, result64_hi, asl  #5
+            orr  result64_hi, result64_hi, result64_lo, lsr #27
+        }
+        return (result64_hi);
+    }
+
+    __inline  Int32 fxp_mul32_Q26(const Int32 L_var1, const Int32 L_var2)
+    {
+        Int32 result64_hi;
+        Int32 result64_lo;
+        __asm
+        {
+            smull result64_lo, result64_hi, L_var2, L_var1
+            mov result64_hi, result64_hi, asl  #6
+            orr  result64_hi, result64_hi, result64_lo, lsr #26
+        }
+        return (result64_hi);
+    }
+
+    __inline  Int32 fxp_mul32_Q20(const Int32 L_var1, const Int32 L_var2)
+    {
+        Int32 result64_hi;
+        Int32 result64_lo;
+        __asm
+        {
+            smull result64_lo, result64_hi, L_var2, L_var1
+            mov result64_hi, result64_hi, asl  #12
+            orr  result64_hi, result64_hi, result64_lo, lsr #20
+        }
+        return (result64_hi);
+    }
+
+    __inline  Int32 fxp_mul32_Q15(const Int32 L_var1, const Int32 L_var2)
+    {
+        Int32 result64_hi;
+        Int32 result64_lo;
+        __asm
+        {
+            smull result64_lo, result64_hi, L_var2, L_var1
+            mov result64_hi, result64_hi, asl  #17
+            orr  result64_hi, result64_hi, result64_lo, lsr #15
+        }
+        return (result64_hi);
+    }
+
+
+
+
+    __inline  Int32 fxp_mul32_Q14(const Int32 L_var1, const Int32 L_var2)
+    {
+        Int32 result64_hi;
+        Int32 result64_lo;
+        __asm
+        {
+            smull result64_lo, result64_hi, L_var2, L_var1
+            mov result64_hi, result64_hi, asl  #18
+            orr  result64_hi, result64_hi, result64_lo, lsr #14
+        }
+        return (result64_hi);
+    }
+
+
+
+#endif
+
+
+#ifdef __cplusplus
+}
+#endif
+
+
+#endif   /*  FXP_MUL32  */
+
diff --git a/media/libstagefright/codecs/aacdec/fxp_mul32_arm_v4_gcc.h b/media/libstagefright/codecs/aacdec/fxp_mul32_arm_v4_gcc.h
new file mode 100755
index 0000000..f4ab2f7
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/fxp_mul32_arm_v4_gcc.h
@@ -0,0 +1,630 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Pathname: fxp_mul32_arm_v4_gcc.h
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+ Who:                                       Date:
+ Description:
+------------------------------------------------------------------------------
+ INCLUDE DESCRIPTION
+
+------------------------------------------------------------------------------
+*/
+
+
+
+#ifndef FXP_MUL32_V4_ARM_GCC
+#define FXP_MUL32_V4_ARM_GCC
+
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+
+#include "pv_audio_type_defs.h"
+
+
+#if defined (_ARM_V4_GCC) /* ARM_V4 GNU COMPILER  */
+
+
+#define preload_cache( a)
+
+
+    static inline  Int32 shft_lft_1(Int32 L_var1)
+    {
+        Int32 x;
+        register Int32 ra = L_var1;
+        Int32 z = INT32_MAX;
+
+        asm volatile(
+            "mov %0, %1, asl #1\n\t"
+            "teq %1, %0, asr #1\n\t"
+            "eorne   %0, %2, %1, asr #31"
+    : "=&r*i"(x)
+                    : "r"(ra),
+                    "r"(z));
+
+        return(x);
+    }
+
+    static inline Int32 fxp_mul_16_by_16bb(Int32 L_var1, Int32 L_var2)
+{
+
+        Int32 tmp1;
+        Int32 tmp2;
+        register Int32 ra = (Int32)L_var1;
+        register Int32 rb = (Int32)L_var2;
+
+        asm volatile(
+            "mov %0, %3, asl #16\n\t"
+            "mov %0, %0, asr #16\n\t"
+            "mov %1, %2, asl #16\n\t"
+            "mov %1, %1, asr #16\n\t"
+            "mul %0, %1, %0"
+    : "=&r*i"(tmp1),
+            "=&r*i"(tmp2)
+                    : "r"(ra),
+                    "r"(rb));
+
+        return (tmp1);
+
+    }
+
+#define fxp_mul_16_by_16(a, b)  fxp_mul_16_by_16bb(  a, b)
+
+
+    static inline Int32 fxp_mul_16_by_16tb(Int32 L_var1, Int32 L_var2)
+{
+
+        Int32 tmp1;
+        Int32 tmp2;
+        register Int32 ra = (Int32)L_var1;
+        register Int32 rb = (Int32)L_var2;
+
+        asm volatile(
+            "mov %0, %3, asl #16\n\t"
+            "mov %0, %0, asr #16\n\t"
+            "mov %1, %2, asr #16\n\t"
+            "mul %0, %1, %0"
+    : "=&r*i"(tmp1),
+            "=&r*i"(tmp2)
+                    : "r"(ra),
+                    "r"(rb));
+
+        return (tmp1);
+
+    }
+
+
+    static inline Int32 fxp_mul_16_by_16bt(Int32 L_var1, Int32 L_var2)
+{
+
+        Int32 tmp1;
+        Int32 tmp2;
+        register Int32 ra = (Int32)L_var1;
+        register Int32 rb = (Int32)L_var2;
+
+        asm volatile(
+            "mov %0, %3, asr #16\n\t"
+            "mov %1, %2, asl #16\n\t"
+            "mov %1, %1, asr #16\n\t"
+            "mul %0, %1, %0"
+    : "=&r*i"(tmp1),
+            "=&r*i"(tmp2)
+                    : "r"(ra),
+                    "r"(rb));
+
+        return (tmp1);
+
+    }
+
+
+    static inline Int32 fxp_mul_16_by_16tt(Int32 L_var1, Int32 L_var2)
+{
+
+        Int32 tmp1;
+        Int32 tmp2;
+        register Int32 ra = (Int32)L_var1;
+        register Int32 rb = (Int32)L_var2;
+
+        asm volatile(
+            "mov %0, %3, asr #16\n\t"
+            "mov %1, %2, asr #16\n\t"
+            "mul %0, %1, %0"
+    : "=&r*i"(tmp1),
+            "=&r*i"(tmp2)
+                    : "r"(ra),
+                    "r"(rb));
+
+        return (tmp1);
+
+    }
+
+
+
+    static inline  Int32 fxp_mac_16_by_16(Int16 L_var1,  Int16 L_var2, Int32 L_add)
+{
+
+        Int32 tmp;
+        register Int32 ra = (Int32)L_var1;
+        register Int32 rb = (Int32)L_var2;
+        register Int32 rc = (Int32)L_add;
+
+        asm volatile(
+            "mla %0, %1, %2, %3"
+    : "=&r*i"(tmp)
+                    : "r"(ra),
+                    "r"(rb),
+                    "r"(rc));
+
+        return (tmp);
+    }
+
+
+
+    static inline Int32 fxp_mac_16_by_16_bb(Int16 L_var1,  Int32 L_var2, Int32 L_add)
+{
+
+        Int32 tmp1;
+        Int32 tmp2;
+        register Int32 ra = (Int32)L_var1;
+        register Int32 rb = (Int32)L_var2;
+        register Int32 rc = (Int32)L_add;
+
+        asm volatile(
+            "mov %0, %3, asl #16\n\t"
+            "mov %0, %0, asr #16\n\t"
+            "mla %1, %0, %2, %4"
+    : "=&r*i"(tmp1),
+            "=&r*i"(tmp2)
+                    : "r"(ra),
+                    "r"(rb),
+                    "r"(rc));
+
+        return (tmp2);
+    }
+
+
+
+    static inline  Int32 fxp_mac_16_by_16_bt(Int16 L_var1,  Int32 L_var2, Int32 L_add)
+{
+
+        Int32 tmp1;
+        Int32 tmp2;
+        register Int32 ra = (Int32)L_var1;
+        register Int32 rb = (Int32)L_var2;
+        register Int32 rc = (Int32)L_add;
+
+        asm volatile(
+            "mov %0, %3, asr #16\n\t"
+            "mla %1, %0, %2, %4"
+    : "=&r*i"(tmp1),
+            "=&r*i"(tmp2)
+                    : "r"(ra),
+                    "r"(rb),
+                    "r"(rc));
+
+        return (tmp2);
+
+    }
+
+
+
+    static inline  Int32 cmplx_mul32_by_16(Int32 x, Int32 y, Int32 exp_jw)
+{
+
+        Int32 rTmp0;
+        Int32 iTmp0;
+        Int32 result64_hi;
+        register Int32 ra = (Int32)x;
+        register Int32 rb = (Int32)y;
+        register Int32 rc = (Int32)exp_jw;
+
+
+
+        asm volatile(
+            "mov %0, %5, asr #16\n\t"
+            "mov %1, %5, asl #16\n\t"
+            "mov %0, %0, asl #16\n\t"
+    : "=&r*i"(rTmp0),
+            "=&r*i"(iTmp0),
+            "=&r*i"(result64_hi)
+                    : "r"(ra),
+                    "r"(rb),
+                    "r"(rc));
+
+
+        asm volatile(
+            "smull %0, %2, %3, %0\n\t"
+            "smlal %1, %2, %4, %1"
+    : "=&r*i"(rTmp0),
+            "=&r*i"(iTmp0),
+            "=&r*i"(result64_hi)
+                    : "r"(ra),
+                    "r"(rb),
+                    "r"(rc));
+
+        return (result64_hi);
+
+
+    }
+
+
+    static inline  Int32 fxp_mul32_by_16(Int32 L_var1, Int32 L_var2)
+{
+
+        Int32 rTmp0;
+        Int32 result64_hi;
+        Int32 result64_lo;
+        register Int32 ra = (Int32)L_var1;
+        register Int32 rb = (Int32)L_var2;
+
+        asm volatile(
+            "mov %0, %4, asl #16\n\t"
+            "smull %2, %1, %0, %3"
+    : "=&r*i"(rTmp0),
+            "=&r*i"(result64_hi),
+            "=&r*i"(result64_lo)
+                    : "r"(ra),
+                    "r"(rb));
+
+        return (result64_hi);
+    }
+
+
+#define fxp_mul32_by_16b( a, b)   fxp_mul32_by_16( a, b)
+
+
+
+    static inline  Int32 fxp_mul32_by_16t(Int32 L_var1, Int32 L_var2)
+{
+
+        Int32 rTmp0;
+        Int32 result64_hi;
+        Int32 result64_lo;
+        register Int32 ra = (Int32)L_var1;
+        register Int32 rb = (Int32)L_var2;
+
+        asm volatile(
+            "mov %0, %4, asr #16\n\t"
+            "mov %0, %0, asl #16\n\t"
+            "smull %2, %1, %0, %3"
+    : "=&r*i"(rTmp0),
+            "=&r*i"(result64_hi),
+            "=&r*i"(result64_lo)
+                    : "r"(ra),
+                    "r"(rb));
+
+        return (result64_hi);
+    }
+
+
+
+    static inline  Int32 fxp_mac32_by_16(Int32 L_var1, Int32 L_var2, Int32 L_add)
+{
+
+        Int32 rTmp0;
+        Int32 result64_hi;
+        Int32 result64_lo;
+        register Int32 ra = (Int32)L_var1;
+        register Int32 rb = (Int32)L_var2;
+        register Int32 rc = (Int32)L_add;
+
+        asm volatile(
+            "mov %0, %4, asl #16\n\t"
+            "mov %1, %5\n\t"
+            "smlal %2, %1, %0, %3"
+    : "=&r*i"(rTmp0),
+            "=&r*i"(result64_hi),
+            "=&r*i"(result64_lo)
+                    : "r"(ra),
+                    "r"(rb),
+                    "r"(rc));
+
+        return (result64_hi);
+    }
+
+
+    static inline int64 fxp_mac64_Q31(int64 sum, const Int32 L_var1, const Int32 L_var2)
+{
+        sum += (int64)L_var1 * L_var2;
+        return (sum);
+    }
+
+
+    static inline Int32 fxp_mac32_Q30(const Int32 a, const Int32 b, Int32 L_add)
+    {
+        Int32 result64_hi;
+        Int32 result64_lo;
+        register Int32 ra = (Int32)a;
+        register Int32 rb = (Int32)b;
+        register Int32 rc = (Int32)L_add;
+
+        asm volatile("smull %1, %0, %2, %3\n\t"
+                     "add %4, %4, %0, asl #2\n\t"
+                     "add %0, %4, %1, lsr #30"
+             : "=&r*i"(result64_hi),
+                     "=&r*i"(result64_lo)
+                             : "r"(ra),
+                             "r"(rb),
+                             "r"(rc));
+
+        return (result64_hi);
+    }
+
+
+    static inline Int32 fxp_mac32_Q31(Int32 L_add, const Int32 a, const Int32 b)
+{
+
+        Int32 result64_hi;
+        Int32 result64_lo;
+        register Int32 ra = (Int32)a;
+        register Int32 rb = (Int32)b;
+        register Int32 rc = (Int32)L_add;
+
+        asm volatile("smull %1, %0, %2, %3\n\t"
+                     "add %0, %0, %4"
+             : "=&r*i"(result64_hi),
+                     "=&r*i"(result64_lo)
+                             : "r"(ra),
+                             "r"(rb),
+                             "r"(rc));
+
+        return (result64_hi);
+    }
+
+
+
+    static inline Int32 fxp_msu32_Q31(Int32 L_sub, const Int32 a, const Int32 b)
+{
+        Int32 result64_hi;
+        Int32 result64_lo;
+        register Int32 ra = (Int32)a;
+        register Int32 rb = (Int32)b;
+        register Int32 rc = (Int32)L_sub;
+
+        asm volatile("smull %1, %0, %2, %3\n\t"
+                     "sub %0, %4, %0"
+             : "=&r*i"(result64_hi),
+                     "=&r*i"(result64_lo)
+                             : "r"(ra),
+                             "r"(rb),
+                             "r"(rc));
+
+
+        return (result64_hi);
+    }
+
+
+    static inline Int32 fxp_mul32_Q31(const Int32 a, const Int32 b)
+{
+        Int32 result64_hi;
+        Int32 result64_lo;
+        register Int32 ra = (Int32)a;
+        register Int32 rb = (Int32)b;
+        asm volatile(
+            "smull %1, %0, %2, %3"
+    : "=&r*i"(result64_hi),
+            "=&r*i"(result64_lo)
+                    : "r"(ra),
+                    "r"(rb));
+
+        return (result64_hi);
+    }
+
+
+    static inline Int32 fxp_mul32_Q30(const Int32 a, const Int32 b)
+{
+        Int32 result64_hi;
+        Int32 result64_lo;
+        register Int32 ra = (Int32)a;
+        register Int32 rb = (Int32)b;
+        asm volatile("smull %1, %0, %2, %3\n\t"
+                     "mov %0, %0, lsl #2\n\t"
+                     "orr   %0, %0, %1, lsr #30"
+             : "=&r*i"(result64_hi),
+                     "=&r*i"(result64_lo)
+                             : "r"(ra),
+                             "r"(rb));
+        return (result64_hi);
+    }
+
+
+
+    static inline Int32 fxp_mac32_Q29(const Int32 a, const Int32 b, Int32 L_add)
+{
+        Int32 result64_hi;
+        Int32 result64_lo;
+        register Int32 ra = (Int32)a;
+        register Int32 rb = (Int32)b;
+        register Int32 rc = (Int32)L_add;
+
+        asm volatile("smull %1, %0, %2, %3\n\t"
+                     "add   %4, %4, %0, lsl #3\n\t"
+                     "add   %0, %4, %1, lsr #29"
+             : "=&r*i"(result64_hi),
+                     "=&r*i"(result64_lo)
+                             : "r"(ra),
+                             "r"(rb),
+                             "r"(rc));
+
+        return (result64_hi);
+    }
+
+
+    static inline Int32 fxp_msu32_Q29(const Int32 a, const Int32 b, Int32 L_sub)
+{
+        Int32 result64_hi;
+        Int32 result64_lo;
+        register Int32 ra = (Int32)a;
+        register Int32 rb = (Int32)b;
+        register Int32 rc = (Int32)L_sub;
+
+        asm volatile("smull %1, %0, %2, %3\n\t"
+                     "sub   %4, %4, %0, lsl #3\n\t"
+                     "sub   %0, %4, %1, lsr #29"
+             : "=&r*i"(result64_hi),
+                     "=&r*i"(result64_lo)
+                             : "r"(ra),
+                             "r"(rb),
+                             "r"(rc));
+
+        return (result64_hi);
+    }
+
+    static inline Int32 fxp_mul32_Q29(const Int32 a, const Int32 b)
+{
+        Int32 result64_hi;
+        Int32 result64_lo;
+        register Int32 ra = (Int32)a;
+        register Int32 rb = (Int32)b;
+        asm volatile("smull %1, %0, %2, %3\n\t"
+                     "mov %0, %0, lsl #3\n\t"
+                     "orr   %0, %0, %1, lsr #29"
+             : "=&r*i"(result64_hi),
+                     "=&r*i"(result64_lo)
+                             : "r"(ra),
+                             "r"(rb));
+        return (result64_hi);
+    }
+
+
+
+    static inline Int32 fxp_mul32_Q28(const Int32 a, const Int32 b)
+{
+        Int32 result64_hi;
+        Int32 result64_lo;
+        register Int32 ra = (Int32)a;
+        register Int32 rb = (Int32)b;
+        asm volatile("smull %1, %0, %2, %3\n\t"
+                     "mov %0, %0, lsl #4\n\t"
+                     "orr   %0, %0, %1, lsr #28"
+             : "=&r*i"(result64_hi),
+                     "=&r*i"(result64_lo)
+                             : "r"(ra),
+                             "r"(rb));
+        return (result64_hi);
+    }
+
+    static inline Int32 fxp_mul32_Q27(const Int32 a, const Int32 b)
+{
+        Int32 result64_hi;
+        Int32 result64_lo;
+        register Int32 ra = (Int32)a;
+        register Int32 rb = (Int32)b;
+        asm volatile("smull %1, %0, %2, %3\n\t"
+                     "mov %0, %0, lsl #5\n\t"
+                     "orr   %0, %0, %1, lsr #27"
+             : "=&r*i"(result64_hi),
+                     "=&r*i"(result64_lo)
+                             : "r"(ra),
+                             "r"(rb));
+
+        return (result64_hi);
+    }
+
+
+    static inline Int32 fxp_mul32_Q26(const Int32 a, const Int32 b)
+{
+        Int32 result64_hi;
+        Int32 result64_lo;
+        register Int32 ra = (Int32)a;
+        register Int32 rb = (Int32)b;
+        asm volatile("smull %1, %0, %2, %3\n\t"
+                     "mov %0, %0, lsl #6\n\t"
+                     "orr   %0, %0, %1, lsr #26"
+             : "=&r*i"(result64_hi),
+                     "=&r*i"(result64_lo)
+                             : "r"(ra),
+                             "r"(rb));
+
+        return (result64_hi);
+    }
+
+
+    static inline Int32 fxp_mul32_Q20(const Int32 a, const Int32 b)
+{
+        Int32 result64_hi;
+        Int32 result64_lo;
+        register Int32 ra = (Int32)a;
+        register Int32 rb = (Int32)b;
+        asm volatile("smull %1, %0, %2, %3\n\t"
+                     "mov %0, %0, lsl #12\n\t"
+                     "orr   %0, %0, %1, lsr #20"
+             : "=&r*i"(result64_hi),
+                     "=&r*i"(result64_lo)
+                             : "r"(ra),
+                             "r"(rb));
+
+        return (result64_hi);
+    }
+
+
+    static inline Int32 fxp_mul32_Q15(const Int32 a, const Int32 b)
+{
+        Int32 result64_hi;
+        Int32 result64_lo;
+        register Int32 ra = (Int32)a;
+        register Int32 rb = (Int32)b;
+        asm volatile("smull %1, %0, %2, %3\n\t"
+                     "mov %0, %0, lsl #17\n\t"
+                     "orr   %0, %0, %1, lsr #15"
+             : "=&r*i"(result64_hi),
+                     "=&r*i"(result64_lo)
+                             : "r"(ra),
+                             "r"(rb));
+
+        return (result64_hi);
+    }
+
+
+
+    static inline Int32 fxp_mul32_Q14(const Int32 a, const Int32 b)
+{
+        Int32 result64_hi;
+        Int32 result64_lo;
+        register Int32 ra = (Int32)a;
+        register Int32 rb = (Int32)b;
+        asm volatile("smull %1, %0, %2,  %3\n\t"
+                     "mov   %0, %0, lsl #18\n\t"
+                     "orr   %0, %0, %1, lsr #14"
+             : "=&r*i"(result64_hi),
+                     "=&r*i"(result64_lo)
+                             : "r"(ra),
+                             "r"(rb));
+
+        return (result64_hi);
+    }
+
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+
+
+#endif   /*  FXP_MUL32_V4_ARM_GCC  */
+
+
+
diff --git a/media/libstagefright/codecs/aacdec/fxp_mul32_arm_v5.h b/media/libstagefright/codecs/aacdec/fxp_mul32_arm_v5.h
new file mode 100644
index 0000000..8ab108f
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/fxp_mul32_arm_v5.h
@@ -0,0 +1,450 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Pathname: ./c/include/fxp_mul32_arm_v5.h
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+ Who:                                       Date:
+ Description:
+------------------------------------------------------------------------------
+ INCLUDE DESCRIPTION
+
+------------------------------------------------------------------------------
+*/
+
+#ifndef FXP_MUL32_ARM_V5
+#define FXP_MUL32_ARM_V5
+
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+#include "pv_audio_type_defs.h"
+
+
+#if defined(PV_ARM_V5)
+
+//#undef EXTENDED_ASM
+#define EXTENDED_ASM
+#define _ARM_V5_
+
+
+    __inline  Int32 shft_lft_1(Int32 L_var1)
+    {
+        __asm
+        {
+            qadd L_var1, L_var1, L_var1
+        }
+
+        return L_var1;
+    }
+
+
+    __inline  Int32 fxp_mul_16_by_16(Int32 L_var1,  Int32 L_var2)
+    {
+        __asm
+        {
+            smulbb L_var1, L_var1, L_var2
+        }
+        return L_var1;
+    }
+
+
+    __inline  Int32 fxp_mul_16_by_16bb(Int32 L_var1,  Int32 L_var2)
+    {
+        __asm
+        {
+            smulbb L_var1, L_var1, L_var2
+        }
+        return L_var1;
+    }
+
+
+    __inline  Int32 fxp_mul_16_by_16tb(Int32 L_var1,  Int32 L_var2)
+    {
+        __asm
+        {
+            smultb L_var1, L_var1, L_var2
+        }
+        return L_var1;
+    }
+
+    __inline  Int32 fxp_mul_16_by_16tt(Int32 L_var1,  Int32 L_var2)
+    {
+        __asm
+        {
+            smultt L_var1, L_var1, L_var2
+        }
+        return L_var1;
+    }
+
+    __inline  Int32 fxp_mul_16_by_16bt(Int32 L_var1,  Int32 L_var2)
+    {
+        __asm
+        {
+            smulbt L_var1, L_var1, L_var2
+        }
+        return L_var1;
+    }
+
+
+
+    __inline  Int32 fxp_mac_16_by_16(const Int32 L_var1, const Int32 L_var2, Int32 L_add)
+    {
+        __asm
+        {
+            smlabb L_add, L_var1, L_var2, L_add
+        }
+        return (L_add);
+    }
+
+    __inline  Int32 fxp_mac_16_by_16_bb(const Int32 L_var1,  Int32 L_var2, Int32 L_add)
+    {
+        __asm
+        {
+            smlabb L_add, L_var1, L_var2, L_add
+        }
+        return L_add;
+    }
+
+    __inline  Int32 fxp_mac_16_by_16_bt(const Int32 L_var1,  Int32 L_var2, Int32 L_add)
+    {
+        __asm
+        {
+            smlabt L_add, L_var1, L_var2, L_add
+        }
+        return L_add;
+    }
+
+
+    __inline  Int32 fxp_mac_16_by_16_tb(const Int32 L_var1,  Int32 L_var2, Int32 L_add)
+    {
+        __asm
+        {
+            smlatb L_add, L_var1, L_var2, L_add
+        }
+        return L_add;
+    }
+
+    __inline  Int32 fxp_mac_16_by_16_tt(const Int32 L_var1,  Int32 L_var2, Int32 L_add)
+    {
+        __asm
+        {
+            smlatt L_add, L_var1, L_var2, L_add
+        }
+        return L_add;
+    }
+
+    __inline  Int32 fxp_mac32_by_16(Int32 L_var1, const Int32 L_var2, Int32 L_add)
+    {
+        __asm
+        {
+            smlawb L_add, L_var1, L_var2, L_add
+        }
+        return (L_add);
+    }
+
+
+    __inline  int64 fxp_mac64_Q31(int64 sum, const Int32 L_var1, const Int32 L_var2)
+    {
+        uint32 b = (UInt32)(sum);
+        int32 c = Int32(sum >> 32);
+        __asm
+        {
+            smlal b, c, L_var1, L_var2
+        }
+        return (((int64(c)) << 32) | b);
+    }
+
+
+    __inline  Int32 fxp_mac32_Q31(Int32 L_add,  Int32 L_var1, const Int32 L_var2)
+    {
+        __asm
+        {
+            smlal L_var1, L_add, L_var2, L_var1
+        }
+        return L_add;
+    }
+
+    __inline  Int32 fxp_msu32_Q31(Int32 L_sub,  Int32 L_var1, const Int32 L_var2)
+    {
+        __asm
+        {
+            rsb   L_var1, L_var1, #0
+            smlal L_var1, L_sub, L_var2, L_var1
+        }
+        return L_sub;
+    }
+
+    __inline  Int32 fxp_mul32_Q31(Int32 L_var1, const Int32 L_var2)
+    {
+        Int32 result64_hi;
+        __asm
+        {
+            smull L_var1, result64_hi, L_var2, L_var1
+        }
+        return (result64_hi);
+    }
+
+    __inline  Int32 fxp_mul32_Q30(const Int32 L_var1, const Int32 L_var2)
+    {
+        Int32 result64_hi;
+        Int32 result64_lo;
+        __asm
+        {
+            smull result64_lo, result64_hi, L_var2, L_var1
+            mov result64_hi, result64_hi, asl  #2
+#ifdef EXTENDED_ASM
+            mov result64_lo, result64_lo, lsr  #30
+            orr  result64_hi, result64_lo, result64_hi
+#else
+            orr  result64_hi, result64_hi, result64_lo, lsr #30
+#endif
+        }
+        return (result64_hi);
+    }
+
+
+    __inline  Int32 fxp_mac32_Q30(const Int32 L_var1, const Int32 L_var2, Int32 L_add)
+    {
+        Int32 result64_hi;
+        Int32 result64_lo;
+        __asm
+        {
+            smull result64_lo, result64_hi, L_var2, L_var1
+            add L_add, L_add, result64_hi, asl  #2
+            add L_add, L_add, result64_lo, lsr  #30
+        }
+        return (L_add);
+    }
+
+
+    __inline  Int32 fxp_mul32_Q29(const Int32 L_var1, const Int32 L_var2)
+    {
+        Int32 result64_hi;
+        Int32 result64_lo;
+        __asm
+        {
+            smull result64_lo, result64_hi, L_var2, L_var1
+            mov result64_hi, result64_hi, asl  #3
+#ifdef EXTENDED_ASM
+            mov result64_lo, result64_lo, lsr  #29
+            orr  result64_hi, result64_lo, result64_hi
+#else
+            orr  result64_hi, result64_hi, result64_lo, lsr #29
+#endif
+        }
+        return (result64_hi);
+    }
+
+
+
+    __inline  Int32 fxp_mac32_Q29(const Int32 L_var1, const Int32 L_var2, Int32 L_add)
+    {
+        Int32 result64_hi;
+        Int32 result64_lo;
+        __asm
+        {
+            smull result64_lo, result64_hi, L_var2, L_var1
+            add L_add, L_add, result64_hi, asl  #3
+            add L_add, L_add, result64_lo, lsr  #29
+        }
+        return (L_add);
+    }
+
+
+    __inline  Int32 fxp_msu32_Q29(const Int32 L_var1, const Int32 L_var2, Int32 L_sub)
+    {
+        Int32 result64_hi;
+        Int32 result64_lo;
+        __asm
+        {
+            smull result64_lo, result64_hi, L_var2, L_var1
+            sub L_sub, L_sub, result64_hi, asl  #3
+            sub L_sub, L_sub, result64_lo, lsr  #29
+        }
+        return (L_sub);
+    }
+
+
+    __inline  Int32 fxp_mul32_Q28(const Int32 L_var1, const Int32 L_var2)
+    {
+        Int32 result64_hi;
+        Int32 result64_lo;
+        __asm
+        {
+            smull result64_lo, result64_hi, L_var2, L_var1
+            mov result64_hi, result64_hi, asl  #4
+#ifdef EXTENDED_ASM
+            mov result64_lo, result64_lo, lsr  #28
+            orr  result64_hi, result64_lo, result64_hi
+#else
+            orr  result64_hi, result64_hi, result64_lo, lsr #28
+#endif
+
+        }
+        return (result64_hi);
+    }
+
+    __inline  Int32 fxp_mul32_Q27(const Int32 L_var1, const Int32 L_var2)
+    {
+        Int32 result64_hi;
+        Int32 result64_lo;
+        __asm
+        {
+            smull result64_lo, result64_hi, L_var2, L_var1
+            mov result64_hi, result64_hi, asl  #5
+#ifdef EXTENDED_ASM
+            mov result64_lo, result64_lo, lsr  #27
+            orr  result64_hi, result64_lo, result64_hi
+#else
+            orr  result64_hi, result64_hi, result64_lo, lsr #27
+#endif
+        }
+        return (result64_hi);
+    }
+
+    __inline  Int32 fxp_mul32_Q26(const Int32 L_var1, const Int32 L_var2)
+    {
+        Int32 result64_hi;
+        Int32 result64_lo;
+        __asm
+        {
+            smull result64_lo, result64_hi, L_var2, L_var1
+            mov result64_hi, result64_hi, asl  #6
+#ifdef EXTENDED_ASM
+            mov result64_lo, result64_lo, lsr  #26
+            orr  result64_hi, result64_lo, result64_hi
+#else
+            orr  result64_hi, result64_hi, result64_lo, lsr #26
+#endif
+
+        }
+        return (result64_hi);
+    }
+
+    __inline  Int32 fxp_mul32_Q20(const Int32 L_var1, const Int32 L_var2)
+    {
+        Int32 result64_hi;
+        Int32 result64_lo;
+        __asm
+        {
+            smull result64_lo, result64_hi, L_var2, L_var1
+            mov result64_hi, result64_hi, asl  #12
+#ifdef EXTENDED_ASM
+            mov result64_lo, result64_lo, lsr  #20
+            orr  result64_hi, result64_lo, result64_hi
+#else
+            orr  result64_hi, result64_hi, result64_lo, lsr #20
+#endif
+        }
+        return (result64_hi);
+    }
+
+    __inline  Int32 fxp_mul32_by_16(Int32 L_var1, const Int32 L_var2)
+    {
+        Int32 result64_hi;
+        __asm
+        {
+            smulwb result64_hi, L_var1, L_var2
+        }
+        return (result64_hi);
+    }
+
+#define fxp_mul32_by_16b( a, b)         fxp_mul32_by_16(a, b)
+
+    __inline  Int32 fxp_mul32_by_16t(Int32 L_var1, const Int32 L_var2)
+    {
+        Int32 result64_hi;
+        __asm
+        {
+            smulwt result64_hi, L_var1, L_var2
+        }
+        return (result64_hi);
+    }
+
+    __inline  Int32 fxp_mul32_Q15(const Int32 L_var1, const Int32 L_var2)
+    {
+        Int32 result64_hi;
+        Int32 result64_lo;
+        __asm
+        {
+            smull result64_lo, result64_hi, L_var2, L_var1
+            mov result64_hi, result64_hi, asl  #17
+#ifdef EXTENDED_ASM
+            mov result64_lo, result64_lo, lsr  #15
+            orr  result64_hi, result64_lo, result64_hi
+#else
+            orr  result64_hi, result64_hi, result64_lo, lsr #15
+#endif
+        }
+        return (result64_hi);
+    }
+
+
+    __inline  Int32 cmplx_mul32_by_16(Int32 L_var1, const Int32 L_var2, const Int32 cmplx)
+    {
+        Int32 result64_hi;
+
+        __asm
+        {
+            smulwt result64_hi, L_var1, cmplx
+            smlawb result64_hi, L_var2, cmplx, result64_hi
+        }
+        return (result64_hi);
+
+    }
+
+    __inline  Int32 fxp_mul32_Q14(const Int32 L_var1, const Int32 L_var2)
+    {
+        Int32 result64_hi;
+        Int32 result64_lo;
+        __asm
+        {
+            smull result64_lo, result64_hi, L_var2, L_var1
+            mov result64_hi, result64_hi, asl  #18
+#ifdef EXTENDED_ASM
+            mov result64_lo, result64_lo, lsr  #14
+            orr  result64_hi, result64_lo, result64_hi
+#else
+            orr  result64_hi, result64_hi, result64_lo, lsr #14
+#endif
+        }
+        return (result64_hi);
+    }
+
+
+#define preload_cache( a)
+
+
+
+
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+
+
+#endif   /*  FXP_MUL32  */
+
diff --git a/media/libstagefright/codecs/aacdec/fxp_mul32_c_equivalent.h b/media/libstagefright/codecs/aacdec/fxp_mul32_c_equivalent.h
new file mode 100644
index 0000000..5bcbe53
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/fxp_mul32_c_equivalent.h
@@ -0,0 +1,285 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Pathname: ./c/include/fxp_mul32_c_equivalent.h
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+ Who:                                       Date:
+ Description:
+------------------------------------------------------------------------------
+ INCLUDE DESCRIPTION
+
+------------------------------------------------------------------------------
+*/
+
+#ifndef FXP_MUL32_C_EQUIVALENT
+#define FXP_MUL32_C_EQUIVALENT
+
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+
+#include "pv_audio_type_defs.h"
+
+
+#if defined(C_EQUIVALENT)
+
+#define preload_cache( a)
+
+    __inline  Int32 shft_lft_1(Int32 L_var1)
+    {
+        if (((L_var1 << 1) >> 1) == L_var1)
+            L_var1 <<= 1;
+        else
+            L_var1 = ((L_var1 >> 31) ^ INT32_MAX);
+
+        return (L_var1);
+
+    }
+
+
+    __inline  Int32 fxp_mul_16_by_16bb(Int32 L_var1,  Int32 L_var2)
+    {
+        L_var2 = (L_var2 << 16) >> 16;
+        L_var1 = (L_var1 << 16) >> 16;
+
+        L_var1 *= L_var2;
+
+        return L_var1;
+
+    }
+
+
+#define fxp_mul_16_by_16(a, b)  fxp_mul_16_by_16bb(  a, b)
+
+
+    __inline  Int32 fxp_mul_16_by_16tb(Int32 L_var1,  Int32 L_var2)
+    {
+        L_var2 = (L_var2 << 16) >> 16;
+        L_var1 =  L_var1 >> 16;
+
+        L_var1 *= L_var2;
+
+        return L_var1;
+
+    }
+
+
+    __inline  Int32 fxp_mul_16_by_16bt(Int32 L_var1,  Int32 L_var2)
+    {
+        L_var2 = L_var2 >> 16;
+        L_var1 = (L_var1 << 16) >> 16;
+
+        L_var1 *= L_var2;
+
+        return L_var1;
+
+    }
+
+
+    __inline  Int32 fxp_mul_16_by_16tt(Int32 L_var1,  Int32 L_var2)
+    {
+        L_var2 = L_var2 >> 16;
+        L_var1 = L_var1 >> 16;
+
+        L_var1 *= L_var2;
+
+        return L_var1;
+
+    }
+
+    __inline  Int32 fxp_mac_16_by_16(Int16 L_var1,  Int16 L_var2, Int32 L_add)
+    {
+
+        L_add += L_var1 * L_var2;
+
+        return L_add;
+
+    }
+
+
+
+
+
+    __inline  Int32 fxp_mac_16_by_16_bb(Int16 L_var1,  Int32 L_var2, Int32 L_add)
+    {
+        L_var2 = (L_var2 << 16) >> 16;
+
+        L_add += L_var1 * L_var2;
+
+        return L_add;
+
+    }
+
+
+    __inline  Int32 fxp_mac_16_by_16_bt(Int16 L_var1,  Int32 L_var2, Int32 L_add)
+    {
+        L_var2 = L_var2 >> 16;
+
+        L_add += L_var1 * L_var2;
+
+        return L_add;
+
+    }
+
+
+
+
+
+    __inline  Int32 cmplx_mul32_by_16(Int32 x, const Int32 y, Int32 exp_jw)
+    {
+        Int32  rTmp0 = (Int16)(exp_jw >> 16);
+        Int32  iTmp0 = exp_jw;
+        Int32  z;
+
+        z  = (Int32)(((int64_t)x * (rTmp0 << 16)) >> 32);
+        z += (Int32)(((int64_t)y * (iTmp0 << 16)) >> 32);
+
+        return (z);
+    }
+
+
+    __inline  Int32 fxp_mul32_by_16(Int32 L_var1, const Int32 L_var2)
+    {
+        Int32  z;
+
+        z = (Int32)(((int64_t) L_var1 * (L_var2 << 16)) >> 32);
+        return(z);
+    }
+
+
+#define fxp_mul32_by_16b( a, b)   fxp_mul32_by_16( a, b)
+
+
+    __inline  Int32 fxp_mul32_by_16t(Int32 L_var1, const Int32 L_var2)
+    {
+        Int32  rTmp0 = (Int16)(L_var2 >> 16);
+        Int32  z;
+
+        z = (Int32)(((int64_t) L_var1 * (rTmp0 << 16)) >> 32);
+
+        return(z);
+    }
+
+
+    __inline  Int32 fxp_mac32_by_16(const Int32 L_var1, const Int32 L_var2, Int32 L_add)
+    {
+        Int32  rTmp0 = L_var2 << 16;
+
+        L_add += (Int32)(((int64_t) L_var1 * rTmp0) >> 32);
+
+        return(L_add);
+    }
+
+    __inline  int64_t fxp_mac64_Q31(int64_t sum, const Int32 L_var1, const Int32 L_var2)
+    {
+        sum += (int64_t)L_var1 * L_var2;
+        return (sum);
+    }
+
+    __inline Int32 fxp_mul32_Q31(const Int32 a, const Int32 b)
+    {
+        return (Int32)(((int64_t)(a) * b) >> 32);
+    }
+
+    __inline Int32 fxp_mac32_Q31(Int32 L_add, const Int32 a, const Int32 b)
+    {
+        return (L_add + (Int32)(((int64_t)(a) * b) >> 32));
+    }
+
+    __inline Int32 fxp_msu32_Q31(Int32 L_sub, const Int32 a, const Int32 b)
+    {
+        return (L_sub - (Int32)(((int64_t)(a) * b) >> 32));
+    }
+
+
+    __inline Int32 fxp_mul32_Q30(const Int32 a, const Int32 b)
+    {
+        return (Int32)(((int64_t)(a) * b) >> 30);
+    }
+
+    __inline Int32 fxp_mac32_Q30(const Int32 a, const Int32 b, Int32 L_add)
+    {
+        return (L_add + (Int32)(((int64_t)(a) * b) >> 30));
+    }
+
+
+    __inline Int32 fxp_mul32_Q29(const Int32 a, const Int32 b)
+    {
+        return (Int32)(((int64_t)(a) * b) >> 29);
+    }
+
+    __inline Int32 fxp_mac32_Q29(const Int32 a, const Int32 b, Int32 L_add)
+    {
+        return (L_add + (Int32)(((int64_t)(a) * b) >> 29));
+    }
+
+    __inline Int32 fxp_msu32_Q29(const Int32 a, const Int32 b, Int32 L_sub)
+    {
+        return (L_sub - (Int32)(((int64_t)(a) * b) >> 29));
+    }
+
+
+    __inline Int32 fxp_mul32_Q28(const Int32 a, const Int32 b)
+    {
+        return (Int32)(((int64_t)(a) * b) >> 28);
+    }
+
+    __inline Int32 fxp_mul32_Q27(const Int32 a, const Int32 b)
+    {
+        return (Int32)(((int64_t)(a) * b) >> 27);
+    }
+
+    __inline Int32 fxp_mul32_Q26(const Int32 a, const Int32 b)
+    {
+        return (Int32)(((int64_t)(a) * b) >> 26);
+    }
+
+    __inline Int32 fxp_mul32_Q20(const Int32 a, const Int32 b)
+    {
+        return (Int32)(((int64_t)(a) * b) >> 20);
+    }
+
+    __inline Int32 fxp_mul32_Q15(const Int32 a, const Int32 b)
+    {
+        return (Int32)(((int64_t)(a) * b) >> 15);
+    }
+
+    __inline Int32 fxp_mul32_Q14(const Int32 a, const Int32 b)
+    {
+        return (Int32)(((int64_t)(a) * b) >> 14);
+    }
+
+
+
+#endif
+
+
+#ifdef __cplusplus
+}
+#endif
+
+
+#endif   /*  FXP_MUL32  */
+
diff --git a/media/libstagefright/codecs/aacdec/fxp_mul32_c_msc_evc.h b/media/libstagefright/codecs/aacdec/fxp_mul32_c_msc_evc.h
new file mode 100644
index 0000000..64397cf
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/fxp_mul32_c_msc_evc.h
@@ -0,0 +1,254 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Pathname: fxp_mul32_msc_evc.h
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+ Who:                                       Date:
+ Description:
+------------------------------------------------------------------------------
+ INCLUDE DESCRIPTION
+
+------------------------------------------------------------------------------
+*/
+
+
+#ifndef FXP_MUL32_MSC_EVC
+#define FXP_MUL32_MSC_EVC
+
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+
+#include "pv_audio_type_defs.h"
+
+#if defined(PV_ARM_MSC_EVC_V4)
+
+#include "cmnintrin.h"
+
+#define preload_cache( a)
+
+    __inline  Int32 shft_lft_1(Int32 L_var1)
+    {
+        if (((L_var1 << 1) >> 1) == L_var1)
+            L_var1 <<= 1;
+        else
+            L_var1 = ((L_var1 >> 31) ^ INT32_MAX);
+
+        return L_var1;
+
+    }
+
+    __inline  Int32 fxp_mul_16_by_16bb(Int32 L_var1,  Int32 L_var2)
+    {
+        L_var2 = (L_var2 << 16) >> 16;
+        L_var1 = (L_var1 << 16) >> 16;
+
+        return (L_var1*L_var2);
+
+    }
+
+#define fxp_mul_16_by_16(a, b)  fxp_mul_16_by_16bb(  a, b)
+
+    __inline  Int32 fxp_mul_16_by_16tb(Int32 L_var1,  Int32 L_var2)
+    {
+        L_var2 = (L_var2 << 16) >> 16;
+        L_var1 =  L_var1 >> 16;
+
+        return (L_var1*L_var2);
+
+    }
+
+
+    __inline  Int32 fxp_mul_16_by_16bt(Int32 L_var1,  Int32 L_var2)
+    {
+        L_var2 = L_var2 >> 16;
+        L_var1 = (L_var1 << 16) >> 16;
+
+        return (L_var1*L_var2);
+
+    }
+
+
+    __inline  Int32 fxp_mul_16_by_16tt(Int32 L_var1,  Int32 L_var2)
+    {
+        L_var2 = L_var2 >> 16;
+        L_var1 = L_var1 >> 16;
+
+        return (L_var1*L_var2);
+
+    }
+
+    __inline  Int32 fxp_mac_16_by_16(Int16 L_var1,  Int16 L_var2, Int32 L_add)
+    {
+        return (L_add + (L_var1*L_var2));
+    }
+
+
+
+    __inline  Int32 fxp_mac_16_by_16_bb(Int16 L_var1,  Int32 L_var2, Int32 L_add)
+    {
+        L_var2 = (L_var2 << 16) >> 16;
+
+        return (L_add + (L_var1*L_var2));
+
+    }
+
+
+    __inline  Int32 fxp_mac_16_by_16_bt(Int16 L_var1,  Int32 L_var2, Int32 L_add)
+    {
+        L_var2 = L_var2 >> 16;
+
+        return (L_add + (L_var1*L_var2));
+
+    }
+
+
+    __inline  Int32 cmplx_mul32_by_16(Int32 x, const Int32 y, Int32 exp_jw)
+    {
+        Int32  rTmp0 = (exp_jw >> 16) << 16;
+        Int32  iTmp0 = exp_jw << 16;
+        Int32  z;
+
+
+        z  = _MulHigh(rTmp0, x);
+        z += _MulHigh(iTmp0, y);
+
+        return (z);
+    }
+
+
+    __inline  Int32 fxp_mul32_by_16(Int32 L_var1, const Int32 L_var2)
+    {
+        Int32  rTmp0 = L_var2 << 16;
+
+        return(_MulHigh(rTmp0, L_var1));
+    }
+
+#define fxp_mul32_by_16b( a, b)   fxp_mul32_by_16( a, b)
+
+
+    __inline  Int32 fxp_mul32_by_16t(Int32 L_var1, const Int32 L_var2)
+    {
+        Int32  rTmp0 = (Int16)(L_var2 >> 16);
+
+        return(_MulHigh((rTmp0 << 16), L_var1));
+    }
+
+
+    __inline  Int32 fxp_mac32_by_16(const Int32 L_var1, const Int32 L_var2, Int32 L_add)
+    {
+
+        Int32  rTmp0 = (L_var2 << 16);
+
+        return(L_add + _MulHigh(rTmp0, L_var1));
+    }
+
+    __inline  int64 fxp_mac64_Q31(int64 sum, const Int32 L_var1, const Int32 L_var2)
+    {
+        sum += (int64)L_var1 * L_var2;
+        return (sum);
+    }
+
+#define fxp_mul32_Q31( a,  b)   _MulHigh( b, a)
+
+    __inline Int32 fxp_mac32_Q31(Int32 L_add, const Int32 a, const Int32 b)
+    {
+        return (L_add + _MulHigh(b, a));
+    }
+
+    __inline Int32 fxp_msu32_Q31(Int32 L_sub, const Int32 a, const Int32 b)
+    {
+        return (L_sub - _MulHigh(b, a));
+    }
+
+
+    __inline Int32 fxp_mul32_Q30(const Int32 a, const Int32 b)
+    {
+        return (Int32)(((int64)(a) * b) >> 30);
+    }
+
+    __inline Int32 fxp_mac32_Q30(const Int32 a, const Int32 b, Int32 L_add)
+    {
+        return (L_add + (Int32)(((int64)(a) * b) >> 30));
+    }
+
+
+    __inline Int32 fxp_mul32_Q29(const Int32 a, const Int32 b)
+    {
+        return (Int32)(((int64)(a) * b) >> 29);
+    }
+
+    __inline Int32 fxp_mac32_Q29(const Int32 a, const Int32 b, Int32 L_add)
+    {
+        return (L_add + (Int32)(((int64)(a) * b) >> 29));
+    }
+
+    __inline Int32 fxp_msu32_Q29(const Int32 a, const Int32 b, Int32 L_sub)
+    {
+        return (L_sub - (Int32)(((int64)(a) * b) >> 29));
+    }
+
+
+    __inline Int32 fxp_mul32_Q28(const Int32 a, const Int32 b)
+    {
+        return (Int32)(((int64)(a) * b) >> 28);
+    }
+
+    __inline Int32 fxp_mul32_Q27(const Int32 a, const Int32 b)
+    {
+        return (Int32)(((int64)(a) * b) >> 27);
+    }
+
+    __inline Int32 fxp_mul32_Q26(const Int32 a, const Int32 b)
+    {
+        return (Int32)(((int64)(a) * b) >> 26);
+    }
+
+    __inline Int32 fxp_mul32_Q20(const Int32 a, const Int32 b)
+    {
+        return (Int32)(((int64)(a) * b) >> 20);
+    }
+
+    __inline Int32 fxp_mul32_Q15(const Int32 a, const Int32 b)
+    {
+        return (Int32)(((int64)(a) * b) >> 15);
+    }
+
+    __inline Int32 fxp_mul32_Q14(const Int32 a, const Int32 b)
+    {
+        return (Int32)(((int64)(a) * b) >> 14);
+    }
+
+
+
+#endif
+
+
+#ifdef __cplusplus
+}
+#endif
+
+
+#endif   /*  FXP_MUL32  */
diff --git a/media/libstagefright/codecs/aacdec/fxp_mul32_c_msc_evc_armv5.h b/media/libstagefright/codecs/aacdec/fxp_mul32_c_msc_evc_armv5.h
new file mode 100644
index 0000000..04cbf49
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/fxp_mul32_c_msc_evc_armv5.h
@@ -0,0 +1,178 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Pathname: .fxp_mul32_msc_evc_armv5.h
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+ Who:                                       Date:
+ Description:
+------------------------------------------------------------------------------
+ INCLUDE DESCRIPTION
+
+------------------------------------------------------------------------------
+*/
+
+#ifndef FXP_MUL32_MSC_EVC_ARMV5
+#define FXP_MUL32_MSC_EVC_ARMV5
+
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+
+#include "pv_audio_type_defs.h"
+
+#if defined(PV_ARM_MSC_EVC_V5)
+
+#include "armintr.h"
+#include "cmnintrin.h"
+
+#define preload_cache( a)
+
+#define shft_lft_1( L_var1)  _AddSatInt( L_var1, L_var1)
+
+#define fxp_mul_16_by_16bb( L_var1, L_var2)  _SmulLo_SW_SL( L_var1, L_var2)
+
+#define fxp_mul_16_by_16(a, b)  fxp_mul_16_by_16bb(  a, b)
+
+#define fxp_mul_16_by_16tb( L_var1, L_var2)  _SmulHiLo_SW_SL( L_var1, L_var2)
+
+#define fxp_mul_16_by_16bt( L_var1, L_var2)  _SmulLoHi_SW_SL( L_var1, L_var2)
+
+#define fxp_mul_16_by_16tt( L_var1, L_var2)  _SmulHi_SW_SL( L_var1, L_var2)
+
+#define fxp_mac_16_by_16( L_var1, L_var2, L_add)  _SmulAddLo_SW_SL( L_add, L_var1, L_var2)
+
+#define fxp_mac_16_by_16_bb(a, b, c)  fxp_mac_16_by_16(  a, b, c)
+
+#define fxp_mac_16_by_16_bt( L_var1, L_var2, L_add)  _SmulAddLoHi_SW_SL( L_add, L_var1, L_var2)
+
+
+    __inline  Int32 cmplx_mul32_by_16(Int32 L_var1, const Int32 L_var2, const Int32 cmplx)
+    {
+        Int32 result64_hi;
+
+        result64_hi = _SmulWHi_SW_SL(L_var1, cmplx);
+        result64_hi = _SmulAddWLo_SW_SL(result64_hi, L_var2, cmplx);
+
+        return (result64_hi);
+    }
+
+#define fxp_mul32_by_16( L_var1, L_var2)  _SmulWLo_SW_SL( L_var1, L_var2)
+
+#define fxp_mul32_by_16b( a, b)   fxp_mul32_by_16( a, b)
+
+#define fxp_mul32_by_16t( L_var1, L_var2)  _SmulWHi_SW_SL( L_var1, L_var2)
+
+#define fxp_mac32_by_16( L_var1, L_var2, L_add)  _SmulAddWLo_SW_SL( L_add, L_var1, L_var2)
+
+
+    __inline  int64 fxp_mac64_Q31(int64 sum, const Int32 L_var1, const Int32 L_var2)
+    {
+        sum += (int64)L_var1 * L_var2;
+        return (sum);
+    }
+
+#define fxp_mul32_Q31( a,  b)   _MulHigh( b, a)
+
+
+    __inline Int32 fxp_mac32_Q31(Int32 L_add, const Int32 a, const Int32 b)
+    {
+        return (L_add + _MulHigh(b, a));
+    }
+
+
+    __inline Int32 fxp_msu32_Q31(Int32 L_sub, const Int32 a, const Int32 b)
+    {
+        return (L_sub - _MulHigh(b, a));
+    }
+
+
+    __inline Int32 fxp_mul32_Q30(const Int32 a, const Int32 b)
+    {
+        return (Int32)(((int64)(a) * b) >> 30);
+    }
+
+    __inline Int32 fxp_mac32_Q30(const Int32 a, const Int32 b, Int32 L_add)
+    {
+        return (L_add + (Int32)(((int64)(a) * b) >> 30));
+    }
+
+
+    __inline Int32 fxp_mul32_Q29(const Int32 a, const Int32 b)
+    {
+        return (Int32)(((int64)(a) * b) >> 29);
+    }
+
+    __inline Int32 fxp_mac32_Q29(const Int32 a, const Int32 b, Int32 L_add)
+    {
+        return (L_add + (Int32)(((int64)(a) * b) >> 29));
+    }
+
+    __inline Int32 fxp_msu32_Q29(const Int32 a, const Int32 b, Int32 L_sub)
+    {
+        return (L_sub - (Int32)(((int64)(a) * b) >> 29));
+    }
+
+
+    __inline Int32 fxp_mul32_Q28(const Int32 a, const Int32 b)
+    {
+        return (Int32)(((int64)(a) * b) >> 28);
+    }
+
+    __inline Int32 fxp_mul32_Q27(const Int32 a, const Int32 b)
+    {
+        return (Int32)(((int64)(a) * b) >> 27);
+    }
+
+    __inline Int32 fxp_mul32_Q26(const Int32 a, const Int32 b)
+    {
+        return (Int32)(((int64)(a) * b) >> 26);
+    }
+
+    __inline Int32 fxp_mul32_Q20(const Int32 a, const Int32 b)
+    {
+        return (Int32)(((int64)(a) * b) >> 20);
+    }
+
+    __inline Int32 fxp_mul32_Q15(const Int32 a, const Int32 b)
+    {
+        return (Int32)(((int64)(a) * b) >> 15);
+    }
+
+    __inline Int32 fxp_mul32_Q14(const Int32 a, const Int32 b)
+    {
+        return (Int32)(((int64)(a) * b) >> 14);
+    }
+
+
+#endif
+
+
+#ifdef __cplusplus
+}
+#endif
+
+
+#endif   /*  FXP_MUL32  */
+
diff --git a/media/libstagefright/codecs/aacdec/fxp_mul32_pentium.h b/media/libstagefright/codecs/aacdec/fxp_mul32_pentium.h
new file mode 100644
index 0000000..72862e7
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/fxp_mul32_pentium.h
@@ -0,0 +1,55 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Pathname: .fxp_mul32_pentium.h
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+ Who:                                       Date:
+ Description:
+------------------------------------------------------------------------------
+ INCLUDE DESCRIPTION
+
+------------------------------------------------------------------------------
+*/
+
+#ifndef FXP_MUL32_PENTIUM
+#define FXP_MUL32_PENTIUM
+
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+
+#include "pv_audio_type_defs.h"
+
+
+
+
+
+#ifdef __cplusplus
+}
+#endif
+
+
+#endif   /*  FXP_MUL32  */
+
diff --git a/media/libstagefright/codecs/aacdec/gen_rand_vector.cpp b/media/libstagefright/codecs/aacdec/gen_rand_vector.cpp
new file mode 100644
index 0000000..08ccc4a
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/gen_rand_vector.cpp
@@ -0,0 +1,512 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+ Description:  Modified from original shareware code
+
+ Description:  Modified to remove instances of pow() and sqrt(), and
+ optimized for inclusion in fixed-point version of decoder.
+
+ Description:  Modified to include comments/optimizations from code review.
+ Also, declared appropriate variables as type "const"
+
+ Description:  Adopted strategy of "one q-format per sfb" strategy, which
+ eliminated the array q-format from this function.  The q-format the
+ random vector is stored in is now returned from the function.
+
+ Description:  Completely redesigned the routine to allow a simplified
+        calculation of the adjusted noise, by eliminating the dependency
+        on the band_length. Added polynomial approximation for the
+        function 1/sqrt(power). Updated comments and pseudo-code
+
+ Description:  Modified function description, pseudocode, etc.
+
+ Description:
+    Modified casting to ensure proper operations for different platforms
+
+ Description:
+    Eliminiated access to memory for noise seed. Now a local variable is
+    used. Also unrolled loops to speed up code.
+
+ Description:
+    Modified pointer decrement to a pointer increment, to ensure proper
+    compiler behavior
+
+ Description:
+------------------------------------------------------------------------------
+ INPUT AND OUTPUT DEFINITIONS
+
+ Inputs:    random_array[] = Array for storage of the power-scaled
+                             random values of length "band_length"
+            Int32
+
+            band_length    = Length of random_array[]
+            const Int
+
+            pSeed          = seed for random number generator
+            Int32*
+
+            power_scale    = scale factor for this particular band
+            const Int
+
+
+ Local Stores/Buffers/Pointers Needed:
+    None
+
+ Global Stores/Buffers/Pointers Needed:
+    None
+
+ Outputs:   Function returns the q-format the random vector is stored in.
+
+ Pointers and Buffers Modified:
+            random_array[] = filled with random numbers scaled
+            to the correct power as defined by the input value power_scale.
+
+ Local Stores Modified:
+    None
+
+ Global Stores Modified:
+    None
+
+------------------------------------------------------------------------------
+ FUNCTION DESCRIPTION
+
+ This function generates a vector of uniformly distributed random numbers for
+ the PNS block.  The random numbers are each scaled by a scale_factor,
+ defined in Ref(2) as
+
+ 2^(scale_factor/4)
+ ------------------
+  sqrt(N*MEAN_NRG)
+
+ where N == band_length, and MEAN_NRG is defined as...
+
+         N-1
+         ___
+     1   \
+    ---   >    x(i)^2
+     N   /__
+         i=0
+
+ And x is the unscaled vector from the random number generator.
+
+ This function takes advantage of the fact that the portion of the
+ scale_factor that is divisible by 4 can be simply accounted for by varying
+ the q-format.
+
+ The scaling of the random numbers is thus broken into the
+ equivalent equation below.
+
+ 2^(scale_factor%4)   2^(floor(scale_factor/4))
+ ------------------ *
+  sqrt(N*MEAN_NRG)
+
+
+ 2^(scale_factor%4) is stored in a simple 4-element table.
+ 2^(floor(scale_factor/4) is accounted for by adjusting the q-format.
+ sqrt(N*MEAN_NRG) is calculated and implemented via a polynomial approximation.
+------------------------------------------------------------------------------
+ REQUIREMENTS
+
+ This function shall produce uniformly distributed random 32-bit integers,
+ with signed random values of average energy equal to the results of the ISO
+ code's multiplying factor discussed in the FUNCTION DESCRIPTION section.
+
+ Please see Ref (2) for a detailed description of the requirements.
+------------------------------------------------------------------------------
+ REFERENCES
+
+ (1) Numerical Recipes in C     Second Edition
+        William H. Press        Saul A. Teukolsky
+        William T. Vetterling   Brian P. Flannery
+        Page 284
+
+ (2) ISO/IEC 14496-3:1999(E)
+     Part 3
+        Subpart 4.6.12 (Perceptual Noise Substitution)
+
+ (3) MPEG-2 NBC Audio Decoder
+   "This software module was originally developed by AT&T, Dolby
+   Laboratories, Fraunhofer Gesellschaft IIS in the course of development
+   of the MPEG-2 NBC/MPEG-4 Audio standard ISO/IEC 13818-7, 14496-1,2 and
+   3. This software module is an implementation of a part of one or more
+   MPEG-2 NBC/MPEG-4 Audio tools as specified by the MPEG-2 NBC/MPEG-4
+   Audio standard. ISO/IEC  gives users of the MPEG-2 NBC/MPEG-4 Audio
+   standards free license to this software module or modifications thereof
+   for use in hardware or software products claiming conformance to the
+   MPEG-2 NBC/MPEG-4 Audio  standards. Those intending to use this software
+   module in hardware or software products are advised that this use may
+   infringe existing patents. The original developer of this software
+   module and his/her company, the subsequent editors and their companies,
+   and ISO/IEC have no liability for use of this software module or
+   modifications thereof in an implementation. Copyright is not released
+   for non MPEG-2 NBC/MPEG-4 Audio conforming products.The original
+   developer retains full right to use the code for his/her  own purpose,
+   assign or donate the code to a third party and to inhibit third party
+   from using the code for non MPEG-2 NBC/MPEG-4 Audio conforming products.
+   This copyright notice must be included in all copies or derivative
+   works."
+   Copyright(c)1996.
+
+------------------------------------------------------------------------------
+ PSEUDO-CODE
+
+    power_adj = scale_mod_4[power_scale & 3];
+
+    power = 0;
+
+    FOR (k=band_length; k > 0; k--)
+
+        *(pSeed) = *(pSeed) * 1664525L;
+        *(pSeed) = *(pSeed) + 1013904223L;
+
+        temp = (Int)(*(pSeed) >> 16);
+
+        power = power + ((temp*temp) >> 6);
+
+        *(pArray) = (Int32)temp;
+
+        pArray = pArray + 1;
+
+    ENDFOR
+
+    k = 0;
+    q_adjust = 30;
+
+    IF (power)
+    THEN
+
+        WHILE ( power > 32767)
+
+            power = power >> 1;
+            k = k + 1;
+
+        ENDWHILE
+
+        k = k - 13;
+
+        IF (k < 0)
+        THEN
+            k = -k;
+            IF ( k & 1 )
+            THEN
+                power_adj = (power_adj*SQRT_OF_2)>>14;
+            ENDIF
+            q_adjust = q_adjust - ( k >> 1);
+
+        ELSE IF (k > 0)
+        THEN
+            IF ( k & 1  )
+            THEN
+                power_adj = (power_adj*INV_SQRT_OF_2)>>14;
+            ENDIF
+            q_adjust = q_adjust + ( k >> 1);
+        ENDIF
+
+        pInvSqrtCoeff = inv_sqrt_coeff;
+
+        inv_sqrt_power  = (*(pInvSqrtCoeff)* power) >>15;
+
+        pInvSqrtCoeff = pInvSqrtCoeff + 1;
+
+        inv_sqrt_power = inv_sqrt_power + *(pInvSqrtCoeff);
+
+        pInvSqrtCoeff = pInvSqrtCoeff + 1;
+
+        FOR ( k=INV_SQRT_POLY_ORDER - 1; k>0; k--)
+
+            inv_sqrt_power  =  ( inv_sqrt_power * power)>>15;
+
+            inv_sqrt_power = inv_sqrt_power + *(pInvSqrtCoeff);
+
+            pInvSqrtCoeff = pInvSqrtCoeff + 1;
+
+        ENDFOR
+
+        inv_sqrt_power = (inv_sqrt_power*power_adj)>>13;
+
+        FOR (k=band_length; k > 0; k--)
+
+            pArray = pArray - 1;
+
+            *(pArray) = *(pArray)*inv_sqrt_power;
+
+        ENDFOR
+
+    ENDIF
+
+    q_adjust = q_adjust - (power_scale >> 2);
+
+    return q_adjust;
+
+------------------------------------------------------------------------------
+ RESOURCES USED
+   When the code is written for a specific target processor
+     the resources used should be documented below.
+
+ STACK USAGE: [stack count for this module] + [variable to represent
+          stack usage for each subroutine called]
+
+     where: [stack usage variable] = stack usage for [subroutine
+         name] (see [filename].ext)
+
+ DATA MEMORY USED: x words
+
+ PROGRAM MEMORY USED: x words
+
+ CLOCK CYCLES: [cycle count equation for this module] + [variable
+           used to represent cycle count for each subroutine
+           called]
+
+     where: [cycle count variable] = cycle count for [subroutine
+        name] (see [filename].ext)
+
+------------------------------------------------------------------------------
+*/
+
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+#include    "pv_audio_type_defs.h"
+#include    "gen_rand_vector.h"
+#include    "window_block_fxp.h"
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here. Include conditional
+; compile variables also.
+----------------------------------------------------------------------------*/
+#define     SQRT_OF_2       23170       /*    sqrt(2) in Q14  */
+#define     INV_SQRT_OF_2   11585       /*  1/sqrt(2) in Q14  */
+#define     INV_SQRT_POLY_ORDER     4
+
+/*----------------------------------------------------------------------------
+; LOCAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; LOCAL STORE/BUFFER/POINTER DEFINITIONS
+; Variable declaration - defined here and used outside this module
+----------------------------------------------------------------------------*/
+
+
+
+/*
+ *  2^([0:3]/4) = 1.0000    1.1892    1.4142    1.6818
+ */
+const UInt scale_mod_4[4] = { 16384, 19484, 23170, 27554};
+
+/*
+ *  polynomial approx. in Q12 (type Int)
+ */
+
+const Int  inv_sqrt_coeff[INV_SQRT_POLY_ORDER+1] =
+    { 4680, -17935, 27697, -22326, 11980};
+
+
+/*----------------------------------------------------------------------------
+; EXTERNAL FUNCTION REFERENCES
+; Declare functions defined elsewhere and referenced in this module
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL GLOBAL STORE/BUFFER/POINTER REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; FUNCTION CODE
+----------------------------------------------------------------------------*/
+
+Int gen_rand_vector(
+    Int32     random_array[],
+    const Int band_length,
+    Int32*   pSeed,
+    const Int power_scale)
+{
+
+    Int      k;
+    UInt     power_adj;
+    Int      q_adjust = 30;
+
+    Int32    temp;
+    Int32    seed;
+    Int32    power;
+
+    Int32*   pArray = &random_array[0];
+
+    Int32    inv_sqrt_power;
+    const Int  *pInvSqrtCoeff;
+
+    /*
+     *  The out of the random number generator is scaled is such a way
+     *  that is independent of the band length.
+     *  The output is computed as:
+     *
+     *                  x(i)
+     *  output = ------------------ * 2^(power_scale%4) 2^(floor(power_scale/4))
+     *                   bl
+     *           sqrt(  SUM x(i)^2 )
+     *                   0
+     *
+     *  bl == band length
+     */
+
+
+    /*
+     *  get 2^(power_scale%4)
+     */
+
+
+    power = 0;
+
+    seed = *pSeed;
+
+    /*
+     *  band_length is always an even number (check tables in pg.66 IS0 14496-3)
+     */
+    if (band_length < 0 || band_length > LONG_WINDOW)
+    {
+        return  q_adjust;     /*  avoid any processing on error condition */
+    }
+
+    for (k = (band_length >> 1); k != 0; k--)
+    {
+        /*------------------------------------------------
+           Numerical Recipes in C
+                    Page 284
+        ------------------------------------------------*/
+        seed *= 1664525L;
+        seed += 1013904223L;
+
+        temp =  seed >> 16;
+
+        seed *= 1664525L;
+        seed += 1013904223L;
+
+        /* shift by 6 make room for band length accumulation  */
+        power  += ((temp * temp) >> 6);
+        *pArray++ = temp;
+
+        temp    = seed >> 16;
+        power  += ((temp * temp) >> 6);
+        *pArray++ = temp;
+
+    } /* END for (k=half_band_length; k > 0; k--) */
+
+
+    *pSeed = seed;
+
+    /*
+     *  If the distribution is uniform, the power is expected to use between
+     *  28 and 27 bits, by shifting down by 13 bits the power will be a
+     *  Q15 number.
+     *  For different band lengths, the power uses between 20 and 29 bits
+     */
+
+
+    k = 0;
+
+    if (power)
+    {
+        /*
+         *    approximation requires power  between 0.5 < power < 1 in Q15.
+         */
+
+        while (power > 32767)
+        {
+            power >>= 1;
+            k++;
+        }
+
+        /*
+         *  expected power bit usage == 27 bits
+         */
+
+        k -= 13;
+
+        power_adj = scale_mod_4[power_scale & 3];
+
+        if (k < 0)
+        {
+            k = -k;
+            if (k & 1)
+            {                               /* multiply by sqrt(2)  */
+                power_adj = (UInt)(((UInt32) power_adj * SQRT_OF_2) >> 14);
+            }
+            q_adjust -= (k >> 1);    /* adjust Q instead of shifting up */
+        }
+        else if (k > 0)
+        {
+            if (k & 1)
+            {                               /* multiply by 1/sqrt(2)  */
+                power_adj = (UInt)(((UInt32) power_adj * INV_SQRT_OF_2) >> 14);
+            }
+            q_adjust += (k >> 1);   /* adjust Q instead of shifting down */
+        }
+
+        /*
+         *    Compute 1/sqrt(power), where 0.5 < power < 1.0 is approximated
+         *    using a polynomial order INV_SQRT_POLY_ORDER
+         */
+
+        pInvSqrtCoeff = inv_sqrt_coeff;
+
+        inv_sqrt_power  = (*(pInvSqrtCoeff++) * power) >> 15;
+        inv_sqrt_power += *(pInvSqrtCoeff++);
+        inv_sqrt_power  = (inv_sqrt_power * power) >> 15;
+        inv_sqrt_power += *(pInvSqrtCoeff++);
+        inv_sqrt_power  = (inv_sqrt_power * power) >> 15;
+        inv_sqrt_power += *(pInvSqrtCoeff++);
+        inv_sqrt_power  = (inv_sqrt_power * power) >> 15;
+        inv_sqrt_power += *(pInvSqrtCoeff);
+
+        inv_sqrt_power  = (inv_sqrt_power * power_adj) >> 13;
+
+        pArray = &random_array[0];
+
+        for (k = (band_length >> 1); k != 0; k--)
+        {
+            temp        = *(pArray) * inv_sqrt_power;
+            *(pArray++) = temp;
+            temp        = *(pArray) * inv_sqrt_power;
+            *(pArray++) = temp;
+        } /* END for (k=half_band_length; k > 0; k--) */
+
+    }   /* if(power) */
+
+    /*
+     *      Adjust Q with the value corresponding to 2^(floor(power_scale/4))
+     */
+
+    q_adjust  -= (power_scale >> 2);
+
+    return (q_adjust);
+
+} /* gen_rand_vector */
diff --git a/media/libstagefright/codecs/aacdec/gen_rand_vector.h b/media/libstagefright/codecs/aacdec/gen_rand_vector.h
new file mode 100644
index 0000000..17b5490
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/gen_rand_vector.h
@@ -0,0 +1,87 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Pathname: gen_rand_vector.h
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+ Description: Added include of pv_audio_type_defs.h
+
+ Who:                       Date:
+ Description:
+------------------------------------------------------------------------------
+ INCLUDE DESCRIPTION
+
+ This include file contains the function declaration for gen_rand_vector.
+
+------------------------------------------------------------------------------
+*/
+
+/*----------------------------------------------------------------------------
+; CONTINUE ONLY IF NOT ALREADY DEFINED
+----------------------------------------------------------------------------*/
+#ifndef gen_rand_vector_H
+#define gen_rand_vector_H
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+#include "pv_audio_type_defs.h"
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here.
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL VARIABLES REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; SIMPLE TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; ENUMERATED TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; STRUCTURES TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; GLOBAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+Int gen_rand_vector(
+    Int32  random_array[],
+    const Int    band_length,
+    Int32 *pSeed,
+    const Int    power_scale);
+/*----------------------------------------------------------------------------
+; END
+----------------------------------------------------------------------------*/
+#endif
diff --git a/media/libstagefright/codecs/aacdec/get_adif_header.cpp b/media/libstagefright/codecs/aacdec/get_adif_header.cpp
new file mode 100644
index 0000000..8a1e74b
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/get_adif_header.cpp
@@ -0,0 +1,443 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Pathname: get_adif_header.c
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+ Description:  Modified from original shareware code
+
+ Description:  Modified to pass variables by reference to eliminate use
+               of global variables.
+
+ Description:  Change to PV template, remove default config parameter,
+               move some functionality into get_prog_config().
+
+ Description: Update per code review
+              1) Add parameter pScratchPCE
+              2) Change way ADIF_ID is read in.
+              3) Fix comments
+              4) ADD a test for status != SUCCESS in loop.
+
+ Description: The ADIF_Header has now been delegated to the "scratch memory"
+ union.  This change inside s_tDec_Int_File.h had to be reflected here also.
+
+ Description: Updated the SW template to include the full pathname to the
+ source file and a slightly modified copyright header.
+
+ Who:                                   Date:
+ Description:
+
+------------------------------------------------------------------------------
+ INPUT AND OUTPUT DEFINITIONS
+
+ Inputs:
+    pVars        = pointer to the structure that contains the current state
+                   of this instance of the library, of data type pointer to
+                   tDec_Int_File
+
+    pScratchPCE  = pointer to a ProgConfig structure used as scratch in the
+                   the function get_prog_config. of data type pointer to
+                   ProgConfig
+
+ Local Stores/Buffers/Pointers Needed: None
+
+ Global Stores/Buffers/Pointers Needed: None
+
+ Outputs:
+    The function returns 0 if no error occurred, non-zero otherwise.
+
+ Pointers and Buffers Modified:
+    pVars->adif_header contents are updated with the some of the ADIF header
+           contents
+    pVars->tempProgConfig contents are overwritten with last PCE found,
+           which is most likely the first one found.
+    pVars->prog_config contents are updated with the first PCE found.
+    pVars->inputStream contents are modify in such a way that the
+           stream is moved further along in the buffer.
+    pVars->SFBWidth128 contents may be updated.
+    pVars->winSeqInfo  contents may be updated.
+    pScratchPCE        contents may be updated.
+
+ Local Stores Modified: None
+
+ Global Stores Modified: None
+
+------------------------------------------------------------------------------
+ FUNCTION DESCRIPTION
+
+ This function reads in the ADIF Header found at the front of ADIF streams.
+ If the header is not found an error is returned. An ADIF header can contain
+ from zero to sixteen program configuration elements (PCE). This function, and
+ the rest of the library, saves and uses the first PCE found.
+------------------------------------------------------------------------------
+ REQUIREMENTS
+
+ Function shall not use static or global variables.
+
+------------------------------------------------------------------------------
+ REFERENCES
+
+ (1) ISO/IEC 13818-7:1997 Titled "Information technology - Generic coding
+   of moving pictures and associated audio information - Part 7: Advanced
+   Audio Coding (AAC)", Table 6.21 - Syntax of program_config_element(),
+   page 16, and section 8.5 "Program Config Element (PCE)", page 30.
+
+ (2) MPEG-2 NBC Audio Decoder
+   "This software module was originally developed by AT&T, Dolby
+   Laboratories, Fraunhofer Gesellschaft IIS in the course of development
+   of the MPEG-2 NBC/MPEG-4 Audio standard ISO/IEC 13818-7, 14496-1,2 and
+   3. This software module is an implementation of a part of one or more
+   MPEG-2 NBC/MPEG-4 Audio tools as specified by the MPEG-2 NBC/MPEG-4
+   Audio standard. ISO/IEC gives users of the MPEG-2 NBC/MPEG-4 Audio
+   standards free license to this software module or modifications thereof
+   for use in hardware or software products claiming conformance to the
+   MPEG-2 NBC/MPEG-4 Audio  standards. Those intending to use this software
+   module in hardware or software products are advised that this use may
+   infringe existing patents. The original developer of this software
+   module and his/her company, the subsequent editors and their companies,
+   and ISO/IEC have no liability for use of this software module or
+   modifications thereof in an implementation. Copyright is not released
+   for non MPEG-2 NBC/MPEG-4 Audio conforming products.The original
+   developer retains full right to use the code for his/her own purpose,
+   assign or donate the code to a third party and to inhibit third party
+   from using the code for non MPEG-2 NBC/MPEG-4 Audio conforming products.
+   This copyright notice must be included in all copies or derivative
+   works."
+   Copyright(c)1996.
+
+------------------------------------------------------------------------------
+ PSEUDO-CODE
+
+     CALL getbits(
+        neededBits = 2 * LEN_BYTE,
+        pInputStream = pInputStream)
+     MODIFYING( pInputStream )
+     RETURNING( theIDFromFile )
+
+     CALL getbits(
+        neededBits = 2 * LEN_BYTE,
+        pInputStream = pInputStream)
+     MODIFYING( pInputStream )
+     RETURNING( temp )
+
+    theIDFromFile = (theIDFromFile << (2*LEN_BYTE)) | temp;
+
+    IF (theIDFromFile != ADIF_ID)
+    THEN
+
+        pInputStream->usedBits -= (4 * LEN_BYTE);
+
+        status = -1;
+    ELSE
+        CALL getbits(
+            neededBits = LEN_COPYRT_PRES,
+            pInputStream = pInputStream)
+        MODIFYING( pInputStream )
+        RETURNING( temp )
+
+        IF (temp != FALSE) THEN
+            FOR (i = LEN_COPYRT_ID; i > 0; i--)
+               CALL getbits(
+                   neededBits = LEN_BYTE,
+                   pInputStream = pInputStream)
+               MODIFYING( pInputStream )
+
+            END FOR
+        END IF
+
+        CALL getbits(
+            neededBits = LEN_ORIG + LEN_HOME,
+            pInputStream = pInputStream)
+        MODIFYING( pInputStream )
+
+        CALL getbits(
+            neededBits = LEN_BS_TYPE,
+            pInputStream = pInputStream)
+        MODIFYING( pInputStream )
+        RETURNING( bitStreamType )
+
+        CALL getbits(
+            neededBits = LEN_BIT_RATE,
+            pInputStream = pInputStream)
+        MODIFYING( pInputStream )
+        RETURNING( pHeader->bitrate )
+
+        CALL getbits(
+            neededBits = LEN_NUM_PCE,
+            pInputStream = pInputStream)
+        MODIFYING( pInputStream )
+        RETURNING( numConfigElementsMinus1 )
+
+        FOR (  i = numConfigElementsMinus1;
+              (i >= 0) && (status == SUCCESS);
+               i--)
+
+            IF (bitStreamType == CONSTANT_RATE_BITSTREAM) THEN
+               CALL getbits(
+                   neededBits = LEN_ADIF_BF,
+                   pInputStream = pInputStream)
+               MODIFYING( pInputStream )
+            END IF
+
+            CALL get_prog_config(
+                pVars = pVars)
+            MODIFYING( pVars->prog_config )
+            RETURNING( status )
+
+        END FOR
+    END IF
+
+    RETURN (status)
+
+------------------------------------------------------------------------------
+ RESOURCES USED
+   When the code is written for a specific target processor the
+     the resources used should be documented below.
+
+ STACK USAGE: [stack count for this module] + [variable to represent
+          stack usage for each subroutine called]
+
+     where: [stack usage variable] = stack usage for [subroutine
+         name] (see [filename].ext)
+
+ DATA MEMORY USED: x words
+
+ PROGRAM MEMORY USED: x words
+
+ CLOCK CYCLES: [cycle count equation for this module] + [variable
+           used to represent cycle count for each subroutine
+           called]
+
+     where: [cycle count variable] = cycle count for [subroutine
+        name] (see [filename].ext)
+
+------------------------------------------------------------------------------
+*/
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+#include "pv_audio_type_defs.h"
+#include "e_adif_const.h"
+
+#include "s_progconfig.h"
+#include "s_adif_header.h"
+#include "s_bits.h"
+#include "s_mc_info.h"
+#include "s_frameinfo.h"
+#include "s_tdec_int_file.h"
+
+#include "get_prog_config.h"
+#include "ibstream.h"
+
+#include "get_adif_header.h"
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here. Include conditional
+; compile variables also.
+----------------------------------------------------------------------------*/
+
+/*
+ * This constant is simply the characters 'A' 'D' 'I' 'F' compressed into
+ * a UInt32. Any possible endian problems that exist must be solved by
+ * the function that fills the buffer and getbits(), or this constant and
+ * the rest of the bit stream will not work.
+ */
+#define ADIF_ID (0x41444946)
+
+/*----------------------------------------------------------------------------
+; LOCAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; LOCAL VARIABLE DEFINITIONS
+; Variable declaration - defined here and used outside this module
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL FUNCTION REFERENCES
+; Declare functions defined elsewhere and referenced in this module
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL VARIABLES REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+Int get_adif_header(
+    tDec_Int_File *pVars,
+    ProgConfig    *pScratchPCE)
+{
+    Int          i;
+    UInt32       temp;
+    Int          numConfigElementsMinus1;
+    Int          bitStreamType;
+    UInt32       theIDFromFile;
+
+    BITS        *pInputStream = &pVars->inputStream;
+    ADIF_Header *pHeader = &pVars->scratch.adif_header;
+    Int          status  = SUCCESS;
+
+    /*
+     * The ADIF_ID field is 32 bits long, one more than what getbits() can
+     * do, so read the field in two parts. There is no point in saving the
+     * string - it either matches or it does not. If it matches, it must
+     * have been 'ADIF'
+     */
+
+    theIDFromFile = get17_n_lessbits((2 * LEN_BYTE), pInputStream);
+
+    temp          = get17_n_lessbits((2 * LEN_BYTE), pInputStream);
+
+    theIDFromFile = (theIDFromFile << (2 * LEN_BYTE)) | temp;
+
+
+    if (theIDFromFile != ADIF_ID)
+    {
+        /*
+         * Rewind the bit stream pointer so a search for ADTS header
+         * can start at the beginning.
+         */
+
+        pInputStream->usedBits -= (4 * LEN_BYTE);
+
+        /*
+         * The constant in the next line needs to be updated when
+         * error handling method is determined.
+         */
+        status = -1;
+    }
+    else
+    {
+        /*
+         * To save space, the unused fields are read in, but not saved.
+         */
+
+        /* copyright string */
+        temp =
+            get1bits(/*                LEN_COPYRT_PRES,*/
+                pInputStream);
+
+        if (temp != FALSE)
+        {
+            /*
+             * Read in and ignore the copyright string. If restoring
+             * watch out for count down loop.
+             */
+
+            for (i = LEN_COPYRT_ID; i > 0; i--)
+            {
+                get9_n_lessbits(LEN_BYTE,
+                                pInputStream);
+            } /* end for */
+
+            /*
+             * Make sure to terminate the string with '\0' if restoring
+             * the the copyright string.
+             */
+
+        } /* end if */
+
+        /* Combine the original/copy and fields into one call */
+        get9_n_lessbits(
+            LEN_ORIG + LEN_HOME,
+            pInputStream);
+
+        bitStreamType =
+            get1bits(/*                LEN_BS_TYPE,*/
+                pInputStream);
+
+        pHeader->bitrate =
+            getbits(
+                LEN_BIT_RATE,
+                pInputStream);
+
+        /*
+         * Read in all the Program Configuration Elements.
+         * For this library, only one of the up to 16 possible PCE's will be
+         * saved. Since each PCE must be read, a temporary PCE structure is
+         * used, and if that PCE is the one to use, it is copied into the
+         * single PCE. This is done inside of get_prog_config()
+         */
+
+        numConfigElementsMinus1 =  get9_n_lessbits(LEN_NUM_PCE,
+                                   pInputStream);
+
+        for (i = numConfigElementsMinus1;
+                (i >= 0) && (status == SUCCESS);
+                i--)
+        {
+            /*
+             * For ADIF contant bit rate streams, the _encoder_ buffer
+             * fullness is transmitted. This version of an AAC decoder has
+             * no use for this variable; yet it must be read in to move
+             * the bitstream pointers.
+             */
+
+            if (bitStreamType == CONSTANT_RATE_BITSTREAM)
+            {
+                getbits(
+                    LEN_ADIF_BF,
+                    pInputStream);
+            } /* end if */
+
+            pVars->adif_test = 1;
+            /* Get one program configuration element */
+            status =
+                get_prog_config(
+                    pVars,
+                    pScratchPCE);
+
+#ifdef AAC_PLUS
+
+            /*
+             *  For implicit signalling, no hint that sbr or ps is used, so we need to
+             *  check the sampling frequency of the aac content, if lesser or equal to
+             *  24 KHz, by defualt upsample, otherwise, do nothing
+             */
+            if ((pVars->prog_config.sampling_rate_idx >= 6) && (pVars->aacPlusEnabled == true) &&
+                    pVars->mc_info.audioObjectType == MP4AUDIO_AAC_LC)
+            {
+                pVars->mc_info.upsamplingFactor = 2;
+                pVars->prog_config.sampling_rate_idx -= 3;
+                pVars->mc_info.sbrPresentFlag = 1;
+                pVars->sbrDecoderData.SbrChannel[0].syncState = UPSAMPLING;
+                pVars->sbrDecoderData.SbrChannel[1].syncState = UPSAMPLING;
+            }
+#endif
+
+
+
+        } /* end for */
+
+
+    } /* end 'else' of --> if (theIDFromFile != ADIF_ID) */
+
+    return status;
+
+} /* end get_adif_header */
diff --git a/media/libstagefright/codecs/aacdec/get_adif_header.h b/media/libstagefright/codecs/aacdec/get_adif_header.h
new file mode 100644
index 0000000..8bc3411
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/get_adif_header.h
@@ -0,0 +1,95 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Pathname: get_adif_header.h
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+ Description: Add parameter to get_adif_header() function.
+
+ Who:                                      Date:
+ Description:
+
+------------------------------------------------------------------------------
+ INCLUDE DESCRIPTION
+
+ Header file for get_adif_header.c
+
+------------------------------------------------------------------------------
+*/
+
+/*----------------------------------------------------------------------------
+; CONTINUE ONLY IF NOT ALREADY DEFINED
+----------------------------------------------------------------------------*/
+#ifndef GET_ADIF_HEADER_H
+#define GET_ADIF_HEADER_H
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+#include "pv_audio_type_defs.h"
+#include "s_tdec_int_file.h"
+
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here.
+----------------------------------------------------------------------------*/
+#define CONSTANT_RATE_BITSTREAM  (0)
+#define VARIABLE_RATE_BITSTREAM  (1)
+
+/*----------------------------------------------------------------------------
+; EXTERNAL VARIABLES REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; SIMPLE TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; ENUMERATED TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; STRUCTURES TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; GLOBAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+
+Int get_adif_header(
+    tDec_Int_File *pVars,
+    ProgConfig    *pScratchPCE);
+
+
+/*----------------------------------------------------------------------------
+; END
+----------------------------------------------------------------------------*/
+#endif
+
+
diff --git a/media/libstagefright/codecs/aacdec/get_adts_header.cpp b/media/libstagefright/codecs/aacdec/get_adts_header.cpp
new file mode 100644
index 0000000..3ac2756
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/get_adts_header.cpp
@@ -0,0 +1,672 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Pathname: get_adts_header.c
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+ Description: Remove default_config variable
+
+ Description: change enter_mc_info to set_mc_info
+
+ Description: (1) add error checking for channel_config > 2
+              (2) eliminated call to check_mc_info
+              (3) use (profile + 1) when calling set_mc_info
+              (4) use winmap when calling set_mc_info
+
+ Who:                                          Date:
+ Description:
+
+------------------------------------------------------------------------------
+ INPUT AND OUTPUT DEFINITIONS
+
+ Inputs:
+    pVars           =   Pointer to structure that holds file-scope variables.
+                        [ tDec_Int_File * ]
+
+    pSyncword       =   Pointer to variable that holds the 28-bit fixed
+                        header upon the exit of this function. [ UInt32 * ]
+
+    pInvoke         =   Pointer to variable that keeps track of how many
+                        "short" (14 bit) headers have been successfully
+                        parsed from the bitstream. [ Int * ]
+
+ Local Stores/Buffers/Pointers Needed:
+    None
+
+ Global Stores/Buffers/Pointers Needed:
+    None
+
+ Outputs:
+    Status = SUCCESS or ERROR CODE
+
+ Pointers and Buffers Modified:
+    pVars->prog_config   Updated with program information data as read from
+                         the ADTS header.
+
+    pSyncword            Value pointed to is updated with the contents of
+                         the 28-bit fixed header.
+
+    pInvoke              Value pointed to is updated to reflect the number
+                         of successful "short" (14 bit) headers that have
+                         been successfully parsed from the bitstream.
+
+ Local Stores Modified:
+    None
+
+ Global Stores Modified:
+    None
+
+------------------------------------------------------------------------------
+ FUNCTION DESCRIPTION
+
+ Acronym Definitions
+ ADTS  Audio Data Transport Stream
+ CRC   Cyclic Redundancy Code
+
+ This function calls find_adts_syncword to find the next ADTS header.  Until
+ three consistent headers have been read, the syncword used for detection
+ consists of the 12-bit syncword and the 2-bit Layer.  After three consistent
+ headers are read, the entire fixed header is used for a robust 28-bit
+ syncword.
+
+ Configuration information is then extracted from the bitstream.
+
+ The bitstream information is packed as follows.
+ Comments about the correct interpretation of these bits are contained within
+ the code.
+
+                                      CRC_absent    sampling_rate_idx
+                                           \               / \
+                                            \             /   \
+                                             \  Profile  /     \  UNUSED
+                                              \   / \   /       \   /
+|00|01|02|03|04|05|06|07|08|09|10|11|12|13|14|15|16|17|18|19|20|21|22|23|24|25|
+ \         _______________         / |   \  /                         \      /
+  \-------|0xFFF syncword |-------/  |   Layer == '00' for AAC         \    /
+           \-------------/           |                                  \  /
+                                     |                                   \/
+                                     ID == '1' for MPEG-2 AAC    channel_config
+       copyright_id_bit                 == '0' for MPEG-4 AAC
+          /
+    home /
+     /  /
+|26|27|28|29|30|31|32|33|34|35|36|37|38|39|40|41|42|
+  |        \  \          _____________           /
+  |         \  \--------|frame length |---------/
+  orig_copy  \           \-----------/
+              \                                  ______________________________
+        copyright_id_start                      | TOTAL HEADER LENGTH: 56 bits|
+                                                |-----------------------------|
+|43|44|45|46|47|48|49|50|51|52|53|54|55|        | FIXED    HEADER BITS 00-27  |
+  \       _______________      /  |   |         | VARIABLE HEADER BITS 28-55  |
+   \-----|buffer_fullness|----/    \ /          |_____________________________|
+          \-------------/           |
+                              headerless_frames
+
+ In addition to the bits displayed above, if the value CRC_absent is '0' an
+ additional 16 bits corresponding to a CRC word are read from the bitstream,
+ following the header.
+------------------------------------------------------------------------------
+ REQUIREMENTS
+
+ After the ADTS syncword is detected, this function shall parse the
+ information residing behind the syncword in the bitstream.
+------------------------------------------------------------------------------
+ REFERENCES
+ (1) ISO/IEC 13818-7:1997(E)
+     Part 7
+        Subpart 6.2 (Audio_Data_Transport_Stream frame, ADTS)
+
+ (2) ISO/IEC 11172-3:1993(E)
+     Part 3
+        Subpart 2.4.3 The audio decoding process
+
+ (3) MPEG-2 NBC Audio Decoder
+   "This software module was originally developed by AT&T, Dolby
+   Laboratories, Fraunhofer Gesellschaft IIS in the course of development
+   of the MPEG-2 NBC/MPEG-4 Audio standard ISO/IEC 13818-7, 14496-1,2 and
+   3. This software module is an implementation of a part of one or more
+   MPEG-2 NBC/MPEG-4 Audio tools as specified by the MPEG-2 NBC/MPEG-4
+   Audio standard. ISO/IEC  gives users of the MPEG-2 NBC/MPEG-4 Audio
+   standards free license to this software module or modifications thereof
+   for use in hardware or software products claiming conformance to the
+   MPEG-2 NBC/MPEG-4 Audio  standards. Those UIntending to use this software
+   module in hardware or software products are advised that this use may
+   infringe existing patents. The original developer of this software
+   module and his/her company, the subsequent editors and their companies,
+   and ISO/IEC have no liability for use of this software module or
+   modifications thereof in an implementation. Copyright is not released
+   for non MPEG-2 NBC/MPEG-4 Audio conforming products.The original
+   developer retains full right to use the code for his/her  own purpose,
+   assign or donate the code to a third party and to inhibit third party
+   from using the code for non MPEG-2 NBC/MPEG-4 Audio conforming products.
+   This copyright notice must be included in all copies or derivative
+   works."
+   Copyright(c)1996.
+
+------------------------------------------------------------------------------
+ PSEUDO-CODE
+
+    IF (*(pInvoke) > 3)
+
+         CALL find_adts_syncword(
+                    pSyncword,
+                   &(pVars->inputStream),
+                    LENGTH_FIXED_HEADER,
+                    MASK_28BITS);
+           RETURNING  status
+    ELSE
+
+        *(pSyncword) = SYNCWORD_15BITS;
+
+        CALL find_adts_syncword(
+                   pSyncword,
+                  &(pVars->inputStream),
+                   LENGTH_SYNCWORD,
+                   ID_BIT_FILTER);
+
+          MODIFYING  *(pSyncword) = 28-bit fixed header (long syncword)
+          RETURNING  status
+
+        CALL getbits(
+                (LENGTH_FIXED_HEADER - LENGTH_SYNCWORD),
+               &(pVars->inputStream));
+
+          MODIFYING pVars->inputStream
+          RETURNING adts_header = remaining bits in the fixed header
+
+        *(pSyncword) <<= 13;
+        *(pSyncword) = *(pSyncword) OR adts_header;
+
+        pVars->prog_config.CRC_absent  = ((UInt)(adts_header >> 12)) AND 0x0001;
+
+        lower_16 = (UInt)adts_header;
+
+        pVars->prog_config.profile = (lower_16 >> 10) AND 0x3;
+
+        pVars->prog_config.sampling_rate_idx = (lower_16 >> 6) AND 0xF;
+
+        channel_configuration = (lower_16 >> 2) AND 0x7;
+
+        channel_configuration = channel_configuration - 1;
+        pVars->prog_config.front.ele_is_cpe[0] = channel_configuration;
+
+        pVars->prog_config.front.num_ele    = 1;
+
+        pVars->prog_config.front.ele_tag[0] = 0;
+
+        pVars->prog_config.mono_mix.present = 0;
+        pVars->prog_config.stereo_mix.present = 0;
+        pVars->prog_config.matrix_mix.present = 0;
+
+        CALL set_mc_info(
+                &(pVars->mc_info),
+                &(pVars->savedMCInfo),
+                &(pVars->prog_config),
+                  pVars->pWinSeqInfo,
+                  pVars->SFBWidth128);
+          MODIFYING pVars->mc_info = multi-channel configuration information
+          RETURNING status         = SUCCESS/FAILURE
+
+        IF ( (*pInvoke) != 0)
+            CALL check_mc_info(
+                    &(pVars->mc_info),
+                    &(pVars->savedMCInfo),
+                     FALSE);
+              RETURNING status = SUCCESS/FAILURE
+        ELSE
+            CALL check_mc_info(
+                    &(pVars->mc_info),
+                    &(pVars->savedMCInfo),
+                     TRUE);
+              MODIFYING pVars->savedMCInfo = pVars->mc_info
+              RETURNING status = SUCCESS/FAILURE
+        ENDIF
+
+        IF (status == SUCCESS)
+            (*pInvoke) = (*pInvoke) + 1;
+        ELSE
+            (*pInvoke) = 0;
+        ENDIF
+
+    ENDIF
+
+    CALL getbits(
+            LENGTH_VARIABLE_HEADER,
+           &(pVars->inputStream));
+      RETURNING adts_header = 28-bits (the contents of the variable header.)
+
+    pVars->prog_config.frame_length  = ((UInt)(adts_header >> 13)) AND 0x1FFF;
+
+    lower_16 = (UInt)adts_header;
+
+    pVars->prog_config.buffer_fullness = (lower_16 >> 2) AND 0x7FF;
+
+    pVars->prog_config.headerless_frames = (lower_16 AND 0x0003);
+
+    IF (pVars->prog_config.CRC_absent == 0)
+
+        CALL getbits(
+                LENGTH_CRC,
+               &(pVars->inputStream) );
+          RETURNING pVars->prog_config.CRC_check = 16-bit CRC
+
+    ENDIF
+
+    pVars->default_config = 0;
+
+    IF (byte_align_offset > 7)
+        status = 1;
+    ENDIF
+
+    return (status);
+
+------------------------------------------------------------------------------
+ RESOURCES USED
+   When the code is written for a specific target processor the
+     the resources used should be documented below.
+
+ STACK USAGE: [stack count for this module] + [variable to represent
+          stack usage for each subroutine called]
+
+     where: [stack usage variable] = stack usage for [subroutine
+         name] (see [filename].ext)
+
+ DATA MEMORY USED: x words
+
+ PROGRAM MEMORY USED: x words
+
+ CLOCK CYCLES: [cycle count equation for this module] + [variable
+           used to represent cycle count for each subroutine
+           called]
+
+     where: [cycle count variable] = cycle count for [subroutine
+        name] (see [filename].ext)
+
+------------------------------------------------------------------------------
+*/
+
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+#include "pv_audio_type_defs.h"
+#include "s_bits.h"
+#include "s_tdec_int_file.h"
+#include "ibstream.h"
+#include "set_mc_info.h"
+#include "find_adts_syncword.h"
+#include "get_adts_header.h"
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here. Include conditional
+; compile variables also.
+----------------------------------------------------------------------------*/
+#define LENGTH_VARIABLE_HEADER  28
+#define LENGTH_FIXED_HEADER     28
+#define LENGTH_SYNCWORD         15
+#define LENGTH_CRC              16
+
+#define ID_BIT_FILTER           0x7FFB
+#define SYNCWORD_15BITS         0x7FF8
+#define MASK_28BITS             0x0FFFFFFFL
+
+/*----------------------------------------------------------------------------
+; LOCAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; LOCAL STORE/BUFFER/POINTER DEFINITIONS
+; Variable declaration - defined here and used outside this module
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL FUNCTION REFERENCES
+; Declare functions defined elsewhere and referenced in this module
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL GLOBAL STORE/BUFFER/POINTER REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; FUNCTION CODE
+----------------------------------------------------------------------------*/
+Int get_adts_header(
+    tDec_Int_File *pVars,
+    UInt32        *pSyncword,
+    Int           *pInvoke,
+    Int            CorrectlyReadFramesCount)
+{
+    UInt32 adts_header;
+    UInt   lower_16;
+    Int    status = SUCCESS;
+    UInt   channel_configuration;
+
+    /*
+     * Search for the LONG ADTS syncword (comprised of the entire fixed header)
+     * if the number of CorrectlyReadFrames is > CorrectlyReadFramesCount
+     *
+     * Otherwise, search for just the short syncword.
+     */
+    if (*(pInvoke) > CorrectlyReadFramesCount)
+    {
+        /*
+         * Find the long ADTS syncword
+         * (comprised of the entire ADTS fixed header)
+         */
+
+        status = find_adts_syncword(pSyncword,
+                                    &(pVars->inputStream),
+                                    LENGTH_FIXED_HEADER,
+                                    MASK_28BITS);
+    }
+    else
+    {
+
+        *(pSyncword) = SYNCWORD_15BITS;
+
+        status = find_adts_syncword(pSyncword,
+                                    &(pVars->inputStream),
+                                    LENGTH_SYNCWORD,
+                                    ID_BIT_FILTER);
+
+        /*
+         *  Extract the data from the header following the syncword
+         */
+        adts_header = getbits((LENGTH_FIXED_HEADER - LENGTH_SYNCWORD),
+                              &(pVars->inputStream));
+
+        *(pSyncword) <<= (LENGTH_FIXED_HEADER - LENGTH_SYNCWORD);
+        *(pSyncword)  |= adts_header;
+
+        /* Denotes whether a CRC check should be performed */
+        pVars->prog_config.CRC_absent  = ((UInt)(adts_header >> 12)) & 0x0001;
+
+        /*
+         * All the unread bits in adts_header reside in the lower
+         * 16-bits at this point.  Perform a typecast for faster
+         * execution on 16-bit processors.
+         */
+        lower_16 = (UInt)adts_header;
+
+        /*
+         * Profile consists of 2 bits, which indicate
+         * the profile used.
+         *
+         * '00' AAC_MAIN profile
+         * '01' AAC_LC (Low Complexity) profile
+         * '10' AAC_SSR (Scaleable Sampling Rate) profile
+         * '11' AAC_LTP (Long Term Prediction) profile
+         */
+        pVars->prog_config.profile = (lower_16 >> 10) & 0x3;
+
+        if (pVars->prog_config.profile == MP4AUDIO_AAC_SSR)
+        {
+            status = 1;     /* Not supported */
+        }
+
+        /*
+         * Sampling_rate_idx consists of 4 bits
+         * see Ref #1 for their interpretation.
+         */
+        pVars->prog_config.sampling_rate_idx = (lower_16 >> 6) & 0xF;
+
+        /*
+         * private_bit is a bit for private use.  ISO/IEC will not make
+         * use of this bit in the future.
+         *
+         * We currently make no use of it, but parsing the information
+         * from the bitstream could be easily implemented with the
+         * following instruction...
+         *
+         * private_bit = (lower_16 & 0x0400) >> 10;
+         */
+
+        /*
+         * These 3 bits indicate the channel configuration used.
+         *
+         * If '0' then the channel configuration is unspecified here,
+         * and must be given by a program configuration element in
+         * the raw data block.
+         *
+         * If '1' then the channel configuration is MONO.
+         * If '2' then the channel configuration is STEREO
+         *
+         * 3-7 represent channel configurations which this library
+         * will not support in the forseeable future.
+         */
+        channel_configuration = (lower_16 >> 2) & 0x7;
+        /* do not support more than 2 channels */
+        if (channel_configuration > 2)
+        {
+            status = 1;
+        }
+
+        /*
+         * The following 2 bits encode copyright information.
+         * original_copy is '0' if there is no copyright in the bitstream.
+         *                  '1' if the bitstream is copyright protected.
+         *
+         * home is '0' for a copy, '1' for an original.
+         *
+         * PacketVideo currently does nothing with this information,
+         * however, parsing the data from the bitstream could be easily
+         * implemented with the following instructions...
+         *
+         * original_copy = (lower_16 >> 1) & 0x1;
+         *
+         * home = (lower_16 & 0x1);
+         *
+         */
+
+        /* Set up based on information extracted from the ADTS FIXED header */
+
+        /* This equals 1 for STEREO, 0 for MONO */
+        if (channel_configuration)
+        {
+            channel_configuration--;
+        }
+        pVars->prog_config.front.ele_is_cpe[0] = channel_configuration;
+
+        /* This value is constant for both MONO and STEREO */
+        pVars->prog_config.front.num_ele    = 1;
+
+        /* ADTS does not specify this tag value - do we even use it? */
+        pVars->prog_config.front.ele_tag[0] = 0;
+
+        /* Disable all mix related variables */
+        pVars->prog_config.mono_mix.present = 0;
+        pVars->prog_config.stereo_mix.present = 0;
+        pVars->prog_config.matrix_mix.present = 0;
+
+        /* enter configuration into MC_Info structure */
+        if (status == SUCCESS)
+        {
+            /* profile + 1 == audioObjectType */
+            status =
+                set_mc_info(
+                    &(pVars->mc_info),
+                    (tMP4AudioObjectType)(pVars->prog_config.profile + 1),
+                    pVars->prog_config.sampling_rate_idx,
+                    pVars->prog_config.front.ele_tag[0],
+                    pVars->prog_config.front.ele_is_cpe[0],
+                    pVars->winmap, /* changed from pVars->pWinSeqInfo, */
+                    pVars->SFBWidth128);
+
+        } /* if (status == SUCCESS) */
+
+
+#ifdef AAC_PLUS
+
+        /*
+         *  For implicit signalling, no hint that sbr or ps is used, so we need to
+         *  check the sampling frequency of the aac content, if lesser or equal to
+         *  24 KHz, by defualt upsample, otherwise, do nothing
+         */
+        if ((pVars->prog_config.sampling_rate_idx >= 6) && (pVars->aacPlusEnabled == TRUE))
+        {
+            pVars->mc_info.upsamplingFactor = 2;
+            pVars->prog_config.sampling_rate_idx -= 3;
+            pVars->mc_info.sbrPresentFlag = 1;
+            pVars->sbrDecoderData.SbrChannel[0].syncState = SBR_ACTIVE;
+            pVars->sbrDecoderData.SbrChannel[1].syncState = SBR_ACTIVE;
+        }
+#endif
+
+
+        /*
+         * The tag and is_cpe will be checked in huffdecode,
+         * remove this check routine.
+         */
+        /*if (status == SUCCESS)
+         *{
+         *   if ( (*pInvoke) != 0)
+         *   {
+         *       status =
+         *           check_mc_info(
+         *               &(pVars->mc_info),
+         *               &(pVars->savedMCInfo),
+         *               FALSE);
+         *   }
+         *   else
+         *   {
+         *       status =
+         *           check_mc_info(
+         *               &(pVars->mc_info),
+         *               &(pVars->savedMCInfo),
+         *               TRUE);
+         *   }
+         *
+         *}*/ /* if (status == SUCCESS) */
+
+        /*
+         * This keeps track of how many headers have been read in the file.
+         * After the three successful headers with the same configuration
+         * are read in, the entire ADTS fixed header is used as the syncword
+         * for a more robust 28-bit long syncword
+         */
+
+        if (status == SUCCESS)
+        {
+            (*pInvoke)++;
+        }
+        else
+        {
+            (*pInvoke) = 0;
+        }
+
+    } /* END if (*(pInvoke) > 3) */
+
+    /* Grab the bits in the ADTS variable header */
+    adts_header = getbits(
+                      LENGTH_VARIABLE_HEADER,
+                      &(pVars->inputStream));
+    /*
+     * copyright_identification bit is a single bit of the 72-bit
+     * copyright_id field.  This consists of a 8-bit copyright identifier
+     * and a 64-bit copyright_number.  72 headers must be decoded
+     * to reconstruct the entire copyright_id field.
+     *
+     * copyright_identification_start is a single bit flagging
+     * the beginning bit of the copyright_id field.  '1' for start of
+     * copyright_id, '0' otherwise.
+     *
+     *
+     * PacketVideo currently does nothing with this information,
+     * however, parsing the data from the bitstream could be easily
+     * implemented with the following instructions...
+     *
+     * copyright_id_bit = ((UInt)(adts_header >> 27)) & 0x1;
+     *
+     * copyright_id_start = ((UInt)(adts_header >> 26)) & 0x1;
+     */
+
+    /*
+     * frame_length is a 13-bit field which indicates the length,
+     * in bytes, of the frame including error_check and headers.
+     * This information can theoretically be used to help verify syncwords.
+     */
+    pVars->prog_config.frame_length  = ((UInt)(adts_header >> 13)) & 0x1FFF;
+
+    /*
+     * All the unread bits in adts_header reside in the lower
+     * 16-bits at this point.  Perform a typecast for faster
+     * execution on 16-bit processors.
+     */
+    lower_16 = (UInt)adts_header;
+
+    /*
+     * Indicates the number of 32-bit words remaining in the
+     * encoder buffer after the encoding of the first raw
+     * data block.  This value is 0x7ff for variable bit
+     * rate encoders, since buffer fullness does not apply
+     * to Variable Bit Rate (VBR) encoders.
+     */
+    pVars->prog_config.buffer_fullness = (lower_16 >> 2) & 0x7FF;
+
+    /*
+     * headerless_frames indicates the number of
+     * frames with no headers to be processed before the reading
+     * in of the next header.
+     *
+     * In ADTS, up to 4 "no header frames" can exist between
+     * syncwords.
+     *
+     * EXAMPLES:
+     *
+     * Legend: (Sync words denoted by X, frames
+     * deonted by FRAME_#)
+     *
+     * Example(1): The ADTS sequence below packs 5
+     * frames per header.
+     * Here, headerless_frames would always be read in as "4"
+     *
+     * |X||FRAME_0||FRAME_1||FRAME_2||FRAME_3||FRAME_4||X||FRAME_0|
+     *
+     * Example(2): The ADTS sequence below packs 1 frame per header.
+     * Here, headerless_frames would always be read in as "0"
+     *
+     * |X||FRAME_0||X||FRAME_1||X||FRAME_2|
+     *
+     */
+    pVars->prog_config.headerless_frames = (lower_16 & 0x0003);
+
+    if (pVars->prog_config.CRC_absent == 0)
+    {
+        pVars->prog_config.CRC_check = (UInt)getbits(
+                                           LENGTH_CRC,
+                                           &(pVars->inputStream));
+    }
+
+    /* pVars->current_program = 0; */ /* shall be set after PCE is read */
+
+    return (status);
+
+} /* END get_adts_header */
diff --git a/media/libstagefright/codecs/aacdec/get_adts_header.h b/media/libstagefright/codecs/aacdec/get_adts_header.h
new file mode 100644
index 0000000..13afa05
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/get_adts_header.h
@@ -0,0 +1,90 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Pathname: ./include/get_adts_header.h
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+ Who:                       Date:
+ Description:
+
+------------------------------------------------------------------------------
+ INCLUDE DESCRIPTION
+
+ This include file has the function declaration for get_adts_header().
+
+------------------------------------------------------------------------------
+*/
+
+/*----------------------------------------------------------------------------
+; CONTINUE ONLY IF NOT ALREADY DEFINED
+----------------------------------------------------------------------------*/
+#ifndef GET_ADTS_HEADER_H
+#define GET_ADTS_HEADER_H
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+#include "pv_audio_type_defs.h"
+#include "s_tdec_int_file.h"
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here.
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL VARIABLES REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; SIMPLE TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; ENUMERATED TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; STRUCTURES TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; GLOBAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+Int get_adts_header(
+    tDec_Int_File *pVars,
+    UInt32        *pSyncword,
+    Int           *pInvoke,
+    Int            CorrectlyReadFramesCount);
+
+/*----------------------------------------------------------------------------
+; END
+----------------------------------------------------------------------------*/
+#endif
+
+
diff --git a/media/libstagefright/codecs/aacdec/get_audio_specific_config.cpp b/media/libstagefright/codecs/aacdec/get_audio_specific_config.cpp
new file mode 100644
index 0000000..092f397
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/get_audio_specific_config.cpp
@@ -0,0 +1,691 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Pathname: ./src/get_audio_specific_config.c
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+ Description: Modified per review comments
+
+ Description: Modified per second review comments
+              (1) change audioObjectType to Int
+              (2) do not set pVars->prog_config.profile
+              (3) clean up status flag, default to SUCCESS
+              (4) fix multiple lines comments
+
+ Description: Change getbits.h to ibstream.h
+
+ Description: Modified per review comments
+              (1) updated revision history
+              (2) declare audioObjectType as enum type
+
+ Description: Replace some instances of getbits to get9_n_lessbits
+              when the number of bits read is 9 or less.
+
+ Description: Added support for backward and non-backward (explicit)
+              mode for Parametric Stereo (PS) used in enhanced AAC+
+
+ Who:                              Date:
+ Description:
+
+------------------------------------------------------------------------------
+ INPUT AND OUTPUT DEFINITIONS
+
+ Inputs:
+    pVars = pointer to the structure that holds all information for
+            this instance of the library. pVars->prog_config is directly
+            used, and pVars->mc_info, pVars->prog_config,
+            pVars->pWinSeqInfo, pVars->SFBWidth128 are needed indirectly
+            for calling set_mc_info. Data type pointer to tDec_Int_File
+
+ Local Stores/Buffers/Pointers Needed:
+    None
+
+ Global Stores/Buffers/Pointers Needed:
+    None
+
+ Outputs:
+    status = 0 if successfully decoded AudioSpecificConfig
+             1 if un-supported config is used for this release
+
+ Pointers and Buffers Modified:
+    pVars->prog_config contents are updated with the information read in.
+    pVars->mc_info contents are updated with channel information.
+    pVars->pWinSeqInfo contents are updated with window information.
+    pVars->SFBWidth128 contents are updated with scale factor band width data.
+
+ Local Stores Modified:
+    None
+
+ Global Stores Modified:
+    None
+
+------------------------------------------------------------------------------
+ FUNCTION DESCRIPTION
+
+ This function reads the bitstream for the structure "AudioSpecificConfig",
+ and sets the decoder configuration that is needed by the decoder to be able
+ to decode the media properly.
+
+------------------------------------------------------------------------------
+ REQUIREMENTS
+
+ This function shall not use global variables
+
+------------------------------------------------------------------------------
+ REFERENCES
+
+ (1) ISO/IEC 14496-3: 1999(E)
+ Part 3
+ Subpart 1  p18     1.6   Interface to MPEG-4 Systems
+ Subpart 4  p13     4.4.1 GA Specific Configuration
+ Amendment  p10     6.2.1 AudioSpecificInfo
+ Amendment  p78     8.2   Decoder configuration (GASpecificConfig)
+
+ (2) AAC DecoderSpecificInfo Information
+   PacketVideo descriptions - San Diego
+
+------------------------------------------------------------------------------
+ PSEUDO-CODE
+
+    status = SUCCESS;
+
+    pInputStream = &(pVars->inputStream);
+
+    temp = CALL getbits(
+                    neededBits = LEN_OBJ_TYPE + LEN_SAMP_RATE_IDX,
+                    pInputStream = pInputStream)
+           MODIFYING (pInputStream)
+           RETURNING (temp)
+
+    audioObjectType = (temp & 0x1f0) >> 4;
+
+    pVars->prog_config.profile = audioObjectType;
+
+    pVars->prog_config.sampling_rate_idx = temp & 0xf;
+
+    IF (pVars->prog_config.sampling_rate_idx == 0xf)
+    THEN
+        sampling_rate = CALL getbits(
+                            neededBits = LEN_SAMP_RATE,
+                            pInputStream = pInputStream);
+                        MODIFYING (pInputStream)
+                        RETURNING (sampling_rate)
+    ENDIF
+
+    channel_config = CALL getbits(
+                            neededBits = LEN_CHAN_CONFIG,
+                            pInputStream = pInputStream);
+                        MODIFYING (pInputStream)
+                        RETURNING (channel_config)
+
+    IF (channel_config > 2)
+    THEN
+        status = 1;
+    ENDIF
+
+    IF (((audioObjectType == MP4AUDIO_AAC_MAIN)     OR
+        (audioObjectType == MP4AUDIO_AAC_LC)        OR
+        (audioObjectType == MP4AUDIO_AAC_SSR)       OR
+        (audioObjectType == MP4AUDIO_LTP)           OR
+        (audioObjectType == MP4AUDIO_AAC_SCALABLE)  OR
+        (audioObjectType == MP4AUDIO_TWINVQ)) AND (status == -1))
+    THEN
+        status = CALL get_GA_specific_config(
+                            pVars = pVars,
+                            channel_config = channel_config,
+                            audioObjectType = audioObjectType,
+                            pInputStream = pInputStream);
+                      MODIFYING (pVars->mc_info,channel_config,pInputStream)
+                      RETURNING (status)
+
+    ENDIF
+
+    IF (audioObjectType == MP4AUDIO_CELP)
+    THEN
+        status = 1;
+    ENDIF
+
+    IF (audioObjectType == MP4AUDIO_HVXC)
+    THEN
+        status = 1;
+    ENDIF
+
+    IF (audioObjectType == MP4AUDIO_TTSI)
+    THEN
+        status = 1;
+    ENDIF
+
+    IF ((audioObjectType == 13) OR (audioObjectType == 14) OR
+        (audioObjectType == 15) OR (audioObjectType == 16))
+    THEN
+        status = 1;
+    ENDIF
+
+    IF (((audioObjectType == MP4AUDIO_ER_AAC_LC)       OR
+         (audioObjectType == MP4AUDIO_ER_AAC_LTP)      OR
+         (audioObjectType == MP4AUDIO_ER_AAC_SCALABLE) OR
+         (audioObjectType == MP4AUDIO_ER_TWINVQ)       OR
+         (audioObjectType == MP4AUDIO_ER_BSAC)         OR
+         (audioObjectType == MP4AUDIO_ER_AAC_LD)) AND (status == -1))
+    THEN
+        status = 1;
+    ENDIF
+
+    IF (audioObjectType == MP4AUDIO_ER_CELP)
+    THEN
+        status = 1;
+    ENDIF
+
+    IF (audioObjectType == MP4AUDIO_ER_HVXC)
+    THEN
+        status = 1;
+    ENDIF
+
+    IF ((audioObjectType == MP4AUDIO_ER_HILN) OR
+        (audioObjectType == MP4AUDIO_PARAMETRIC))
+    THEN
+        status = 1;
+    ENDIF
+
+    IF ((audioObjectType == MP4AUDIO_ER_AAC_LC)       OR
+        (audioObjectType == MP4AUDIO_ER_AAC_LTP)      OR
+        (audioObjectType == MP4AUDIO_ER_AAC_SCALABLE) OR
+        (audioObjectType == MP4AUDIO_ER_TWINVQ)       OR
+        (audioObjectType == MP4AUDIO_ER_BSAC)         OR
+        (audioObjectType == MP4AUDIO_ER_AAC_LD)       OR
+        (audioObjectType == MP4AUDIO_ER_CELP)         OR
+        (audioObjectType == MP4AUDIO_ER_HVXC)         OR
+        (audioObjectType == MP4AUDIO_ER_HILN)         OR
+        (audioObjectType == MP4AUDIO_PARAMETRIC))
+    THEN
+        epConfig = CALL getbits(
+                            neededBits = LEN_EP_CONFIG,
+                            pInputStream = pInputStream);
+                      MODIFYING (pInputStream)
+                      RETURNING (epConfig)
+
+        IF (epConfig == 2)
+        THEN
+            status = 1;
+        ENDIF
+
+    ENDIF
+
+    RETURN status;
+
+------------------------------------------------------------------------------
+ RESOURCES USED
+   When the code is written for a specific target processor the
+     the resources used should be documented below.
+
+ STACK USAGE: [stack count for this module] + [variable to represent
+          stack usage for each subroutine called]
+
+     where: [stack usage variable] = stack usage for [subroutine
+         name] (see [filename].ext)
+
+ DATA MEMORY USED: x words
+
+ PROGRAM MEMORY USED: x words
+
+ CLOCK CYCLES: [cycle count equation for this module] + [variable
+           used to represent cycle count for each subroutine
+           called]
+
+     where: [cycle count variable] = cycle count for [subroutine
+        name] (see [filename].ext)
+
+------------------------------------------------------------------------------
+*/
+
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+#include    "pv_audio_type_defs.h"
+#include    "e_mp4ff_const.h"
+#include    "e_tmp4audioobjecttype.h"
+#include    "get_audio_specific_config.h"
+#include    "get_ga_specific_config.h"
+#include    "ibstream.h"
+#include    "sfb.h"                   /* Where samp_rate_info[] is declared */
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here. Include conditional
+; compile variables also.
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; LOCAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; LOCAL STORE/BUFFER/POINTER DEFINITIONS
+; Variable declaration - defined here and used outside this module
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL FUNCTION REFERENCES
+; Declare functions defined elsewhere and referenced in this module
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL GLOBAL STORE/BUFFER/POINTER REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; FUNCTION CODE
+----------------------------------------------------------------------------*/
+Int get_audio_specific_config(tDec_Int_File   * const pVars)
+{
+
+    UInt    temp;
+    tMP4AudioObjectType     audioObjectType;
+    //UInt32  sampling_rate;
+    UInt    channel_config;
+    UInt    syncExtensionType;
+    UInt    extensionAudioObjectType = 0;
+    UInt    extensionSamplingFrequencyIndex = 0;
+    BITS   *pInputStream;
+    Int     status;
+
+    status = SUCCESS;
+
+    pInputStream = &(pVars->inputStream);
+
+    pVars->mc_info.upsamplingFactor = 1;   /*  default to regular AAC */
+
+    temp =  get9_n_lessbits(LEN_OBJ_TYPE + LEN_SAMP_RATE_IDX,
+                            pInputStream);
+
+    /*
+     * The following code can directly set the values of elements in
+     * MC_Info, rather than first setting the values in pVars->prog_config
+     * and then copy these values to MC_Info by calling set_mc_info.
+     * In order to keep consistent with get_prog_config (ADIF) and
+     * get_adts_header (ADTS), the code here is still copying
+     * the info, and set the pVars->current_program = 0
+     */
+
+    /* AudioObjectType */
+    audioObjectType = (tMP4AudioObjectType)((temp & 0x1f0) >> 4);
+
+    pVars->mc_info.ExtendedAudioObjectType =  audioObjectType;   /* default */
+    /* saving an audioObjectType into a profile field */
+    /* pVars->prog_config.profile = audioObjectType; */
+
+    /* sampling rate index */
+    pVars->prog_config.sampling_rate_idx = temp & 0xf;
+
+    if (pVars->prog_config.sampling_rate_idx > 0xb)
+    {
+        /*
+         *  Only support 12 sampling frequencies from array samp_rate_info ( see sfb.cpp)
+         *  7350 Hz (index 0xc) is not supported, the other indexes are reserved or escape
+         */
+        if (pVars->prog_config.sampling_rate_idx == 0xf) /* escape sequence */
+        {
+            /*
+             * sampling rate not listed in Table 1.6.2,
+             * this release does not support this
+             */
+            /*sampling_rate =  getbits( LEN_SAMP_RATE,
+                                      pInputStream);*/
+            getbits(LEN_SAMP_RATE, pInputStream); /* future use */
+        }
+
+        status = 1;
+    }
+
+    channel_config =  get9_n_lessbits(LEN_CHAN_CONFIG,
+                                      pInputStream);
+
+    if ((channel_config > 2) && (!pVars->aacConfigUtilityEnabled))
+    {
+        /*
+         * AAC lib does not support more than two channels
+         * signal error when in decoder mode
+         * do not test when in utility mode
+         */
+        status = 1;
+
+    }
+
+    if (audioObjectType == MP4AUDIO_SBR || audioObjectType == MP4AUDIO_PS)
+    {
+        /* to disable explicit backward compatiblity check */
+        pVars->mc_info.ExtendedAudioObjectType = MP4AUDIO_SBR;
+        pVars->mc_info.sbrPresentFlag = 1;
+
+        if (audioObjectType == MP4AUDIO_PS)
+        {
+            pVars->mc_info.psPresentFlag = 1;
+            pVars->mc_info.ExtendedAudioObjectType = MP4AUDIO_PS;
+        }
+
+        extensionSamplingFrequencyIndex = /* extensionSamplingFrequencyIndex */
+            get9_n_lessbits(LEN_SAMP_RATE_IDX,
+                            pInputStream);
+        if (extensionSamplingFrequencyIndex == 0x0f)
+        {
+            /*
+             * sampling rate not listed in Table 1.6.2,
+             * this release does not support this
+                */
+            /*sampling_rate = getbits( LEN_SAMP_RATE,
+                                     pInputStream);*/
+            getbits(LEN_SAMP_RATE, pInputStream);
+        }
+
+        audioObjectType = (tMP4AudioObjectType) get9_n_lessbits(LEN_OBJ_TYPE ,
+                          pInputStream);
+    }
+
+
+    if ((/*(audioObjectType == MP4AUDIO_AAC_MAIN)     ||*/
+                (audioObjectType == MP4AUDIO_AAC_LC)        ||
+                /*(audioObjectType == MP4AUDIO_AAC_SSR)       ||*/
+                (audioObjectType == MP4AUDIO_LTP)           /*||*/
+                /*(audioObjectType == MP4AUDIO_AAC_SCALABLE)  ||*/
+                /*(audioObjectType == MP4AUDIO_TWINVQ)*/) && (status == SUCCESS))
+    {
+        status = get_GA_specific_config(pVars,
+                                        pInputStream,
+                                        channel_config,
+                                        audioObjectType);
+
+        /*
+         *  verify that Program config returned a supported audio object type
+         */
+
+        if ((pVars->mc_info.audioObjectType != MP4AUDIO_AAC_LC) &&
+                (pVars->mc_info.audioObjectType != MP4AUDIO_LTP))
+        {
+            return 1;   /* status != SUCCESS invalid aot */
+        }
+    }
+    else
+    {
+        return 1;   /* status != SUCCESS invalid aot or invalid parameter */
+    }
+
+    /*
+     *  SBR tool explicit signaling ( backward compatible )
+     */
+    if (extensionAudioObjectType != MP4AUDIO_SBR)
+    {
+        syncExtensionType = (UInt)get17_n_lessbits(LEN_SYNC_EXTENSION_TYPE,
+                            pInputStream);
+
+        if (syncExtensionType == 0x2b7)
+        {
+            extensionAudioObjectType = get9_n_lessbits( /* extensionAudioObjectType */
+                                           LEN_OBJ_TYPE,
+                                           pInputStream);
+
+            if (extensionAudioObjectType == MP4AUDIO_SBR)
+            {
+                pVars->mc_info.sbrPresentFlag = get1bits(pInputStream);  /* sbrPresentFlag */
+                if (pVars->mc_info.sbrPresentFlag == 1)
+                {
+                    extensionSamplingFrequencyIndex =
+                        get9_n_lessbits( /* extensionSamplingFrequencyIndex */
+                            LEN_SAMP_RATE_IDX,
+                            pInputStream);
+                    if (pVars->aacPlusEnabled == true)
+                    {
+#ifdef AAC_PLUS
+                        pVars->mc_info.upsamplingFactor = (samp_rate_info[extensionSamplingFrequencyIndex].samp_rate >> 1) ==
+                                                          samp_rate_info[pVars->prog_config.sampling_rate_idx].samp_rate ? 2 : 1;
+
+                        if ((Int)extensionSamplingFrequencyIndex == pVars->prog_config.sampling_rate_idx)
+                        {
+                            /*
+                             *  Disable SBR decoding for any sbr-downsampled file whose SF is >= 24 KHz
+                             */
+                            if (pVars->prog_config.sampling_rate_idx < 6)
+                            {
+                                pVars->aacPlusEnabled = false;
+                            }
+
+                            pVars->mc_info.bDownSampledSbr = true;
+                        }
+                        pVars->prog_config.sampling_rate_idx = extensionSamplingFrequencyIndex;
+
+#endif
+                    }
+
+                    if (extensionSamplingFrequencyIndex == 0x0f)
+                    {
+                        /*
+                         * sampling rate not listed in Table 1.6.2,
+                         * this release does not support this
+                         */
+                        /*sampling_rate = getbits( LEN_SAMP_RATE,
+                                                 pInputStream);*/
+                        getbits(LEN_SAMP_RATE, pInputStream);
+                    }
+                    /* syncExtensionType */
+                    syncExtensionType = (UInt)get17_n_lessbits(LEN_SYNC_EXTENSION_TYPE,
+                                        pInputStream);
+                    if (syncExtensionType == 0x548)
+                    {
+                        pVars->mc_info.psPresentFlag = get1bits(pInputStream);  /* psPresentFlag */
+                        if (pVars->mc_info.psPresentFlag)
+                        {
+                            extensionAudioObjectType = MP4AUDIO_PS;
+                        }
+                    }
+                    else
+                    {
+                        /*
+                        * Rewind bitstream pointer so that the syncExtensionType reading has no
+                        * effect when decoding raw bitstream
+                            */
+                        pVars->inputStream.usedBits -= LEN_SYNC_EXTENSION_TYPE;
+                    }
+
+                    pVars->mc_info.ExtendedAudioObjectType = (eMP4AudioObjectType)extensionAudioObjectType;
+                }
+            }
+        }
+        else if (!status)
+        {
+            /*
+             * Rewind bitstream pointer so that the syncExtensionType reading has no
+             * effect when decoding raw bitstream
+             */
+            pVars->inputStream.usedBits -= LEN_SYNC_EXTENSION_TYPE;
+
+#ifdef AAC_PLUS
+
+            /*
+             *  For implicit signalling, no hint that sbr or ps is used, so we need to
+             *  check the sampling frequency of the aac content, if lesser or equal to
+             *  24 KHz, by defualt upsample, otherwise, do nothing
+             */
+            if ((pVars->prog_config.sampling_rate_idx >= 6) && (pVars->aacPlusEnabled == true) &&
+                    audioObjectType == MP4AUDIO_AAC_LC)
+            {
+                pVars->mc_info.upsamplingFactor = 2;
+                pVars->prog_config.sampling_rate_idx -= 3;
+                pVars->mc_info.sbrPresentFlag = 1;
+                pVars->sbrDecoderData.SbrChannel[0].syncState = SBR_NOT_INITIALIZED;
+                pVars->sbrDecoderData.SbrChannel[1].syncState = SBR_NOT_INITIALIZED;
+
+            }
+#endif
+
+        }
+    }
+    else    /*  MP4AUDIO_SBR was detected  */
+    {
+        /*
+         *  Set the real output frequency use by the SBR tool, define tentative upsample ratio
+         */
+        if (pVars->aacPlusEnabled == true)
+        {
+#ifdef AAC_PLUS
+            pVars->mc_info.upsamplingFactor = (samp_rate_info[extensionSamplingFrequencyIndex].samp_rate >> 1) ==
+                                              samp_rate_info[pVars->prog_config.sampling_rate_idx].samp_rate ? 2 : 1;
+
+            if ((Int)extensionSamplingFrequencyIndex == pVars->prog_config.sampling_rate_idx)
+            {
+                /*
+                 *  Disable SBR decoding for any sbr-downsampled file whose SF is >= 24 KHz
+                 */
+                if (pVars->prog_config.sampling_rate_idx < 6)
+                {
+                    pVars->aacPlusEnabled = false;
+                }
+                pVars->mc_info.bDownSampledSbr = true;
+            }
+            pVars->prog_config.sampling_rate_idx = extensionSamplingFrequencyIndex;
+
+
+
+#endif
+
+
+
+
+        }
+
+    }  /*  if ( extensionAudioObjectType != MP4AUDIO_SBR ) */
+
+    /*
+     * The following object types are not supported in this release,
+     * however, keep these interfaces for future implementation
+     */
+
+    /*
+     *if (audioObjectType == MP4AUDIO_CELP)
+     *{
+     *    status = 1;
+     *}
+     */
+
+    /*
+     *if (audioObjectType == MP4AUDIO_HVXC)
+     *{
+     *    status = 1;
+     *}
+     */
+
+    /*
+     *if (audioObjectType == MP4AUDIO_TTSI)
+     *{
+     *    status = 1;
+     *}
+     */
+
+    /*
+     *if ((audioObjectType == 13) || (audioObjectType == 14) ||
+     *   (audioObjectType == 15) || (audioObjectType == 16))
+     *{
+     *    status = 1;
+     *}
+     */
+
+    /* The following objects are Amendment 1 objects */
+    /*
+     *if (((audioObjectType == MP4AUDIO_ER_AAC_LC)       ||
+     *    (audioObjectType == MP4AUDIO_ER_AAC_LTP)      ||
+     *    (audioObjectType == MP4AUDIO_ER_AAC_SCALABLE) ||
+     *    (audioObjectType == MP4AUDIO_ER_TWINVQ)       ||
+     *    (audioObjectType == MP4AUDIO_ER_BSAC)         ||
+     *    (audioObjectType == MP4AUDIO_ER_AAC_LD)) && (status == -1))
+     *{
+     */
+    /*
+     * should call get_GA_specific_config
+     * for this release, do not support Error Resilience
+     * temporary solution is set status flag and exit decoding
+     */
+    /*    status = 1;
+    *}
+    */
+
+    /*
+     *if (audioObjectType == MP4AUDIO_ER_CELP)
+     * {
+     *    status = 1;
+     *}
+     */
+
+    /*
+     *if (audioObjectType == MP4AUDIO_ER_HVXC)
+     *{
+     *    status = 1;
+     *}
+     */
+
+    /*
+     *if ((audioObjectType == MP4AUDIO_ER_HILN) ||
+     *    (audioObjectType == MP4AUDIO_PARAMETRIC))
+     *{
+     *    status = 1;
+     *}
+     */
+
+    /*
+     *if ((audioObjectType == MP4AUDIO_ER_AAC_LC)       ||
+     *    (audioObjectType == MP4AUDIO_ER_AAC_LTP)      ||
+     *    (audioObjectType == MP4AUDIO_ER_AAC_SCALABLE) ||
+     *    (audioObjectType == MP4AUDIO_ER_TWINVQ)       ||
+     *    (audioObjectType == MP4AUDIO_ER_BSAC)         ||
+     *    (audioObjectType == MP4AUDIO_ER_AAC_LD)       ||
+     *    (audioObjectType == MP4AUDIO_ER_CELP)         ||
+     *    (audioObjectType == MP4AUDIO_ER_HVXC)         ||
+     *    (audioObjectType == MP4AUDIO_ER_HILN)         ||
+     *    (audioObjectType == MP4AUDIO_PARAMETRIC))
+     *{
+     */
+    /* error protection config */
+    /*
+     *     epConfig =
+     *       getbits(
+     *           LEN_EP_CONFIG,
+     *           pInputStream);
+     *
+     *   if (epConfig == 2)
+     *   {
+     */
+    /* should call ErrorProtectionSpecificConfig() */
+    /*
+     *       status = 1;
+     *   }
+     *
+     *}
+     */
+
+    return status;
+
+}
diff --git a/media/libstagefright/codecs/aacdec/get_audio_specific_config.h b/media/libstagefright/codecs/aacdec/get_audio_specific_config.h
new file mode 100644
index 0000000..b7cfcf5
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/get_audio_specific_config.h
@@ -0,0 +1,86 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Pathname: ./include/get_audio_specific_config.h
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+ Who:                              Date:
+ Description:
+
+------------------------------------------------------------------------------
+ INCLUDE DESCRIPTION
+
+ This file includes function declaration for get_audio_specific_config
+
+------------------------------------------------------------------------------
+*/
+
+/*----------------------------------------------------------------------------
+; CONTINUE ONLY IF NOT ALREADY DEFINED
+----------------------------------------------------------------------------*/
+#ifndef GET_AUDIO_SPECIFIC_CONFIG_H
+#define GET_AUDIO_SPECIFIC_CONFIG_H
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+#include    "pv_audio_type_defs.h"
+#include    "s_tdec_int_file.h"
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here.
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL VARIABLES REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; SIMPLE TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; ENUMERATED TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; STRUCTURES TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; GLOBAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+Int get_audio_specific_config(
+    tDec_Int_File   * const pVars
+);
+
+/*----------------------------------------------------------------------------
+; END
+----------------------------------------------------------------------------*/
+#endif
diff --git a/media/libstagefright/codecs/aacdec/get_dse.cpp b/media/libstagefright/codecs/aacdec/get_dse.cpp
new file mode 100644
index 0000000..d64087f
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/get_dse.cpp
@@ -0,0 +1,215 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+------------------------------------------------------------------------------
+ INPUT AND OUTPUT DEFINITIONS
+
+ Inputs:
+    pInputStream = pointer to a BITS structure that holds information
+                   regarding the input stream.
+
+ Local Stores/Buffers/Pointers Needed:
+    None
+
+ Global Stores/Buffers/Pointers Needed:
+    None
+
+ Outputs:
+    None
+
+ Pointers and Buffers Modified:
+    pInputStream->usedBits is rounded up to a number that represents the next
+    byte boundary.
+
+ Local Stores Modified:
+    None
+
+ Global Stores Modified:
+    None
+
+------------------------------------------------------------------------------
+ FUNCTION DESCRIPTION
+
+    Adquire Data Stream element (DSE) from raw bitstream
+    At this time this function just drops the information.
+
+------------------------------------------------------------------------------
+ REQUIREMENTS
+
+  This function shall not use global or static variables.
+
+------------------------------------------------------------------------------
+ REFERENCES
+
+ (1) MPEG-2 NBC Audio Decoder
+   "This software module was originally developed by AT&T, Dolby
+   Laboratories, Fraunhofer Gesellschaft IIS in the course of development
+   of the MPEG-2 NBC/MPEG-4 Audio standard ISO/IEC 13818-7, 14496-1,2 and
+   3. This software module is an implementation of a part of one or more
+   MPEG-2 NBC/MPEG-4 Audio tools as specified by the MPEG-2 NBC/MPEG-4
+   Audio standard. ISO/IEC gives users of the MPEG-2 NBC/MPEG-4 Audio
+   standards free license to this software module or modifications thereof
+   for use in hardware or software products claiming conformance to the
+   MPEG-2 NBC/MPEG-4 Audio  standards. Those intending to use this software
+   module in hardware or software products are advised that this use may
+   infringe existing patents. The original developer of this software
+   module and his/her company, the subsequent editors and their companies,
+   and ISO/IEC have no liability for use of this software module or
+   modifications thereof in an implementation. Copyright is not released
+   for non MPEG-2 NBC/MPEG-4 Audio conforming products.The original
+   developer retains full right to use the code for his/her own purpose,
+   assign or donate the code to a third party and to inhibit third party
+   from using the code for non MPEG-2 NBC/MPEG-4 Audio conforming products.
+   This copyright notice must be included in all copies or derivative
+   works."
+   Copyright(c)1996.
+
+------------------------------------------------------------------------------
+ PSEUDO-CODE
+
+void byte_align(
+    BITS  *pInputStream)
+
+    MODIFYING(pInputStream->usedBits = pInputStream->usedBits +
+                (pInputStream->usedBits + 7) % 8)
+
+    RETURN(nothing)
+
+------------------------------------------------------------------------------
+ RESOURCES USED
+
+ STACK USAGE:
+
+     where:
+
+ DATA MEMORY USED: x words
+
+ PROGRAM MEMORY USED: x words
+
+ CLOCK CYCLES:
+
+------------------------------------------------------------------------------
+*/
+
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+
+#include "pv_audio_type_defs.h"
+#include "get_dse.h"
+#include "ibstream.h"
+#include "getbits.h"
+#include "s_bits.h"
+
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here. Include conditional
+; compile variables also.
+----------------------------------------------------------------------------*/
+
+
+/*----------------------------------------------------------------------------
+; LOCAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; LOCAL VARIABLE DEFINITIONS
+; Variable declaration - defined here and used outside this module
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL FUNCTION REFERENCES
+; Declare functions defined elsewhere and referenced in this module
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL VARIABLES REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; FUNCTION CODE
+----------------------------------------------------------------------------*/
+
+void get_dse(
+    Char    *DataStreamBytes,
+    BITS    *pInputStream)
+{
+    Int i;
+    Int data_byte_align_flag;
+    UInt count;
+    Int esc_count;
+    Char    *pDataStreamBytes;
+
+    pDataStreamBytes = DataStreamBytes;
+
+    /*
+     *  Get element instance tag  ( 4 bits)
+     *  ( max of 16 per raw data block)
+     */
+    get9_n_lessbits(LEN_TAG, pInputStream);
+
+    /*
+     *  get data_byte_align_flag ( 1 bit0 to see if byte alignment is
+     *  performed within the DSE
+     */
+    data_byte_align_flag = get1bits(pInputStream);
+
+    /*
+     *  get count ( 8 bits)
+     */
+    count =  get9_n_lessbits(LEN_D_CNT, pInputStream);
+
+    /*
+     *  if count == 255, its value it is incremented  by a
+     *  second 8 bit value, esc_count. This final value represents
+     *  the number of bytes in the DSE
+     */
+    if (count == (1 << LEN_D_CNT) - 1)
+    {
+        esc_count = (Int)get9_n_lessbits(LEN_D_ESC, pInputStream);  /* 8 bits */
+        count +=  esc_count;
+    }
+
+    /*
+     *  Align if flag is set
+     */
+    if (data_byte_align_flag)
+    {
+        byte_align(pInputStream);
+    }
+
+    for (i = count; i != 0; i--)
+    {
+        *(pDataStreamBytes++) = (Char) get9_n_lessbits(
+                                    LEN_BYTE,
+                                    pInputStream);
+    }
+
+    return;
+
+} /* end get_dse */
+
diff --git a/media/libstagefright/codecs/aacdec/get_dse.h b/media/libstagefright/codecs/aacdec/get_dse.h
new file mode 100644
index 0000000..3563f71
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/get_dse.h
@@ -0,0 +1,87 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Pathname: get_dse.h
+ Funtions:
+    get_dse
+
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+
+ Who:                                   Date: MM/DD/YYYY
+ Description:
+------------------------------------------------------------------------------
+
+*/
+
+/*----------------------------------------------------------------------------
+; CONTINUE ONLY IF NOT ALREADY DEFINED
+----------------------------------------------------------------------------*/
+#ifndef GET_DSE_H
+#define GET_DSE_H
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+#include "pv_audio_type_defs.h"
+#include "s_elelist.h"
+#include "s_bits.h"
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here.
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL VARIABLES REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; SIMPLE TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; ENUMERATED TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; STRUCTURES TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; GLOBAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+
+void get_dse(
+    Char    *DataStreamBytes,
+    BITS    *pInputStream);
+
+/*----------------------------------------------------------------------------
+; END
+----------------------------------------------------------------------------*/
+#endif
diff --git a/media/libstagefright/codecs/aacdec/get_ele_list.cpp b/media/libstagefright/codecs/aacdec/get_ele_list.cpp
new file mode 100644
index 0000000..0534c13
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/get_ele_list.cpp
@@ -0,0 +1,243 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Pathname: get_ele_list.c
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+ Description:  Modified from original shareware code
+
+ Description:  Modified to pass variables by reference to eliminate use
+               of global variables.
+
+ Description: Change to PacketVideo standard, rename variables.
+
+ Description: Add own header file, make pInputStream second param for speed.
+
+ Description: Changes per code review:
+              1) Include header file
+              2) Convert to count down
+              3) Add return (not in review)
+
+ Description:
+ (1) Updated copyright header
+ (2) Replaced include of "interface.h" with "e_ProgConfig.h"
+
+ Description: Replace some instances of getbits to get9_n_lessbits
+              when the number of bits read is 9 or less and get1bits
+              when only 1 bit is read.
+
+ Who:                                 Date:
+ Description:
+------------------------------------------------------------------------------
+ INPUT AND OUTPUT DEFINITIONS
+
+ Inputs:
+    pElementList = pointer to an EleList structure - only the field num_ele
+                   needs to be set. Data type pointer to EleList.
+
+   pInputStream = pointer to a BITS structure, used by the function getbits
+                   to provide data. Data type pointer to BITS
+
+    enableCPE = boolean value indicating the area to be read contains
+                a channel pair element field. Data type Bool
+
+
+ Local Stores/Buffers/Pointers Needed: None
+
+ Global Stores/Buffers/Pointers Needed: None
+
+ Outputs: None
+
+ Pointers and Buffers Modified:
+    pElementList contents are updated with information pertaining to channel
+        configuration.
+
+    pInputBuffer contents are updated to the next location to be read from
+        the input stream.
+
+ Local Stores Modified: None
+
+ Global Stores Modified: None
+
+------------------------------------------------------------------------------
+ FUNCTION DESCRIPTION
+
+ This function is called several times by get_prog_config() to read in part of
+ the program configuration data related to channel setup.
+
+------------------------------------------------------------------------------
+ REQUIREMENTS
+
+ This function shall not have static or global variables.
+
+------------------------------------------------------------------------------
+ REFERENCES
+
+ (1) ISO/IEC 13818-7:1997 Titled "Information technology - Generic coding
+   of moving pictures and associated audio information - Part 7: Advanced
+   Audio Coding (AAC)", Table 6.21 - Syntax of program_config_element(),
+   page 16, and section 8.5 "Program Config Element (PCE)", page 30.
+
+ (2) MPEG-2 NBC Audio Decoder
+   "This software module was originally developed by AT&T, Dolby
+   Laboratories, Fraunhofer Gesellschaft IIS in the course of development
+   of the MPEG-2 NBC/MPEG-4 Audio standard ISO/IEC 13818-7, 14496-1,2 and
+   3. This software module is an implementation of a part of one or more
+   MPEG-2 NBC/MPEG-4 Audio tools as specified by the MPEG-2 NBC/MPEG-4
+   Audio standard. ISO/IEC gives users of the MPEG-2 NBC/MPEG-4 Audio
+   standards free license to this software module or modifications thereof
+   for use in hardware or software products claiming conformance to the
+   MPEG-2 NBC/MPEG-4 Audio  standards. Those intending to use this software
+   module in hardware or software products are advised that this use may
+   infringe existing patents. The original developer of this software
+   module and his/her company, the subsequent editors and their companies,
+   and ISO/IEC have no liability for use of this software module or
+   modifications thereof in an implementation. Copyright is not released
+   for non MPEG-2 NBC/MPEG-4 Audio conforming products.The original
+   developer retains full right to use the code for his/her own purpose,
+   assign or donate the code to a third party and to inhibit third party
+   from using the code for non MPEG-2 NBC/MPEG-4 Audio conforming products.
+   This copyright notice must be included in all copies or derivative
+   works."
+   Copyright(c)1996.
+
+
+------------------------------------------------------------------------------
+ PSEUDO-CODE
+
+    elementCount = pElementList->num_ele;
+
+    FOR (index = 0; index < elementCount; index++)
+        IF (enableCPE != FALSE) THEN
+            pElementList->ele_is_cpe[index] =
+                getbits(LEN_ELE_IS_CPE, pInputStream);
+        ELSE
+            pElementList->ele_is_cpe[index] = 0;
+        END IF
+
+        pElementList->ele_tag[index] = getbits(LEN_TAG, pInputStream);
+
+    END FOR
+
+    RETURNS nothing
+
+------------------------------------------------------------------------------
+ RESOURCES USED
+   When the code is written for a specific target processor the
+     the resources used should be documented below.
+
+ STACK USAGE: [stack count for this module] + [variable to represent
+          stack usage for each subroutine called]
+
+     where: [stack usage variable] = stack usage for [subroutine
+         name] (see [filename].ext)
+
+ DATA MEMORY USED: x words
+
+ PROGRAM MEMORY USED: x words
+
+ CLOCK CYCLES: [cycle count equation for this module] + [variable
+           used to represent cycle count for each subroutine
+           called]
+
+     where: [cycle count variable] = cycle count for [subroutine
+        name] (see [filename].ext)
+
+------------------------------------------------------------------------------
+*/
+
+
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+#include "pv_audio_type_defs.h"
+#include "s_elelist.h"
+#include "s_bits.h"
+#include "e_progconfigconst.h"
+#include "ibstream.h"
+#include "get_ele_list.h"
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here. Include conditional
+; compile variables also.
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; LOCAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; LOCAL STORE/BUFFER/POINTER DEFINITIONS
+; Variable declaration - defined here and used outside this module
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL FUNCTION REFERENCES
+; Declare functions defined elsewhere and referenced in this module
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL GLOBAL STORE/BUFFER/POINTER REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; FUNCTION CODE
+----------------------------------------------------------------------------*/
+void get_ele_list(
+    EleList     *pElementList,
+    BITS        *pInputStream,
+    const Bool   enableCPE)
+{
+    Int index;
+    Int *pEleIsCPE;
+    Int *pEleTag;
+
+    pEleIsCPE = &pElementList->ele_is_cpe[0];
+    pEleTag   = &pElementList->ele_tag[0];
+
+    for (index = pElementList->num_ele; index > 0; index--)
+    {
+        if (enableCPE != FALSE)
+        {
+            *pEleIsCPE++ = get1bits(/*LEN_ELE_IS_CPE, */pInputStream);
+        }
+        else
+        {
+            *pEleIsCPE++ = FALSE;
+        }
+
+        *pEleTag++ = get9_n_lessbits(LEN_TAG, pInputStream);
+
+    } /* end for (index) */
+
+    return;
+
+} /* end get_ele_list */
+
diff --git a/media/libstagefright/codecs/aacdec/get_ele_list.h b/media/libstagefright/codecs/aacdec/get_ele_list.h
new file mode 100644
index 0000000..82f140b
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/get_ele_list.h
@@ -0,0 +1,90 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Pathname: ./include/get_ele_list.h
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+ Who:                       Date:
+ Description:
+
+------------------------------------------------------------------------------
+ INCLUDE DESCRIPTION
+
+ Header file for get_ele_list.c
+
+------------------------------------------------------------------------------
+*/
+
+/*----------------------------------------------------------------------------
+; CONTINUE ONLY IF NOT ALREADY DEFINED
+----------------------------------------------------------------------------*/
+#ifndef GET_ELE_LIST_H
+#define GET_ELE_LIST_H
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+#include "pv_audio_type_defs.h"
+#include "s_elelist.h"
+#include "s_bits.h"
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here.
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL VARIABLES REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; SIMPLE TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; ENUMERATED TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; STRUCTURES TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; GLOBAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+void get_ele_list(
+    EleList     *pElementList,
+    BITS        *pInputStream,
+    const Bool   enableCPE);
+
+/*----------------------------------------------------------------------------
+; END
+----------------------------------------------------------------------------*/
+#endif
+
+
diff --git a/media/libstagefright/codecs/aacdec/get_ga_specific_config.cpp b/media/libstagefright/codecs/aacdec/get_ga_specific_config.cpp
new file mode 100644
index 0000000..65c00ea
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/get_ga_specific_config.cpp
@@ -0,0 +1,473 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Pathname: get_GA_specific_config.c
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+ Description: Modified per review comments
+
+ Description: Change getbits.h to ibstream.h
+
+ Description: (1) use enum type for audioObjectType (2) update revision history
+
+ Description: Updated the SW template to include the full pathname to the
+ source file and a slightly modified copyright header.
+
+ Description: Updated to use scratch memory for the temporary prog config.
+
+ Description: Replace some instances of getbits to get1bits
+              when only 1 bit is read.
+
+ Who:                               Date:
+ Description:
+
+------------------------------------------------------------------------------
+ INPUT AND OUTPUT DEFINITIONS
+
+ Inputs:
+        pVars   = pointer to the structure that holds all information for
+                  this instance of the library. pVars->prog_config
+                  pVars->mc_info, pVars->pWinSeqInfo, pVars->SFBWidth128
+                  are needed for calling set_mc_info.
+                  Data type pointer to tDec_Int_File
+
+        channel_config = variable that indicates the channel configuration
+                         information, in this decoder library, only values
+                         0, 1, and 2 are allowed.
+                         Data type UInt
+
+        audioObjectType = variable that indicates the Audio Object Type.
+                          Data type UInt.
+
+        pInputStream = pointer to a BITS structure that holds information
+                       regarding the input stream.
+
+ Local Stores/Buffers/Pointers Needed:
+    None
+
+ Global Stores/Buffers/Pointers Needed:
+    None
+
+ Outputs:
+    status = 0 if success
+             1 otherwise
+
+ Pointers and Buffers Modified:
+    pVars->mc_info contents are updated with channel information.
+    if infoinit is called within set_mc_info, then
+    pVars->pWinSeqInfo contents are updated with window information.
+    pVars->SFBWidth128 contents are updated with scale factor band width data.
+
+ Local Stores Modified:
+    None
+
+ Global Stores Modified:
+    None
+
+------------------------------------------------------------------------------
+ FUNCTION DESCRIPTION
+
+ This function takes the sampling_rate_idx, channel_config, and
+ audioObjectType from AudioSpecificConfig() and set the decoder configuration
+ necessary for the decoder to decode properly.
+ It also reads the bitstream for frame length, scalable bitstream information
+ and extension information to General Audio defined in MPEG-4 phase 1
+
+------------------------------------------------------------------------------
+ REQUIREMENTS
+
+  This function shall not use global variables
+
+------------------------------------------------------------------------------
+ REFERENCES
+
+ (1) ISO/IEC 14496-3: 1999(E)
+ Part 3
+ Subpart 1  p18     1.6 Interface to MPEG-4 Systems
+ Subpart 4  p13     4.4.1 GA Specific Configuration
+ Amendment  p10     6.2.1 AudioSpecificInfo
+ Amendment  p78     8.2 Decoder configuration (GASpecificConfig)
+
+ (2) AAC DecoderSpecificInfo Information
+   PacketVideo descriptions - San Diego
+
+------------------------------------------------------------------------------
+ PSEUDO-CODE
+
+    frameLenFlag = CALL getbits(
+                            neededBits = LEN_FRAME_LEN_FLAG,
+                            pInputStream = pInputStream);
+                        MODIFYING (pInputStream)
+                        RETURNING (frameLenFlag)
+
+    dependsOnCoreCoder = CALL getbits(
+                               neededBits = LEN_DEPEND_ON_CORE,
+                               pInputStream = pInputStream);
+                        MODIFYING (pInputStream)
+                        RETURNING (dependsOnCoreCoder)
+
+    IF (dependsOnCoreCoder != FALSE)
+    THEN
+        coreCoderDelay = CALL getbits(
+                                neededBits = LEN_CORE_DELAY,
+                                pInputStream = pInputStream);
+                            MODIFYING (pInputStream)
+                            RETURNING (coreCoderDelay)
+    ENDIF
+
+    extFlag = CALL getbits(
+                      neededBits = LEN_EXT_FLAG,
+                      pInputStream = pInputStream);
+                   MODIFYING (pInputStream)
+                   RETURNING (extFlag)
+
+    IF (channel_config == 0)
+    THEN
+        status = CALL get_prog_config(
+                        pVars = pVars,
+                        pScratchPCE = &pVars->scratch_prog_config);
+                   MODIFYING (pVars, pScratchPCE)
+                   RETURNING (status)
+
+    ELSE
+        channel_config--;
+        pVars->prog_config.front.ele_is_cpe[0] = channel_config;
+        pVars->prog_config.front.ele_tag[0] = 0;
+
+        status = CALL set_mc_info(
+                        pMC_Info =  &(pVars->mc_info),
+                        audioObjectType = audioObjectType,
+                        sampling_rate_idx = pVars->prog_config.sampling_rate_idx,
+                        tag = pVars->prog_config.front.ele_tag[0],
+                        is_cpe = pVars->prog_config.front.ele_is_cpe[0],
+                        pWinSeqInfo = pVars->pWinSeqInfo,
+                        sfbwidth128 = pVars->SFBWidth128);
+                    MODIFYING (pMC_Info, pWinSeqInfo, sfbwidth128)
+                    RETURNING (SUCCESS)
+    ENDIF
+
+    IF ((audioObjectType == MP4AUDIO_AAC_SCALABLE) OR
+        (audioObjectType == MP4AUDIO_ER_AAC_SCALABLE))
+    THEN
+        layer_num = CALL getbits(
+                            neededBits = LEN_LAYER_NUM,
+                            pInputStream = pInputStream);
+                        MODIFYING (pInputStream)
+                        RETURNING (layer_num)
+
+        status = 1;
+    ENDIF
+
+    IF (extFlag != FALSE)
+    THEN
+         IF (audioObjectType == MP4AUDIO_ER_BSAC)
+         THEN
+              numOfSubFrame = CALL getbits(
+                                     neededBits = LEN_SUB_FRAME,
+                                     pInputStream = pInputStream);
+                                MODIFYING (pInputStream)
+                                RETURNING (numOfSubFrame)
+
+              layer_len = CALL getbits(
+                                neededBits = LEN_LAYER_LEN,
+                                pInputStream = pInputStream);
+                               MODIFYING (pInputStream)
+                               RETURNING (layer_len)
+
+         ENDIF
+
+         IF (((audioObjectType > 16) AND (audioObjectType < 22)) OR
+             (audioObjectType == 23))
+         THEN
+             aacSectionDataResilienceFlag =
+                            CALL getbits(
+                                    neededBits = LEN_SECT_RES_FLAG,
+                                    pInputStream = pInputStream);
+                                MODIFYING (pInputStream)
+                                RETURNING (aacSectionDataResilienceFlag)
+
+             aacScalefactorDataResilienceFlag =
+                            CALL getbits(
+                                    neededBits = LEN_SFB_RES_FLAG,
+                                    pInputStream = pInputStream);
+                                MODIFYING (pInputStream)
+                                RETURNING (aacScalefactorDataResilienceFlag)
+
+             aacSpectralDataResilienceFlag =
+                            CALL getbits(
+                                    neededBits = LEN_SPEC_RES_FLAG,
+                                    pInputStream = pInputStream);
+                                MODIFYING (pInputStream)
+                                RETURNING (aacSpectralDataResilienceFlag)
+         ENDIF
+
+        status = 1;
+
+    ENDIF
+
+    RETURN status;
+
+------------------------------------------------------------------------------
+ RESOURCES USED
+   When the code is written for a specific target processor the
+     the resources used should be documented below.
+
+ STACK USAGE: [stack count for this module] + [variable to represent
+          stack usage for each subroutine called]
+
+     where: [stack usage variable] = stack usage for [subroutine
+         name] (see [filename].ext)
+
+ DATA MEMORY USED: x words
+
+ PROGRAM MEMORY USED: x words
+
+ CLOCK CYCLES: [cycle count equation for this module] + [variable
+           used to represent cycle count for each subroutine
+           called]
+
+     where: [cycle count variable] = cycle count for [subroutine
+        name] (see [filename].ext)
+
+------------------------------------------------------------------------------
+*/
+
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+#include    "pv_audio_type_defs.h"
+#include    "e_mp4ff_const.h"
+#include    "e_tmp4audioobjecttype.h"
+#include    "s_tdec_int_file.h"
+#include    "get_ga_specific_config.h"
+#include    "set_mc_info.h"
+#include    "get_prog_config.h"
+#include    "ibstream.h"
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here. Include conditional
+; compile variables also.
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; LOCAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; LOCAL STORE/BUFFER/POINTER DEFINITIONS
+; Variable declaration - defined here and used outside this module
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL FUNCTION REFERENCES
+; Declare functions defined elsewhere and referenced in this module
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL GLOBAL STORE/BUFFER/POINTER REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; FUNCTION CODE
+----------------------------------------------------------------------------*/
+Int get_GA_specific_config(
+    tDec_Int_File * const pVars,
+    BITS    *pInputStream,
+    UInt     channel_config,
+    const tMP4AudioObjectType audioObjectType
+)
+{
+
+    Int status = SUCCESS;
+    UInt dependsOnCoreCoder;
+    /* Int coreCoderDelay; */
+    UInt extFlag;
+
+    /* These variables are left for future implementation */
+    /* UInt layer_num; */
+    /* UInt numOfSubFrame; */
+    /* UInt layer_len; */
+    /* UInt aacSectionDataResilienceFlag; */
+    /* UInt aacScalefactorDataResilienceFlag; */
+    /* UInt aacSpectralDataResilienceFlag; */
+    Int  extFlag3;
+
+    /*
+     * frame length flag == 0, 1024 samples/frame
+     * frame length flag == 1,  960 samples/frame
+     */
+    get1bits(/*            LEN_FRAME_LEN_FLAG,*/
+        pInputStream);
+
+    /*
+     * dependsOnCoreCoder == 1, core coder has different sampling rate
+     * in a scalable bitstream
+     */
+    dependsOnCoreCoder =
+        get1bits(/*            LEN_DEPEND_ON_CORE,*/
+            pInputStream);
+
+    if (dependsOnCoreCoder != FALSE)
+    {
+        /*coreCoderDelay =
+         *    getbits(
+         *        LEN_CORE_DELAY,
+         *        pInputStream);
+         */
+
+        status = 1; /* do not support scalable coding in this release */
+    }
+
+    /*
+     * extension flag indicates if Amendment 1 objects are used or not
+     * extension flag == 0 objects = 1, 2, 3, 4, 6, 7
+     * extension flag == 1 objects = 17, 19, 20, 21, 22, 23
+     */
+    extFlag = get1bits(pInputStream);       /*  LEN_EXT_FLAG,*/
+
+
+    /* Force checks for implicit channel configuration */
+    pVars->mc_info.implicit_channeling = 1;
+
+    if (status == SUCCESS)
+    {
+
+        if (channel_config == 0)
+        {
+            status = get_prog_config(pVars,
+                                     &pVars->scratch.scratch_prog_config);
+
+            if (status != SUCCESS)
+            {
+                pVars->prog_config.front.ele_is_cpe[0] = 0; /* default to mono  */
+                pVars->mc_info.nch = 1;
+                pVars->prog_config.front.ele_tag[0] = 0;
+
+                status = SUCCESS;
+            }
+        }
+        else
+        {
+            /*
+             * dummy tag = 0 and
+             * set up decoding configurations
+             */
+            channel_config--;
+            pVars->prog_config.front.ele_is_cpe[0] = channel_config;
+            pVars->prog_config.front.ele_tag[0] = 0;
+
+            status =
+                set_mc_info(
+                    &(pVars->mc_info),
+                    audioObjectType, /* previously profile */
+                    pVars->prog_config.sampling_rate_idx,
+                    pVars->prog_config.front.ele_tag[0],
+                    pVars->prog_config.front.ele_is_cpe[0],
+                    pVars->winmap, /*pVars->pWinSeqInfo,*/
+                    pVars->SFBWidth128);
+
+        } /* if (channel_config) */
+
+    } /* if(status) */
+
+    /*
+     * This layer_num is not found in ISO/IEC specs,
+     * but it is defined in San Diego spec for scalable bitstream
+     */
+    if ((audioObjectType == MP4AUDIO_AAC_SCALABLE) ||
+            (audioObjectType == MP4AUDIO_ER_AAC_SCALABLE))
+    {
+        /*layer_num =
+         *    getbits(
+         *        LEN_LAYER_NUM,
+         *        pInputStream);
+         */
+
+        status = 1; /* for this release only */
+    }
+
+    if (extFlag)
+    {
+        /*
+         * currently do not implement these functionalities
+         * defined in Amendment 1
+         * keep it here for future release
+         */
+        if (audioObjectType == MP4AUDIO_ER_BSAC)
+        {
+            status = 1;     /* NOT SUPPORTED */
+            /*
+            numOfSubFrame = getbits( LEN_SUB_FRAME, pInputStream);
+
+            layer_len = getbits( LEN_LAYER_LEN, pInputStream);
+            */
+        }
+
+        /*
+         * The following code is equivalent to
+         * if ((audioObjectType == 17) || (audioObjectType == 18) ||
+         *     (audioObjectType == 19) || (audioObjectType == 20) ||
+         *     (audioObjectType == 21) || (audioObjectType == 23))
+         */
+
+        if (((audioObjectType > 16) && (audioObjectType < 22)) ||
+                (audioObjectType == 23))
+        {
+            status = 1;     /* NOT SUPPORTED */
+            /*
+            aacSectionDataResilienceFlag = getbits( LEN_SECT_RES_FLAG,
+                                                    pInputStream);
+
+            aacScalefactorDataResilienceFlag = getbits( LEN_SCF_RES_FLAG,
+                                                        pInputStream);
+
+            aacSpectralDataResilienceFlag = getbits( LEN_SPEC_RES_FLAG,
+                                                     pInputStream);
+            */
+        }
+        /*
+         * this flag is tbd in version 3 of ISO/IEC spec
+         * if the encoder generates this bit, then it has to be read
+         * current adif2mp4ff does not write this bit. If this bit is to
+         * be read, it can be done by the following code:
+         */
+
+        extFlag3 = get1bits(pInputStream);       /*  LEN_EXT_FLAG3 */
+
+        if (extFlag3)
+        {
+            status = 1;     /* NOT SUPPORTED */
+        }
+
+    }
+
+    return status;
+}
diff --git a/media/libstagefright/codecs/aacdec/get_ga_specific_config.h b/media/libstagefright/codecs/aacdec/get_ga_specific_config.h
new file mode 100644
index 0000000..7c77da5
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/get_ga_specific_config.h
@@ -0,0 +1,94 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Pathname: get_GA_specific_config.h
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+ Description: (1) use enum type for audioObjectType
+              (2) update revision history
+
+ Who:                       Date:
+ Description:
+------------------------------------------------------------------------------
+ INCLUDE DESCRIPTION
+
+ This file includes the function declaration for get_GA_specific_config.c
+
+------------------------------------------------------------------------------
+*/
+
+/*----------------------------------------------------------------------------
+; CONTINUE ONLY IF NOT ALREADY DEFINED
+----------------------------------------------------------------------------*/
+#ifndef GET_GA_SPECIFIC_CONFIG_H
+#define GET_GA_SPECIFIC_CONFIG_H
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+#include    "pv_audio_type_defs.h"
+#include    "s_tdec_int_file.h"
+#include    "s_bits.h"
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here.
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL VARIABLES REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; SIMPLE TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; ENUMERATED TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; STRUCTURES TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; GLOBAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+Int get_GA_specific_config(
+    tDec_Int_File * const pVars,
+    BITS    *pInputStream,
+    UInt     channel_config,
+    const tMP4AudioObjectType audioObjectType
+);
+
+/*----------------------------------------------------------------------------
+; END
+----------------------------------------------------------------------------*/
+#endif
+
+
diff --git a/media/libstagefright/codecs/aacdec/get_ics_info.cpp b/media/libstagefright/codecs/aacdec/get_ics_info.cpp
new file mode 100644
index 0000000..17204cc
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/get_ics_info.cpp
@@ -0,0 +1,608 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Pathname: ./src/get_ics_info.c
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+ Description:  Modified from original shareware code
+
+ Description:  Modified to pass variables by reference to eliminate use
+               of global variables.
+
+ Description:  Clean up code.
+
+ Description:  Fix comments before review, remove lpflag[]
+
+ Description:  Update per review comments, and match ISO/IEC 14496-3
+
+ Description:  Update per peer review comments.
+
+ Description:  Remove "rollback" of used bits, since lt_decode is to change.
+
+ Description: Replace some instances of getbits to get9_n_lessbits
+              when the number of bits read is 9 or less and get1bits
+              when only 1 bit is read.
+
+ Who:                                   Date:
+ Description:
+
+------------------------------------------------------------------------------
+ INPUT AND OUTPUT DEFINITIONS
+
+ Inputs:
+    audioObjectType = MP4 Audio Object Type for the current song. Only if
+                    this is set to LTP (MP4AUDIO_LTP) will long term
+                    prediction bits be retrieved. Data type
+                    tMP4AudioObjectType, which is an enumeration, which in
+                    turn is an Int.
+
+    pInputStream  = pointer to a BITS structure, used by the function getbits
+                    to provide data. This is the second parameter to this
+                    function to match its position in getbits().
+                    Data type pointer to BITS structure
+
+    common_window = field read in huffdecode, which tells whether information
+                    is shared between the left and right channel. Long term
+                    prediction (LTP) data is NOT shared even if its a common
+                    window, so this flag is needed to see if another set of
+                    LTP possibly needs to be read. If this flag is false,
+                    pSecondLTPStatus is not touched, it could be NULL if
+                    need be. Data type Bool, which is Int.
+
+    pWindowSequence = pointer to where the the window type of the current
+                    frame and channel should be placed, of data type
+                    WINDOW_SEQUENCE, which is Int. It can take on one
+                    of four values: ONLY_LONG_SEQUENCE, LONG_START_SEQUENCE,
+                    EIGHT_SHORT_SEQUENCE, LONG_STOP_SEQUENCE,
+
+    pWindowShape =  pointer to where the window shape for the current frame
+                    and channel should be placed, of data type WINDOW_SHAPE,
+                    which is Int. It can take on the one of these two values:
+                    SINE_WINDOW, KAISER_BESSEL_WINDOW. It is used in the
+                    "filterbank" section of decoding.
+
+    group         = array that holds the index of the first window in each
+                    group. Data type array of Int, eight elements.
+
+    p_max_sfb     = pointer to where the maximum number of scale factor bands
+                    for the current frame and channel will be placed. Data
+                    type of pointer to Int.
+
+    p_winmap      = array of pointers to all of the possible four window
+                    configurations. This parameter did not need to be pointers,
+                    and could be changed in the future. Data type array of pointers
+                    to FrameInfo structures, length 4.
+
+    pFirstLTPStatus = pointer to a structure where the first LTP
+                    information will be stored. It would be confusing and wrong
+                    to call this left LTP status since if common_window = FALSE,
+                    this function will be called twice - once for the left, once
+                    for the right. It could be done, but extra conditional code
+                    would need to be done.
+                    Data type pointer to LT_PRED_STATUS structure.
+
+    pSecondLTPStatus = pointer to where the right channel of LTP
+                    information will be stored only if common_window is non-zero.
+                    Data type pointer to LT_PRED_STATUS structure.
+
+ Local Stores/Buffers/Pointers Needed: None.
+
+ Global Stores/Buffers/Pointers Needed: None.
+
+ Outputs:
+    status  = 0 implies no error occurred, non-zero otherwise.
+
+ Pointers and Buffers Modified:
+    pInputStream contents are modified in such a way that the number of bits
+        read increases.
+    pWindowSequence contents are updated with the current window for this
+        frame and channel
+    group[] contents will be modified to grouping information. See getgroup
+        source code for a better description of what this is.
+    p_max_sfb contents will be updated with the maximum scale factor bands
+        for this frame and channel.
+    pFirstLTPStatus contents may be updated if the stream has long term
+        prediction information.
+    pSecondLTPStatus contents may be updated if common_window != 0 and LTP data
+        is present.
+
+
+ Local Stores Modified: None
+
+ Global Stores Modified: None
+
+------------------------------------------------------------------------------
+ FUNCTION DESCRIPTION
+
+ This function retrieves the individual channel stream (ICS) information
+ from the bitstream. The information read for the current
+ frame and channel is:
+ - window sequence
+ - window shape for use in the filter bank
+ - number of scale factor bands
+ - long term predication (LTP) information
+ - grouping information
+
+ This function does NOT support MPEG2 style AAC Frequency Domain Predictor,
+ not to be confused with LTP (Long Term Prediction). If such data is found
+ to be on the file an error is generated.
+
+------------------------------------------------------------------------------
+ REQUIREMENTS
+
+ This function is not to use static or global data.
+
+------------------------------------------------------------------------------
+ REFERENCES
+
+  (1) ISO/IEC 14496-3:1999(E) Titled "Information technology - Coding
+      of audio-visual objects Part 3: Audio Subpart 4:"
+      Table 4.4.6 - Syntax of ics_info(), page 16.
+
+
+ (2) MPEG-2 NBC Audio Decoder
+   "This software module was originally developed by AT&T, Dolby
+   Laboratories, Fraunhofer Gesellschaft IIS in the course of development
+   of the MPEG-2 NBC/MPEG-4 Audio standard ISO/IEC 13818-7, 14496-1,2 and
+   3. This software module is an implementation of a part of one or more
+   MPEG-2 NBC/MPEG-4 Audio tools as specified by the MPEG-2 NBC/MPEG-4
+   Audio standard. ISO/IEC  gives users of the MPEG-2 NBC/MPEG-4 Audio
+   standards free license to this software module or modifications thereof
+   for use in hardware or software products claiming conformance to the
+   MPEG-2 NBC/MPEG-4 Audio  standards. Those intending to use this software
+   module in hardware or software products are advised that this use may
+   infringe existing patents. The original developer of this software
+   module and his/her company, the subsequent editors and their companies,
+   and ISO/IEC have no liability for use of this software module or
+   modifications thereof in an implementation. Copyright is not released
+   for non MPEG-2 NBC/MPEG-4 Audio conforming products.The original
+   developer retains full right to use the code for his/her own purpose,
+   assign or donate the code to a third party and to inhibit third party
+   from using the code for non MPEG-2 NBC/MPEG-4 Audio conforming products.
+   This copyright notice must be included in all copies or derivative
+   works."
+   Copyright(c)1996.
+
+------------------------------------------------------------------------------
+ PSEUDO-CODE
+
+    status = 0;
+    first_ltp_data_present = FALSE;
+    second_ltp_data_present = FALSE;
+
+
+    CALL getbits(
+        neededBits = LEN_ICS_RESERV + LEN_WIN_SEQ + LEN_WIN_SH,
+        pInputStream = pInputStream)
+    MODIFYING( pInputStream )
+    RETURNING( temp = returnValue )
+
+    windowSequence = (temp >> LEN_WIN_SH) & ((0x1<<LEN_WIN_SEQ)-1);
+
+    *pWindowShape = (temp) & ((0x1<<LEN_WIN_SH)-1);
+
+    IF (windowSequence == EIGHT_SHORT_SEQUENCE)
+    THEN
+        CALL getbits(
+            neededBits = LEN_MAX_SFBS,
+            pInputStream = pInputStream)
+        MODIFYING(pInputStream)
+        RETURNING(local_max_sfb = returnValue)
+
+        CALL getgroup(
+            group = group,
+            pInputStream = pInputStream)
+        MODIFYING(group)
+        MODIFYING(pInputStream)
+        RETURNING(nothing)
+
+
+    ELSE
+
+        group[0] = 1;
+
+        CALL getbits(
+            neededBits = LEN_MAX_SFBL + LEN_PREDICTOR_DATA_PRESENT,
+            pInputStream = pInputStream)
+        MODIFYING(pInputStream)
+        RETURNING(temp = returnValue)
+
+        predictor_data_present =
+            (Bool) getbits(
+                LEN_BOOLEAN,
+                pInputStream);
+
+        local_max_sfb = (Int)(temp >> LEN_PREDICTOR_DATA_PRESENT);
+
+        predictor_data_present =
+            (Bool) (temp & ((0x1 << LEN_PREDICTOR_DATA_PRESENT)-1));
+
+        IF (local_max_sfb > allowed_max_sfb)
+        THEN
+            status = 1
+        ELSEIF (audioObjectType == MP4AUDIO_LTP)
+        THEN
+            IF (predictor_data_present != FALSE)
+            THEN
+                CALL getbits(
+                    neededBits = LEN_LTP_DATA_PRESENT,
+                    pInputStream = pInputStream)
+                MODIFYING(pInputStream)
+                RETURNING(first_ltp_data_present = returnValue)
+
+                IF (ltp_data_present != FALSE)
+                THEN
+
+                    CALL lt_decode(
+                        win_type = windowSequence,
+                        pInputStream  = pInputStream,
+                        max_sfb = local_max_sfb,
+                        pLt_pred = pFirstLTPStatus)
+                    MODIFYING(pInputStream)
+                    MODIFYING(pFirstLTPStatus)
+                    RETURNING(nothing)
+
+                ENDIF
+
+                IF (common_window != FALSE)
+                THEN
+                    CALL getbits(
+                        neededBits = LEN_LTP_DATA_PRESENT,
+                        pInputStream = pInputStream)
+                    MODIFYING(pInputStream)
+                    RETURNING(second_ltp_data_present = returnValue)
+
+                    IF (second_ltp_data_present != FALSE)
+                    THEN
+
+                        CALL lt_decode(
+                            win_type = windowSequence,
+                            pInputStream  = pInputStream,
+                            max_sfb = local_max_sfb,
+                            pLt_pred = pSecondLTPStatus)
+                        MODIFYING(pInputStream)
+                        MODIFYING(pSecondLTPStatus)
+                        RETURNING(nothing)
+                    ENDIF
+                ENDIF
+            ENDIF
+        ELSE
+            IF  (predictor_data_present != FALSE)
+            THEN
+                status = 1
+            ENDIF
+        END IF
+    ENDIF
+
+    pFirstLTPStatus->ltp_data_present = first_ltp_data_present;
+
+    IF (common_window != FALSE)
+    THEN
+        pSecondLTPStatus->ltp_data_present = second_ltp_data_present;
+    ENDIF
+
+    pFrameInfo = p_winmap[*p_wnd];
+    IF (local_max_sfb > pFrameInfo->sfb_per_frame)
+    THEN
+        status = 1;
+    ENDIF
+
+    *(p_max_sfb) = local_max_sfb;
+
+    MODIFY(*(pWindowSequence))
+    MODIFY(*(pWinShape))
+    MODIFY(*(p_max_sfb))
+    MODIFY(group[])
+    MODIFY(*pInputStream)
+    MODIFY(*pFirstLTPStatus)
+    MODIFY(*pSecondLTPStatus)
+    RETURN (status);
+
+
+
+------------------------------------------------------------------------------
+ RESOURCES USED
+   When the code is written for a specific target processor the
+     the resources used should be documented below.
+
+ STACK USAGE: [stack count for this module] + [variable to represent
+          stack usage for each subroutine called]
+
+     where: [stack usage variable] = stack usage for [subroutine
+         name] (see [filename].ext)
+
+ DATA MEMORY USED: x words
+
+ PROGRAM MEMORY USED: x words
+
+ CLOCK CYCLES: [cycle count equation for this module] + [variable
+           used to represent cycle count for each subroutine
+           called]
+
+     where: [cycle count variable] = cycle count for [subroutine
+        name] (see [filename].ext)
+
+------------------------------------------------------------------------------
+*/
+
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+#include "pv_audio_type_defs.h"
+
+#include "e_rawbitstreamconst.h"
+#include "e_tmp4audioobjecttype.h"
+
+#include "s_bits.h"
+#include "s_frameinfo.h"
+#include "s_lt_pred_status.h"
+
+#include "ibstream.h"
+#include "lt_decode.h"
+#include "ltp_common_internal.h" /* For LEN_LTP_DATA_PRESENT constant */
+
+#include "get_ics_info.h"
+#include "huffman.h"        /* For the declaration of getgroup */
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here. Include conditional
+; compile variables also.
+----------------------------------------------------------------------------*/
+
+#define LEN_PREDICTOR_DATA_PRESENT (1)
+
+/*----------------------------------------------------------------------------
+; LOCAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; LOCAL VARIABLE DEFINITIONS
+; Variable declaration - defined here and used outside this module
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL FUNCTION REFERENCES
+; Declare functions defined elsewhere and referenced in this module
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL VARIABLES REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; FUNCTION CODE
+----------------------------------------------------------------------------*/
+
+Int get_ics_info(
+    const tMP4AudioObjectType  audioObjectType,
+    BITS                      *pInputStream,
+    const Bool                 common_window,
+    WINDOW_SEQUENCE           *pWindowSequence,
+    WINDOW_SHAPE              *pWindowShape,
+    Int                        group[],
+    Int                       *p_max_sfb,
+    FrameInfo                 *p_winmap[],
+    LT_PRED_STATUS            *pFirstLTPStatus,
+    LT_PRED_STATUS            *pSecondLTPStatus)
+{
+    WINDOW_SEQUENCE       windowSequence;
+    UInt                  temp;
+    Bool                  predictor_data_present;
+    UInt                   local_max_sfb;
+    UInt                   allowed_max_sfb;
+    Int                   status = SUCCESS;
+    Bool                  first_ltp_data_present = FALSE;
+    Bool                  second_ltp_data_present = FALSE;
+
+    /*
+     * The following three calls to getbits have been replaced with one
+     * call for speed:
+     *
+     *                  getbits(LEN_ICS_RESERV, pInputStream);
+     * windowSequence = getbits(LEN_WIN_SEQ, pInputStream);
+     * *pWindowShape  = getbits(LEN_WIN_SH, pInputStream);
+     *
+     */
+
+    temp =
+        get9_n_lessbits(
+            LEN_ICS_RESERV + LEN_WIN_SEQ + LEN_WIN_SH,
+            pInputStream);
+
+
+    windowSequence = (WINDOW_SEQUENCE)((temp >> LEN_WIN_SH) & ((0x1 << LEN_WIN_SEQ) - 1));
+
+    *pWindowShape = (WINDOW_SHAPE)((temp) & ((0x1 << LEN_WIN_SH) - 1));
+
+    /*
+     * This pointer should not be NULL as long as the initialization code
+     * has been run, so the test for NULL has been removed.
+     */
+    allowed_max_sfb = p_winmap[windowSequence]->sfb_per_win[0];
+
+    if (windowSequence == EIGHT_SHORT_SEQUENCE)
+    {
+        local_max_sfb =  get9_n_lessbits(LEN_MAX_SFBS,
+                                         pInputStream);
+
+        getgroup(
+            group,
+            pInputStream);
+
+        if (local_max_sfb > allowed_max_sfb)
+        {
+            status = 1;  /* ERROR CODE - needs to be updated */
+        }
+
+    } /* end of TRUE of if (windowSequence == EIGHT_SHORT_SEQUENCE) */
+    else
+    {
+        /* There is only one group for long windows. */
+        group[0] = 1;
+
+        /*
+         * The window is long, get the maximum scale factor bands,
+         * and get long term prediction info.
+         *
+         * Reference [1] states that the audioObjectType is first tested,
+         * then the predictor_data_present is read on either branch of the
+         * if (audioObjectType == MP4AUDIO_LTP). Instead, this code combines
+         * the two calls on both branches into one before the
+         * if, and then in turn combines with another call to getbits, all
+         * in the name of speed.
+         *
+         * This would be the individual calls, without checking the number
+         * of scale factor bands:
+         *
+         *   local_max_sfb =
+         *      (Int) getbits(
+         *          LEN_MAX_SFBL,
+         *           pInputStream);
+         *
+         *  if (audioObjectType == MP4AUDIO_LTP)
+         *  {
+         *        predictor_data_present =
+         *           (Bool) getbits(
+         *              LEN_PREDICTOR_DATA_PRESENT,
+         *              pInputStream);
+         *
+         *     .....   (read LTP data)
+         *
+         *    }
+         *    else
+         *    {
+         *
+         *        predictor_data_present =
+         *           (Bool) getbits(
+         *              LEN_PREDICTOR_DATA_PRESENT,
+         *              pInputStream);
+         *
+         *     .....   (its an error for this library)
+         *     }
+         */
+        temp =
+            get9_n_lessbits(
+                LEN_MAX_SFBL + LEN_PREDICTOR_DATA_PRESENT,
+                pInputStream);
+
+        local_max_sfb = (Int)(temp >> LEN_PREDICTOR_DATA_PRESENT);
+
+        predictor_data_present =
+            (Bool)(temp & ((0x1 << LEN_PREDICTOR_DATA_PRESENT) - 1));
+
+        if (local_max_sfb > allowed_max_sfb)
+        {
+            status = 1;  /* ERROR CODE - needs to be updated */
+        }
+        else if (audioObjectType == MP4AUDIO_LTP)
+        {
+            /*
+             * Note that the predictor data bit has already been
+             * read.
+             */
+
+            /*
+             * If the object type is LTP, the predictor data is
+             * LTP. If the object type is not LTP, the predictor data
+             * is so called "frequency predictor data", which is not
+             * supported by this implementation. Refer to (1)
+             */
+            if (predictor_data_present != FALSE)
+            {
+                first_ltp_data_present =
+                    (Bool) get1bits(/*                        LEN_LTP_DATA_PRESENT,*/
+                        pInputStream);
+
+                if (first_ltp_data_present != FALSE)
+                {
+                    lt_decode(
+                        windowSequence,
+                        pInputStream,
+                        local_max_sfb,
+                        pFirstLTPStatus);
+                }
+                if (common_window != FALSE)
+                {
+                    second_ltp_data_present =
+                        (Bool) get1bits(/*                            LEN_LTP_DATA_PRESENT,*/
+                            pInputStream);
+
+                    if (second_ltp_data_present != FALSE)
+                    {
+                        lt_decode(
+                            windowSequence,
+                            pInputStream,
+                            local_max_sfb,
+                            pSecondLTPStatus);
+                    }
+                } /* if (common_window != FALSE) */
+
+            } /* if (predictor_data_present != FALSE) */
+
+        } /* else if (audioObjectType == MP4AUDIO_LTP) */
+        else
+        {
+            /*
+             * Note that the predictor data bit has already been
+             * read.
+             */
+
+            /*
+             * The object type is not LTP. If there is data, its
+             * frequency predictor data, not supported by this
+             * implementation.
+             */
+            if (predictor_data_present != FALSE)
+            {
+                status = 1; /* ERROR CODE UPDATE LATER */
+            } /* if (predictor_data_present != FALSE) */
+
+        } /* end of "else" clause of if (audioObjectType == MP4AUDIO_LTP) */
+
+    } /*  if (windowSequence == EIGHT_SHORT_SEQUENCE) [FALSE branch] */
+
+
+    /*
+     * Save all local copies.
+     */
+    pFirstLTPStatus->ltp_data_present = first_ltp_data_present;
+    if (common_window != FALSE)
+    {
+        pSecondLTPStatus->ltp_data_present = second_ltp_data_present;
+    }
+
+    *p_max_sfb = local_max_sfb;
+
+    *pWindowSequence = windowSequence;
+
+    return (status);
+
+}  /* get_ics_info */
+
diff --git a/media/libstagefright/codecs/aacdec/get_ics_info.h b/media/libstagefright/codecs/aacdec/get_ics_info.h
new file mode 100644
index 0000000..b94ef8e
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/get_ics_info.h
@@ -0,0 +1,111 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Pathname: ./include/get_ics_info.h
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+ Who:                       Date:
+ Description:
+
+------------------------------------------------------------------------------
+ INCLUDE DESCRIPTION
+
+ Contains the declaration for the function get_ics_info()
+
+------------------------------------------------------------------------------
+*/
+
+/*----------------------------------------------------------------------------
+; CONTINUE ONLY IF NOT ALREADY DEFINED
+----------------------------------------------------------------------------*/
+#ifndef GET_ICS_INFO_H
+#define GET_ICS_INFO_H
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+    /*----------------------------------------------------------------------------
+    ; INCLUDES
+    ----------------------------------------------------------------------------*/
+#include "pv_audio_type_defs.h"
+#include "e_tmp4audioobjecttype.h"
+#include "s_bits.h"
+#include "e_window_sequence.h"
+#include "e_window_shape.h"
+#include "s_frameinfo.h"
+#include "s_lt_pred_status.h"
+
+    /*----------------------------------------------------------------------------
+    ; MACROS
+    ; Define module specific macros here
+    ----------------------------------------------------------------------------*/
+
+    /*----------------------------------------------------------------------------
+    ; DEFINES
+    ; Include all pre-processor statements here.
+    ----------------------------------------------------------------------------*/
+
+    /*----------------------------------------------------------------------------
+    ; EXTERNAL VARIABLES REFERENCES
+    ; Declare variables used in this module but defined elsewhere
+    ----------------------------------------------------------------------------*/
+
+    /*----------------------------------------------------------------------------
+    ; SIMPLE TYPEDEF'S
+    ----------------------------------------------------------------------------*/
+
+    /*----------------------------------------------------------------------------
+    ; ENUMERATED TYPEDEF'S
+    ----------------------------------------------------------------------------*/
+
+    /*----------------------------------------------------------------------------
+    ; STRUCTURES TYPEDEF'S
+    ----------------------------------------------------------------------------*/
+
+    /*----------------------------------------------------------------------------
+    ; GLOBAL FUNCTION DEFINITIONS
+    ; Function Prototype declaration
+    ----------------------------------------------------------------------------*/
+    Int get_ics_info(
+        const tMP4AudioObjectType  audioObjectType,
+        BITS                      *pInputStream,
+        const Bool                 common_window,
+        WINDOW_SEQUENCE           *p_wnd,
+        WINDOW_SHAPE              *pWindowShape,
+        Int                        group[],
+        Int                       *p_max_sfb,
+        FrameInfo                 *p_winmap[],
+        LT_PRED_STATUS            *pFirstLTPStatus,
+        LT_PRED_STATUS            *pSecondLTPStatus);
+
+
+#ifdef __cplusplus
+}
+#endif
+
+/*----------------------------------------------------------------------------
+; END
+----------------------------------------------------------------------------*/
+#endif /* GET_ICS_INFO_H */
+
+
diff --git a/media/libstagefright/codecs/aacdec/get_prog_config.cpp b/media/libstagefright/codecs/aacdec/get_prog_config.cpp
new file mode 100644
index 0000000..6bddd57
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/get_prog_config.cpp
@@ -0,0 +1,739 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Pathname: get_prog_config.c
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+ Description:  Modified from original shareware code
+
+ Description:  Modified to pass variables by reference to eliminate use
+               of global variables.
+
+ Description:  Move functionality from get_adif_header for when to change
+               the current program configuration, add a temporary config
+               to read into, clean up code, change function prototype.
+
+ Description:  Clean up
+
+ Description:  Update per review comments
+
+ Description:  Fix double 'could'
+
+ Description:  change enter_mc_info to set_mc_info
+
+ Description:  update comments
+
+ Description: Replace some instances of getbits to get9_n_lessbits
+              when the number of bits read is 9 or less and get1bits
+              when only 1 bit is read.
+
+ Who:                                   Date:
+ Description:
+
+------------------------------------------------------------------------------
+ INPUT AND OUTPUT DEFINITIONS
+
+ Inputs:
+    pVars      = pointer to the structure that holds all information for
+                 this instance of the library. pVars->prog_config is directly
+                 used, and pVars->mc_info, pVars->prog_config, pVars->winmap,
+                 pVars->SFBWidth128 are needed indirectly for calling
+                 set_mc_info. Data type  pointer to tDec_Int_File structure.
+
+    pScratchPCE = pointer to a temporary ProgConfig structure to be used
+                  to read in the program configuration element.
+
+ Local Stores/Buffers/Pointers Needed: None
+
+ Global Stores/Buffers/Pointers Needed: None
+
+ Outputs:
+    status     = zero if no error was found, non-zero otherwise.
+
+ Pointers and Buffers Modified:
+    pVars->prog_config contents are updated with the PCE read in.
+    pVars->mc_info contents are updated with channel information.
+    pVars->winmap contents are updated with window information.
+    pVars->SFBWidth128 contents are updated with scale factor band width data.
+
+ Local Stores Modified: None
+
+ Global Stores Modified: None
+
+------------------------------------------------------------------------------
+ FUNCTION DESCRIPTION
+
+ This function reads from the input stream to memory for a temporary
+ program configuration element (PCE). If the PCE read is the first
+ encountered it is saved. Or, if the tag of the PCE read matches the tag of
+ the first PCE encounted, it is saved as well. This is a mechanism for
+ changing the sampling rate.
+
+------------------------------------------------------------------------------
+ REQUIREMENTS
+
+ This function shall not use static or global variables.
+
+------------------------------------------------------------------------------
+ REFERENCES
+
+ (1) ISO/IEC 13818-7:1997 Titled "Information technology - Generic coding
+   of moving pictures and associated audio information - Part 7: Advanced
+   Audio Coding (AAC)", Table 6.21 - Syntax of program_config_element(),
+   page 16, and section 8.5 "Program Config Element (PCE)", page 30.
+
+ (2) MPEG-2 NBC Audio Decoder
+   "This software module was originally developed by AT&T, Dolby
+   Laboratories, Fraunhofer Gesellschaft IIS in the course of development
+   of the MPEG-2 NBC/MPEG-4 Audio standard ISO/IEC 13818-7, 14496-1,2 and
+   3. This software module is an implementation of a part of one or more
+   MPEG-2 NBC/MPEG-4 Audio tools as specified by the MPEG-2 NBC/MPEG-4
+   Audio standard. ISO/IEC gives users of the MPEG-2 NBC/MPEG-4 Audio
+   standards free license to this software module or modifications thereof
+   for use in hardware or software products claiming conformance to the
+   MPEG-2 NBC/MPEG-4 Audio  standards. Those intending to use this software
+   module in hardware or software products are advised that this use may
+   infringe existing patents. The original developer of this software
+   module and his/her company, the subsequent editors and their companies,
+   and ISO/IEC have no liability for use of this software module or
+   modifications thereof in an implementation. Copyright is not released
+   for non MPEG-2 NBC/MPEG-4 Audio conforming products.The original
+   developer retains full right to use the code for his/her own purpose,
+   assign or donate the code to a third party and to inhibit third party
+   from using the code for non MPEG-2 NBC/MPEG-4 Audio conforming products.
+   This copyright notice must be included in all copies or derivative
+   works."
+   Copyright(c)1996.
+
+
+------------------------------------------------------------------------------
+ PSEUDO-CODE
+
+    status          = SUCCESS;
+    pInputStream   = &(pVars->inputStream);
+
+
+    CALL getbits(
+        neededBits = LEN_TAG,
+        pInputStream = pInputStream )
+    MODIFYING( pInputStream )
+    RETURNING( tag = returnValue )
+
+    CALL getbits(
+        neededBits = LEN_PROFILE,
+        pInputStream = pInputStream )
+    MODIFYING( pInputStream )
+    RETURNING( pScratchPCE->profile = returnValue )
+
+    CALL getbits(
+        neededBits = LEN_PROFILE,
+        pInputStream = pInputStream )
+    MODIFYING( pInputStream )
+    RETURNING( pScratchPCE->sampling_rate_idx = returnValue )
+
+    CALL getbits(
+        neededBits = LEN_NUM_ELE,
+        pInputStream = pInputStream )
+    MODIFYING( pInputStream )
+    RETURNING( temp = returnValue )
+
+    pScratchPCE->front.num_ele = temp;
+
+    CALL getbits(
+        neededBits = LEN_NUM_ELE,
+        pInputStream = pInputStream )
+    MODIFYING( pInputStream )
+    RETURNING( temp = returnValue )
+
+    pScratchPCE->side.num_ele = temp;
+
+    CALL getbits(
+        neededBits = LEN_NUM_ELE,
+        pInputStream = pInputStream )
+    MODIFYING( pInputStream )
+    RETURNING( temp = returnValue )
+
+    pScratchPCE->back.num_ele = temp;
+
+    CALL getbits(
+        neededBits = LEN_NUM_LFE,
+        pInputStream = pInputStream )
+    MODIFYING( pInputStream )
+    RETURNING( temp = returnValue )
+
+    pScratchPCE->lfe.num_ele = temp;
+
+    CALL getbits(
+        neededBits = LEN_NUM_DAT,
+        pInputStream = pInputStream )
+    MODIFYING( pInputStream )
+    RETURNING( temp = returnValue )
+
+    pScratchPCE->data.num_ele = temp;
+
+    CALL getbits(
+        neededBits = LEN_NUM_CCE,
+        pInputStream = pInputStream )
+    MODIFYING( pInputStream )
+    RETURNING( temp = returnValue )
+
+    pScratchPCE->coupling.num_ele = temp;
+
+    CALL getbits(
+        neededBits = LEN_MIX_PRES,
+        pInputStream = pInputStream )
+    MODIFYING( pInputStream )
+    RETURNING( flag = returnValue )
+
+    pScratchPCE->mono_mix.present = flag;
+
+    IF (flag != FALSE)
+    THEN
+        CALL getbits(
+            neededBits = LEN_TAG,
+            pInputStream = pInputStream )
+        MODIFYING( pInputStream )
+        RETURNING( temp = returnValue )
+
+        pScratchPCE->mono_mix.ele_tag = temp;
+
+    ENDIF
+
+    CALL getbits(
+        neededBits = LEN_MIX_PRES,
+        pInputStream = pInputStream )
+    MODIFYING( pInputStream )
+    RETURNING( flag = returnValue )
+
+    pScratchPCE->stereo_mix.present = flag;
+
+    IF (flag != FALSE)
+    THEN
+
+        CALL getbits(
+            neededBits = LEN_TAG,
+            pInputStream = pInputStream )
+        MODIFYING( pInputStream )
+        RETURNING( temp = returnValue )
+
+        pScratchPCE->stereo_mix.ele_tag = temp;
+
+    ENDIF
+
+    CALL getbits(
+        neededBits = LEN_MIX_PRES,
+        pInputStream = pInputStream )
+    MODIFYING( pInputStream )
+    RETURNING( flag = returnValue )
+
+    flag =
+        getbits(
+            LEN_MIX_PRES,
+            pInputStream);
+
+    pScratchPCE->matrix_mix.present = flag;
+
+    IF (flag != FALSE)
+    THEN
+        CALL getbits(
+            neededBits = LEN_MMIX_IDX,
+            pInputStream = pInputStream )
+        MODIFYING( pInputStream )
+        RETURNING( temp = returnValue )
+
+        pScratchPCE->matrix_mix.ele_tag = temp;
+
+        CALL getbits(
+            neededBits = LEN_PSUR_ENAB,
+            pInputStream = pInputStream )
+        MODIFYING( pInputStream )
+        RETURNING( temp = returnValue )
+
+        pScratchPCE->matrix_mix.pseudo_enab = temp;
+
+    ENDIF
+
+
+    CALL get_ele_list(
+        pElementList = &pScratchPCE->front,
+        pInputStream = pInputStream,
+        enableCPE    = TRUE )
+    MODIFYING( pInputStream )
+    MODIFYING( pScratchPCE->front )
+    RETURNING( nothing )
+
+    CALL get_ele_list(
+        pElementList = &pScratchPCE->side,
+        pInputStream = pInputStream,
+        enableCPE    = TRUE )
+    MODIFYING( pInputStream )
+    MODIFYING( pScratchPCE->side )
+    RETURNING( nothing )
+
+    CALL get_ele_list(
+        pElementList = &pScratchPCE->back,
+        pInputStream = pInputStream,
+        enableCPE    = TRUE )
+    MODIFYING( pInputStream )
+    MODIFYING( pScratchPCE->back )
+    RETURNING( nothing )
+
+    CALL get_ele_list(
+        pElementList = &pScratchPCE->lfe,
+        pInputStream = pInputStream,
+        enableCPE    = FALSE )
+    MODIFYING( pInputStream )
+    MODIFYING( pScratchPCE->lfe )
+    RETURNING( nothing )
+
+    CALL get_ele_list(
+        pElementList = &pScratchPCE->data,
+        pInputStream = pInputStream,
+        enableCPE    = FALSE )
+    MODIFYING( pInputStream )
+    MODIFYING( pScratchPCE->data )
+    RETURNING( nothing )
+
+    CALL get_ele_list(
+        pElementList = &pScratchPCE->coupling,
+        pInputStream = pInputStream,
+        enableCPE    = TRUE )
+    MODIFYING( pInputStream )
+    MODIFYING( pScratchPCE->coupling )
+    RETURNING( nothing )
+
+
+    CALL byte_align(
+        pInputStream = pInputStream )
+    MODIFYING( pInputStream )
+    RETURNING( nothing )
+
+    CALL getbits(
+        neededBits = LEN_COMMENT_BYTES,
+        pInputStream = pInputStream )
+    MODIFYING( pInputStream )
+    RETURNING( numChars = returnValue )
+
+    FOR (i = numChars; i > 0; i--)
+
+        CALL getbits(
+            neededBits = LEN_COMMENT_BYTES,
+            pInputStream = pInputStream )
+        MODIFYING( pInputStream )
+        RETURNING( nothing )
+
+    ENDFOR
+
+    IF (pVars->current_program < 0)
+    THEN
+        pVars->current_program = tag;
+    ENDIF
+
+
+    IF (tag == pVars->current_program)
+    THEN
+
+        CALL pv_memcpy(
+            to = &pVars->prog_config,
+            from = pScratchPCE,
+            n = sizeof(ProgConfig))
+        MODIFYING( pVars->prog_config )
+        RETURNING( nothing )
+
+        CALL set_mc_info(
+            pMC_Info = &pVars->mc_info,
+            objectType = pVars->prog_config.profile + 1,
+            samplin_rate_idx = pVars->prog_config.sampling_rate_idx,
+            tag = pVars->prog_config.front.ele_tag[0],
+            is_cpe = pVars->prog_config.front.ele_is_cpe[0],
+            pWinSeqInfo = pVars->winmap,
+            pSfbwidth128 = pVars->SFBWidth128)
+        MODIFYING( pVars->mc_info )
+        MODIFYING( pVars->winmap )
+        MODIFYING( pVars->SFBWidth128 )
+        RETURN( status = return_value )
+
+    ENDIF
+
+    MODIFY( pVars->mc_info )
+    MODIFY( pVars->winmap )
+    MODIFY( pVars->SFBWidth128 )
+    RETURN (status)
+
+------------------------------------------------------------------------------
+ RESOURCES USED
+   When the code is written for a specific target processor the
+     the resources used should be documented below.
+
+ STACK USAGE: [stack count for this module] + [variable to represent
+          stack usage for each subroutine called]
+
+     where: [stack usage variable] = stack usage for [subroutine
+         name] (see [filename].ext)
+
+ DATA MEMORY USED: x words
+
+ PROGRAM MEMORY USED: x words
+
+ CLOCK CYCLES: [cycle count equation for this module] + [variable
+           used to represent cycle count for each subroutine
+           called]
+
+     where: [cycle count variable] = cycle count for [subroutine
+        name] (see [filename].ext)
+
+------------------------------------------------------------------------------
+*/
+
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+#include "pv_audio_type_defs.h"
+#include "s_bits.h"
+#include "s_elelist.h"
+#include "s_tdec_int_file.h"
+#include "s_tdec_int_chan.h"
+#include "e_progconfigconst.h"
+#include "ibstream.h"
+#include "get_ele_list.h"
+#include "aac_mem_funcs.h"
+#include "set_mc_info.h"
+#include "get_prog_config.h"
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here. Include conditional
+; compile variables also.
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; LOCAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; LOCAL VARIABLE DEFINITIONS
+; Variable declaration - defined here and used outside this module
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL FUNCTION REFERENCES
+; Declare functions defined elsewhere and referenced in this module
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL VARIABLES REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+Int get_prog_config(
+    tDec_Int_File *pVars,
+    ProgConfig    *pScratchPCE)
+{
+    Int    i;
+    UInt    tag;
+    Int    numChars;
+    UInt    temp;
+    Bool   flag;
+    Int    status          = SUCCESS;
+    BITS  *pInputStream   = &(pVars->inputStream);
+
+
+    /*
+     * The tag is used at the very end to see if this PCE is
+     * the one to be used. Otherwise it does not need to be saved for the
+     * the simple configurations to be used in this version of an AAC
+     * decoder.
+     *
+     * All of the bits of this PCE must be read even if this PCE will not
+     * be used. They are read into a temporary PCE, then later it is decided
+     * whether to keep this PCE.
+     *
+     * To allow quick removal of the fields from the ProgConfig structure
+     * that will probably not be used at a later date,
+     * while still advancing the bitstream pointer,the return value of
+     * getbits is saved into a temporary variable, then transfered to
+     * the structure item.
+     */
+    tag =
+        get9_n_lessbits(
+            LEN_TAG,
+            pInputStream);
+
+    pScratchPCE->profile =
+        get9_n_lessbits(
+            LEN_PROFILE,
+            pInputStream);
+
+    pScratchPCE->sampling_rate_idx =
+        get9_n_lessbits(
+            LEN_SAMP_IDX,
+            pInputStream);
+
+    if (!pVars->adif_test && pScratchPCE->sampling_rate_idx != pVars->prog_config.sampling_rate_idx)
+    {
+        /* rewind the pointer as implicit channel configuration maybe the case */
+        pInputStream->usedBits -= (LEN_TAG + LEN_PROFILE + LEN_SAMP_IDX);
+
+        return (1); /*  mismatch cannot happen */
+    }
+
+
+    /*
+     * Retrieve the number of element lists for each of
+     * front, side, back, lfe, data, and coupling.
+     *
+     * For two-channel stereo or mono, only the data in the front needs
+     * to be saved. However, ALL fields need to be skipped over in some
+     * fashion. Also, the number of elements needs to be temporarily saved
+     * to call get_ele_list(). If that function was changed to pass in
+     * the number of points to be read, the memory set aside inside the
+     * ProgConfig structure could be removed.
+     */
+
+    /*
+     * The next six function calls could be combined into one, then use
+     * shifts and masks to retrieve the individual fields.
+     */
+    temp =
+        get9_n_lessbits(
+            LEN_NUM_ELE,
+            pInputStream);
+
+    pScratchPCE->front.num_ele = temp;
+
+    /* Needed only to read in the element list. */
+    temp =
+        get9_n_lessbits(
+            LEN_NUM_ELE,
+            pInputStream);
+
+    pScratchPCE->side.num_ele = temp;
+
+    /* Needed only to read in the element list. */
+    temp =
+        get9_n_lessbits(
+            LEN_NUM_ELE,
+            pInputStream);
+
+    pScratchPCE->back.num_ele = temp;
+
+    /* Needed only to read in the element list. */
+    temp =
+        get9_n_lessbits(
+            LEN_NUM_LFE,
+            pInputStream);
+
+    pScratchPCE->lfe.num_ele = temp;
+
+    /* Needed only to read in the element list. */
+    temp =
+        get9_n_lessbits(
+            LEN_NUM_DAT,
+            pInputStream);
+    pScratchPCE->data.num_ele = temp;
+
+    /* Needed only to read in the element list. */
+    temp =
+        get9_n_lessbits(
+            LEN_NUM_CCE,
+            pInputStream);
+
+    pScratchPCE->coupling.num_ele = temp;
+
+    /*
+     * Read in mix down data.
+     *
+     * Whether these fields can be removed and have proper operation
+     * will be determined at a later date.
+     */
+
+    /* Read presence of mono_mix */
+    flag =
+        get1bits(/*            LEN_MIX_PRES,*/
+            pInputStream);
+
+    pScratchPCE->mono_mix.present = flag;
+
+    if (flag != FALSE)
+    {
+        temp =
+            get9_n_lessbits(
+                LEN_TAG,
+                pInputStream);
+
+        pScratchPCE->mono_mix.ele_tag = temp;
+
+    } /* end if (flag != FALSE) */
+
+    /* Read presence of stereo mix */
+    flag =
+        get1bits(/*            LEN_MIX_PRES,*/
+            pInputStream);
+
+    pScratchPCE->stereo_mix.present = flag;
+
+    if (flag != FALSE)
+    {
+        temp =
+            get9_n_lessbits(
+                LEN_TAG,
+                pInputStream);
+
+        pScratchPCE->stereo_mix.ele_tag = temp;
+
+    } /* end if (flag != FALSE) */
+
+    /* Read presence of matrix mix */
+    flag =
+        get1bits(/*            LEN_MIX_PRES,*/
+            pInputStream);
+
+    pScratchPCE->matrix_mix.present = flag;
+
+    if (flag != FALSE)
+    {
+        temp =
+            get9_n_lessbits(
+                LEN_MMIX_IDX,
+                pInputStream);
+
+        pScratchPCE->matrix_mix.ele_tag = temp;
+
+        temp =
+            get1bits(/*                LEN_PSUR_ENAB,*/
+                pInputStream);
+
+        pScratchPCE->matrix_mix.pseudo_enab = temp;
+
+    } /* end if (flag != FALSE) */
+
+    /*
+     * Get each of the element lists. Only the front information will be
+     * used for the PV decoder, but the usedBits field of pInputStream must
+     * be advanced appropriately.
+     *
+     * This could be optimized by advancing the bit stream for the
+     * elements that do not need to be read.
+     */
+    get_ele_list(
+        &pScratchPCE->front,
+        pInputStream,
+        TRUE);
+
+    get_ele_list(
+        &pScratchPCE->side,
+        pInputStream,
+        TRUE);
+
+    get_ele_list(
+        &pScratchPCE->back,
+        pInputStream,
+        TRUE);
+
+    get_ele_list(
+        &pScratchPCE->lfe,
+        pInputStream,
+        FALSE);
+
+    get_ele_list(
+        &pScratchPCE->data,
+        pInputStream,
+        FALSE);
+
+    get_ele_list(
+        &pScratchPCE->coupling,
+        pInputStream,
+        TRUE);
+
+    /*
+     * The standard requests a byte alignment before reading in the
+     * comment. This can be done because LEN_COMMENT_BYTES == 8.
+     */
+    byte_align(pInputStream);
+
+    numChars =
+        get9_n_lessbits(
+            LEN_COMMENT_BYTES, pInputStream);
+
+    /*
+     * Ignore the comment - it requires 65 bytes to store (or worse on DSP).
+     * If this field is restored, make sure to append a trailing '\0'
+     */
+    for (i = numChars; i > 0; i--)
+    {
+        pScratchPCE->comments[i] = (Char) get9_n_lessbits(LEN_BYTE,
+                                   pInputStream);
+
+    } /* end for */
+
+    if (pVars->current_program < 0)
+    {
+        /*
+         * If this is the first PCE, it becomes the current, regardless of
+         * its tag number.
+         */
+        pVars->current_program = tag;
+
+    } /* end if (pVars->current_program < 0) */
+
+
+    if (tag == (UInt)pVars->current_program)
+    {
+        /*
+         * This branch is reached under two conditions:
+         * 1) This is the first PCE found, it was selected in the above if
+         *    block. In all encoders found thus far, the tag value has been
+         *    zero.
+         * 2) A PCE has been sent by the encoder with a tag that matches the
+         *    the first one sent. It will then be re-read. No encoder found
+         *    thus far re-sends a PCE, when looking at ADIF files.
+         *
+         * Regardless, the temporary PCE will now be copied into the
+         * the one official program configuration.
+         */
+        pv_memcpy(
+            &pVars->prog_config,
+            pScratchPCE,
+            sizeof(ProgConfig));
+
+        /* enter configuration into MC_Info structure */
+        status =
+            set_mc_info(
+                &pVars->mc_info,
+                (tMP4AudioObjectType)(pVars->prog_config.profile + 1),
+                pVars->prog_config.sampling_rate_idx,
+                pVars->prog_config.front.ele_tag[0],
+                pVars->prog_config.front.ele_is_cpe[0],
+                pVars->winmap,
+                pVars->SFBWidth128);
+
+    } /* end if (tag == pVars->current_program) */
+
+    return (status);
+}
+
diff --git a/media/libstagefright/codecs/aacdec/get_prog_config.h b/media/libstagefright/codecs/aacdec/get_prog_config.h
new file mode 100644
index 0000000..646ba46
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/get_prog_config.h
@@ -0,0 +1,89 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Pathname: get_prog_config.h
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+ Who:                                      Date:
+ Description:
+
+------------------------------------------------------------------------------
+ INCLUDE DESCRIPTION
+
+ Header file for get_prog_config.c
+
+------------------------------------------------------------------------------
+*/
+
+/*----------------------------------------------------------------------------
+; CONTINUE ONLY IF NOT ALREADY DEFINED
+----------------------------------------------------------------------------*/
+#ifndef GET_PROG_CONFIG_H
+#define GET_PROG_CONFIG_H
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+#include "pv_audio_type_defs.h"
+#include "s_progconfig.h"
+#include "s_tdec_int_file.h"
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here.
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL VARIABLES REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; SIMPLE TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; ENUMERATED TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; STRUCTURES TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; GLOBAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+Int get_prog_config(
+    tDec_Int_File *pVars,
+    ProgConfig    *pTempPCE);
+
+/*----------------------------------------------------------------------------
+; END
+----------------------------------------------------------------------------*/
+#endif
+
+
diff --git a/media/libstagefright/codecs/aacdec/get_pulse_data.cpp b/media/libstagefright/codecs/aacdec/get_pulse_data.cpp
new file mode 100644
index 0000000..f9c24f4
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/get_pulse_data.cpp
@@ -0,0 +1,286 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Pathname: get_pulse_data.c
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+ Description:  Modified from original shareware code
+
+ Description:  Modified to pass variables by reference to eliminate use
+               of global variables.
+
+ Description: Put into PV format
+
+ Description: 1) Change loop to use pointers.
+              2) Rename to from get_nec_nc to get_pulse_data
+
+ Description: Changes per code review
+              1) Fix pathname
+              2) Read in two fields to save call to getbits
+              3) Change how pPulseInfo->number_pulse is stored.
+
+ Description: Placed typecast to Int in places where UInt->Int
+
+ Description: Replace some instances of getbits to get9_n_lessbits
+              when the number of bits read is 9.
+
+ Who:                                  Date:
+ Description:
+------------------------------------------------------------------------------
+ INPUT AND OUTPUT DEFINITIONS
+
+ Inputs:
+     pInputStream = pointer to a BITS structure, used by the function getbits
+                   to provide data. Data type pointer to BITS structure
+
+     pPulseInfo   = pointer to pulse data structure to be filled with data
+                    concerning pulses in the frequency domain.
+                    Data type pointer to PulseInfo
+
+ Local Stores/Buffers/Pointers Needed: None
+
+ Global Stores/Buffers/Pointers Needed: None
+
+ Outputs:
+     status       = return value, zero signifies success, non-zero otherwise.
+                    Presently this function only returns a success, error
+                    checking may be added later.
+                    Data type Int.
+
+ Pointers and Buffers Modified:
+
+    pPulseInfo contents are updated with pulse information. Specifically,
+    pPulseInfo->number_pulse with the number of pulses found, and
+    pPulseInfo->pulse_start_sfb is set to the first scale factor band.
+    Then pPulseInfo->pulse_offset and pPulseInfo->pulse_amp are filled
+    with data. For these array, only the number of pulses defined will be
+    set, those values beyond the number of pulses will retain their previous
+    value and should not be read from.
+    Note: The value in pPulseInfo->number_pulse is different by a value of
+          one from the original ISO code.
+
+    pInputBuffer contents are updated to the next location to be read from
+        the input stream.
+
+ Local Stores Modified: None
+
+ Global Stores Modified: None
+
+------------------------------------------------------------------------------
+ FUNCTION DESCRIPTION
+
+ This function fills in the pulse data structure with information to be used
+ later for restoring pulses in the spectrum.
+
+------------------------------------------------------------------------------
+ REQUIREMENTS
+
+ This function shall not use global or static variables.
+
+------------------------------------------------------------------------------
+ REFERENCES
+
+  (1) ISO/IEC 13818-7:1997 Titled "Information technology - Generic coding
+      of moving pictures and associated audio information - Part 7: Advanced
+      Audio Coding (AAC)", Table 6.17 - Syntax of pulse_data(),
+      page 15, and section 9.3 "Decoding process", starting on page 41.
+
+
+ (2) MPEG-2 NBC Audio Decoder
+   "This software module was originally developed by AT&T, Dolby
+   Laboratories, Fraunhofer Gesellschaft IIS in the course of development
+   of the MPEG-2 NBC/MPEG-4 Audio standard ISO/IEC 13818-7, 14496-1,2 and
+   3. This software module is an implementation of a part of one or more
+   MPEG-2 NBC/MPEG-4 Audio tools as specified by the MPEG-2 NBC/MPEG-4
+   Audio standard. ISO/IEC gives users of the MPEG-2 NBC/MPEG-4 Audio
+   standards free license to this software module or modifications thereof
+   for use in hardware or software products claiming conformance to the
+   MPEG-2 NBC/MPEG-4 Audio  standards. Those intending to use this software
+   module in hardware or software products are advised that this use may
+   infringe existing patents. The original developer of this software
+   module and his/her company, the subsequent editors and their companies,
+   and ISO/IEC have no liability for use of this software module or
+   modifications thereof in an implementation. Copyright is not released
+   for non MPEG-2 NBC/MPEG-4 Audio conforming products.The original
+   developer retains full right to use the code for his/her own purpose,
+   assign or donate the code to a third party and to inhibit third party
+   from using the code for non MPEG-2 NBC/MPEG-4 Audio conforming products.
+   This copyright notice must be included in all copies or derivative
+   works."
+   Copyright(c)1996.
+
+------------------------------------------------------------------------------
+ PSEUDO-CODE
+
+    status = SUCCESS;
+
+    CALL getbits(neededBits = LEN_PULSE_NPULSE + LEN_PULSE_ST_SFB,
+                 pInputStream = pInputStream)
+    MODIFYING(*pInputStream)
+    RETURNING(temp)
+
+    pPulseInfo->number_pulse = 1 + (temp >> LEN_PULSE_ST_SFB);
+    pPulseInfo->pulse_start_sfb = temp & ((1 << LEN_PULSE_ST_SFB) - 1);
+
+    pPulseOffset = &pPulseInfo->pulse_offset[0];
+    pPulseAmp    = &pPulseInfo->pulse_amp[0];
+
+    FOR (i = PulseInfo->number_pulse; i > 0; i--)
+        CALL getbits(neededBits = LEN_PULSE_POFF + LEN_PULSE_PAMP,
+                     pInputStream = pInputStream)
+        MODIFYING(*pInputStream)
+        RETURNING(temp)
+
+        *pPulseOffset++ = temp >> LEN_PULSE_PAMP;
+        *pPulseAmp++    = temp & ((1 << LEN_PULSE_PAMP) - 1);
+    END FOR
+
+    MODIFYING (*pInputStream)
+    MODIFYING (*pPulseInfo)
+
+    RETURN status
+
+------------------------------------------------------------------------------
+ RESOURCES USED
+   When the code is written for a specific target processor the
+     the resources used should be documented below.
+
+ STACK USAGE: [stack count for this module] + [variable to represent
+          stack usage for each subroutine called]
+
+     where: [stack usage variable] = stack usage for [subroutine
+         name] (see [filename].ext)
+
+ DATA MEMORY USED: x words
+
+ PROGRAM MEMORY USED: x words
+
+ CLOCK CYCLES: [cycle count equation for this module] + [variable
+           used to represent cycle count for each subroutine
+           called]
+
+     where: [cycle count variable] = cycle count for [subroutine
+        name] (see [filename].ext)
+
+------------------------------------------------------------------------------
+*/
+
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+
+#include "pv_audio_type_defs.h"
+#include "ibstream.h"
+#include "s_pulseinfo.h"
+#include "s_bits.h"
+#include "e_rawbitstreamconst.h"
+#include "get_pulse_data.h"
+
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here. Include conditional
+; compile variables also.
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; LOCAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; LOCAL VARIABLE DEFINITIONS
+; Variable declaration - defined here and used outside this module
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL FUNCTION REFERENCES
+; Declare functions defined elsewhere and referenced in this module
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL VARIABLES REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; FUNCTION CODE
+----------------------------------------------------------------------------*/
+Int get_pulse_data(
+    PulseInfo   *pPulseInfo,
+    BITS        *pInputStream)
+{
+    Int   i;
+    Int  *pPulseOffset;
+    Int  *pPulseAmp;
+    Int   status = SUCCESS;
+    UInt  temp;
+
+    /*
+     * Read in both field fields at once to save cycles. These are the
+     * original lines of code:
+     * pPulseInfo->number_pulse = getbits(LEN_PULSE_NPULSE, pInputStream);
+     * pPulseInfo->pulse_start_sfb = getbits(LEN_PULSE_ST_SFB, pInputStream);
+     */
+
+    temp =
+        get9_n_lessbits(
+            LEN_PULSE_NPULSE + LEN_PULSE_ST_SFB,
+            pInputStream);
+
+    pPulseInfo->number_pulse = (Int)(1 + (temp >> LEN_PULSE_ST_SFB));
+    pPulseInfo->pulse_start_sfb = (Int)(temp & ((1 << LEN_PULSE_ST_SFB) - 1));
+
+    pPulseOffset = &pPulseInfo->pulse_offset[0];
+    pPulseAmp    = &pPulseInfo->pulse_amp[0];
+
+    /*
+     * This loop needs to count one more than the number read in from
+     * the bitstream - look at reference [1].
+     */
+
+    for (i = pPulseInfo->number_pulse; i > 0; i--)
+    {
+        /*
+         * Read in both fields. Original lines:
+         *  *pPulseOffset++ = getbits(LEN_PULSE_POFF, pInputStream);
+         *  *pPulseAmp++    = getbits(LEN_PULSE_PAMP, pInputStream);
+         */
+
+        temp =
+            get9_n_lessbits(
+                LEN_PULSE_POFF + LEN_PULSE_PAMP,
+                pInputStream);
+
+        *pPulseOffset++ = (Int)(temp >> LEN_PULSE_PAMP);
+
+        *pPulseAmp++    = (Int)(temp & ((1 << LEN_PULSE_PAMP) - 1));
+    }
+
+    return (status);
+}
+
diff --git a/media/libstagefright/codecs/aacdec/get_pulse_data.h b/media/libstagefright/codecs/aacdec/get_pulse_data.h
new file mode 100644
index 0000000..267f534
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/get_pulse_data.h
@@ -0,0 +1,100 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Pathname: get_pulse_data.h
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+ Description: Change structure name.
+
+ Who:                                      Date:
+ Description:
+
+------------------------------------------------------------------------------
+ INCLUDE DESCRIPTION
+
+ Header file for get_pulse_data.c
+
+------------------------------------------------------------------------------
+*/
+
+/*----------------------------------------------------------------------------
+; CONTINUE ONLY IF NOT ALREADY DEFINED
+----------------------------------------------------------------------------*/
+#ifndef GET_PULSE_DATA_H
+#define GET_PULSE_DATA_H
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+    /*----------------------------------------------------------------------------
+    ; INCLUDES
+    ----------------------------------------------------------------------------*/
+#include "pv_audio_type_defs.h"
+#include "s_pulseinfo.h"
+#include "s_bits.h"
+
+    /*----------------------------------------------------------------------------
+    ; MACROS
+    ; Define module specific macros here
+    ----------------------------------------------------------------------------*/
+
+    /*----------------------------------------------------------------------------
+    ; DEFINES
+    ; Include all pre-processor statements here.
+    ----------------------------------------------------------------------------*/
+
+    /*----------------------------------------------------------------------------
+    ; EXTERNAL VARIABLES REFERENCES
+    ; Declare variables used in this module but defined elsewhere
+    ----------------------------------------------------------------------------*/
+
+    /*----------------------------------------------------------------------------
+    ; SIMPLE TYPEDEF'S
+    ----------------------------------------------------------------------------*/
+
+    /*----------------------------------------------------------------------------
+    ; ENUMERATED TYPEDEF'S
+    ----------------------------------------------------------------------------*/
+
+    /*----------------------------------------------------------------------------
+    ; STRUCTURES TYPEDEF'S
+    ----------------------------------------------------------------------------*/
+
+    /*----------------------------------------------------------------------------
+    ; GLOBAL FUNCTION DEFINITIONS
+    ; Function Prototype declaration
+    ----------------------------------------------------------------------------*/
+    Int get_pulse_data(
+        PulseInfo   *pPulseInfo,
+        BITS        *pInputStream);
+
+
+#ifdef __cplusplus
+}
+#endif
+
+/*----------------------------------------------------------------------------
+; END
+----------------------------------------------------------------------------*/
+#endif  /*  GET_PULSE_DATA_H  */
+
diff --git a/media/libstagefright/codecs/aacdec/get_sbr_bitstream.cpp b/media/libstagefright/codecs/aacdec/get_sbr_bitstream.cpp
new file mode 100644
index 0000000..b6ec365
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/get_sbr_bitstream.cpp
@@ -0,0 +1,183 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Filename: get_sbr_bitstream.c
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+
+ Who:                                   Date: MM/DD/YYYY
+ Description:
+
+------------------------------------------------------------------------------
+ INPUT AND OUTPUT DEFINITIONS
+
+    INPUT
+
+    SBRDECODER self,
+    SBRBITSTREAM * stream,
+    float *timeData,
+    int numChannels
+
+    OUTPUT
+
+    errorCode, noError if successful
+
+------------------------------------------------------------------------------
+ FUNCTION DESCRIPTION
+
+        sbr decoder processing, set up SBR decoder phase 2 in case of
+        different cotrol data
+
+------------------------------------------------------------------------------
+ REQUIREMENTS
+
+
+------------------------------------------------------------------------------
+ REFERENCES
+
+SC 29 Software Copyright Licencing Disclaimer:
+
+This software module was originally developed by
+  Coding Technologies
+
+and edited by
+  -
+
+in the course of development of the ISO/IEC 13818-7 and ISO/IEC 14496-3
+standards for reference purposes and its performance may not have been
+optimized. This software module is an implementation of one or more tools as
+specified by the ISO/IEC 13818-7 and ISO/IEC 14496-3 standards.
+ISO/IEC gives users free license to this software module or modifications
+thereof for use in products claiming conformance to audiovisual and
+image-coding related ITU Recommendations and/or ISO/IEC International
+Standards. ISO/IEC gives users the same free license to this software module or
+modifications thereof for research purposes and further ISO/IEC standardisation.
+Those intending to use this software module in products are advised that its
+use may infringe existing patents. ISO/IEC have no liability for use of this
+software module or modifications thereof. Copyright is not released for
+products that do not conform to audiovisual and image-coding related ITU
+Recommendations and/or ISO/IEC International Standards.
+The original developer retains full right to modify and use the code for its
+own purpose, assign or donate the code to a third party and to inhibit third
+parties from using the code for products that do not conform to audiovisual and
+image-coding related ITU Recommendations and/or ISO/IEC International Standards.
+This copyright notice must be included in all copies or derivative works.
+Copyright (c) ISO/IEC 2002.
+
+------------------------------------------------------------------------------
+ PSEUDO-CODE
+
+------------------------------------------------------------------------------
+*/
+
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+#ifdef AAC_PLUS
+
+#include "get_sbr_bitstream.h"
+#include "pv_audio_type_defs.h"
+#include    "sbr_crc_check.h"
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here. Include conditional
+; compile variables also.
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; LOCAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; LOCAL STORE/BUFFER/POINTER DEFINITIONS
+; Variable declaration - defined here and used outside this module
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL FUNCTION REFERENCES
+; Declare functions defined elsewhere and referenced in this module
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL GLOBAL STORE/BUFFER/POINTER REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; FUNCTION CODE
+----------------------------------------------------------------------------*/
+
+void get_sbr_bitstream(SBRBITSTREAM *sbrBitStream, BITS *pInputStream)
+{
+    /*----------------------------------------------------------------------------
+    ; Define all local variables
+    ----------------------------------------------------------------------------*/
+
+    Int32 count;
+    Int32 esc_count;
+    Int32 Extention_Type;
+    Int32 i;
+
+    count = get9_n_lessbits(LEN_F_CNT, pInputStream);
+    if (count == 15)
+    {
+        esc_count = get9_n_lessbits(LEN_F_ESC, pInputStream);
+        count = esc_count + 14;
+    }
+
+
+
+    Extention_Type = get9_n_lessbits(LEN_F_CNT, pInputStream);
+
+
+    if (((Extention_Type == SBR_EXTENSION) || (Extention_Type == SBR_EXTENSION_CRC))
+            && (count < MAXSBRBYTES) && (count) && (sbrBitStream->NrElements < MAXNRELEMENTS))
+    {
+
+        sbrBitStream->sbrElement[sbrBitStream->NrElements].ExtensionType = Extention_Type;
+        sbrBitStream->sbrElement[sbrBitStream->NrElements].Payload       = count;
+        sbrBitStream->sbrElement[sbrBitStream->NrElements].Data[0]       = (UChar) get9_n_lessbits(LEN_F_CNT, pInputStream);
+        for (i = 1 ; i < count ; i++)
+        {
+            sbrBitStream->sbrElement[sbrBitStream->NrElements].Data[i] = (UChar) get9_n_lessbits(8, pInputStream);
+        }
+
+        sbrBitStream->NrElements += 1;
+
+    }
+    else
+    {
+        pInputStream->usedBits += (count - 1) * LEN_BYTE;
+        pInputStream->usedBits += 4;        /* compenste for LEN_F_CNT (=4) bits read for Extention_Type */
+
+    }
+}
+
+#endif
diff --git a/media/libstagefright/codecs/aacdec/get_sbr_bitstream.h b/media/libstagefright/codecs/aacdec/get_sbr_bitstream.h
new file mode 100644
index 0000000..8094b1a
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/get_sbr_bitstream.h
@@ -0,0 +1,126 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Filename: get_sbr_bitstream.h
+ Funtions:
+    get_dse
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+
+ Who:                                   Date: MM/DD/YYYY
+ Description:
+------------------------------------------------------------------------------
+SC 29 Software Copyright Licencing Disclaimer:
+
+This software module was originally developed by
+  Coding Technologies
+
+and edited by
+  -
+
+in the course of development of the ISO/IEC 13818-7 and ISO/IEC 14496-3
+standards for reference purposes and its performance may not have been
+optimized. This software module is an implementation of one or more tools as
+specified by the ISO/IEC 13818-7 and ISO/IEC 14496-3 standards.
+ISO/IEC gives users free license to this software module or modifications
+thereof for use in products claiming conformance to audiovisual and
+image-coding related ITU Recommendations and/or ISO/IEC International
+Standards. ISO/IEC gives users the same free license to this software module or
+modifications thereof for research purposes and further ISO/IEC standardisation.
+Those intending to use this software module in products are advised that its
+use may infringe existing patents. ISO/IEC have no liability for use of this
+software module or modifications thereof. Copyright is not released for
+products that do not conform to audiovisual and image-coding related ITU
+Recommendations and/or ISO/IEC International Standards.
+The original developer retains full right to modify and use the code for its
+own purpose, assign or donate the code to a third party and to inhibit third
+parties from using the code for products that do not conform to audiovisual and
+image-coding related ITU Recommendations and/or ISO/IEC International Standards.
+This copyright notice must be included in all copies or derivative works.
+Copyright (c) ISO/IEC 2002.
+
+ $Id: ct_envcalc.h,v 1.3 2002/11/29 16:11:49 kaehleof Exp $
+*/
+
+/*----------------------------------------------------------------------------
+; CONTINUE ONLY IF NOT ALREADY DEFINED
+----------------------------------------------------------------------------*/
+#ifndef GET_SBR_BITSTREAM_H
+#define GET_SBR_BITSTREAM_H
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+#include "s_bits.h"
+#include "ibstream.h"
+#include "e_rawbitstreamconst.h"
+#include "s_sbrbitstream.h"
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here.
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL VARIABLES REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; SIMPLE TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; ENUMERATED TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; STRUCTURES TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; GLOBAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+    void get_sbr_bitstream(SBRBITSTREAM *sbrBitStream,
+    BITS *pInputStream);
+
+#ifdef __cplusplus
+}
+#endif
+
+/*----------------------------------------------------------------------------
+; END
+----------------------------------------------------------------------------*/
+#endif
+
+
diff --git a/media/libstagefright/codecs/aacdec/get_sbr_startfreq.cpp b/media/libstagefright/codecs/aacdec/get_sbr_startfreq.cpp
new file mode 100644
index 0000000..38ddc0b
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/get_sbr_startfreq.cpp
@@ -0,0 +1,183 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Filename: get_sbr_startfreq.c
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+
+ Who:                                   Date: MM/DD/YYYY
+ Description:
+
+------------------------------------------------------------------------------
+ INPUT AND OUTPUT DEFINITIONS
+
+
+
+------------------------------------------------------------------------------
+ FUNCTION DESCRIPTION
+
+
+------------------------------------------------------------------------------
+ REQUIREMENTS
+
+
+------------------------------------------------------------------------------
+ REFERENCES
+
+SC 29 Software Copyright Licencing Disclaimer:
+
+This software module was originally developed by
+  Coding Technologies
+
+and edited by
+  -
+
+in the course of development of the ISO/IEC 13818-7 and ISO/IEC 14496-3
+standards for reference purposes and its performance may not have been
+optimized. This software module is an implementation of one or more tools as
+specified by the ISO/IEC 13818-7 and ISO/IEC 14496-3 standards.
+ISO/IEC gives users free license to this software module or modifications
+thereof for use in products claiming conformance to audiovisual and
+image-coding related ITU Recommendations and/or ISO/IEC International
+Standards. ISO/IEC gives users the same free license to this software module or
+modifications thereof for research purposes and further ISO/IEC standardisation.
+Those intending to use this software module in products are advised that its
+use may infringe existing patents. ISO/IEC have no liability for use of this
+software module or modifications thereof. Copyright is not released for
+products that do not conform to audiovisual and image-coding related ITU
+Recommendations and/or ISO/IEC International Standards.
+The original developer retains full right to modify and use the code for its
+own purpose, assign or donate the code to a third party and to inhibit third
+parties from using the code for products that do not conform to audiovisual and
+image-coding related ITU Recommendations and/or ISO/IEC International Standards.
+This copyright notice must be included in all copies or derivative works.
+Copyright (c) ISO/IEC 2002.
+
+------------------------------------------------------------------------------
+ PSEUDO-CODE
+
+------------------------------------------------------------------------------
+*/
+
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+#include    "get_sbr_startfreq.h"
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here. Include conditional
+; compile variables also.
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; LOCAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; LOCAL STORE/BUFFER/POINTER DEFINITIONS
+; Variable declaration - defined here and used outside this module
+----------------------------------------------------------------------------*/
+const Int v_offset[7][16] =
+{
+    { -8, -7, -6, -5, -4, -3, -2, -1,  0,  1,  2,  3,  4,  5,  6,  7},
+    { -5, -4, -3, -2, -1,  0,  1,  2,  3,  4,  5,  6,  7,  9, 11, 13},
+    { -5, -3, -2, -1,  0,  1,  2,  3,  4,  5,  6,  7,  9, 11, 13, 16},
+    { -6, -4, -2, -1,  0,  1,  2,  3,  4,  5,  6,  7,  9, 11, 13, 16},
+    { -4, -2, -1,  0,  1,  2,  3,  4,  5,  6,  7,  9, 11, 13, 16, 20},
+    { -2, -1,  0,  1,  2,  3,  4,  5,  6,  7,  9, 11, 13, 16, 20, 24},
+    { 0,  1,  2,  3,  4,  5,  6,  7,  9, 11, 13, 16, 20, 24, 28, 33}
+};
+
+/*----------------------------------------------------------------------------
+; EXTERNAL FUNCTION REFERENCES
+; Declare functions defined elsewhere and referenced in this module
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL GLOBAL STORE/BUFFER/POINTER REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; FUNCTION CODE
+----------------------------------------------------------------------------*/
+
+Int get_sbr_startfreq(const Int32 fs,
+                      const Int32 start_freq)
+{
+    Int k0_min = 0;
+    Int32 index;
+
+
+    switch (fs)
+    {
+        case 16000:
+            index = 0;
+            k0_min = 24;
+            break;
+        case 22050:
+            index = 1;
+            k0_min = 17;
+            break;
+        case 24000:
+            index = 2;
+            k0_min = 16;
+            break;
+        case 32000:
+            index = 3;
+            k0_min = 16;
+            break;
+        case 44100:
+            index = 4;
+            k0_min = 12;
+            break;
+        case 48000:
+            index = 4;
+            k0_min = 11;
+            break;
+        case 64000:
+            index = 4;
+            k0_min = 10;
+            break;
+        case 88200:
+        case 96000:
+            index = 5;
+            k0_min = 7;
+            break;
+
+        default:
+            index = 6;
+    }
+    return (k0_min + v_offset[index][start_freq]);
+
+}
+
+
+
diff --git a/media/libstagefright/codecs/aacdec/get_sbr_startfreq.h b/media/libstagefright/codecs/aacdec/get_sbr_startfreq.h
new file mode 100644
index 0000000..10fa160
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/get_sbr_startfreq.h
@@ -0,0 +1,85 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Filename: get_sbr_startfreq.h
+ Funtions:
+    get_dse
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+
+ Who:                                   Date: MM/DD/YYYY
+ Description:
+------------------------------------------------------------------------------
+
+
+----------------------------------------------------------------------------
+; CONTINUE ONLY IF NOT ALREADY DEFINED
+----------------------------------------------------------------------------*/
+#ifndef GET_SBR_STARTFREQ_H
+#define GET_SBR_STARTFREQ_H
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+#include "pv_audio_type_defs.h"
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here.
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL VARIABLES REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; SIMPLE TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; ENUMERATED TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; STRUCTURES TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+
+/*----------------------------------------------------------------------------
+; GLOBAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+
+Int get_sbr_startfreq(const Int32 fs,
+                      const Int32 start_freq);
+
+/*----------------------------------------------------------------------------
+; END
+----------------------------------------------------------------------------*/
+#endif
+
+
diff --git a/media/libstagefright/codecs/aacdec/get_sbr_stopfreq.cpp b/media/libstagefright/codecs/aacdec/get_sbr_stopfreq.cpp
new file mode 100644
index 0000000..e32c61d
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/get_sbr_stopfreq.cpp
@@ -0,0 +1,190 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Filename: get_sbr_stopfreq.c
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+
+ Who:                                   Date: MM/DD/YYYY
+ Description:
+
+------------------------------------------------------------------------------
+ INPUT AND OUTPUT DEFINITIONS
+
+
+
+------------------------------------------------------------------------------
+ FUNCTION DESCRIPTION
+
+
+------------------------------------------------------------------------------
+ REQUIREMENTS
+
+
+------------------------------------------------------------------------------
+ REFERENCES
+
+SC 29 Software Copyright Licencing Disclaimer:
+
+This software module was originally developed by
+  Coding Technologies
+
+and edited by
+  -
+
+in the course of development of the ISO/IEC 13818-7 and ISO/IEC 14496-3
+standards for reference purposes and its performance may not have been
+optimized. This software module is an implementation of one or more tools as
+specified by the ISO/IEC 13818-7 and ISO/IEC 14496-3 standards.
+ISO/IEC gives users free license to this software module or modifications
+thereof for use in products claiming conformance to audiovisual and
+image-coding related ITU Recommendations and/or ISO/IEC International
+Standards. ISO/IEC gives users the same free license to this software module or
+modifications thereof for research purposes and further ISO/IEC standardisation.
+Those intending to use this software module in products are advised that its
+use may infringe existing patents. ISO/IEC have no liability for use of this
+software module or modifications thereof. Copyright is not released for
+products that do not conform to audiovisual and image-coding related ITU
+Recommendations and/or ISO/IEC International Standards.
+The original developer retains full right to modify and use the code for its
+own purpose, assign or donate the code to a third party and to inhibit third
+parties from using the code for products that do not conform to audiovisual and
+image-coding related ITU Recommendations and/or ISO/IEC International Standards.
+This copyright notice must be included in all copies or derivative works.
+Copyright (c) ISO/IEC 2002.
+
+------------------------------------------------------------------------------
+ PSEUDO-CODE
+
+     if(fs < 32000)
+     {
+         k1_min = (Int) ( ( (float) (6000 * 2 * 64) / fs ) + 0.5 );
+     }
+     else
+     {
+         if (fs < 64000)
+         {
+             k1_min = (Int) ( ( (float) (8000 * 2 * 64) / fs ) + 0.5 );
+         }
+         else
+         {
+             k1_min = (Int) ( ((float) (10000 * 2 * 64) / fs ) + 0.5);
+         }
+     }
+
+     return((Int)( k1_min * pow( 64.0 / k1_min,(stop_freq)/13.0) + 0.5));
+
+------------------------------------------------------------------------------
+*/
+
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+
+#ifdef AAC_PLUS
+
+#include    "get_sbr_stopfreq.h"
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here. Include conditional
+; compile variables also.
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; LOCAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; LOCAL STORE/BUFFER/POINTER DEFINITIONS
+; Variable declaration - defined here and used outside this module
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL FUNCTION REFERENCES
+; Declare functions defined elsewhere and referenced in this module
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL GLOBAL STORE/BUFFER/POINTER REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; FUNCTION CODE
+----------------------------------------------------------------------------*/
+
+const UChar sbr_stopfreq_tbl[6][13] =
+{
+
+    { 21, 23, 25, 27, 29, 32, 35, 38, 41, 45, 49, 54, 59},  /* 48000  */
+    { 23, 25, 27, 29, 31, 34, 37, 40, 43, 47, 51, 55, 59},  /* 44100  */
+    { 32, 34, 36, 38, 40, 42, 44, 46, 49, 52, 55, 58, 61},  /* 32000  and 24000 */
+    { 35, 36, 38, 40, 42, 44, 46, 48, 50, 52, 55, 58, 61},  /* 22050  */
+    { 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 60, 62}   /* 16000  */
+
+};
+
+Int get_sbr_stopfreq(const Int32 fs,
+                     const Int32 stop_freq)
+{
+
+    Int i;
+
+    switch (fs)
+    {
+        case 48000:
+            i = 0;
+            break;
+
+        case 32000:
+        case 24000:
+            i = 2;
+            break;
+
+        case 22050:
+            i = 3;
+            break;
+
+        case 16000:
+            i = 4;
+            break;
+
+        case 44100:
+        default:
+            i = 1;
+            break;
+    }
+
+    return((Int)sbr_stopfreq_tbl[i][stop_freq]);
+
+}
+
+
+
+#endif
diff --git a/media/libstagefright/codecs/aacdec/get_sbr_stopfreq.h b/media/libstagefright/codecs/aacdec/get_sbr_stopfreq.h
new file mode 100644
index 0000000..341a3d4
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/get_sbr_stopfreq.h
@@ -0,0 +1,85 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Filename: get_sbr_stopfreq.h
+ Funtions:
+    get_dse
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+
+ Who:                                   Date: MM/DD/YYYY
+ Description:
+------------------------------------------------------------------------------
+
+
+ ----------------------------------------------------------------------------
+; CONTINUE ONLY IF NOT ALREADY DEFINED
+----------------------------------------------------------------------------*/
+#ifndef GET_SBR_STOPFREQ_H
+#define GET_SBR_STOPFREQ_H
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+#include "pv_audio_type_defs.h"
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here.
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL VARIABLES REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; SIMPLE TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; ENUMERATED TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; STRUCTURES TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+
+/*----------------------------------------------------------------------------
+; GLOBAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+
+Int get_sbr_stopfreq(const Int32 fs,
+                     const Int32 stop_freq);
+
+/*----------------------------------------------------------------------------
+; END
+----------------------------------------------------------------------------*/
+#endif
+
+
diff --git a/media/libstagefright/codecs/aacdec/get_sign_bits.h b/media/libstagefright/codecs/aacdec/get_sign_bits.h
new file mode 100644
index 0000000..445d2f2
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/get_sign_bits.h
@@ -0,0 +1,99 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Pathname: get_sign_bits.h
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+ Description: Update comments for the structure
+
+ Description: Change include file. Above description probably from another
+              header file.
+
+ Description: Fix pathname above
+
+ Who:                                               Date: MM/DD/YYYY
+ Description:
+
+------------------------------------------------------------------------------
+ INCLUDE DESCRIPTION
+
+ Header file for the function get_sign_bits()
+
+------------------------------------------------------------------------------
+*/
+
+/*----------------------------------------------------------------------------
+; CONTINUE ONLY IF NOT ALREADY DEFINED
+----------------------------------------------------------------------------*/
+#ifndef GET_SIGN_BITS_H
+#define GET_SIGN_BITS_H
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+#include "pv_audio_type_defs.h"
+#include "ibstream.h"
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here.
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL VARIABLES REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; SIMPLE TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; ENUMERATED TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; STRUCTURES TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+
+/*----------------------------------------------------------------------------
+; GLOBAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+
+void get_sign_bits(
+    Int          q[],
+    BITS        *pInputStream,
+    const Int    q_len
+);
+
+/*----------------------------------------------------------------------------
+; END
+----------------------------------------------------------------------------*/
+#endif /* GET_SIGN_BITS_H */
+
+
diff --git a/media/libstagefright/codecs/aacdec/get_tns.cpp b/media/libstagefright/codecs/aacdec/get_tns.cpp
new file mode 100644
index 0000000..e0b021b
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/get_tns.cpp
@@ -0,0 +1,573 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Pathname: get_tns.c
+
+     Date: 10/25/2000
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+ Description:  Modified from original shareware code
+
+ Description:  Modified to pass variables by reference to eliminate use
+               of global variables.
+
+ Description:  Brought code in-line with PV standards.  Some minor
+               optimizations (count-down for loops, etc.) were made.
+
+ Description:  Made cosmetic changes as suggested during review.  Also,
+ changed calculation of s_mask and n_mask from table-based to being
+ calculated based on res_index.  Also, the flag coef_res was changed
+ from having a range of [3,4] to having a range of [0,1], which corresponds
+ exactly with the true value that is passed via the bitstream.
+
+ Description:  Modified to use more efficient TNS memory structure.
+
+ Description: Updated to reflect more efficient usage of memory by the TNS
+ filters.
+
+ Description: Updated the SW template to include the full pathname to the
+ source file and a slightly modified copyright header.
+
+ Description: Moved pInputStream to be the 2nd parameter, for a slight
+ optimization on some platforms.
+
+ Description: Moved pSfbTop outside of the loops, since its value does
+ not change.
+
+ Description: Replace some instances of getbits to get1bits
+              when only 1 bit is read.
+
+ Who:                       Date:
+ Description:
+
+------------------------------------------------------------------------------
+ INPUT AND OUTPUT DEFINITIONS
+
+ Inputs:
+    FrameInfo *pFrameInfo
+        Pointer to structure that holds information about each block.
+        (long block flag,
+         number of subblocks,
+         scalefactor bands per subblock, etc.)
+
+    BITS *pInputStream
+        Pointer to a BITS structure that is
+        passed on to function getbits to pull information from the bitstream.
+
+    TNS_Frame_info *pTnsFrameInfo
+        Pointer to filter data structure - to be populated by this function.
+
+ Local Stores/Buffers/Pointers Needed:
+    None
+
+ Global Stores/Buffers/Pointers Needed:
+    None
+
+ Outputs:
+    None
+
+ Pointers and Buffers Modified:
+    TNS_frame_info *pTnsFrameInfo
+
+    pTnsFrameInfo->n_filt = Number of tns filters to be applied to the data.
+
+    pTnsFrameInfo->filt[]->order = The order of each individual TNS filter.
+
+    pTnsFrameInfo->filt[]->coef_res = The resolution of the filter coefficients
+
+    pTnsFrameInfo->filt[]->start_band = start of spectral band
+
+    pTnsFrameInfo->filt[]->stop_band = end of spectral band
+
+    pTnsFrameInfo->filt[]->coef[] = Each filter's coefficients are filled with
+    data read from the input bitstream.
+
+    pTnsFrameInfo->filt[]->direction = A flag is set for each TNS filter.
+
+    If the direction flag (on the bitstream) = 0, then the filter
+    is applied to the block of spectral data in normal (upward) fashion.
+
+    If the direction flag (on the bitstream) = 1, then the filter
+    is applied in a reverse (downward) fashion.
+    (Starting with the last element in the block of data.)
+
+    The value stored in filt[]->direction maps the values [0,1] to [1,-1] for
+    a more intuitive storage of this flag's meaning.
+
+ Local Stores Modified:
+
+ Global Stores Modified:
+
+
+------------------------------------------------------------------------------
+ FUNCTION DESCRIPTION
+
+ This function reads the TNS filter information from the bitstream, and stores
+ the filter order, LPC coefficients, and the number of TNS filters to
+ be applied in the structure TNS_frame_info.
+
+------------------------------------------------------------------------------
+ REQUIREMENTS
+
+ This code should match the ISO code in functionality, with the exception
+ that coef_res has range of [0,1] (PV code) instead of [3,4] (ISO code)
+
+ coef_res is only used by tns_decode_coef.
+
+------------------------------------------------------------------------------
+ REFERENCES
+ (1) ISO/IEC 14496-3:1999(E)
+     Part 3
+        Subpart 4.6.8 (Temporal Noise Shaping)
+
+ (2) MPEG-2 NBC Audio Decoder
+   "This software module was originally developed by AT&T, Dolby
+   Laboratories, Fraunhofer Gesellschaft IIS in the course of development
+   of the MPEG-2 NBC/MPEG-4 Audio standard ISO/IEC 13818-7, 14496-1,2 and
+   3. This software module is an implementation of a part of one or more
+   MPEG-2 NBC/MPEG-4 Audio tools as specified by the MPEG-2 NBC/MPEG-4
+   Audio standard. ISO/IEC  gives users of the MPEG-2 NBC/MPEG-4 Audio
+   standards free license to this software module or modifications thereof
+   for use in hardware or software products claiming conformance to the
+   MPEG-2 NBC/MPEG-4 Audio  standards. Those intending to use this software
+   module in hardware or software products are advised that this use may
+   infringe existing patents. The original developer of this software
+   module and his/her company, the subsequent editors and their companies,
+   and ISO/IEC have no liability for use of this software module or
+   modifications thereof in an implementation. Copyright is not released
+   for non MPEG-2 NBC/MPEG-4 Audio conforming products.The original
+   developer retains full right to use the code for his/her own purpose,
+   assign or donate the code to a third party and to inhibit third party
+   from using the code for non MPEG-2 NBC/MPEG-4 Audio conforming products.
+   This copyright notice must be included in all copies or derivative
+   works."
+   Copyright(c)1996.
+
+------------------------------------------------------------------------------
+ PSEUDO-CODE
+
+
+------------------------------------------------------------------------------
+ RESOURCES USED
+   When the code is written for a specific target processor
+     the resources used should be documented below.
+
+ STACK USAGE: [stack count for this module] + [variable to represent
+          stack usage for each subroutine called]
+
+     where: [stack usage variable] = stack usage for [subroutine
+         name] (see [filename].ext)
+
+ DATA MEMORY USED: x words
+
+ PROGRAM MEMORY USED: x words
+
+ CLOCK CYCLES: [cycle count equation for this module] + [variable
+           used to represent cycle count for each subroutine
+           called]
+
+     where: [cycle count variable] = cycle count for [subroutine
+        name] (see [filename].ext)
+
+----------------------------------------------------------------------------*/
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+#include "pv_audio_type_defs.h"
+#include "get_tns.h"
+#include "s_mc_info.h"
+#include "s_frameinfo.h"
+#include "s_tnsfilt.h"
+#include "s_tns_frame_info.h"
+#include "s_bits.h"
+#include "ibstream.h"
+#include "e_window_sequence.h"
+#include "e_progconfigconst.h"
+
+#include "tns_decode_coef.h"
+
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+#define SCALE_FACTOR_BAND_OFFSET(x) ( ((x) > 0) ? pSFB_top[(x)-1] : 0 )
+#define MINIMUM(x,y) ( ((x) < (y)) ? (x) : (y) )
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here. Include conditional
+; compile variables also.
+----------------------------------------------------------------------------*/
+/*----------------------------------------------------------------------------
+; LOCAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+/*----------------------------------------------------------------------------
+; LOCAL STORE/BUFFER/POINTER DEFINITIONS
+; Variable declaration - defined here and used outside this module
+----------------------------------------------------------------------------*/
+/*
+ * The entries in the ensuing tables provide the maximum permissable
+ * number of scalefactor bands for each TNS filter.  This value is effected
+ * by the sampling rate, and window type.
+ */
+
+const Int tns_max_bands_tbl_long_wndw[(1<<LEN_SAMP_IDX)] =
+    {31,       /* 96000 Hz */
+     31,       /* 88200 Hz */
+     34,       /* 64000 Hz */
+     40,       /* 48000 Hz */
+     42,       /* 44100 Hz */
+     51,       /* 32000 Hz */
+     46,       /* 24000 Hz */
+     46,       /* 22050 Hz */
+     42,       /* 16000 Hz */
+     42,       /* 12000 Hz */
+     42,       /* 11025 Hz */
+     39,       /* 8000  Hz */
+     0,
+     0,
+     0,
+     0
+    };
+
+const Int tns_max_bands_tbl_short_wndw[(1<<LEN_SAMP_IDX)] =
+    {9,       /* 96000 Hz */
+     9,       /* 88200 Hz */
+     10,       /* 64000 Hz */
+     14,       /* 48000 Hz */
+     14,       /* 44100 Hz */
+     14,       /* 32000 Hz */
+     14,       /* 24000 Hz */
+     14,       /* 22050 Hz */
+     14,       /* 16000 Hz */
+     14,       /* 12000 Hz */
+     14,       /* 11025 Hz */
+     14,       /* 8000  Hz */
+     0,
+     0,
+     0,
+     0
+    };
+
+/*
+ * For completeness, here are the table entries for object types that make
+ * use of PQF filter bank.  We do not currently support this; these are
+ * given here only to ease future implementation.
+ *
+ *  const Int tns_max_bands_tbl_long_wndw_PQF[(1<<LEN_SAMP_IDX)] =
+ *         {28,       ; 96000
+ *          28,       ; 88200
+ *          27,       ; 64000
+ *          26,       ; 48000
+ *          26,       ; 44100
+ *          26,       ; 32000
+ *          29,       ; 24000
+ *          29,       ; 22050
+ *          23,       ; 16000
+ *          23,       ; 12000
+ *          23,       ; 11025
+ *          19,       ; 8000
+ *           0,
+ *           0,
+ *           0,
+ *           0};
+ *
+ *  const Int tns_max_bands_tbl_short_wndw_PQF[(1<<LEN_SAMP_IDX)] =
+ *         {7,       ; 96000
+ *          7,       ; 88200
+ *          7,       ; 64000
+ *          6,       ; 48000
+ *          6,       ; 44100
+ *          6,       ; 32000
+ *          7,       ; 24000
+ *          7,       ; 22050
+ *          8,       ; 16000
+ *          8,       ; 12000
+ *          8,       ; 11025
+ *          7,       ; 8000
+ *          0,
+ *          0,
+ *          0,
+ *          0};
+ */
+
+/*----------------------------------------------------------------------------
+; EXTERNAL FUNCTION REFERENCES
+; Declare functions defined elsewhere and referenced in this module
+----------------------------------------------------------------------------*/
+/*----------------------------------------------------------------------------
+; EXTERNAL GLOBAL STORE/BUFFER/POINTER REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+/*----------------------------------------------------------------------------
+; FUNCTION CODE
+----------------------------------------------------------------------------*/
+
+
+void get_tns(
+    const Int               max_bands,
+    BITS            * const pInputStream,
+    const WINDOW_SEQUENCE   wnd_seq,
+    const FrameInfo * const pFrameInfo,
+    const MC_Info   * const pMC_Info,
+    TNS_frame_info  * const pTnsFrameInfo,
+    Int32                   scratchTnsDecCoefMem[])
+{
+
+    const Int16 * const pSFB_top = pFrameInfo->win_sfb_top[0];
+
+    Int f;
+    Int t;
+    Int win;
+    UInt tempInt;
+
+    Int num_filt_bits;
+    Int num_order_bits;
+    Int num_start_band_bits;
+
+    Int top;
+    Int res;
+    Int res_index;
+    Int compress;
+
+    Int sfb_per_win;
+
+    Int32 *pLpcCoef;
+    Int32 *pStartLpcCoef;
+    Int s_mask;
+    Int n_mask;
+
+    Int tns_bands;
+    UInt max_order;
+    Int coef_res;
+
+
+    TNSfilt *pFilt;
+
+    if (wnd_seq != EIGHT_SHORT_SEQUENCE)
+    {
+        num_filt_bits  = 2;
+        num_order_bits = 5;
+        num_start_band_bits = 6;
+
+        tns_bands = tns_max_bands_tbl_long_wndw[pMC_Info->sampling_rate_idx];
+
+        /*
+         *  Definition from 14496-3:1999 doc. Our first encoder follows this rule,
+         *  later encoders don't
+         */
+
+        if (pMC_Info->sampling_rate_idx > 4)  /* if (sampling_rate <= 32000 */
+        {
+            max_order = 20;
+        }
+        else
+        {
+            max_order = 12;
+        }
+    }
+    else
+    {
+        num_filt_bits  = 1;
+        num_order_bits = 3;
+        num_start_band_bits = 4;
+
+        tns_bands = tns_max_bands_tbl_short_wndw[pMC_Info->sampling_rate_idx];
+
+        max_order = 7;
+    }
+
+    /*
+     * After this branch, tns_bands will be equal to the minimum of
+     * the passed in variable, nbands, and the result from the
+     * tns_max_bands_tbl
+     */
+
+    if (max_bands < tns_bands)
+    {
+        tns_bands = max_bands;
+    }
+
+    sfb_per_win = pFrameInfo->sfb_per_win[0];
+
+    win = 0;
+
+    pLpcCoef = pTnsFrameInfo->lpc_coef;
+
+    pFilt = pTnsFrameInfo->filt;
+
+    do
+    {
+        tempInt = get9_n_lessbits(num_filt_bits,
+                                  pInputStream);
+
+        pTnsFrameInfo->n_filt[win] = tempInt;
+
+        if (tempInt != 0)
+        {
+            /*
+             * coef_res = [0, 1]
+             * Switch between a resolution of 3 and 4 bits respectively
+             *
+             * if coef_res = 0, the coefficients have a range of
+             *
+             *                 -4  -3  -2  -1  0   1   2   3
+             *
+             * if coef_res = 1, the coefficients have a range of
+             *
+             * -8  -7  -6  -5  -4  -3  -2  -1  0   1   2   3   4   5   6   7
+             *
+             * The arrays in ./src/tns_tab.c are completely based on
+             * the value of coef_res.
+             */
+            res = get1bits(
+                      pInputStream);
+
+            /* res is post-incremented for correct calculation of res_index */
+            coef_res = res++;
+
+            top = sfb_per_win;
+
+            for (f = pTnsFrameInfo->n_filt[win]; f > 0; f--)
+            {
+                tempInt = MINIMUM(top, tns_bands);
+
+                pFilt->stop_coef = SCALE_FACTOR_BAND_OFFSET(tempInt);
+
+                pFilt->stop_band = tempInt;
+
+                top -= get9_n_lessbits(num_start_band_bits,
+                                       pInputStream);
+
+                tempInt = MINIMUM(top, tns_bands);
+
+                pFilt->start_coef = SCALE_FACTOR_BAND_OFFSET(tempInt);
+
+                pFilt->start_band = tempInt;
+
+                tempInt = get9_n_lessbits(num_order_bits,
+                                          pInputStream);
+
+                pFilt->order = tempInt;
+
+                if (tempInt != 0)
+                {
+                    if (tempInt > max_order)
+                    {
+                        pFilt->order = max_order;
+                    }
+
+                    /*
+                     * This maps the bitstream's [0,1] to
+                     * pFilt->direction = [1,-1]
+                     */
+
+                    tempInt = get1bits(pInputStream);
+
+                    pFilt->direction = (-(Int)tempInt) | 0x1;
+
+                    /*
+                     * compress = [0,1]
+                     * If compress is true, the MSB has
+                     * been omitted from transmission (Ref. 1)
+                     *
+                     * For coef_res = 0, this limits the range of
+                     * transmitted coefficients to...
+                     *
+                     *         -2  -1  0   1
+                     *
+                     * For coef_res = 1, the coefficients have
+                     * a range of...
+                     *
+                     * -4  -3  -2  -1  0   1   2   3
+                     */
+                    compress = get1bits(pInputStream);
+
+                    /*
+                     * res has a range of [1,2]
+                     * compress has a range of [0,1]
+                     * So (res - compress) has range [0,2];
+                     */
+                    res_index = res - compress;
+
+                    s_mask =  2 << res_index;
+
+                    /*
+                     * If res_index = 0, grab 2 bits of data
+                     * If res_index = 1, grab 3 bits of data
+                     * If res_index = 2, grab 4 bits of data
+                     */
+                    res_index += 2;
+
+                    pStartLpcCoef = pLpcCoef;
+
+                    for (t = pFilt->order; t > 0; t--)
+                    {
+                        /*
+                         * These are the encoded coefficients, which will
+                         * later be decoded into LPC coefficients by
+                         * the function tns_decode_coef()
+                         */
+                        tempInt = get9_n_lessbits(res_index,
+                                                  pInputStream);
+
+                        n_mask  = -((Int)tempInt & s_mask);
+
+                        /*
+                         * n_mask is used to sign_extend the
+                         * value, if it is negative.
+                         *
+                         */
+                        *(pLpcCoef++) = tempInt | n_mask;
+                    }
+
+                    /* Decode the TNS coefficients */
+
+                    tempInt = pFilt->stop_coef - pFilt->start_coef;
+
+                    if (tempInt > 0)
+                    {
+                        pFilt->q_lpc =
+                            tns_decode_coef(
+                                pFilt->order,
+                                coef_res,
+                                pStartLpcCoef,
+                                scratchTnsDecCoefMem);
+                    }
+
+                } /* if (pTnsFilt->order != 0) */
+
+                pFilt++;
+
+            } /* END for (f=pTnsInfo->n_filt; f>0; f--, pTnsFilt++) */
+
+        } /* if (pTnsInfo->n_filt != 0) */
+
+        win++;
+
+    }
+    while (win < pFrameInfo->num_win);
+
+    return;
+
+} /* get_tns */
diff --git a/media/libstagefright/codecs/aacdec/get_tns.h b/media/libstagefright/codecs/aacdec/get_tns.h
new file mode 100644
index 0000000..731484f
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/get_tns.h
@@ -0,0 +1,124 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Pathname: get_tns.h
+
+   Author:
+     Date: 03/08/2001
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+ Description:
+ (1) Modified to include the lines...
+
+    #ifdef __cplusplus
+    extern "C" {
+    #endif
+
+    #ifdef __cplusplus
+    }
+    #endif
+
+ (2) Updated the copyright header.
+
+ Description: Modified to include updated function declaration, which reflects
+ the combination of the get_tns and tns_setup_filter routines.  Also, moved
+ pInputStream to be the 2nd parameter, for a slight optimization.
+
+ Who:                       Date:
+ Description:
+
+------------------------------------------------------------------------------
+ INCLUDE DESCRIPTION
+
+  This file includes the function definition for get_tns.c
+
+------------------------------------------------------------------------------
+*/
+
+/*----------------------------------------------------------------------------
+; CONTINUE ONLY IF NOT ALREADY DEFINED
+----------------------------------------------------------------------------*/
+#ifndef GET_TNS_H
+#define GET_TNS_H
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+    /*----------------------------------------------------------------------------
+    ; INCLUDES
+    ----------------------------------------------------------------------------*/
+#include "pv_audio_type_defs.h"
+#include "s_frameinfo.h"
+#include "s_mc_info.h"
+#include "s_tns_frame_info.h"
+#include "s_bits.h"
+#include "e_window_sequence.h"
+
+    /*----------------------------------------------------------------------------
+    ; MACROS
+    ; Define module specific macros here
+    ----------------------------------------------------------------------------*/
+
+    /*----------------------------------------------------------------------------
+    ; DEFINES
+    ; Include all pre-processor statements here.
+    ----------------------------------------------------------------------------*/
+
+    /*----------------------------------------------------------------------------
+    ; EXTERNAL VARIABLES REFERENCES
+    ; Declare variables used in this module but defined elsewhere
+    ----------------------------------------------------------------------------*/
+
+    /*----------------------------------------------------------------------------
+    ; SIMPLE TYPEDEF'S
+    ----------------------------------------------------------------------------*/
+
+    /*----------------------------------------------------------------------------
+    ; ENUMERATED TYPEDEF'S
+    ----------------------------------------------------------------------------*/
+
+    /*----------------------------------------------------------------------------
+    ; STRUCTURES TYPEDEF'S
+    ----------------------------------------------------------------------------*/
+
+    /*----------------------------------------------------------------------------
+    ; GLOBAL FUNCTION DEFINITIONS
+    ; Function Prototype declaration
+    ----------------------------------------------------------------------------*/
+    void get_tns(
+        const Int               max_bands,
+        BITS            * const pInputStream,
+        const WINDOW_SEQUENCE   wnd_seq,
+        const FrameInfo * const pFrameInfo,
+        const MC_Info   * const pMC_Info,
+        TNS_frame_info  * const pTnsFrameInfo,
+        Int32                   scratchTnsDecCoefMem[]);
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* GET_TNS_H */
+
+
diff --git a/media/libstagefright/codecs/aacdec/getbits.h b/media/libstagefright/codecs/aacdec/getbits.h
new file mode 100644
index 0000000..e854be5
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/getbits.h
@@ -0,0 +1,346 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Pathname: getbits.h
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+ Description: Update comments for the structure
+
+ Description: Move structur to another file
+
+ Who:                                            Date: MM/DD/YYYY
+ Description:
+
+
+------------------------------------------------------------------------------
+ INCLUDE DESCRIPTION
+
+ Header file for the function getbits().
+
+------------------------------------------------------------------------------
+*/
+
+/*----------------------------------------------------------------------------
+; CONTINUE ONLY IF NOT ALREADY DEFINED
+----------------------------------------------------------------------------*/
+#ifndef GETBITS_H
+#define GETBITS_H
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+    /*----------------------------------------------------------------------------
+    ; INCLUDES
+    ----------------------------------------------------------------------------*/
+#include "pv_audio_type_defs.h"
+#include "ibstream.h"
+
+    /*----------------------------------------------------------------------------
+    ; MACROS
+    ; Define module specific macros here
+    ----------------------------------------------------------------------------*/
+
+    /*----------------------------------------------------------------------------
+    ; DEFINES
+    ; Include all pre-processor statements here.
+    ----------------------------------------------------------------------------*/
+
+    /*----------------------------------------------------------------------------
+    ; EXTERNAL VARIABLES REFERENCES
+    ; Declare variables used in this module but defined elsewhere
+    ----------------------------------------------------------------------------*/
+
+    /*----------------------------------------------------------------------------
+    ; SIMPLE TYPEDEF'S
+    ----------------------------------------------------------------------------*/
+
+    /*----------------------------------------------------------------------------
+    ; ENUMERATED TYPEDEF'S
+    ----------------------------------------------------------------------------*/
+
+    /*----------------------------------------------------------------------------
+    ; STRUCTURES TYPEDEF'S
+    ----------------------------------------------------------------------------*/
+
+    /*----------------------------------------------------------------------------
+    ; GLOBAL FUNCTION DEFINITIONS
+    ; Function Prototype declaration
+    ----------------------------------------------------------------------------*/
+
+#define INBUF_ARRAY_INDEX_SHIFT  (3)
+#define INBUF_BIT_WIDTH         (1<<(INBUF_ARRAY_INDEX_SHIFT))
+#define INBUF_BIT_MODULO_MASK   ((INBUF_BIT_WIDTH)-1)
+
+#define MAX_GETBITS             (25)
+
+#define  CHECK_INPUT_BUFFER_LIMITS  1
+
+    __inline UInt32 getbits(
+        const UInt  neededBits,
+        BITS       *pInputStream)
+    {
+        UInt32   returnValue = 0;
+        UInt     offset;
+        UInt     bitIndex;
+        UChar    *pElem;        /* Needs to be same type as pInput->pBuffer */
+
+        offset = (pInputStream->usedBits) >> INBUF_ARRAY_INDEX_SHIFT;
+
+        pElem = pInputStream->pBuffer + offset;
+
+#if CHECK_INPUT_BUFFER_LIMITS
+
+        offset =  pInputStream->inputBufferCurrentLength - offset;
+        /*  check if access to input buffer does not go beyond boundaries */
+        if (offset > 3)
+        {
+            returnValue = (((UInt32) * (pElem)) << 24) |
+                          (((UInt32) * (pElem + 1)) << 16) |
+                          (((UInt32) * (pElem + 2)) << 8) |
+                          ((UInt32) * (pElem + 3));
+        }
+        else  /*  then access only available bytes  */
+        {
+            /*  Access to the bitstream beyond frame boundaries are not allowed,
+             *  Here, only what was available before the end of the frame will
+             *  be processed. Non-accessible bytes will be filled in with zeros.
+             *  Zero values guarantees that the data structures are filled in with values
+             *  that eventually will signal an error (like invalid parameters) or that allow
+             *  completion of the parsing routine.
+             *  Overrun is detected on file pvmp4audiodecodeframe.cpp.
+             */
+            switch (offset)
+            {
+                case 3:
+                    returnValue  = (((UInt32) * (pElem + 2)) << 8);
+                case 2:
+                    returnValue |= (((UInt32) * (pElem + 1)) << 16);
+                case 1:
+                    returnValue |= (((UInt32) * (pElem)) << 24);
+                default:
+                    break;
+            }
+        }
+
+
+#else
+
+        returnValue = (((UInt32) * (pElem)) << 24) |
+                      (((UInt32) * (pElem + 1)) << 16) |
+                      (((UInt32) * (pElem + 2)) << 8) |
+                      ((UInt32) * (pElem + 3));
+#endif
+
+        /* Remove extra high bits by shifting up */
+        bitIndex = (UInt)((pInputStream->usedBits) & INBUF_BIT_MODULO_MASK);
+
+        /* This line is faster way to mask off the high bits. */
+        returnValue = returnValue << (bitIndex);
+
+        /* Move the field down. */
+        returnValue = returnValue >> (32 - neededBits);
+
+        pInputStream->usedBits += neededBits;
+
+        return (returnValue);
+
+    }
+
+
+
+    __inline UInt get1bits(
+        BITS       *pInputStream)
+    {
+        UInt     returnValue;
+        UInt     offset;
+        UInt     bitIndex;
+        UChar    *pElem;        /* Needs to be same type as pInput->pBuffer */
+
+        offset = (pInputStream->usedBits) >> INBUF_ARRAY_INDEX_SHIFT;
+
+        pElem = pInputStream->pBuffer + offset;
+
+#if CHECK_INPUT_BUFFER_LIMITS
+        returnValue = (offset < pInputStream->inputBufferCurrentLength) ? ((UInt) * (pElem)) : 0;
+#else
+        returnValue = ((UInt32) * (pElem));
+#endif
+
+
+        /* Remove extra high bits by shifting up */
+        bitIndex = (UInt)((pInputStream->usedBits++) & INBUF_BIT_MODULO_MASK);
+
+        /* This line is faster way to mask off the high bits. */
+        returnValue = 0xFF & (returnValue << (bitIndex));
+
+        /* Move the field down. */
+
+        return ((UInt)(returnValue >> 7));
+
+    }
+
+
+
+    __inline UInt get9_n_lessbits(
+        const UInt  neededBits,
+        BITS       *pInputStream)
+
+    {
+        UInt     returnValue;
+        UInt     offset;
+        UInt     bitIndex;
+        UChar    *pElem;        /* Needs to be same type as pInput->pBuffer */
+
+        offset = (pInputStream->usedBits) >> INBUF_ARRAY_INDEX_SHIFT;
+
+        pElem = pInputStream->pBuffer + offset;
+
+#if CHECK_INPUT_BUFFER_LIMITS
+
+
+        offset =  pInputStream->inputBufferCurrentLength - offset;
+        /*  check if access to input buffer does not go beyond boundaries */
+        if (offset > 1)
+        {
+            returnValue = (((UInt32) * (pElem)) << 8) |
+                          ((UInt32) * (pElem + 1));
+        }
+        else  /*  then access only available bytes  */
+        {
+            /*  Access to the bitstream beyond frame boundaries are not allowed,
+             *  Here, only what was available before the end of the frame will
+             *  be processed. Non-accessible bytes will be filled in with zeros.
+             *  Zero values guarantees that the data structures are filled in with values
+             *  that eventually will signal an error (like invalid parameters) or that allow
+             *  completion of the parsing routine.
+             *  Overrun is detected on file pvmp4audiodecodeframe.cpp
+             */
+            switch (offset)
+            {
+                case 1:
+                    returnValue  = (((UInt32) * (pElem)) << 8);
+                    break;
+                default:
+                    returnValue = 0;
+                    break;
+            }
+        }
+
+
+#else
+        returnValue = (((UInt32) * (pElem)) << 8) |
+                      ((UInt32) * (pElem + 1)) ;
+#endif
+
+        /* Remove extra high bits by shifting up */
+        bitIndex = (UInt)((pInputStream->usedBits) & INBUF_BIT_MODULO_MASK);
+
+        pInputStream->usedBits += neededBits;
+
+        /* This line is faster way to mask off the high bits. */
+        returnValue = 0xFFFF & (returnValue << (bitIndex));
+
+        /* Move the field down. */
+
+        return (UInt)(returnValue >> (16 - neededBits));
+
+    }
+
+    __inline UInt32 get17_n_lessbits(
+        const UInt  neededBits,
+        BITS       *pInputStream)
+    {
+        UInt32   returnValue;
+        UInt     offset;
+        UInt     bitIndex;
+        UChar    *pElem;        /* Needs to be same type as pInput->pBuffer */
+
+        offset = (pInputStream->usedBits) >> INBUF_ARRAY_INDEX_SHIFT;
+
+        pElem = pInputStream->pBuffer + offset;
+
+#if CHECK_INPUT_BUFFER_LIMITS
+
+        offset =  pInputStream->inputBufferCurrentLength - offset;
+        /*  check if access to input buffer does not go beyond boundaries */
+
+        if (offset > 2)
+        {
+            returnValue = (((UInt32) * (pElem)) << 16) |
+                          (((UInt32) * (pElem + 1)) << 8) |
+                          ((UInt32)  * (pElem + 2));
+        }
+        else   /*  then access only available bytes  */
+        {
+            /*  Access to the bitstream beyond frame boundaries are not allowed,
+             *  Here, only what was available before the end of the frame will
+             *  be processed. Non-accessible bytes will be filled in with zeros.
+             *  Zero values guarantees that the data structures are filled in with values
+             *  that eventually will signal an error (like invalid parameters) or that allow
+             *  completion of the parsing routine.
+             *  Overrun is detected on file pvmp4audiodecodeframe.cpp
+             */
+            returnValue = 0;
+            switch (offset)
+            {
+                case 2:
+                    returnValue  = (((UInt32) * (pElem + 1)) << 8);
+                case 1:
+                    returnValue |= (((UInt32) * (pElem)) << 16);
+                default:
+                    break;
+            }
+        }
+
+#else
+
+        returnValue = (((UInt32) * (pElem)) << 16) |
+                      (((UInt32) * (pElem + 1)) << 8) |
+                      ((UInt32)  * (pElem + 2));
+#endif
+
+        /* Remove extra high bits by shifting up */
+        bitIndex = (UInt)((pInputStream->usedBits) & INBUF_BIT_MODULO_MASK);
+
+        /* This line is faster way to mask off the high bits. */
+        returnValue = 0xFFFFFF & (returnValue << (bitIndex));
+
+        /* Move the field down. */
+        returnValue = returnValue >> (24 - neededBits);
+
+        pInputStream->usedBits += neededBits;
+
+        return (returnValue);
+
+    }
+
+#ifdef __cplusplus
+}
+#endif
+
+/*----------------------------------------------------------------------------
+; END
+----------------------------------------------------------------------------*/
+#endif /* GETBITS_H*/
+
+
diff --git a/media/libstagefright/codecs/aacdec/getfill.cpp b/media/libstagefright/codecs/aacdec/getfill.cpp
new file mode 100644
index 0000000..3c4fc4c
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/getfill.cpp
@@ -0,0 +1,247 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Pathname: getfill.c
+ Funtions: getfill
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+ Description:  Modified from original shareware code
+
+ Description:  Modified to pass variables by reference to eliminate use
+               of global variables.
+
+ Description:  1. Used template to re-organize function and filled out
+                  Input/Output and Function definition section.
+               2. Optimized code.
+
+ Description:  Made the following changes based on review comments.
+               1. Exchanging MODIFYING and RETURNING on line 87, 88.
+               2. Added MPEG reference.
+               3. Changed "fill" to "pass over", "bitstreams are" to
+                  "bitstream is" in FUNCTION DESCRIPTION section.
+               4. Fixed tabs.
+
+ Description: Replace some instances of getbits to get9_n_lessbits
+              when the number of bits read is 9 or less.
+
+ Who:                                   Date:
+ Description:
+
+------------------------------------------------------------------------------
+ INPUT AND OUTPUT DEFINITIONS
+
+ Inputs:
+    pInputStream = pointer to structure BITS containing input stream
+                   information.
+
+ Local Stores/Buffers/Pointers Needed:
+    None
+
+ Global Stores/Buffers/Pointers Needed:
+    None
+
+ Outputs:
+    None
+
+ Pointers and Buffers Modified:
+    pInputStream->usedBits is updated to the newly calculated value.
+
+ Local Stores Modified:
+    None
+
+ Global Stores Modified:
+    None
+
+------------------------------------------------------------------------------
+ FUNCTION DESCRIPTION
+
+ This function passes over fill bits in the raw data block to adjust the
+ instantaneous bit rate when the bitstream is to be transmitted over a
+ constant rate channel.
+
+------------------------------------------------------------------------------
+ REQUIREMENTS
+
+ None
+
+------------------------------------------------------------------------------
+ REFERENCES
+
+ (1) MPEG-2 NBC Audio Decoder
+
+   "This software module was originally developed by AT&T, Dolby
+   Laboratories, Fraunhofer Gesellschaft IIS in the course of development
+   of the MPEG-2 NBC/MPEG-4 Audio standard ISO/IEC 13818-7, 14496-1,2 and
+   3. This software module is an implementation of a part of one or more
+   MPEG-2 NBC/MPEG-4 Audio tools as specified by the MPEG-2 NBC/MPEG-4
+   Audio standard. ISO/IEC  gives users of the MPEG-2 NBC/MPEG-4 Audio
+   standards free license to this software module or modifications thereof
+   for use in hardware or software products claiming conformance to the
+   MPEG-2 NBC/MPEG-4 Audio  standards. Those intending to use this software
+   module in hardware or software products are advised that this use may
+   infringe existing patents. The original developer of this software
+   module and his/her company, the subsequent editors and their companies,
+   and ISO/IEC have no liability for use of this software module or
+   modifications thereof in an implementation. Copyright is not released
+   for non MPEG-2 NBC/MPEG-4 Audio conforming products.The original
+   developer retains full right to use the code for his/her own purpose,
+   assign or donate the code to a third party and to inhibit third party
+   from using the code for non MPEG-2 NBC/MPEG-4 Audio conforming products.
+   This copyright notice must be included in all copies or derivative
+   works."
+   Copyright(c)1996.
+
+ (2) ISO/IEC 14496-3: 1999(E)
+     Subpart 4      p15     (Table 4.4.11)
+
+------------------------------------------------------------------------------
+ PSEUDO-CODE
+
+    CALL getbits(
+            LEN_F_CNT,
+            pInputStream);
+    MODIFYING (pInputStream)
+    RETURNING (cnt)
+
+    IF ( cnt == (1<<LEN_F_CNT)-1 )
+
+        CALL getbits(
+                LEN_F_ESC,
+                pInputStream);
+        MODIFYING (pInputStream)
+        RETURNING (esc_cnt)
+
+        cnt +=  esc_cnt - 1;
+
+    ENDIF
+
+    pInputStream->usedBits += cnt * LEN_BYTE;
+
+------------------------------------------------------------------------------
+ RESOURCES USED
+   When the code is written for a specific target processor the
+     the resources used should be documented below.
+
+ STACK USAGE: [stack count for this module] + [variable to represent
+        stack usage for each subroutine called]
+
+     where: [stack usage variable] = stack usage for [subroutine
+        name] (see [filename].ext)
+
+ DATA MEMORY USED: x words
+
+ PROGRAM MEMORY USED: x words
+
+ CLOCK CYCLES: [cycle count equation for this module] + [variable
+           used to represent cycle count for each subroutine
+           called]
+
+     where: [cycle count variable] = cycle count for [subroutine
+        name] (see [filename].ext)
+
+------------------------------------------------------------------------------
+*/
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+#include "pv_audio_type_defs.h"
+#include "s_bits.h"
+#include "ibstream.h"
+#include "e_rawbitstreamconst.h"
+#include "getfill.h"
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here. Include conditional
+; compile variables also.
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; LOCAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; LOCAL VARIABLE DEFINITIONS
+; Variable declaration - defined here and used outside this module
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL FUNCTION REFERENCES
+; Declare functions defined elsewhere and referenced in this module
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL GLOBAL STORE/BUFFER/POINTER REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; FUNCTION CODE
+----------------------------------------------------------------------------*/
+
+void getfill(BITS *pInputStream)
+{
+    /*----------------------------------------------------------------------------
+    ; Define all local variables
+    ----------------------------------------------------------------------------*/
+    Int cnt;
+    Int esc_cnt;
+
+    /*----------------------------------------------------------------------------
+    ; Function body here
+    ----------------------------------------------------------------------------*/
+
+    cnt = get9_n_lessbits(
+              LEN_F_CNT,
+              pInputStream);
+
+    if (cnt == (1 << LEN_F_CNT) - 1)  /* if (cnt == 15) */
+    {
+        esc_cnt = get9_n_lessbits(
+                      LEN_F_ESC,
+                      pInputStream);
+
+        cnt +=  esc_cnt - 1;
+    }
+
+    /*
+     * The following codes are replaced by directly updating usedBits
+     * in BITS structure. This will save one call for getbits().
+     *
+     * for (i=0; i<cnt; i++)
+     * { getbits(LEN_BYTE, pInputStream); }
+     */
+
+    pInputStream->usedBits += cnt * LEN_BYTE;
+
+    /*----------------------------------------------------------------------------
+    ; Return nothing or data or data pointer
+    ----------------------------------------------------------------------------*/
+
+} /* getfill */
+
diff --git a/media/libstagefright/codecs/aacdec/getfill.h b/media/libstagefright/codecs/aacdec/getfill.h
new file mode 100644
index 0000000..3ba976a
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/getfill.h
@@ -0,0 +1,88 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Pathname: getfill.h
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+ Description: Changed "definition" to "declaration" on line 28 per
+              review comments.
+
+ Who:                           Date:
+ Description:
+
+------------------------------------------------------------------------------
+ INCLUDE DESCRIPTION
+
+ This file contains prototype declaration for getfill function.
+
+------------------------------------------------------------------------------
+*/
+
+/*----------------------------------------------------------------------------
+; CONTINUE ONLY IF NOT ALREADY DEFINED
+----------------------------------------------------------------------------*/
+#ifndef GETFILL_H
+#define GETFILL_H
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+#include "s_bits.h"
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here.
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL VARIABLES REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; SIMPLE TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; ENUMERATED TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; STRUCTURES TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; GLOBAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+void getfill(BITS    *pInputStream);
+
+/*----------------------------------------------------------------------------
+; END
+----------------------------------------------------------------------------*/
+#endif
+
+
diff --git a/media/libstagefright/codecs/aacdec/getgroup.cpp b/media/libstagefright/codecs/aacdec/getgroup.cpp
new file mode 100644
index 0000000..0f909cd
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/getgroup.cpp
@@ -0,0 +1,255 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Pathname: getgroup.c
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+ Description:  Modified from original shareware code
+
+ Description:  Modified to pass variables by reference to eliminate use
+               of global variables.
+
+ Description: (1) Modified to bring code in-line with PV standards
+              (2) Eliminated if(first_short) statement, move for-loop
+                  inside if statement
+              (3) Modified UChar -> Int on data types of group
+
+ Description: Replace some instances of getbits to get9_n_lessbits
+              when the number of bits read is 9 or less.
+
+ Who:                       Date: MM/DD/YYYY
+ Description:
+
+------------------------------------------------------------------------------
+ INPUT AND OUTPUT DEFINITIONS
+
+ Inputs:
+    pInputStream = pointer to structure that holds input bitstream
+                   information. Type BITS
+
+    group[]     = array that holds the index of the first window in each
+                  group. Type Int
+
+ Local Stores/Buffers/Pointers Needed:
+    None
+
+ Global Stores/Buffers/Pointers Needed:
+    None
+
+ Outputs:
+    None
+
+ Pointers and Buffers Modified:
+    group   contains the index of first windows in each group
+
+ Local Stores Modified:
+    None
+
+ Global Stores Modified:
+    None
+
+------------------------------------------------------------------------------
+ FUNCTION DESCRIPTION
+
+ This function reads the window grouping information associated with an
+ Individual Channel Stream (ICS). If the window sequence is
+ EIGHT_SHORT_SEQUENCE, scalefactor grouping information is transmitted. If a
+ set of short windows form a group then they share scalefactors, intensity
+ positions and PNS information. The first short window is always a new group
+ so no grouping bit is transmitted. Subsequent short windows are in the same
+ group if the associated grouping bit is 1. A new group is started if the
+ associated grouping bit is 0.
+ The pointer pGroup points to an array that stores the first window index
+ of next group. For example, if the window grouping is:
+
+ window index:    |  0  |  1  |  2  |  3  |  4  |  5  |  6  |  7  |
+ grouping    :    |<-   0   ->|  1  |<-    2        ->|<-   3   ->|
+
+ Then:
+
+    group[]  :    |     2     |  3  |        6        |     8     |
+
+------------------------------------------------------------------------------
+ REQUIREMENTS
+
+ This function should replace the contents of the array pointed to by pGroup
+ with the first window indexes of groups starting from the second group.
+
+------------------------------------------------------------------------------
+ REFERENCES
+
+ (1) MPEG-2 NBC Audio Decoder
+   "This software module was originally developed by AT&T, Dolby
+   Laboratories, Fraunhofer Gesellschaft IIS in the course of development
+   of the MPEG-2 NBC/MPEG-4 Audio standard ISO/IEC 13818-7, 14496-1,2 and
+   3. This software module is an implementation of a part of one or more
+   MPEG-2 NBC/MPEG-4 Audio tools as specified by the MPEG-2 NBC/MPEG-4
+   Audio standard. ISO/IEC  gives users of the MPEG-2 NBC/MPEG-4 Audio
+   standards free license to this software module or modifications thereof
+   for use in hardware or software products claiming conformance to the
+   MPEG-2 NBC/MPEG-4 Audio  standards. Those intending to use this software
+   module in hardware or software products are advised that this use may
+   infringe existing patents. The original developer of this software
+   module and his/her company, the subsequent editors and their companies,
+   and ISO/IEC have no liability for use of this software module or
+   modifications thereof in an implementation. Copyright is not released
+   for non MPEG-2 NBC/MPEG-4 Audio conforming products.The original
+   developer retains full right to use the code for his/her own purpose,
+   assign or donate the code to a third party and to inhibit third party
+   from using the code for non MPEG-2 NBC/MPEG-4 Audio conforming products.
+   This copyright notice must be included in all copies or derivative
+   works."
+   Copyright(c)1996.
+
+ (2) ISO/IEC 14496-3: 1999(E)
+    Subpart 4
+                    p16 (Table 4.4.6)
+                    p55 (Recovering ics_info)
+
+------------------------------------------------------------------------------
+ PSEUDO-CODE
+
+    IF (pFrameInfo->coef_per_win[0] > SN2)
+
+        *pGroup++ = 1;
+        *pGroup   = 1;
+
+    ELSE
+
+        FOR (win = 1; win < pFrameInfo->num_win; win++)
+
+            IF (getbits(1,pInputStream) == 0)
+
+                *pGroup++ = win;
+
+            ENDIF
+
+        ENDFOR (win)
+
+        *pGroup = win;
+
+    ENDIF(pFrameInfo)
+
+------------------------------------------------------------------------------
+ RESOURCES USED
+   When the code is written for a specific target processor the
+     the resources used should be documented below.
+
+ STACK USAGE: [stack count for this module] + [variable to represent
+          stack usage for each subroutine called]
+
+     where: [stack usage variable] = stack usage for [subroutine
+         name] (see [filename].ext)
+
+ DATA MEMORY USED: x words
+
+ PROGRAM MEMORY USED: x words
+
+ CLOCK CYCLES: [cycle count equation for this module] + [variable
+           used to represent cycle count for each subroutine
+           called]
+
+     where: [cycle count variable] = cycle count for [subroutine
+        name] (see [filename].ext)
+
+------------------------------------------------------------------------------
+*/
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+#include    "pv_audio_type_defs.h"
+#include    "huffman.h"
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here. Include conditional
+; compile variables also.
+----------------------------------------------------------------------------*/
+#define     SEVEN   7
+
+/*----------------------------------------------------------------------------
+; LOCAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; LOCAL STORE/BUFFER/POINTER DEFINITIONS
+; Variable declaration - defined here and used outside this module
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL FUNCTION REFERENCES
+; Declare functions defined elsewhere and referenced in this module
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL GLOBAL STORE/BUFFER/POINTER REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; FUNCTION CODE
+----------------------------------------------------------------------------*/
+void getgroup(
+    Int         group[],
+    BITS        *pInputStream)
+{
+    Int      win;
+    Int     *pGroup;
+    UInt     mask;
+    UInt     groupBits;
+
+    pGroup      = group;
+
+    mask        = 0x40;
+
+    /* only short-window sequences are grouped!
+     * first short window is always a new group,
+     * start reading bitstream from the second
+     * window, a new group is indicated by an
+     * "0" bit in the input stream
+     */
+    groupBits =
+        get9_n_lessbits(
+            SEVEN,
+            pInputStream);
+
+    for (win = 1; win < NUM_SHORT_WINDOWS; win++)
+    {
+        if ((groupBits & mask) == 0)
+        {
+            *pGroup++ = win;
+
+        } /* if (groupBits) */
+
+        mask >>= 1;
+
+    } /* for (win) */
+
+    *pGroup = win;
+
+} /* getgroup */
diff --git a/media/libstagefright/codecs/aacdec/getics.cpp b/media/libstagefright/codecs/aacdec/getics.cpp
new file mode 100644
index 0000000..8d76744
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/getics.cpp
@@ -0,0 +1,674 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Pathname: getics.c
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+ Description:  Modified from original shareware code
+
+ Description:  Modified to pass variables by reference to eliminate use
+               of global variables
+
+ Description: Remove pass-in parameter global_gain, define it on stack.
+
+ Description: (1) Modified to bring in-line with PV standards
+              (2) Modified pass in parameters
+              (3) Removed multiple returns, removed some if branch
+              (4) Replace for loop with pv_memset
+
+ Description: Remove prstflag, fix copyright.
+
+ Description: Fix pseudo-code
+
+ Description: Remove lpflag from get_ics_info
+
+ Description: (1) Removed widx, therefore, pChVarsWin is eliminated from
+                  pass in parameter
+
+ Description: merged the above changes from Michael and Wen
+
+ Description: Removed initialization of "pTnsFrameInfo->num_subblocks" since
+ this element was removed from that structure, as a part of
+ rearchitecting the TNS routines to use memory more efficiently.
+
+ Description:
+ (1) Added #include of "e_HuffmanConst.h"
+     Previously, this function was relying on another include file
+     to include "e_HuffmanConst.h"
+
+ (2) Updated the copyright header.
+
+ (3) Added #include of <stdlib.h> for NULL macro definition.
+
+ Description:
+ (1) Removed the first parameter to getics.c  This extra
+     FrameInfo was not needed, the contents of winmap can be used.
+ (2) Removed the memcpy of the data from winmap to the temporary
+     FrameInfo.
+
+ Description: Replace some instances of getbits to get1bits
+              when only 1 bit is read.
+
+ Description:
+
+------------------------------------------------------------------------------
+ INPUT AND OUTPUT DEFINITIONS
+
+ Inputs:
+    pInputStream    =   pointer to structure that holds input stream,
+                        Type BITS
+
+    common_window   =   flag that indicates whether left and right channel
+                        share the same window sequence & shape, Type Int
+
+    pVars           =   pointer to structure that holds decoder information
+                        Type tDec_Int_File
+
+    pChVarsCh       =   pointer to structure that holds channel related
+                        decoding information, Type tDec_Int_Chan
+
+    group[]         =   pointer to array that contains window grouping
+                        information of current frame, Type UChar
+
+    pMax_sfb        =   pointer to variable that stores maximum active
+                        scalefactor bands of current frame, Type UChar
+
+    pCodebookMap    =   pointer to array that holds the indexes of all
+                        Huffman codebooks used for current frame, ordered
+                        from section 0 to last section. Type UChar
+
+    pTnsFrameInfo   =   pointer to structure that holds TNS information.
+                        Type TNS_frame_info
+
+    pWinMap         =   array of pointers which points to structures that
+                        hold information of long and short window sequences
+                        Type FrameInfo
+
+    pPulseInfo       =   pointer to structure that holds pulse data decoding
+                        information, Type Nec_info
+
+    sect[]          =   array of structures that hold section codebook and
+                        section length in current frame, Type SectInfo
+
+ Local Stores/Buffers/Pointers Needed:
+    None
+
+ Global Stores/Buffers/Pointers Needed:
+    None
+
+ Outputs:
+    status = 0  if success
+             1  otherwise
+
+ Pointers and Buffers Modified:
+    pCodebookMap    contents are replaced by the indexes of all the huffman
+                    codebooks used for current frame
+
+    pWinMap         For short windows, the contents of frame_sfb_top are
+                    modified by calc_gsfb_table, with the top coefficient
+                    index of each scalefactor band.
+
+ Local Stores Modified:
+    None
+
+ Global Stores Modified:
+    None
+
+------------------------------------------------------------------------------
+ FUNCTION DESCRIPTION
+
+ This function decodes individual channel stream by calling other Huffman
+ decoding functions.
+
+------------------------------------------------------------------------------
+ REQUIREMENTS
+
+ This function replaces the contents of pCodebookMap with the decoded
+ codebook indexes. By calling hufffac, it decodes scale factor data. Call
+ huffspec_fxp to decode spectral coefficients of current frame.
+
+------------------------------------------------------------------------------
+ REFERENCES
+
+ (1) MPEG-2 NBC Audio Decoder
+   "This software module was originally developed by AT&T, Dolby
+   Laboratories, Fraunhofer Gesellschaft IIS in the course of development
+   of the MPEG-2 NBC/MPEG-4 Audio standard ISO/IEC 13818-7, 14496-1,2 and
+   3. This software module is an implementation of a part of one or more
+   MPEG-2 NBC/MPEG-4 Audio tools as specified by the MPEG-2 NBC/MPEG-4
+   Audio standard. ISO/IEC  gives users of the MPEG-2 NBC/MPEG-4 Audio
+   standards free license to this software module or modifications thereof
+   for use in hardware or software products claiming conformance to the
+   MPEG-2 NBC/MPEG-4 Audio  standards. Those intending to use this software
+   module in hardware or software products are advised that this use may
+   infringe existing patents. The original developer of this software
+   module and his/her company, the subsequent editors and their companies,
+   and ISO/IEC have no liability for use of this software module or
+   modifications thereof in an implementation. Copyright is not released
+   for non MPEG-2 NBC/MPEG-4 Audio conforming products.The original
+   developer retains full right to use the code for his/her own purpose,
+   assign or donate the code to a third party and to inhibit third party
+   from using the code for non MPEG-2 NBC/MPEG-4 Audio conforming products.
+   This copyright notice must be included in all copies or derivative
+   works."
+   Copyright(c)1996.
+
+ (2) ISO/IEC 14496-3: 1999(E)
+    Subpart 4           p24 (Table 4.4.24)
+                        p54 (4.5.2.3.2)
+
+------------------------------------------------------------------------------
+ PSEUDO-CODE
+
+    pGroup = group;
+
+    global_gain = CALL getbits(
+                            neededBits   = LEN_SCL_PCM,
+                            pInputStream = pInputStream)
+                        MODIFYING(pInputStream)
+                        ReTURNING(global_gain)
+
+    IF (common_window == FALSE)
+    THEN
+        status = CALL get_ics_info(
+                        pVars->mc_info.audioObjectType,
+                        pInputStream,
+                        common_window,
+                       &pChVars->wnd,
+                       &pChVars->wnd_shape_this_bk,
+                        group,
+                        pMax_sfb,
+                        pWinMap,
+                        &pChVars->lt_status,
+                        NULL)
+                    MODIFYING(pInputStream,pChVars,group,max_sfb,lt_status)
+                    RETURNING(status)
+    ENDIF
+
+    memcpy(pFrameInfo, pWinMap[pChVars->wnd], sizeof(FrameInfo))
+
+    IF (*pMax_sfb > 0)
+    THEN
+
+        i      = 0;
+        totSfb = 0;
+
+        DO
+
+            totSfb++;
+
+        WHILE( *pGroup++ < pFrameInfo->num_win);
+
+        totSfb  *=  pFrameInfo->sfb_per_win[0];
+
+        nsect = CALL huffcb(
+                        sect,
+                        pInputStream,
+                        pFrameInfo->sectbits,
+                        totSfb,
+                        pFrameInfo->sfb_per_win[0],
+                       *pMax_sfb)
+                    MODIFYING(sect,pInputStream,sectbits)
+                    RETURNING(nsect)
+
+        IF (nsect == 0)
+        THEN
+            status = 1
+
+        ENDIF
+
+        sectStart = 0;
+        FOR (i = 0; i < nsect; i++)
+
+            cb  = sect[i].sect_cb;
+            sectWidth =  sect[i].sect_end - sectStart;
+            sectStart += sectWidth;
+
+            WHILE (sectWidth > 0)
+
+                *pCodebookMap++ = cb
+                 sectWidth--
+            ENDWHILE
+
+        ENDFOR (i)
+
+    ELSE
+
+        memset(pCodebookMap,ZERO_HCB,MAXBANDS*sizeof(*pCodebookMap));
+
+    ENDIF (*pMax_sfb)
+
+    IF (pFrameInfo->islong == FALSE)
+    THEN
+        CALL calc_gsfb_table(
+                pFramInfo = pFrameInfo,
+                group[]   = group)
+              MODIFYING(pFrameInfo->frame_sfb_top)
+              RETURNING(void)
+    ENDIF
+
+    IF (status == SUCCESS)
+    THEN
+        status = CALL hufffac(
+                        pFrameInfo,
+                        pInputStream,
+                        group,
+                        nsect,
+                        sect,
+                        global_gain,
+                        pChVars->factors,
+                        pVars->huffBookUsed)
+                    MODIFYING(pInputStream,factors)
+                    RETURNING(status)
+
+    ENDIF (status)
+
+    IF (status == SUCCESS)
+    THEN
+        present = CALL getbits(
+                        neededBits   = LEN_PULSE_PRES,
+                        pInputStream = pInputStream)
+                    MODIFYING(pInputStream)
+                    RETURNING(present)
+
+        pPulseInfo->pulse_data_present = present;
+
+        IF (present != FALSE)
+        THEN
+            IF (pFrameInfo->islong == 1)
+            THEN
+                CALL get_pulse_data(
+                          pPulseInfo = pPulseInfo,
+                          pInputStream = pInputStream)
+                    MODIFYING(pInputStream,pPulseInfo)
+                    RETURNING(void)
+
+            ELSE
+
+                status = 1;
+
+            ENDIF (pFrameInfo)
+        ENDIF (present)
+
+    ENDIF (status)
+
+    IF (status == SUCCESS)
+    THEN
+        present = CALL getbits(
+                        neededBits = LEN_TNS_PRES,
+                        pInputStream = pInputStream)
+                    MODIFYING(pInputStream)
+                    RETURNING(present)
+
+        pTnsFrameInfo->tns_data_present = present;
+
+        IF (present != FALSE)
+        THEN
+            CALL get_tns(
+                    pFrameInfo = pFrameInfo,
+                    pTnsFrameInfo = pTnsFrameInfo,
+                    pInputStream = pInputStream)
+                MODIFYING(pInputStream, pTnsFrameInfo)
+                RETURNING(void)
+        ELSE
+
+            FOR (i = pTnsFrameInfo->n_subblocks - 1; i >= 0 ; i--)
+
+                pTnsFrameInfo->info[i].n_filt = 0;
+            ENDFOR
+
+        ENDIF(present)
+
+    ENDIF (status)
+
+    IF (status == SUCCESS)
+    THEN
+        present = CALL getbits(
+                        neededBits = LEN_GAIN_PRES,
+                        pInputStream = pInputStream)
+                MODIFYING(pInputStream)
+                RETURNING(present)
+
+        IF (present != FALSE)
+        THEN
+            status = 1;
+        ENDIF
+    ENDIF (status)
+
+    IF (status == SUCCESS)
+    THEN
+        status = CALL huffspec_fxp(
+                        pFrameInfo,
+                        pInputStream,
+                        nsect,
+                        sect,
+                        pChVars->factors,
+                        pChVars->fxpCoef,
+                        pVars->quantSpec,
+                        pVars->tmp_spec,
+                        pWinMap[ONLY_LONG_WINDOW],
+                        pPulseInfo,
+                        pChVars->qFormat)
+                MODIFYING(pInputStream,fxpCoef,quantSpec,tmp_spec,qFormat)
+                RETURNING(status)
+    ENDIF
+
+    RETURN status
+
+------------------------------------------------------------------------------
+*/
+
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+#include    "pv_audio_type_defs.h"
+#include    "e_huffmanconst.h"
+#include    "huffman.h"
+#include    "aac_mem_funcs.h"
+#include    "get_tns.h"
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here. Include conditional
+; compile variables also.
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; LOCAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; LOCAL STORE/BUFFER/POINTER DEFINITIONS
+; Variable declaration - defined here and used outside this module
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL FUNCTION REFERENCES
+; Declare functions defined elsewhere and referenced in this module
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL GLOBAL STORE/BUFFER/POINTER REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; FUNCTION CODE
+----------------------------------------------------------------------------*/
+Int getics(
+    BITS            *pInputStream,
+    Int             common_window,
+    tDec_Int_File   *pVars,
+    tDec_Int_Chan   *pChVars,
+    Int             group[],
+    Int             *pMax_sfb,
+    Int             *pCodebookMap,
+    TNS_frame_info  *pTnsFrameInfo,
+    FrameInfo       **pWinMap,
+    PulseInfo       *pPulseInfo,
+    SectInfo        sect[])
+{
+    /*----------------------------------------------------------------------------
+    ; Define all local variables
+    ----------------------------------------------------------------------------*/
+    Int     status = SUCCESS;
+
+    Int     nsect = 0;
+    Int     i;
+    Int     cb;
+    Int     sectWidth;
+    Int     sectStart;
+    Int     totSfb;
+    Int     *pGroup;
+
+    FrameInfo *pFrameInfo;
+
+    Int     global_gain; /* originally passed in from huffdecode */
+    Bool    present;
+
+    /*----------------------------------------------------------------------------
+    ; Function body here
+    ----------------------------------------------------------------------------*/
+    pGroup = group;
+
+    /* read global gain from Input bitstream */
+    global_gain =
+        get9_n_lessbits(
+            LEN_SCL_PCM,
+            pInputStream);
+
+    if (common_window == FALSE)
+    {
+        status = get_ics_info(
+                     pVars->mc_info.audioObjectType,
+                     pInputStream,
+                     common_window,
+                     &pChVars->wnd,
+                     &pChVars->wnd_shape_this_bk,
+                     group,
+                     pMax_sfb,
+                     pWinMap,
+                     &pChVars->pShareWfxpCoef->lt_status,
+                     NULL);
+    }
+
+    pFrameInfo = pWinMap[pChVars->wnd];
+
+    /* First, calculate total number of scalefactor bands
+     * for this grouping. Then, decode section data
+     */
+    if (*pMax_sfb > 0)
+    {
+
+        /* calculate total number of sfb */
+        i      = 0;
+        totSfb = 0;
+
+        do
+        {
+            totSfb++;
+
+        }
+        while (*pGroup++ < pFrameInfo->num_win);
+
+        totSfb  *=  pFrameInfo->sfb_per_win[0];
+
+        /* decode section data */
+        nsect =
+            huffcb(
+                sect,
+                pInputStream,
+                pFrameInfo->sectbits,
+                totSfb,
+                pFrameInfo->sfb_per_win[0],
+                *pMax_sfb);
+
+        if (nsect == 0)
+        {
+            status = 1;     /* decode section data error */
+
+        }/* if (nsect) */
+
+        /* generate "linear" description from section info
+         * stored as codebook for each scalefactor band and group
+         * when nsect == 0, for-loop does not execute
+         */
+        sectStart = 0;
+        for (i = 0; i < nsect; i++)
+        {
+            cb  = sect[i].sect_cb;
+            sectWidth =  sect[i].sect_end - sectStart;
+            sectStart += sectWidth;
+
+            while (sectWidth > 0)
+            {
+                *pCodebookMap++ = cb;   /* cannot use memset for Int */
+                sectWidth--;
+            }
+
+        } /* for (i) */
+
+    }
+    else
+    {
+        /* set all sections with ZERO_HCB */
+        pv_memset(
+            pCodebookMap,
+            ZERO_HCB,
+            MAXBANDS*sizeof(*pCodebookMap));
+        /*
+                for (i=MAXBANDS; i>0; i--)
+                {
+                    *(pCodebookMap++) = ZERO_HCB;
+                }
+        */
+
+    } /* if (*pMax_sfb) */
+
+    /* calculate band offsets
+     * (because of grouping and interleaving this cannot be
+     * a constant: store it in pFrameInfo->frame_sfb_top)
+     */
+    if (pFrameInfo->islong == FALSE)
+    {
+        calc_gsfb_table(
+            pFrameInfo,
+            group);
+    }
+
+    /* decode scale factor data */
+    if (status == SUCCESS)
+    {
+        status =
+            hufffac(
+                pFrameInfo,
+                pInputStream,
+                group,
+                nsect,
+                sect,
+                global_gain,
+                pChVars->pShareWfxpCoef->factors,
+                pVars->scratch.huffbook_used);
+
+    } /* if (status) */
+
+    /* noiseless coding */
+    if (status == SUCCESS)
+    {
+        present =
+            get1bits(pInputStream);
+
+        pPulseInfo->pulse_data_present = present;
+
+        if (present != FALSE)
+        {
+            if (pFrameInfo->islong == 1)
+            {
+                status = get_pulse_data(
+                             pPulseInfo,
+                             pInputStream);
+            }
+            else
+            {
+                /* CommonExit(1,"Pulse data not allowed for short blocks"); */
+                status = 1;
+
+            } /* if (pFrameInfo) */
+        } /* if (present) */
+
+    } /* if (status) */
+
+
+    /* decode tns data */
+    if (status == SUCCESS)
+    {
+        present =
+            get1bits(pInputStream);
+
+        pTnsFrameInfo->tns_data_present = present;
+
+        if (present != FALSE)
+        {
+            get_tns(
+                pChVars->pShareWfxpCoef->max_sfb,
+                pInputStream,
+                pChVars->wnd,
+                pFrameInfo,
+                &pVars->mc_info,
+                pTnsFrameInfo,
+                pVars->scratch.tns_decode_coef);
+        }
+        else
+        {
+            for (i = pFrameInfo->num_win - 1; i >= 0 ; i--)
+            {
+                pTnsFrameInfo->n_filt[i] = 0;
+            }
+
+        } /* if(present) */
+
+    } /* if (status) */
+
+    /* gain control */
+    if (status == SUCCESS)
+    {
+        present =
+            get1bits(pInputStream);
+
+        if (present != FALSE)
+        {
+            /* CommonExit(1, "Gain control not implemented"); */
+            status = 1;
+        }
+    } /* if (status) */
+
+    if (status == SUCCESS)
+    {
+        status =
+            huffspec_fxp(
+                pFrameInfo,
+                pInputStream,
+                nsect,
+                sect,
+                pChVars->pShareWfxpCoef->factors,
+                pChVars->fxpCoef,
+                pVars->share.a.quantSpec,
+                pVars->scratch.tmp_spec,
+                pWinMap[ONLY_LONG_WINDOW],
+                pPulseInfo,
+                pChVars->pShareWfxpCoef->qFormat);
+    }
+
+    /*----------------------------------------------------------------------------
+    ; Return status
+    ----------------------------------------------------------------------------*/
+
+    return status;
+
+} /* getics */
diff --git a/media/libstagefright/codecs/aacdec/getmask.cpp b/media/libstagefright/codecs/aacdec/getmask.cpp
new file mode 100644
index 0000000..2fd34f1
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/getmask.cpp
@@ -0,0 +1,384 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Pathname: getmask.c
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+ Description:  Modified from original shareware code
+
+ Description:  Modified to pass variables by reference to eliminate use
+               of global variables.
+               Replaced for-loop style memory initialization with memset()
+
+ Description: (1) Modified to bring code in-line with PV standard
+              (2) Removed multiple returns, Replaced multiple 'if's with
+                  switch
+
+ Description: (1) Modified per review comments
+              (2) increment pointer pMask after memset
+
+ Description: Make the maximum number of bits requested from getbits
+              become a constant.
+
+ Description: Typecast 1 to UInt32 for bitmask to avoid masking on a 16-bit
+              platform
+
+ Description: Replace some instances of getbits to get9_n_lessbits
+              when the number of bits read is 9 or less.
+
+ Who:                                   Date: MM/DD/YYYY
+ Description:
+
+------------------------------------------------------------------------------
+ INPUT AND OUTPUT DEFINITIONS
+
+ Inputs:
+        pFrameInfo  = pointer to structure that holds information for current
+                      frame, Type FrameInfo
+
+        pInputStream= pointer to structure that holds input stream information
+                      Type BITS
+
+        pGroup      = pointer to array that holds the stop window index for
+                      each group in current frame, Type Int
+
+        max_sfb     = number of active sfbs for each window, Type Int
+
+        mask[]      = array that holds the MS_mask information
+                      Type Int
+
+ Local Stores/Buffers/Pointers Needed:
+    None
+
+ Global Stores/Buffers/Pointers Needed:
+    None
+
+ Outputs:
+    mask_present = 0    (no Mid/Side mixed)
+                   2    (Mid/Side mixed present for entire frame)
+                   1    (Mid/Side mixed information read from bitstream)
+                   -1   (invalid mask_present read from bitstream)
+
+ Pointers and Buffers Modified:
+    pMask   contents replaced by MS information of each scalefactor band
+
+ Local Stores Modified:
+    None
+
+ Global Stores Modified:
+    None
+
+------------------------------------------------------------------------------
+ FUNCTION DESCRIPTION
+
+ This function reads the Mid/Side(MS) mask information from the input
+ bitstream. If the mask_present field is equal to 2, the mask bits is set to
+ 1 for the entire frame. If mask_present has a value of 0, the function
+ returns 0, If mask_present is set to 1, the Mid/Side(MS) information is
+ read from the input stream. When mask_present is 3, an error code (-1) is
+ generated.
+ The Mid/Side(MS) information is later used for mixing the left and right
+ channel sounds. Each scalefactor band has its own MS information.
+
+ (ISO comments: read a synthesis mask,  read a synthesis mask uses
+                EXTENDED_MS_MASK and grouped mask )
+
+------------------------------------------------------------------------------
+ REQUIREMENTS
+
+ This function shall replace the contents of pMask with the MS information
+ of each scalefactor band
+
+------------------------------------------------------------------------------
+ REFERENCES
+
+ (1) MPEG-2 NBC Audio Decoder
+   "This software module was originally developed by AT&T, Dolby
+   Laboratories, Fraunhofer Gesellschaft IIS in the course of development
+   of the MPEG-2 NBC/MPEG-4 Audio standard ISO/IEC 13818-7, 14496-1,2 and
+   3. This software module is an implementation of a part of one or more
+   MPEG-2 NBC/MPEG-4 Audio tools as specified by the MPEG-2 NBC/MPEG-4
+   Audio standard. ISO/IEC  gives users of the MPEG-2 NBC/MPEG-4 Audio
+   standards free license to this software module or modifications thereof
+   for use in hardware or software products claiming conformance to the
+   MPEG-2 NBC/MPEG-4 Audio  standards. Those intending to use this software
+   module in hardware or software products are advised that this use may
+   infringe existing patents. The original developer of this software
+   module and his/her company, the subsequent editors and their companies,
+   and ISO/IEC have no liability for use of this software module or
+   modifications thereof in an implementation. Copyright is not released
+   for non MPEG-2 NBC/MPEG-4 Audio conforming products.The original
+   developer retains full right to use the code for his/her own purpose,
+   assign or donate the code to a third party and to inhibit third party
+   from using the code for non MPEG-2 NBC/MPEG-4 Audio conforming products.
+   This copyright notice must be included in all copies or derivative
+   works."
+   Copyright(c)1996.
+
+ (2) ISO/IEC 14496-3: 1999(E)
+    Subpart 4
+                    p15     (Table 4.4.5    getmask)
+
+------------------------------------------------------------------------------
+ PSEUDO-CODE
+
+    CALL getbits(LEN_MASK_PRES, pInputStream)
+    MODIFYING (pInputStream)
+    RETURNING (mask present information)
+    mask_present = mask present information
+
+    SWITCH (mask_present)
+
+        CASE (0):
+            BREAK;
+
+        CASE (2):
+            nwin = pFrameInfo->num_win;
+            FOR(win = 0; win < nwin; win = *(pGroup++))
+
+                FOR(sfb = pFrameInfo->sfb_per_win[win]; sfb > 0; sfb--)
+                    *(pMask++) = 1;
+                ENDFOR
+
+            ENDFOR
+
+            BREAK;
+
+        CASE(1):
+
+            nwin = pFrameInfo->num_win;
+
+                nToDo = max_sfb;
+
+                WHILE (nToDo > 0)
+                    nCall = nToDo;
+
+                    IF (nCall > MAX_GETBITS)
+                    THEN
+                        nCall = MAX_GETBITS;
+                    ENDIF
+
+                    tempMask =
+                        getbits(
+                            nCall,
+                            pInputStream);
+
+                    bitmask = 1 << (nCall - 1);
+                    FOR (sfb = nCall; sfb > 0; sfb--)
+                       *(pMask++) = (tempMask & bitmask) >> (sfb - 1);
+                        bitmask >>= 1;
+                    ENDFOR
+
+                    nToDo -= nCall;
+                END WHILE
+
+                pv_memset(
+                    pMask,
+                    0,
+                    (pFrameInfo->sfb_per_win[win]-max_sfb)*sizeof(*pMask));
+
+            ENDFOR (win)
+
+            BREAK
+
+        DEFAULT:
+            mask_present = -1
+
+    ENDSWITCH
+
+    RETURN  mask_present
+
+------------------------------------------------------------------------------
+*/
+
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+#include    "pv_audio_type_defs.h"
+#include    "huffman.h"
+#include    "aac_mem_funcs.h"
+#include    "e_maskstatus.h"
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here. Include conditional
+; compile variables also.
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; LOCAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; LOCAL STORE/BUFFER/POINTER DEFINITIONS
+; Variable declaration - defined here and used outside this module
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL FUNCTION REFERENCES
+; Declare functions defined elsewhere and referenced in this module
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL GLOBAL STORE/BUFFER/POINTER REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; FUNCTION CODE
+----------------------------------------------------------------------------*/
+Int getmask(
+    FrameInfo   *pFrameInfo,
+    BITS        *pInputStream,
+    Int         group[],
+    Int         max_sfb,
+    Int         mask[])
+{
+
+    Int     win; /* window index */
+    Int     sfb;
+    Int     mask_present;
+    Int    *pMask;
+    Int    *pGroup;
+    Int     nwin;
+    Int     nCall;
+    Int     nToDo;
+    UInt32  tempMask;
+    UInt32  bitmask;
+
+    pMask  = mask;
+    pGroup = group;
+
+    mask_present =
+        get9_n_lessbits(
+            LEN_MASK_PRES,
+            pInputStream);
+
+    switch (mask_present)
+    {
+        case(MASK_NOT_PRESENT):
+            /* special EXTENDED_MS_MASK cases */
+            /* no ms at all */
+            break;
+
+        case(MASK_ALL_FRAME):
+            /* MS for whole spectrum on, mask bits set to 1 */
+            nwin = pFrameInfo->num_win;
+            for (win = 0; win < nwin; win = *(pGroup++))
+            {
+                for (sfb = pFrameInfo->sfb_per_win[win]; sfb > 0; sfb--)
+                {
+                    *(pMask++) = 1; /* cannot use memset for Int type */
+                }
+
+            }
+
+            break;
+
+        case(MASK_FROM_BITSTREAM):
+            /* MS_mask_present==1, get mask information*/
+            nwin = pFrameInfo->num_win;
+            for (win = 0; win < nwin; win = *(pGroup++))
+            {
+                /*
+                 * the following code is equivalent to
+                 *
+                 * for(sfb = max_sfb; sfb > 0; sfb--)
+                 * {
+                 *   *(pMask++) =
+                 *       getbits(
+                 *           LEN_MASK,
+                 *           pInputStream);
+                 * }
+                 *
+                 * in order to save the calls to getbits, the above
+                 * for-loop is broken into two parts
+                 */
+
+                nToDo = max_sfb;
+
+                while (nToDo > 0)
+                {
+                    nCall = nToDo;
+
+                    if (nCall > MAX_GETBITS)
+                    {
+                        nCall = MAX_GETBITS;
+                    }
+
+                    tempMask =
+                        getbits(
+                            nCall,
+                            pInputStream);
+
+                    bitmask = (UInt32) 1 << (nCall - 1);
+                    for (sfb = nCall; sfb > 0; sfb--)
+                    {
+                        *(pMask++) = (Int)((tempMask & bitmask) >> (sfb - 1));
+                        bitmask >>= 1;
+                    }
+
+                    nToDo -= nCall;
+                }
+
+                /*
+                 * set remaining sfbs to zero
+                 * re-use nCall to save one variable on stack
+                 */
+
+                nCall = pFrameInfo->sfb_per_win[win] - max_sfb;
+
+
+                if (nCall >= 0)
+                {
+                    pv_memset(pMask,
+                              0,
+                              nCall*sizeof(*pMask));
+
+                    pMask += nCall;
+                }
+                else
+                {
+                    mask_present = MASK_ERROR;
+                    break;
+                }
+
+
+            } /* for (win) */
+
+            break;
+
+        default:
+            /* error */
+            break;
+
+    } /* switch (mask_present) */
+
+    return mask_present;
+
+} /* getmask */
diff --git a/media/libstagefright/codecs/aacdec/hcbtables.h b/media/libstagefright/codecs/aacdec/hcbtables.h
new file mode 100644
index 0000000..a35fed0
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/hcbtables.h
@@ -0,0 +1,118 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Pathname: hcbtables.h
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+ Description: (1) Add declaration of binary tree tables
+              (2) #if optimized Linear Search Huffman decoding
+
+ Description: Modified per review comments
+              (1) delete #if optimized Linear Search Huffman decoding
+              (2) modified copyright header
+
+ Description: (1) Add declaration different huffman tables
+
+ Who:                              Date:
+ Description:
+
+------------------------------------------------------------------------------
+ INCLUDE DESCRIPTION
+
+ Declare the structure array for Huffman Codebooks information.
+
+------------------------------------------------------------------------------
+*/
+
+/*----------------------------------------------------------------------------
+; CONTINUE ONLY IF NOT ALREADY DEFINED
+----------------------------------------------------------------------------*/
+#ifndef _HCBTABLES_H
+#define _HCBTABLES_H
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+    /*----------------------------------------------------------------------------
+    ; INCLUDES
+    ----------------------------------------------------------------------------*/
+#include    "s_hcb.h"
+
+    /*----------------------------------------------------------------------------
+    ; MACROS
+    ; Define module specific macros here
+    ----------------------------------------------------------------------------*/
+
+    /*----------------------------------------------------------------------------
+    ; DEFINES
+    ; Include all pre-processor statements here.
+    ----------------------------------------------------------------------------*/
+
+    /*----------------------------------------------------------------------------
+    ; EXTERNAL VARIABLES REFERENCES
+    ; Declare variables used in this module but defined elsewhere
+    ----------------------------------------------------------------------------*/
+
+    /* ISO: Hcb book[NSPECBOOKS + 2]; */
+
+    extern const Hcb hcbbook_binary[13];
+    extern const Int32 huff_tab1[88];
+    extern const Int32 huff_tab2[90];
+    extern const Int32 huff_tab3[151];
+    extern const Int32 huff_tab4[119];
+    extern const Int32 huff_tab5[110];
+    extern const Int32 huff_tab6[113];
+    extern const Int32 huff_tab7[107];
+    extern const Int32 huff_tab8[90];
+    extern const Int32 huff_tab9[204];
+    extern const Int32 huff_tab10[186];
+    extern const Int32 huff_tab11[301];
+    extern const UInt32 huff_tab_scl[188];
+
+    /*----------------------------------------------------------------------------
+    ; SIMPLE TYPEDEF'S
+    ----------------------------------------------------------------------------*/
+
+    /*----------------------------------------------------------------------------
+    ; ENUMERATED TYPEDEF'S
+    ----------------------------------------------------------------------------*/
+
+    /*----------------------------------------------------------------------------
+    ; STRUCTURES TYPEDEF'S
+    ----------------------------------------------------------------------------*/
+
+    /*----------------------------------------------------------------------------
+    ; GLOBAL FUNCTION DEFINITIONS
+    ; Function Prototype declaration
+    ----------------------------------------------------------------------------*/
+
+    /*----------------------------------------------------------------------------
+    ; END
+    ----------------------------------------------------------------------------*/
+#ifdef __cplusplus
+}
+#endif
+
+#endif
+
+
diff --git a/media/libstagefright/codecs/aacdec/hcbtables_binary.cpp b/media/libstagefright/codecs/aacdec/hcbtables_binary.cpp
new file mode 100644
index 0000000..d097af1
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/hcbtables_binary.cpp
@@ -0,0 +1,1938 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Pathname: hcbtables.c
+
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+ Description: Modifiy per review comments
+    (1) delete the following comments:
+        The LAV field has been deleted, since it is never used.
+
+ Description: Remove old structure of huffman table and add new table structure.
+
+ Description: Modified structure to avoid assigning addresses to constant
+              tables. This solve linking problem when using the
+              /ropi option (Read-only position independent) for some
+              compilers
+              - Eliminated references to contant vector addresses in
+                hcbbook_binary
+
+
+ Who:                       Date:
+ Description:
+
+------------------------------------------------------------------------------
+ INPUT AND OUTPUT DEFINITIONS
+
+ Inputs: None
+
+ Local Stores/Buffers/Pointers Needed: None
+
+ Global Stores/Buffers/Pointers Needed: None
+
+ Outputs: None
+
+ Pointers and Buffers Modified: None
+
+ Local Stores Modified: None
+
+ Global Stores Modified: None
+
+------------------------------------------------------------------------------
+ FUNCTION DESCRIPTION
+
+ This file defines the 12 packed Huffman Tables and a structure that reference
+ to these tables.
+
+------------------------------------------------------------------------------
+ REQUIREMENTS
+
+
+------------------------------------------------------------------------------
+ REFERENCES
+
+ ISO/IEC 14496-3: 1999(E)
+ Subpart 4          p78 (Table 4.6.1 and Table 4.6.2)
+                    p77 (pseudo code)
+
+------------------------------------------------------------------------------
+ PSEUDO-CODE
+
+------------------------------------------------------------------------------
+ RESOURCES USED
+   When the code is written for a specific target processor the
+     the resources used should be documented below.
+
+ STACK USAGE: [stack count for this module] + [variable to represent
+          stack usage for each subroutine called]
+
+     where: [stack usage variable] = stack usage for [subroutine
+         name] (see [filename].ext)
+
+ DATA MEMORY USED: x words
+
+ PROGRAM MEMORY USED: x words
+
+ CLOCK CYCLES: [cycle count equation for this module] + [variable
+           used to represent cycle count for each subroutine
+           called]
+
+     where: [cycle count variable] = cycle count for [subroutine
+        name] (see [filename].ext)
+
+------------------------------------------------------------------------------
+*/
+#include    "s_hcb.h"
+#include    "hcbtables.h"
+
+/* This file store packed Huffman tables for binary tree search */
+
+/*
+ * all tables are packed in the following way:
+ * right pointer (7 bits) idx (9 bits)
+ */
+
+
+const Hcb hcbbook_binary[13] =
+{
+
+    { 0, -1,  -1, -1, -1 },   /* ZERO_HCB */
+    { 1,  4,   3,  1,  1 },   /* codebook 1 */
+    { 2,  4,   3,  1,  1 },   /* codebook 2 */
+    { 3,  4,   3,  0,  0 },   /* codebook 3 */
+    { 4,  4,   3,  0,  0 },   /* codebook 4 */
+    { 5,  2,   9,  4,  1 },
+    { 6,  2,   9,  4,  1 },
+    { 7,  2,   8,  0,  0 },
+    { 8,  2,   8,  0,  0 },
+    { 9,  2,  13,  0,  0 },
+    {10,  2,  13,  0,  0 },
+    {11,  2,  17,  0,  0 },  /* codebook 11 ESC book */
+    {12, -1,  -1, -1, -1 }   /* scalefactor codebook */
+
+
+};
+
+
+/* New look-up table for huffman decoding
+   Created by ordering the codeword in the table according to their
+   normalized shifted binary value, i.e., all the codewords are left
+   shifted to meet the maximum codelength. Example, max codelength is
+   10, the codeword with lenth 3 will left shift by 7.
+   The binary values of after the shift are sorted.
+   Then the sorted table is divided into several partition.
+   At the VLC decoding period, input is read in at max codelenght.
+   The partition is decided using if-else logic.
+   Inside each partition, a look-up table is used to map the input value
+   to a correct symbol. Table entries can appear to be repeated according
+   to the humming distance between adjacent codewords.
+*/
+
+const Int32 huff_tab1[88] =
+{
+    0x430005,
+    0xd0005,
+    0x270005,
+    0x310005,
+    0x290005,
+    0x250005,
+    0x2b0005,
+    0x1f0005,
+    0x3a0007,
+    0x160007,
+    0x260007,
+    0x2e0007,
+    0x220007,
+    0x2a0007,
+    0x4c0007,
+    0x240007,
+    0x40007,
+    0x1c0007,
+    0x400007,
+    0x300007,
+    0x100007,
+    0x2c0007,
+    0x460007,
+    0x200007,
+    0x340007,
+    0x320007,
+    0xa0007,
+    0x440007,
+    0xc0007,
+    0x420007,
+    0xe0007,
+    0x1e0007,
+    0x490009,
+    0x130009,
+    0x3d0009,
+    0x330009,
+    0x2f0009,
+    0x230009,
+    0x210009,
+    0x370009,
+    0x410009,
+    0x2d0009,
+    0x190009,
+    0xf0009,
+    0x70009,
+    0x1d0009,
+    0x3b0009,
+    0x390009,
+    0x150009,
+    0x10009,
+    0x1b0009,
+    0x350009,
+    0x450009,
+    0x4d0009,
+    0x170009,
+    0x4f0009,
+    0x5000a,
+    0x5000a,
+    0x9000a,
+    0x9000a,
+    0x4b000a,
+    0x4b000a,
+    0x3f000a,
+    0x3f000a,
+    0xb000a,
+    0xb000a,
+    0x3000a,
+    0x3000a,
+    0x11000a,
+    0x11000a,
+    0x47000a,
+    0x47000a,
+    0x3c000b,
+    0x14000b,
+    0x18000b,
+    0x38000b,
+    0x50000b,
+    0x8000b,
+    0x48000b,
+    0x6000b,
+    0xb,
+    0x4a000b,
+    0x3e000b,
+    0x1a000b,
+    0x12000b,
+    0x2000b,
+    0x36000b,
+    0x4e000b
+};
+
+const Int32 huff_tab2[90] =
+{
+    0x430004,
+    0x430004,
+    0x430004,
+    0x430004,
+    0xd0005,
+    0xd0005,
+    0x290005,
+    0x290005,
+    0x250005,
+    0x250005,
+    0x270005,
+    0x270005,
+    0x1f0005,
+    0x1f0005,
+    0x2b0005,
+    0x2b0005,
+    0x310005,
+    0x310005,
+    0x220006,
+    0x160006,
+    0x2e0006,
+    0x2a0006,
+    0x300006,
+    0x260006,
+    0xc0006,
+    0x3a0006,
+    0x400006,
+    0x40006,
+    0x240006,
+    0x460006,
+    0x440006,
+    0x200006,
+    0x100006,
+    0x320006,
+    0x1c0006,
+    0xe0006,
+    0x1e0006,
+    0xa0006,
+    0x4c0006,
+    0x340006,
+    0x2c0006,
+    0x420006,
+    0x2f0007,
+    0x410007,
+    0x130007,
+    0x210007,
+    0x3d0007,
+    0x4b0007,
+    0x470007,
+    0x190007,
+    0x1d0007,
+    0x4f0007,
+    0xf0007,
+    0x10007,
+    0xb0007,
+    0x370007,
+    0x490007,
+    0x3b0008,
+    0x150008,
+    0x70008,
+    0x110008,
+    0x50008,
+    0x30008,
+    0x1b0008,
+    0x450008,
+    0x3f0008,
+    0x2d0008,
+    0x350008,
+    0x170008,
+    0x90008,
+    0x330008,
+    0x390008,
+    0x230008,
+    0x4d0008,
+    0x3c0008,
+    0x140008,
+    0x380009,
+    0x9,
+    0x180009,
+    0x1a0009,
+    0x500009,
+    0x60009,
+    0x3e0009,
+    0x120009,
+    0x80009,
+    0x480009,
+    0x360009,
+    0x20009,
+    0x4a0009,
+    0x4e0009
+};
+
+const Int32 huff_tab3[151] =
+{
+    0x1b0004,
+    0x1b0004,
+    0x1b0004,
+    0x1b0004,
+    0x10004,
+    0x10004,
+    0x10004,
+    0x10004,
+    0x90004,
+    0x90004,
+    0x90004,
+    0x90004,
+    0x30004,
+    0x30004,
+    0x30004,
+    0x30004,
+    0x240005,
+    0x240005,
+    0x40005,
+    0x40005,
+    0xc0006,
+    0xa0006,
+    0x1e0006,
+    0xd0006,
+    0x1c0006,
+    0x270006,
+    0x280007,
+    0x280007,
+    0x280007,
+    0x280007,
+    0x1f0007,
+    0x1f0007,
+    0x1f0007,
+    0x1f0007,
+    0x250007,
+    0x250007,
+    0x250007,
+    0x250007,
+    0x360008,
+    0x360008,
+    0x20008,
+    0x20008,
+    0x50008,
+    0x50008,
+    0x3f0008,
+    0x3f0008,
+    0x300008,
+    0x300008,
+    0x70009,
+    0x100009,
+    0x2d0009,
+    0xe0009,
+    0x420009,
+    0x60009,
+    0x150009,
+    0xf0009,
+    0x120009,
+    0xb0009,
+    0x390009,
+    0x310009,
+    0x160009,
+    0x2a0009,
+    0x2b0009,
+    0x2e000a,
+    0x21000a,
+    0x22000a,
+    0x13000a,
+    0x43000a,
+    0x29000a,
+    0x40000a,
+    0x20000a,
+    0x8000a,
+    0x11000a,
+    0x4b000a,
+    0x33000a,
+    0x1d000a,
+    0x37000a,
+    0x19000a,
+    0x48000b,
+    0x48000b,
+    0x34000b,
+    0x34000b,
+    0x26000b,
+    0x26000b,
+    0x3a000b,
+    0x3a000b,
+    0x2c000b,
+    0x2c000b,
+    0x4c000b,
+    0x4c000b,
+    0x18000b,
+    0x18000b,
+    0x17000b,
+    0x17000b,
+    0x23000c,
+    0x49000c,
+    0x45000c,
+    0x4e000c,
+    0x1a000c,
+    0x4f000c,
+    0x46000c,
+    0x32000c,
+    0x35000c,
+    0x14000d,
+    0x14000d,
+    0x14000d,
+    0x14000d,
+    0x14000d,
+    0x14000d,
+    0x14000d,
+    0x14000d,
+    0x3c000d,
+    0x3c000d,
+    0x3c000d,
+    0x3c000d,
+    0x3c000d,
+    0x3c000d,
+    0x3c000d,
+    0x3c000d,
+    0x2f000d,
+    0x2f000d,
+    0x2f000d,
+    0x2f000d,
+    0x2f000d,
+    0x2f000d,
+    0x2f000d,
+    0x2f000d,
+    0x3d000e,
+    0x3d000e,
+    0x3d000e,
+    0x3d000e,
+    0x44000e,
+    0x44000e,
+    0x44000e,
+    0x44000e,
+    0x41000e,
+    0x41000e,
+    0x41000e,
+    0x41000e,
+    0x50000f,
+    0x50000f,
+    0x4d000f,
+    0x4d000f,
+    0x47000f,
+    0x47000f,
+    0x3b000f,
+    0x3b000f,
+    0x38000f,
+    0x38000f,
+    0x4a0010,
+    0x3e0010
+};
+
+const Int32 huff_tab4[119] =
+{
+    0x280004,
+    0x280004,
+    0xd0004,
+    0xd0004,
+    0x250004,
+    0x250004,
+    0x270004,
+    0x270004,
+    0x1f0004,
+    0x1f0004,
+    0x1b0004,
+    0x1b0004,
+    0x240004,
+    0x240004,
+    0x4,
+    0x4,
+    0x40004,
+    0x40004,
+    0x1e0004,
+    0x1e0004,
+    0x1c0005,
+    0xc0005,
+    0x10005,
+    0xa0005,
+    0x30005,
+    0x90005,
+    0x430007,
+    0x430007,
+    0x2b0007,
+    0x2b0007,
+    0x310007,
+    0x310007,
+    0x290007,
+    0x290007,
+    0x420007,
+    0x420007,
+    0x400007,
+    0x400007,
+    0x300007,
+    0x300007,
+    0x3a0007,
+    0x3a0007,
+    0x100007,
+    0x100007,
+    0xe0008,
+    0x2a0008,
+    0x160008,
+    0x200008,
+    0x2e0008,
+    0x260008,
+    0x220008,
+    0x3f0008,
+    0x390008,
+    0x2d0008,
+    0x370008,
+    0xb0008,
+    0x150008,
+    0x50008,
+    0xf0008,
+    0x130008,
+    0x1d0008,
+    0x70008,
+    0x210008,
+    0x360008,
+    0x20008,
+    0x120009,
+    0x120009,
+    0x60009,
+    0x60009,
+    0x340009,
+    0x340009,
+    0x4c0009,
+    0x4c0009,
+    0x460009,
+    0x460009,
+    0x2c0009,
+    0x2c0009,
+    0x320009,
+    0x320009,
+    0x440009,
+    0x440009,
+    0x33000a,
+    0x4b000a,
+    0x45000a,
+    0x19000a,
+    0x11000a,
+    0x49000a,
+    0x17000a,
+    0x3d000a,
+    0x23000a,
+    0x4f000a,
+    0x2f000a,
+    0x3b000a,
+    0x41000a,
+    0x35000a,
+    0x47000b,
+    0x47000b,
+    0x4d000b,
+    0x4d000b,
+    0x18000b,
+    0x18000b,
+    0x48000b,
+    0x48000b,
+    0x8000b,
+    0x8000b,
+    0x3c000b,
+    0x3c000b,
+    0x14000b,
+    0x14000b,
+    0x38000b,
+    0x38000b,
+    0x50000b,
+    0x50000b,
+    0x1a000b,
+    0x1a000b,
+    0x4e000b,
+    0x4e000b,
+    0x4a000c,
+    0x3e000c
+};
+
+const Int32 huff_tab5[110] =
+{
+    0x1f0004,
+    0x1f0004,
+    0x310004,
+    0x310004,
+    0x290004,
+    0x290004,
+    0x270004,
+    0x270004,
+    0x300005,
+    0x200005,
+    0x1e0005,
+    0x320005,
+    0x160007,
+    0x160007,
+    0x2a0007,
+    0x2a0007,
+    0x3a0007,
+    0x3a0007,
+    0x260007,
+    0x260007,
+    0x150008,
+    0x3b0008,
+    0x1d0008,
+    0x330008,
+    0x170008,
+    0x390008,
+    0x210008,
+    0x2f0008,
+    0xd0008,
+    0x430008,
+    0x250008,
+    0x2b0008,
+    0xc0009,
+    0xc0009,
+    0x340009,
+    0x340009,
+    0x440009,
+    0x440009,
+    0x1c0009,
+    0x1c0009,
+    0xe0009,
+    0xe0009,
+    0x420009,
+    0x420009,
+    0x2e0009,
+    0x2e0009,
+    0x220009,
+    0x220009,
+    0x180009,
+    0x180009,
+    0x3c0009,
+    0x3c0009,
+    0x140009,
+    0x140009,
+    0x380009,
+    0x380009,
+    0xb000a,
+    0x41000a,
+    0x19000a,
+    0x37000a,
+    0x45000a,
+    0x3d000a,
+    0xf000a,
+    0x13000a,
+    0x24000a,
+    0x4000a,
+    0x4d000a,
+    0x4c000a,
+    0x3000b,
+    0x2c000b,
+    0x4b000b,
+    0x1b000b,
+    0x35000b,
+    0x23000b,
+    0x5000b,
+    0x2d000b,
+    0x40000b,
+    0xa000b,
+    0x10000b,
+    0x1a000b,
+    0x2000b,
+    0x4e000b,
+    0x36000b,
+    0x3e000b,
+    0x46000b,
+    0x6000b,
+    0x12000c,
+    0x12000c,
+    0x4a000c,
+    0x4a000c,
+    0x3f000c,
+    0x3f000c,
+    0x1000c,
+    0x1000c,
+    0x7000c,
+    0x7000c,
+    0x47000c,
+    0x47000c,
+    0x11000c,
+    0x11000c,
+    0x4f000c,
+    0x4f000c,
+    0x49000c,
+    0x49000c,
+    0x9000c,
+    0x9000c,
+    0x48000d,
+    0x8000d,
+    0x50000d,
+    0xd
+};
+const Int32 huff_tab6[113] =
+{
+    0x280004,
+    0x310004,
+    0x270004,
+    0x290004,
+    0x1f0004,
+    0x320004,
+    0x200004,
+    0x300004,
+    0x1e0004,
+    0x390006,
+    0x390006,
+    0x3b0006,
+    0x3b0006,
+    0x170006,
+    0x170006,
+    0x150006,
+    0x150006,
+    0x160006,
+    0x160006,
+    0x210006,
+    0x210006,
+    0x3a0006,
+    0x3a0006,
+    0x2f0006,
+    0x2f0006,
+    0x330006,
+    0x330006,
+    0x260006,
+    0x260006,
+    0x1d0006,
+    0x1d0006,
+    0x2a0006,
+    0x2a0006,
+    0x380006,
+    0x380006,
+    0x180006,
+    0x180006,
+    0x140006,
+    0x140006,
+    0x3c0006,
+    0x3c0006,
+    0xe0007,
+    0x440007,
+    0x420007,
+    0x220007,
+    0xc0007,
+    0x340007,
+    0x2e0007,
+    0x1c0007,
+    0x430007,
+    0xd0007,
+    0x250007,
+    0x2b0007,
+    0x450007,
+    0xb0008,
+    0xb0008,
+    0x190008,
+    0x190008,
+    0x3d0008,
+    0x3d0008,
+    0x410008,
+    0x410008,
+    0x370008,
+    0x370008,
+    0x130008,
+    0x130008,
+    0xf0008,
+    0xf0008,
+    0x460008,
+    0x460008,
+    0x400009,
+    0xa0009,
+    0x100009,
+    0x2d0009,
+    0x1b0009,
+    0x4d0009,
+    0x50009,
+    0x30009,
+    0x350009,
+    0x4b0009,
+    0x230009,
+    0x240009,
+    0x60009,
+    0x20009,
+    0x3e0009,
+    0x120009,
+    0x40009,
+    0x4e0009,
+    0x4a0009,
+    0x1a0009,
+    0x4c0009,
+    0x360009,
+    0x2c0009,
+    0x9000a,
+    0x9000a,
+    0x11000a,
+    0x11000a,
+    0x3f000a,
+    0x3f000a,
+    0x49000a,
+    0x49000a,
+    0x47000a,
+    0x47000a,
+    0x4f000a,
+    0x4f000a,
+    0x7000a,
+    0x7000a,
+    0x1000a,
+    0x1000a,
+    0x50000b,
+    0x8000b,
+    0xb,
+    0x48000b
+};
+
+const Int32 huff_tab7[107] =
+{
+    0x80003,
+    0x80003,
+    0x80003,
+    0x80003,
+    0x80003,
+    0x80003,
+    0x80003,
+    0x80003,
+    0x10003,
+    0x10003,
+    0x10003,
+    0x10003,
+    0x10003,
+    0x10003,
+    0x10003,
+    0x10003,
+    0x90004,
+    0x90004,
+    0x90004,
+    0x90004,
+    0x110006,
+    0xa0006,
+    0x100006,
+    0x20006,
+    0x190007,
+    0x190007,
+    0xb0007,
+    0xb0007,
+    0x120007,
+    0x120007,
+    0x180007,
+    0x180007,
+    0x30007,
+    0x30007,
+    0x130008,
+    0x1a0008,
+    0xc0008,
+    0x210008,
+    0xd0008,
+    0x290008,
+    0x1b0008,
+    0x140008,
+    0x40008,
+    0x200008,
+    0x220009,
+    0x220009,
+    0x150009,
+    0x150009,
+    0x2a0009,
+    0x2a0009,
+    0x50009,
+    0x50009,
+    0x310009,
+    0x310009,
+    0x280009,
+    0x280009,
+    0xe0009,
+    0xe0009,
+    0x230009,
+    0x230009,
+    0x1d0009,
+    0x1d0009,
+    0x1c0009,
+    0x1c0009,
+    0x2b0009,
+    0x2b0009,
+    0x160009,
+    0x160009,
+    0x320009,
+    0x320009,
+    0xf0009,
+    0xf0009,
+    0x1e000a,
+    0x6000a,
+    0x30000a,
+    0x24000a,
+    0x39000a,
+    0x25000a,
+    0x3a000a,
+    0x2c000a,
+    0x33000a,
+    0x17000a,
+    0x3b000a,
+    0x34000a,
+    0x2d000a,
+    0x26000a,
+    0x1f000a,
+    0x38000b,
+    0x38000b,
+    0x7000b,
+    0x7000b,
+    0x35000b,
+    0x35000b,
+    0x2e000b,
+    0x2e000b,
+    0x3c000b,
+    0x3c000b,
+    0x27000b,
+    0x27000b,
+    0x2f000b,
+    0x2f000b,
+    0x3d000b,
+    0x3d000b,
+    0x3e000c,
+    0x36000c,
+    0x37000c,
+    0x3f000c
+};
+const Int32 huff_tab8[90] =
+{
+    0x90003,
+    0x90003,
+    0x90003,
+    0x90003,
+    0x110004,
+    0x110004,
+    0x80004,
+    0x80004,
+    0xa0004,
+    0xa0004,
+    0x10004,
+    0x10004,
+    0x120004,
+    0x120004,
+    0x5,
+    0x100005,
+    0x20005,
+    0x190005,
+    0xb0005,
+    0x1a0005,
+    0x130005,
+    0x1b0006,
+    0x1b0006,
+    0x210006,
+    0x210006,
+    0xc0006,
+    0xc0006,
+    0x220006,
+    0x220006,
+    0x140006,
+    0x140006,
+    0x180006,
+    0x180006,
+    0x30006,
+    0x30006,
+    0x230006,
+    0x230006,
+    0x1c0006,
+    0x1c0006,
+    0x2a0006,
+    0x2a0006,
+    0x290007,
+    0x150007,
+    0xd0007,
+    0x2b0007,
+    0x1d0007,
+    0x240007,
+    0x2c0007,
+    0x40007,
+    0x250007,
+    0x200007,
+    0x160007,
+    0x320007,
+    0x310007,
+    0xe0007,
+    0x1e0008,
+    0x330008,
+    0x2d0008,
+    0x280008,
+    0x340008,
+    0x50008,
+    0x260008,
+    0x390008,
+    0x3a0008,
+    0x170008,
+    0x350008,
+    0x3b0008,
+    0xf0008,
+    0x2e0008,
+    0x1f0008,
+    0x360009,
+    0x360009,
+    0x3c0009,
+    0x3c0009,
+    0x300009,
+    0x300009,
+    0x270009,
+    0x270009,
+    0x60009,
+    0x60009,
+    0x3d0009,
+    0x3d0009,
+    0x3e0009,
+    0x3e0009,
+    0x370009,
+    0x370009,
+    0x2f000a,
+    0x38000a,
+    0x7000a,
+    0x3f000a
+};
+const Int32 huff_tab9[204] =
+{
+    0x1,
+    0x1,
+    0x1,
+    0x1,
+    0x1,
+    0x1,
+    0x1,
+    0x1,
+    0xd0003,
+    0xd0003,
+    0x10003,
+    0x10003,
+    0xe0004,
+    0x1b0006,
+    0x1b0006,
+    0xf0006,
+    0xf0006,
+    0x1a0006,
+    0x1a0006,
+    0x20006,
+    0x20006,
+    0x280007,
+    0x1c0007,
+    0x100007,
+    0x270008,
+    0x270008,
+    0x30008,
+    0x30008,
+    0x1d0008,
+    0x1d0008,
+    0x290008,
+    0x290008,
+    0x110008,
+    0x110008,
+    0x350008,
+    0x350008,
+    0x1e0008,
+    0x1e0008,
+    0x120008,
+    0x120008,
+    0x360009,
+    0x2a0009,
+    0x40009,
+    0x340009,
+    0x420009,
+    0x1f0009,
+    0x130009,
+    0x2b0009,
+    0x430009,
+    0x4f0009,
+    0x370009,
+    0x5000a,
+    0x20000a,
+    0x41000a,
+    0x14000a,
+    0x2c000a,
+    0x15000a,
+    0x69000a,
+    0x38000a,
+    0x44000a,
+    0x50000a,
+    0x5c000a,
+    0x6000a,
+    0x6a000a,
+    0x22000a,
+    0x2d000a,
+    0x21000a,
+    0x39000a,
+    0x76000a,
+    0x16000a,
+    0x5d000a,
+    0x4e000b,
+    0x45000b,
+    0x51000b,
+    0x6b000b,
+    0x7000b,
+    0x77000b,
+    0x2f000b,
+    0x3a000b,
+    0x2e000b,
+    0x8000b,
+    0x83000b,
+    0x52000b,
+    0x23000b,
+    0x46000b,
+    0x68000b,
+    0x5b000b,
+    0x5e000b,
+    0x84000b,
+    0x78000b,
+    0x6c000b,
+    0x17000b,
+    0x5f000b,
+    0x53000b,
+    0x47000b,
+    0x3c000b,
+    0x3b000b,
+    0x30000b,
+    0x90000b,
+    0x49000b,
+    0x75000b,
+    0x6d000b,
+    0x85000c,
+    0x24000c,
+    0x9000c,
+    0x91000c,
+    0x79000c,
+    0x54000c,
+    0x9d000c,
+    0x3d000c,
+    0x6e000c,
+    0x18000c,
+    0x7a000c,
+    0x86000c,
+    0x48000c,
+    0x60000c,
+    0x25000c,
+    0x19000c,
+    0x9e000c,
+    0x92000c,
+    0x31000c,
+    0x4a000c,
+    0x55000c,
+    0x6f000c,
+    0x93000c,
+    0xa000c,
+    0x61000c,
+    0x9f000c,
+    0x82000c,
+    0x87000c,
+    0x3e000c,
+    0x56000c,
+    0x26000c,
+    0x7b000c,
+    0x7c000c,
+    0x3f000c,
+    0x8f000c,
+    0x57000c,
+    0x32000c,
+    0x4b000c,
+    0x70000d,
+    0x63000d,
+    0xa1000d,
+    0x33000d,
+    0x94000d,
+    0x62000d,
+    0xa0000d,
+    0x95000d,
+    0x88000d,
+    0x40000d,
+    0x64000d,
+    0x4c000d,
+    0xb000d,
+    0xa2000d,
+    0x58000d,
+    0x9c000d,
+    0x89000d,
+    0x4d000d,
+    0x65000d,
+    0x7d000d,
+    0xc000d,
+    0x96000d,
+    0x71000d,
+    0x7e000d,
+    0x8a000d,
+    0x66000d,
+    0xa3000d,
+    0x59000d,
+    0x73000d,
+    0x97000d,
+    0x67000d,
+    0x5a000d,
+    0x72000e,
+    0x72000e,
+    0x8b000e,
+    0x8b000e,
+    0x74000e,
+    0x74000e,
+    0x7f000e,
+    0x7f000e,
+    0x80000e,
+    0x80000e,
+    0x81000e,
+    0x81000e,
+    0x8d000e,
+    0x8d000e,
+    0xa5000e,
+    0xa5000e,
+    0x8c000e,
+    0x8c000e,
+    0x98000e,
+    0x98000e,
+    0xa4000e,
+    0xa4000e,
+    0x99000e,
+    0x99000e,
+    0xa6000e,
+    0xa6000e,
+    0xa7000e,
+    0xa7000e,
+    0x8e000f,
+    0x9a000f,
+    0x9b000f,
+    0xa8000f
+};
+const Int32 huff_tab10[186] =
+{
+    0xe0004,
+    0xe0004,
+    0xe0004,
+    0xe0004,
+    0xf0004,
+    0xf0004,
+    0xf0004,
+    0xf0004,
+    0x1b0004,
+    0x1b0004,
+    0x1b0004,
+    0x1b0004,
+    0x1c0005,
+    0x1c0005,
+    0xd0005,
+    0xd0005,
+    0x10005,
+    0x10005,
+    0x100005,
+    0x100005,
+    0x290005,
+    0x290005,
+    0x280005,
+    0x280005,
+    0x1d0005,
+    0x1d0005,
+    0x2a0005,
+    0x2a0005,
+    0x1a0006,
+    0x20006,
+    0x1e0006,
+    0x360006,
+    0x110006,
+    0x350006,
+    0x6,
+    0x370006,
+    0x2b0006,
+    0x270006,
+    0x30006,
+    0x380006,
+    0x1f0006,
+    0x430006,
+    0x120007,
+    0x420007,
+    0x440007,
+    0x2c0007,
+    0x450007,
+    0x390007,
+    0x500007,
+    0x200007,
+    0x510007,
+    0x340007,
+    0x4f0007,
+    0x40007,
+    0x130007,
+    0x2d0007,
+    0x460007,
+    0x520007,
+    0x3a0007,
+    0x530008,
+    0x5d0008,
+    0x2e0008,
+    0x210008,
+    0x470008,
+    0x6a0008,
+    0x5e0008,
+    0x410008,
+    0x5c0008,
+    0x50008,
+    0x690008,
+    0x140008,
+    0x6b0008,
+    0x5f0008,
+    0x3b0008,
+    0x220008,
+    0x540008,
+    0x600008,
+    0x150008,
+    0x2f0008,
+    0x6c0008,
+    0x3c0008,
+    0x480008,
+    0x6d0008,
+    0x490008,
+    0x610009,
+    0x550009,
+    0x770009,
+    0x4e0009,
+    0x560009,
+    0x780009,
+    0x300009,
+    0x760009,
+    0x230009,
+    0x60009,
+    0x6e0009,
+    0x790009,
+    0x3d0009,
+    0x840009,
+    0x160009,
+    0x620009,
+    0x6f0009,
+    0x7a0009,
+    0x630009,
+    0x850009,
+    0x4a0009,
+    0x860009,
+    0x240009,
+    0x830009,
+    0x310009,
+    0x7b0009,
+    0x570009,
+    0x680009,
+    0x3e0009,
+    0x5b0009,
+    0x910009,
+    0x64000a,
+    0x92000a,
+    0x88000a,
+    0x17000a,
+    0x90000a,
+    0x7c000a,
+    0x7000a,
+    0x70000a,
+    0x87000a,
+    0x32000a,
+    0x4b000a,
+    0x71000a,
+    0x94000a,
+    0x8000a,
+    0x93000a,
+    0x25000a,
+    0x65000a,
+    0x58000a,
+    0x89000a,
+    0x3f000a,
+    0x18000a,
+    0x9e000a,
+    0x7d000a,
+    0x9f000a,
+    0x95000a,
+    0x4c000a,
+    0xa0000a,
+    0x96000a,
+    0xa1000a,
+    0x33000a,
+    0x59000a,
+    0x75000a,
+    0x8a000a,
+    0x82000a,
+    0x9d000a,
+    0x9000a,
+    0x40000a,
+    0x7e000a,
+    0xa2000a,
+    0x26000a,
+    0x72000a,
+    0x7f000b,
+    0x19000b,
+    0x97000b,
+    0xa3000b,
+    0x66000b,
+    0x4d000b,
+    0x5a000b,
+    0x8b000b,
+    0x73000b,
+    0xa4000b,
+    0xa000b,
+    0x67000b,
+    0x8f000b,
+    0x8c000b,
+    0x98000b,
+    0x99000b,
+    0xb000b,
+    0x9a000b,
+    0x80000b,
+    0x8d000b,
+    0x9c000b,
+    0x74000b,
+    0xa5000c,
+    0x8e000c,
+    0x81000c,
+    0x9b000c,
+    0xa7000c,
+    0xc000c,
+    0xa6000c,
+    0xa8000c
+};
+const Int32 huff_tab11[301] =
+{
+    0x4,
+    0x4,
+    0x4,
+    0x4,
+    0x120004,
+    0x120004,
+    0x120004,
+    0x120004,
+    0x1200005,
+    0x1200005,
+    0x110005,
+    0x110005,
+    0x10005,
+    0x10005,
+    0x230005,
+    0x230005,
+    0x130005,
+    0x130005,
+    0x240005,
+    0x240005,
+    0x140006,
+    0x340006,
+    0x350006,
+    0x220006,
+    0x250006,
+    0x20006,
+    0x360006,
+    0x450007,
+    0x150007,
+    0x460007,
+    0x260007,
+    0x470007,
+    0x370007,
+    0x330007,
+    0x30007,
+    0x560007,
+    0x570007,
+    0x270007,
+    0x480007,
+    0x160007,
+    0x580007,
+    0x380007,
+    0x590007,
+    0x490008,
+    0x680008,
+    0x280008,
+    0x670008,
+    0x690008,
+    0x390008,
+    0x170008,
+    0x540008,
+    0x430008,
+    0x1150008,
+    0x1130008,
+    0x1140008,
+    0x6a0008,
+    0x1160008,
+    0x440008,
+    0x4a0008,
+    0x40008,
+    0x320008,
+    0x5a0008,
+    0x650008,
+    0x1170008,
+    0x1120008,
+    0x1180008,
+    0x290008,
+    0x790008,
+    0x3a0008,
+    0x6b0008,
+    0x5b0008,
+    0x760008,
+    0x11a0008,
+    0x7a0008,
+    0x780008,
+    0x1190008,
+    0x870008,
+    0x210008,
+    0x180008,
+    0x4b0008,
+    0x11b0008,
+    0x7b0008,
+    0x11c0008,
+    0x980008,
+    0x1110008,
+    0x6c0008,
+    0xa90008,
+    0x2a0008,
+    0x5c0008,
+    0xba0008,
+    0x11d0008,
+    0x8b0008,
+    0x8a0008,
+    0x3b0008,
+    0x550008,
+    0x11e0008,
+    0xcb0008,
+    0x7c0008,
+    0x4c0008,
+    0x6d0008,
+    0x7d0008,
+    0x50008,
+    0x8c0009,
+    0x11f0009,
+    0xdc0009,
+    0x190009,
+    0x890009,
+    0xfe0009,
+    0x5d0009,
+    0xed0009,
+    0x3c0009,
+    0x8d0009,
+    0x7e0009,
+    0x2b0009,
+    0x8e0009,
+    0x9b0009,
+    0x9c0009,
+    0x10f0009,
+    0x4d0009,
+    0x6e0009,
+    0x660009,
+    0x9d0009,
+    0x5e0009,
+    0x8f0009,
+    0x7f0009,
+    0x1a0009,
+    0xad0009,
+    0x60009,
+    0xac0009,
+    0x9a0009,
+    0x9e0009,
+    0x4e0009,
+    0x2c0009,
+    0x9f0009,
+    0x3d0009,
+    0x6f0009,
+    0xae0009,
+    0x900009,
+    0xaf0009,
+    0xa00009,
+    0xbe0009,
+    0x1b0009,
+    0x770009,
+    0xb00009,
+    0x800009,
+    0x3e0009,
+    0x5f0009,
+    0xab0009,
+    0x4f0009,
+    0xbd0009,
+    0xdf0009,
+    0x700009,
+    0xe00009,
+    0x2d0009,
+    0x1100009,
+    0x600009,
+    0xc00009,
+    0xbf000a,
+    0xa1000a,
+    0x81000a,
+    0x91000a,
+    0x10000a,
+    0x51000a,
+    0x7000a,
+    0x40000a,
+    0xc1000a,
+    0xde000a,
+    0xe1000a,
+    0xcf000a,
+    0x2f000a,
+    0xe2000a,
+    0x92000a,
+    0x71000a,
+    0xb2000a,
+    0xb1000a,
+    0xf0000a,
+    0xd0000a,
+    0x1c000a,
+    0x50000a,
+    0xbc000a,
+    0x3f000a,
+    0x1e000a,
+    0xce000a,
+    0x82000a,
+    0x41000a,
+    0x61000a,
+    0x62000a,
+    0xf2000a,
+    0x52000a,
+    0xc2000a,
+    0xf1000a,
+    0xd1000a,
+    0xe3000a,
+    0xd2000a,
+    0x88000a,
+    0xc3000a,
+    0x2e000a,
+    0xa2000a,
+    0xf3000a,
+    0x73000a,
+    0xb4000a,
+    0x101000a,
+    0x93000a,
+    0xa3000a,
+    0xf4000a,
+    0xb3000a,
+    0x63000a,
+    0xc4000a,
+    0xef000a,
+    0x30000a,
+    0x72000a,
+    0x1d000a,
+    0xe5000a,
+    0x8000a,
+    0xe4000a,
+    0x83000a,
+    0xd3000a,
+    0x84000a,
+    0x102000a,
+    0xcd000a,
+    0x74000a,
+    0x31000a,
+    0x104000a,
+    0x103000a,
+    0x1f000a,
+    0xa4000a,
+    0x53000a,
+    0xf5000a,
+    0x95000a,
+    0xe6000a,
+    0x94000a,
+    0x64000a,
+    0x42000a,
+    0xb5000a,
+    0xc5000a,
+    0xd4000a,
+    0x105000a,
+    0x106000a,
+    0x96000a,
+    0x100000a,
+    0x85000a,
+    0x99000a,
+    0x9000a,
+    0xa6000a,
+    0xa5000a,
+    0xd5000a,
+    0xf6000a,
+    0xb7000a,
+    0xf7000a,
+    0xd6000a,
+    0x75000a,
+    0x86000a,
+    0xa7000b,
+    0x107000b,
+    0xc6000b,
+    0xc9000b,
+    0x20000b,
+    0xb6000b,
+    0xb8000b,
+    0xe8000b,
+    0xe7000b,
+    0xc8000b,
+    0xc7000b,
+    0x97000b,
+    0xf9000b,
+    0xe9000b,
+    0xd9000b,
+    0x108000b,
+    0xf8000b,
+    0xaa000b,
+    0xd7000b,
+    0xa8000b,
+    0xa000b,
+    0xd8000b,
+    0xbb000b,
+    0xda000b,
+    0xb9000b,
+    0xea000b,
+    0xd000b,
+    0xfa000b,
+    0x109000b,
+    0x10a000b,
+    0xca000b,
+    0xfb000b,
+    0xdd000b,
+    0xb000b,
+    0xeb000b,
+    0x10b000b,
+    0x10c000b,
+    0xdb000b,
+    0xee000b,
+    0xfc000b,
+    0xec000b,
+    0xcc000b,
+    0xfd000b,
+    0xe000c,
+    0xc000c,
+    0x10d000c,
+    0xff000c,
+    0xf000c,
+    0x10e000c
+};
+
+const UInt32 huff_tab_scl[188] =
+{
+    0x3b0003,
+    0x3b0003,
+    0x3b0003,
+    0x3b0003,
+    0x3b0003,
+    0x3b0003,
+    0x3b0003,
+    0x3b0003,
+    0x3d0004,
+    0x3d0004,
+    0x3d0004,
+    0x3d0004,
+    0x3a0004,
+    0x3a0004,
+    0x3a0004,
+    0x3a0004,
+    0x3e0004,
+    0x3e0004,
+    0x3e0004,
+    0x3e0004,
+    0x390005,
+    0x390005,
+    0x3f0005,
+    0x3f0005,
+    0x380006,
+    0x400006,
+    0x370006,
+    0x410006,
+    0x420007,
+    0x420007,
+    0x420007,
+    0x420007,
+    0x360007,
+    0x360007,
+    0x360007,
+    0x360007,
+    0x430007,
+    0x430007,
+    0x430007,
+    0x430007,
+    0x350008,
+    0x350008,
+    0x440008,
+    0x440008,
+    0x340008,
+    0x340008,
+    0x450008,
+    0x450008,
+    0x330008,
+    0x330008,
+    0x460009,
+    0x320009,
+    0x310009,
+    0x470009,
+    0x48000a,
+    0x48000a,
+    0x48000a,
+    0x48000a,
+    0x30000a,
+    0x30000a,
+    0x30000a,
+    0x30000a,
+    0x49000a,
+    0x49000a,
+    0x49000a,
+    0x49000a,
+    0x2f000a,
+    0x2f000a,
+    0x2f000a,
+    0x2f000a,
+    0x4a000a,
+    0x4a000a,
+    0x4a000a,
+    0x4a000a,
+    0x2e000a,
+    0x2e000a,
+    0x2e000a,
+    0x2e000a,
+    0x4c000b,
+    0x4c000b,
+    0x4b000b,
+    0x4b000b,
+    0x4d000b,
+    0x4d000b,
+    0x4e000b,
+    0x4e000b,
+    0x2d000b,
+    0x2d000b,
+    0x2b000b,
+    0x2b000b,
+    0x2c000c,
+    0x4f000c,
+    0x2a000c,
+    0x29000c,
+    0x50000c,
+    0x28000c,
+    0x51000d,
+    0x51000d,
+    0x27000d,
+    0x27000d,
+    0x52000d,
+    0x52000d,
+    0x26000d,
+    0x26000d,
+    0x53000d,
+    0x53000d,
+    0x25000e,
+    0x23000e,
+    0x55000e,
+    0x21000e,
+    0x24000e,
+    0x22000e,
+    0x54000e,
+    0x20000e,
+    0x57000f,
+    0x57000f,
+    0x59000f,
+    0x59000f,
+    0x1e000f,
+    0x1e000f,
+    0x1f000f,
+    0x1f000f,
+    0x560010,
+    0x1d0010,
+    0x1a0010,
+    0x1b0010,
+    0x1c0010,
+    0x180010,
+    0x580010,
+    0x190011,
+    0x190011,
+    0x160011,
+    0x160011,
+    0x170011,
+    0x170011,
+    0x5a0012,
+    0x150012,
+    0x130012,
+    0x30012,
+    0x10012,
+    0x20012,
+    0x12,
+    0x620013,
+    0x630013,
+    0x640013,
+    0x650013,
+    0x660013,
+    0x750013,
+    0x610013,
+    0x5b0013,
+    0x5c0013,
+    0x5d0013,
+    0x5e0013,
+    0x5f0013,
+    0x600013,
+    0x680013,
+    0x6f0013,
+    0x700013,
+    0x710013,
+    0x720013,
+    0x730013,
+    0x740013,
+    0x6e0013,
+    0x690013,
+    0x6a0013,
+    0x6b0013,
+    0x6c0013,
+    0x6d0013,
+    0x760013,
+    0x60013,
+    0x80013,
+    0x90013,
+    0xa0013,
+    0x50013,
+    0x670013,
+    0x780013,
+    0x770013,
+    0x40013,
+    0x70013,
+    0xf0013,
+    0x100013,
+    0x120013,
+    0x140013,
+    0x110013,
+    0xb0013,
+    0xc0013,
+    0xe0013,
+    0xd0013
+};
diff --git a/media/libstagefright/codecs/aacdec/huffcb.cpp b/media/libstagefright/codecs/aacdec/huffcb.cpp
new file mode 100644
index 0000000..30f38fa
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/huffcb.cpp
@@ -0,0 +1,381 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Pathname: ./src/huffcb.c
+ Funtions:
+    huffcb
+
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+ Description:  Modified from original shareware code
+
+ Description:  Modified to pass variables by reference to eliminate use
+               of global variables.
+
+ Description:  Change variable names for clarity,
+               change variables 'base', 'sect_len_inc', and 'esc_val' to
+               UChar type.
+
+ Description:  Add "if ((pSect[-1] % sfb_per_win) > max_sfb)" statement to
+               detect the error condition.
+               add more white space.
+
+ Description: eliminated "pSect[-1]%sfb_per_win" operation
+
+ Description: eliminated "pSect[-1]%sfb_per_win" operation
+
+ Description: (1) Pass in SectInfo pSect
+              (2) put BITS *pInputStream as second parameter
+
+ Description:  Fix a failure for thrid party AAC encoding.
+               The problem came when the total and the
+               maximun number of active scale factor bands do not coincide.
+               This is a rare situation but produces a problem when decoding
+               encoders that tolerate this.
+
+ Description: Replace some instances of getbits to get9_n_lessbits
+              when the number of bits read is 9 or less and get1bits
+              when only 1 bit is read.
+
+ Description:
+
+------------------------------------------------------------------------------
+ INPUT AND OUTPUT DEFINITIONS
+
+ Inputs:
+
+    UChar   *pSect  = pointer to array that contains the interleaved
+                      information of huffman codebook index and section
+                      length. Array contains:
+                      [codebook index]
+                      [section boundary]
+                      [codebook index]
+                      [section boundary]
+                      ...
+
+    Int     sectbits  =   array that defines the number of bits
+                          used for expressing the escape value of
+                          section length
+
+    Int     tot_sfb     = total number of sfb in one Frame
+
+    Int     sfb_per_win = number of sfb in each sub-block (window)
+
+    UChar   max_sfb     = 1 + number of active sfbs - see reference (2) p56
+
+    BITS    *pInputStream = pointer to input stream
+
+
+ Local Stores/Buffers/Pointers Needed:
+
+    UChar    base     = number of sfb in already detected sections
+
+    UChar    sect_len_inc = section length increment in number of sfbs'
+
+    UChar    esc_val  = escape value for section length
+
+    Int     bits     = number of bits needed for expressing section length
+
+
+ Global Stores/Buffers/Pointers Needed:
+
+
+ Outputs:
+
+    num_sect = total number of sections in one frame
+
+
+ Pointers and Buffers Modified:
+
+    UChar    *pSect = pointer to array where huffman codebook index and
+                     section length are stored
+
+ Local Stores Modified:
+
+ Global Stores Modified:
+
+------------------------------------------------------------------------------
+ FUNCTION DESCRIPTION
+
+ Background knowledge: 1024(960) coef's are separated into several sections,
+ each section is encoded with one single Huffman codebook, and each section
+ has a length of multiples of sfb.
+
+ max_sfb <= sfb_per_win <= tot_sfb
+ tot_sfb = total number of scalefactor bands in one frame (1024 coefs)
+
+ This function reads the codebook index and section boundaries (expressed
+ in number of sfb) from the input bitstream, store these information in
+ *pSect, and return the number of sections been detected. Returns 0 if there
+ is an error.
+
+------------------------------------------------------------------------------
+ REQUIREMENTS
+
+ This function should fill the array *pSect with section Huffman codebook
+ indexes and section boundaries
+
+------------------------------------------------------------------------------
+ REFERENCES
+
+ (1) MPEG-2 NBC Audio Decoder
+   "This software module was originally developed by AT&T, Dolby
+   Laboratories, Fraunhofer Gesellschaft IIS in the course of development
+   of the MPEG-2 NBC/MPEG-4 Audio standard ISO/IEC 13818-7, 14496-1,2 and
+   3. This software module is an implementation of a part of one or more
+   MPEG-2 NBC/MPEG-4 Audio tools as specified by the MPEG-2 NBC/MPEG-4
+   Audio standard. ISO/IEC  gives users of the MPEG-2 NBC/MPEG-4 Audio
+   standards free license to this software module or modifications thereof
+   for use in hardware or software products claiming conformance to the
+   MPEG-2 NBC/MPEG-4 Audio  standards. Those intending to use this software
+   module in hardware or software products are advised that this use may
+   infringe existing patents. The original developer of this software
+   module and his/her company, the subsequent editors and their companies,
+   and ISO/IEC have no liability for use of this software module or
+   modifications thereof in an implementation. Copyright is not released
+   for non MPEG-2 NBC/MPEG-4 Audio conforming products.The original
+   developer retains full right to use the code for his/her own purpose,
+   assign or donate the code to a third party and to inhibit third party
+   from using the code for non MPEG-2 NBC/MPEG-4 Audio conforming products.
+   This copyright notice must be included in all copies or derivative
+   works."
+   Copyright(c)1996.
+
+ (2) ISO/IEC 14496-3 1999(E)
+   Subpart 4    p55     (Recovering section_data())
+                p24-25  (Syntax of section_data())
+
+ (3) M. Bosi, K. Brandenburg, etc., "ISO/IEC MPEG-2 Advanced Audio Coding,"
+     J. Audio Eng. Soc., Vol.45, No.10, 1997 October
+
+------------------------------------------------------------------------------
+ PSEUDO-CODE
+
+ bits_needed_for_ESC  = sectbits[0];
+ ESC_value            = (1<<bits_needed_for_ESC) - 1;
+ num_of_section       = 0;
+
+
+ FOR (base = 0; base<total_sfb AND num_of_section<total_sfb)
+ {
+    *pSect++     = getbits(LEN_CB, pInputStream);   (read huffman_codebook_num)
+    sect_length_incr  = getbits(bits_needed_for_ESC, pInputStream);
+
+    WHILE (sect_length_incr == ESC_value AND base < total_sfb)
+    {
+        base              += ESC_value;
+        sect_length_incr  =  getbits(bits_needed_for_ESC, ebits);
+    }
+    ENDWHILE
+
+    base      += sect_length_incr;
+    *pSect++   =  base;
+    num_of_section++;
+
+   IF (num_of_sfb_for_this_group==max_sfb)
+   {
+        *pSect++    = 0; (use huffman codebook 0)
+        base       += sfb_per_win - max_sfb;
+        *pSect++    = base;
+        num_of_section++;
+   }
+   ENDIF
+
+   IF (num_of_sfb_for_this_group > max_sfb)
+        break;
+   ENDIF
+
+ }
+ ENDFOR
+
+ IF (base != total_sfb OR num_of_section>total_sfb)
+      return 0;
+ ENDIF
+
+ return num_sect;
+
+------------------------------------------------------------------------------
+ RESOURCES USED
+   When the code is written for a specific target processor the
+     the resources used should be documented below.
+
+ STACK USAGE: [stack count for this module] + [variable to represent
+          stack usage for each subroutine called]
+
+     where: [stack usage variable] = stack usage for [subroutine
+         name] (see [filename].ext)
+
+ DATA MEMORY USED: x words
+
+ PROGRAM MEMORY USED: x words
+
+ CLOCK CYCLES: [cycle count equation for this module] + [variable
+           used to represent cycle count for each subroutine
+           called]
+
+     where: [cycle count variable] = cycle count for [subroutine
+        name] (see [filename].ext)
+
+------------------------------------------------------------------------------
+*/
+
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+#include    "pv_audio_type_defs.h"
+#include    "huffman.h"
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here. Include conditional
+; compile variables also.
+----------------------------------------------------------------------------*/
+
+
+/*----------------------------------------------------------------------------
+; LOCAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; LOCAL STORE/BUFFER/POINTER DEFINITIONS
+; Variable declaration - defined here and used outside this module
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL FUNCTION REFERENCES
+; Declare functions defined elsewhere and referenced in this module
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL GLOBAL STORE/BUFFER/POINTER REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; FUNCTION CODE
+----------------------------------------------------------------------------*/
+Int huffcb(
+    SectInfo    *pSect,
+    BITS        *pInputStream,
+    Int         sectbits[],
+    Int         tot_sfb,
+    Int         sfb_per_win,
+    Int         max_sfb)
+{
+    /*----------------------------------------------------------------------------
+    ; Define all local variables
+    ----------------------------------------------------------------------------*/
+
+    Int   base;        /* section boundary */
+    Int   sect_len_incr;
+    Int   esc_val;     /* ESC of section length = 31(long), =7 (short) */
+    Int     bits;        /* # of bits used to express esc_val */
+    Int     num_sect;
+    Int     active_sfb;
+    Int   group_base;
+
+
+    /*----------------------------------------------------------------------------
+    ; Function body here
+    ----------------------------------------------------------------------------*/
+
+    bits       =  sectbits[0];     /* 3 for SHORT_WIN, 5 for LONG_WIN */
+    esc_val    = (1 << bits) - 1;   /* ESC_value for section length */
+    num_sect   =  0;
+    base       =  0;
+    group_base =  0;
+
+    /* read until the end of one frame */
+    while ((base < tot_sfb) && (num_sect < tot_sfb))
+    {
+
+        pSect->sect_cb  = get9_n_lessbits(
+                              LEN_CB,
+                              pInputStream); /* section codebook */
+
+        sect_len_incr   = get9_n_lessbits(
+                              bits,
+                              pInputStream); /* length_incr */
+
+
+        /* read until non-ESC value, see p55 reference 2 */
+        while ((sect_len_incr == esc_val) && (base < tot_sfb))
+        {
+            base            +=  esc_val;
+
+            sect_len_incr   = get9_n_lessbits(
+                                  bits,
+                                  pInputStream);
+        }
+
+        base      += sect_len_incr;
+        pSect->sect_end  =  base; /* total # of sfb until current section */
+        pSect++;
+        num_sect++;
+
+        /* active_sfb = base % sfb_per_win; */
+        active_sfb = base - group_base;
+
+        /*
+         *  insert a zero section for regions above max_sfb for each group
+         *  Make sure that active_sfb is also lesser than tot_sfb
+         */
+
+        if ((active_sfb == max_sfb) && (active_sfb < tot_sfb))
+        {
+            base      += (sfb_per_win - max_sfb);
+            pSect->sect_cb   =   0; /* huffman codebook 0 */
+            pSect->sect_end  =   base;
+            num_sect++;
+            pSect++;
+            group_base = base;
+        }
+        else if (active_sfb > max_sfb)
+        {
+            /* within each group, the sections must delineate the sfb
+             * from zero to max_sfb so that the 1st section within each
+             * group starts at sfb0 and the last section ends at max_sfb
+             * see p55 reference 2
+             */
+            break;
+        }
+
+    } /* while (base=0) */
+
+
+    if (base != tot_sfb || num_sect > tot_sfb)
+    {
+        num_sect = 0;   /* error */
+    }
+
+    return num_sect;
+
+} /* huffcb */
+
+
diff --git a/media/libstagefright/codecs/aacdec/huffdecode.cpp b/media/libstagefright/codecs/aacdec/huffdecode.cpp
new file mode 100644
index 0000000..890a6fb
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/huffdecode.cpp
@@ -0,0 +1,528 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Pathname: huffdecode.c
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+ Description:  Modified from original shareware code
+
+ Description:  Modified to pass variables by reference to eliminate use
+               of global variables.
+
+ Description:  Change variable types.
+
+ Description:  (1) Modified to bring in-line with PV standards.
+               (2) Eliminated global_gain on stack,
+                   getics() has to define this parameter on its stack.
+               (3) Eliminated multiple returns
+               (4) Altered return logic of getics()
+               (5) Convert Real coef -> Int32 coef
+               (6) Move BITS *pInputStream to 2nd parameter of huffdecode.c
+                   and getics.c
+               (7) Pass pFrameInfo per channel, because two channels can have
+                   different windows
+
+ Description: (1) Eliminated function call to chn_config
+              (2) Eliminate widx calculation
+              (3) copy channel info from left to right when common_window
+                  is enabled
+              (4) add error checking of getmask return value
+
+ Description:  Change default_position to current_program
+
+ Description:  Remove prstflag
+
+ Description:  Modify call to get_ics_info
+
+ Description:  Modified so getmask is NOT called if the status returned
+ from get_ics_info indicates an error.
+
+ Description:
+ (1) Added include of "e_ElementId.h"
+     Previously, this function was relying on another include file
+     to include e_ElementId.h
+
+ (2) Updated the copyright header.
+
+ Description:  Modified to include usage of the new "shared memory" structures
+ defined in s_tDec_Int_File.h and s_tDec_Int_Chan.h
+
+ Description:
+ (1) Updated to reflect the fact that the temporary FrameInfo used by getics.c
+ was moved into the region of memory shared with fxpCoef.
+
+ Description:
+ (1) Removed first parameter to getics.  The temporary FrameInfo was
+     unnecessary.
+
+ Description: Replace some instances of getbits to get9_n_lessbits
+              when the number of bits read is 9 or less and get1bits
+              when only 1 bit is read.
+
+ Description: Relaxed tag verification. Some encoder do not match the tag
+              to the channel ID (as the standard request to differentiate
+              different channel), in our wireless work, with only mono
+              or stereo channel, this become restrictive to some encoders
+
+
+ Description:
+
+------------------------------------------------------------------------------
+ INPUT AND OUTPUT DEFINITIONS
+
+ Inputs:
+
+    id_syn_ele  = identification flag for channel syntactic element, Int
+
+    pInputStream= pointer to input bitstream, BITS.
+
+    pVars       = pointer to structure that holds information for decoding,
+                  tDec_Int_File
+
+    pChVars[]   = pointer to structure that holds channel information,
+                  tDec_Int_Chan
+
+
+ Local Stores/Buffers/Pointers Needed:
+    None
+
+ Global Stores/Buffers/Pointers Needed:
+    None
+
+ Outputs:
+    status = 0  if success
+             non-zero  otherwise
+
+ Pointers and Buffers Modified:
+    pChVars->sect   contents updated by newly decoded section information
+                    of current frame
+
+    pChVars->factors contents updated by newly decoded scalefactors
+
+    pChVars->ch_coef contents updated by newly decoded spectral coefficients
+
+    PChVars->tns    contents updated by newly decoded TNS information
+
+    pVars->hasmask  contents updated by newly decoded Mid/Side mask
+                    information
+
+    pVars->pulseInfo contents updated by newly decoded pulse data information
+
+ Local Stores Modified:
+    None
+
+ Global Stores Modified:
+    None
+
+------------------------------------------------------------------------------
+ FUNCTION DESCRIPTION
+
+  This function offers a framework for decoding the data of the next 1024
+  samples. It maps the channel configuration according to the id_syn_ele flag,
+  configures the channel information, and calls getics to do huffman decoding
+  The function returns 1 if there was an error
+
+------------------------------------------------------------------------------
+ REQUIREMENTS
+
+ This function should set up the channel configuration for huffman decoding
+
+------------------------------------------------------------------------------
+ REFERENCES
+
+ (1) MPEG-2 NBC Audio Decoder
+   "This software module was originally developed by AT&T, Dolby
+   Laboratories, Fraunhofer Gesellschaft IIS in the course of development
+   of the MPEG-2 NBC/MPEG-4 Audio standard ISO/IEC 13818-7, 14496-1,2 and
+   3. This software module is an implementation of a part of one or more
+   MPEG-2 NBC/MPEG-4 Audio tools as specified by the MPEG-2 NBC/MPEG-4
+   Audio standard. ISO/IEC  gives users of the MPEG-2 NBC/MPEG-4 Audio
+   standards free license to this software module or modifications thereof
+   for use in hardware or software products claiming conformance to the
+   MPEG-2 NBC/MPEG-4 Audio  standards. Those intending to use this software
+   module in hardware or software products are advised that this use may
+   infringe existing patents. The original developer of this software
+   module and his/her company, the subsequent editors and their companies,
+   and ISO/IEC have no liability for use of this software module or
+   modifications thereof in an implementation. Copyright is not released
+   for non MPEG-2 NBC/MPEG-4 Audio conforming products.The original
+   developer retains full right to use the code for his/her own purpose,
+   assign or donate the code to a third party and to inhibit third party
+   from using the code for non MPEG-2 NBC/MPEG-4 Audio conforming products.
+   This copyright notice must be included in all copies or derivative
+   works."
+   Copyright(c)1996.
+
+ (2) ISO/IEC 14496-3: 1999(E)
+    Subpart 4       p15     (single_channel_element, channel_pair_element)
+                    p15     (Table 4.4.5    getmask)
+                    p16     (Table 4.4.6    get_ics_info)
+                    p24     (Table 4.4.24   getics)
+
+------------------------------------------------------------------------------
+ PSEUDO-CODE
+
+    tag = CALL getbits(LEN_TAG,pInputStream)
+                MODIFYING(pInputStream)
+                RETURNING(tag)
+
+    common_window = 0;
+
+    IF (id_syn_ele == ID_CPE)
+    THEN
+        common_window = CALL getbits(LEN_COM_WIN,pInputStream);
+                                MODIFYING(pInputStream)
+                                RETURNING(common_window)
+    ENDIF
+
+    pMcInfo = &pVars->mc_info;
+
+    IF ( (pMcInfo->ch_info[0].cpe != id_syn_ele) OR
+         (pMcInfo->ch_info[0].tag != tag) )
+    THEN
+        status = 1;
+    ENDIF
+
+
+    IF (status == SUCCESS)
+    THEN
+        IF (id_syn_ele == ID_SCE)
+        THEN
+
+            leftCh  = 0;
+            RIGHT = 0;
+            pChVars[leftCh]->hasmask = 0;
+        ELSEIF (id_syn_ele == ID_CPE)
+
+            leftCh = 0;
+            rightCh  = 1;
+
+            IF (common_window != FALSE)
+            THEN
+
+                CALL get_ics_info(
+                        audioObjectType = pVars->mc_info.audioObjectType,
+                        pInputStream = pInputStream,
+                        common_window = common_window,
+                        pWindowSequence = &pChVars[leftCh]->wnd,
+                        &pChVars[leftCh]->wnd_shape_this_bk,
+                        pChVars[leftCh]->group,
+                        &pChVars[leftCh]->max_sfb,
+                        pVars->winmap,
+                        &pChVars[leftCh]->lt_status,
+                        &pChVars[rightCh]->lt_status);
+                     MODIFYING(pInputStream, wnd, wnd_shape_this_bk,group,
+                               max_sfb, lt_status)
+                     RETURNING(status)
+
+                IF (status == SUCCESS)
+                THEN
+
+                    pChVars[rightCh]->wnd = pChVars[leftCh]->wnd;
+                    pChVars[rightCh]->wnd_shape_this_bk =
+                        pChVars[leftCh]->wnd_shape_this_bk;
+                    pChVars[rightCh]->max_sfb = pChVars[leftCh]->max_sfb;
+                    pv_memcpy(
+                        pChVars[rightCh]->group,
+                        pChVars[leftCh]->group,
+                        NSHORT*sizeof(pChVars[leftCh]->group[0]));
+
+                    hasmask = CALL getmask(
+                                    pVars->winmap[pChVars[leftCh]->wnd],
+                                    pInputStream,
+                                    pChVars[leftCh]->group,
+                                    pChVars[leftCh]->max_sfb,
+                                    pChVars[leftCh]->mask);
+                                MODIFYING(pInputStream, mask)
+                                RETURNING(hasmask)
+
+                    IF (hasmask == MASK_ERROR)
+                    THEN
+                        status = 1;
+                    ENDIF
+                    pChVars[leftCh]->hasmask  = hasmask;
+                    pChVars[rightCh]->hasmask = hasmask;
+
+                ENDIF
+
+            ELSE
+
+                 pChVars[leftCh]->hasmask  = 0;
+                 pChVars[rightCh]->hasmask = 0;
+            ENDIF(common_window)
+
+        ENDIF(id_syn_ele)
+
+    ENDIF (status)
+
+    ch = leftCh;
+
+    WHILE((ch <= rightCh) AND (status == SUCCESS))
+
+        status = CALL getics(
+                        pInputStream,
+                        common_window,
+                        pVars,
+                        pChVars[ch],
+                        pChVars[ch]->group,
+                        &pChVars[ch]->max_sfb,
+                        pChVars[ch]->cb_map,
+                        &pChVars[ch]->tns,
+                        pVars->winmap,
+                        &pVars->pulseInfo,
+                        pChVars[ch]->sect);
+                    MODIFYING(pInputStream,pVarsp,ChVars[ch],group,
+                              max_sfb,tns,pulseInfo,sect)
+                    RETURNING(status)
+
+        ch++;
+
+    ENDWHILE
+
+    RETURN status;
+
+------------------------------------------------------------------------------
+ RESOURCES USED
+   When the code is written for a specific target processor the
+     the resources used should be documented below.
+
+ STACK USAGE: [stack count for this module] + [variable to represent
+          stack usage for each subroutine called]
+
+     where: [stack usage variable] = stack usage for [subroutine
+         name] (see [filename].ext)
+
+ DATA MEMORY USED: x words
+
+ PROGRAM MEMORY USED: x words
+
+ CLOCK CYCLES: [cycle count equation for this module] + [variable
+           used to represent cycle count for each subroutine
+           called]
+
+     where: [cycle count variable] = cycle count for [subroutine
+        name] (see [filename].ext)
+
+------------------------------------------------------------------------------
+*/
+
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+#include    "pv_audio_type_defs.h"
+#include    "aac_mem_funcs.h"
+#include    "huffman.h"
+#include    "e_maskstatus.h"
+#include    "e_elementid.h"
+#include    "get_ics_info.h"
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here. Include conditional
+; compile variables also.
+----------------------------------------------------------------------------*/
+#define LEFT  (0)
+#define RIGHT (1)
+/*----------------------------------------------------------------------------
+; LOCAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; LOCAL STORE/BUFFER/POINTER DEFINITIONS
+; Variable declaration - defined here and used outside this module
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL FUNCTION REFERENCES
+; Declare functions defined elsewhere and referenced in this module
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL GLOBAL STORE/BUFFER/POINTER REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; FUNCTION CODE
+----------------------------------------------------------------------------*/
+Int huffdecode(
+    Int           id_syn_ele,
+    BITS          *pInputStream,
+    tDec_Int_File *pVars,
+    tDec_Int_Chan *pChVars[])
+
+{
+    /*----------------------------------------------------------------------------
+    ; Define all local variables
+    ----------------------------------------------------------------------------*/
+    Int      ch;
+    Int      common_window;
+    Int      hasmask;
+    Int      status   = SUCCESS;
+    Int      num_channels = 0;
+    MC_Info  *pMcInfo;
+
+    per_chan_share_w_fxpCoef *pChLeftShare;  /* Helper pointer */
+    per_chan_share_w_fxpCoef *pChRightShare; /* Helper pointer */
+    /*----------------------------------------------------------------------------
+    ; Function body here
+    ----------------------------------------------------------------------------*/
+
+    get9_n_lessbits(
+        LEN_TAG,
+        pInputStream);
+
+    /* suppose an un-supported id_syn_ele will never be passed */
+
+    common_window = 0;
+
+    if (id_syn_ele == ID_CPE)
+    {
+        common_window =
+            get1bits(pInputStream);
+    }
+
+    pMcInfo = &pVars->mc_info;
+
+    /*
+     *  check if provided info (num of channels) on audio config,
+     *  matches read bitstream data, if not, allow update only once.
+     *  In almost all cases it should match.
+     */
+    if ((pMcInfo->ch_info[0].cpe != id_syn_ele))
+    {
+        if (pVars->mc_info.implicit_channeling)     /* check done only once */
+        {
+            pMcInfo->ch_info[0].cpe = id_syn_ele & 1; /*  collect info from bitstream
+                                                     *  implicit_channeling flag is locked
+                                                     *  after 1st frame, to avoid toggling
+                                                     *  parameter in the middle of the clip
+                                                     */
+            pMcInfo->nch = (id_syn_ele & 1) + 1;     /* update number of channels */
+        }
+        else
+        {
+            status = 1; /* ERROR break if syntax error persist  */
+        }
+    }
+
+    if (status == SUCCESS)
+    {
+        if (id_syn_ele == ID_SCE)
+        {
+
+            num_channels = 1;
+            pVars->hasmask = 0;
+        }
+        else if (id_syn_ele == ID_CPE)
+        {
+            pChLeftShare = pChVars[LEFT]->pShareWfxpCoef;
+            pChRightShare = pChVars[RIGHT]->pShareWfxpCoef;
+            num_channels = 2;
+
+            if (common_window != FALSE)
+            {
+
+                status = get_ics_info(
+                             (tMP4AudioObjectType) pVars->mc_info.audioObjectType,
+                             pInputStream,
+                             (Bool)common_window,
+                             (WINDOW_SEQUENCE *) & pChVars[LEFT]->wnd,
+                             (WINDOW_SHAPE *) & pChVars[LEFT]->wnd_shape_this_bk,
+                             pChLeftShare->group,
+                             (Int *) & pChLeftShare->max_sfb,
+                             pVars->winmap,
+                             (LT_PRED_STATUS *) & pChLeftShare->lt_status,
+                             (LT_PRED_STATUS *) & pChRightShare->lt_status);
+
+                if (status == SUCCESS)
+                {
+                    /* copy left channel info to right channel */
+                    pChVars[RIGHT]->wnd = pChVars[LEFT]->wnd;
+                    pChVars[RIGHT]->wnd_shape_this_bk =
+                        pChVars[LEFT]->wnd_shape_this_bk;
+                    pChRightShare->max_sfb = pChLeftShare->max_sfb;
+                    pv_memcpy(
+                        pChRightShare->group,
+                        pChLeftShare->group,
+                        NSHORT*sizeof(pChLeftShare->group[0]));
+
+                    hasmask = getmask(
+                                  pVars->winmap[pChVars[LEFT]->wnd],
+                                  pInputStream,
+                                  pChLeftShare->group,
+                                  pChLeftShare->max_sfb,
+                                  pVars->mask);
+
+                    if (hasmask == MASK_ERROR)
+                    {
+                        status = 1; /* ERROR code */
+                    }
+                    pVars->hasmask  = hasmask;
+
+                } /* if (status == 0) */
+            }
+            else
+            {
+                pVars->hasmask  = 0;
+            } /* if (common_window) */
+
+        } /* if (id_syn_ele) */
+
+    } /* if (status) */
+
+    ch = 0;
+    while ((ch < num_channels) && (status == SUCCESS))
+    {
+        pChLeftShare = pChVars[ch]->pShareWfxpCoef;
+
+        status = getics(
+                     pInputStream,
+                     common_window,
+                     pVars,
+                     pChVars[ch],
+                     pChLeftShare->group,
+                     &pChLeftShare->max_sfb,
+                     pChLeftShare->cb_map,
+                     &pChLeftShare->tns,
+                     pVars->winmap,
+                     &pVars->share.a.pulseInfo,
+                     pVars->share.a.sect);
+
+        ch++;
+
+    } /* while (ch) */
+
+    /*----------------------------------------------------------------------------
+    ; Return status
+    ----------------------------------------------------------------------------*/
+
+    return status;
+
+} /* huffdecode */
+
diff --git a/media/libstagefright/codecs/aacdec/hufffac.cpp b/media/libstagefright/codecs/aacdec/hufffac.cpp
new file mode 100644
index 0000000..e5a9c59
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/hufffac.cpp
@@ -0,0 +1,550 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Pathname: ./src/hufffac.c
+ Funtions:
+    hufffac
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+ Description:  Modified from original shareware code
+
+ Description:  Modified to pass variables by reference to eliminate use
+               of global variables.
+
+ Description: (1) Modified with new templates,
+              (2) Modified variable names for clarity
+              (3) adjusted variables of "for loop"
+              (4) eliminated multiple returns, use return valid
+
+ Description: (1) Change return logic: 0 if success, 1 if error
+              (2) Define SectInfo structure to store section codebook index
+                  and section boundary
+              (3) Substitute "switch" with "if- else if"
+              (4) move BITS *pInputStream to second pass-in parameter
+              (5) pass in huffBookUsed[] to save stack size
+
+ Description: (1) Remove pass in parameter Hcb pBook
+
+ Description: Use binary tree search in decode_huff_cw_binary
+
+ Description: Use decode_huff_scl function.
+
+ Who:                                   Date: MM/DD/YYYY
+ Description:
+
+------------------------------------------------------------------------------
+ INPUT AND OUTPUT DEFINITIONS
+
+ Inputs:
+
+    *pFrameInfo     = pointer to structure that holds information
+                      of each Frame. type FrameInfo
+
+    *pInputStream   = pointer to input bitstream. type BITS
+
+    *pGroup         = pointer to array that contains the index of the first
+                      window in each group, type UChar
+
+    nsect           = number of sections to be decoded. type Int
+
+    *pSect          = pointer to structure array that contains the huffman
+                      codebook index and section boundary for each section,
+                      type SectInfo
+
+    global_gain     = initial value for "DPCM encoded" scalefactors and noise
+                      energy, type Int
+
+    *pFactors       = pointer to array that stores the decoded scalefactors,
+                      intensity position or noise energy, type Int
+
+    huffBookUsed    = array that will hold the huffman codebook index for
+                      each sfb, type Int
+
+    *pBook          = pointer to structure that contains the huffman codebook
+                      information, such as dimension, Largest Absolute Value
+                      (LAV) of each huffman codebook, etc. type Hcb
+
+
+ Local Stores/Buffers/Pointers Needed: None
+
+ Global Stores/Buffers/Pointers Needed: None
+
+ Outputs:
+         0 if success
+         1 if error
+
+ Pointers and Buffers Modified:
+
+        Int   *pFactors    contains the newly decoded scalefactors and/or
+                             intensity position and/or noise energy level
+
+ Local Stores Modified:
+
+ Global Stores Modified:
+
+------------------------------------------------------------------------------
+ FUNCTION DESCRIPTION
+
+ This function first reads the Huffman codebook index of all sections within
+ one Frame. Then, depending on the huffman codebook index of each section,
+ the function decodes the scalefactors, and/or intensity positions
+ (INTENSITY_HCB, INTENSITY_HCB2), and/or noise energy (NOISE_HCB)
+ for every scalefactor band in each section.
+ The function returns 0 upon successful decoding, returns 1 if error.
+
+------------------------------------------------------------------------------
+ REQUIREMENTS
+
+ This function should replace the content of the array pFactors with the
+ decoded scalefactors and/or intensity positions and/or noise energy
+
+------------------------------------------------------------------------------
+ REFERENCES
+
+ (1) MPEG-2 NBC Audio Decoder
+   "This software module was originally developed by AT&T, Dolby
+   Laboratories, Fraunhofer Gesellschaft IIS in the course of development
+   of the MPEG-2 NBC/MPEG-4 Audio standard ISO/IEC 13818-7, 14496-1,2 and
+   3. This software module is an implementation of a part of one or more
+   MPEG-2 NBC/MPEG-4 Audio tools as specified by the MPEG-2 NBC/MPEG-4
+   Audio standard. ISO/IEC  gives users of the MPEG-2 NBC/MPEG-4 Audio
+   standards free license to this software module or modifications thereof
+   for use in hardware or software products claiming conformance to the
+   MPEG-2 NBC/MPEG-4 Audio  standards. Those intending to use this software
+   module in hardware or software products are advised that this use may
+   infringe existing patents. The original developer of this software
+   module and his/her company, the subsequent editors and their companies,
+   and ISO/IEC have no liability for use of this software module or
+   modifications thereof in an implementation. Copyright is not released
+   for non MPEG-2 NBC/MPEG-4 Audio conforming products.The original
+   developer retains full right to use the code for his/her own purpose,
+   assign or donate the code to a third party and to inhibit third party
+   from using the code for non MPEG-2 NBC/MPEG-4 Audio conforming products.
+   This copyright notice must be included in all copies or derivative
+   works."
+   Copyright(c)1996.
+
+ (2) ISO/IEC 14496-3: 1999(E)
+     Subpart 4      p72-73  (scalefactors)
+                    p76     (decoding)
+                    p78     (Table 4.6.1, Table 4.6.2)
+                    p93-94  (INTENSITY_HCB)
+                    p123    (NOISE_HCB)
+
+------------------------------------------------------------------------------
+ PSEUDO-CODE
+
+ status = SUCCESS;
+
+ CALL pv_memset(pHuffBookUsed, ZERO_HCB, MAXBANDS*sizeof(*pHuffBookUsed));
+
+ CALL pv_memset(pFactors, ZERO_HCB, MAXBANDS*sizeof(*pFactors));
+
+ sect_start       = 0;
+
+ FOR(sect_idx = nsect; sect_idx > 0; sect_idx--)
+ {
+     sect_cb  = pSect->sect_cb;
+     sect_end = pSect->sect_end;
+     pSect++;
+
+     CALL pv_memset(
+        &pHuffBookUsed[sect_start],
+        sect_cb,
+        (sect_end - sect_start));
+
+ }
+ ENDFOR
+
+    fac       = global_gain;
+    is_pos    = 0;
+    noise_nrg = global_gain - NOISE_OFFSET;
+
+    pTable    = pBook[BOOKSCL].pTable;
+    group_win  = 0;
+    group_end  = 0;
+
+    WHILE((group_end < pFrameInfo->num_win)&&(status == SUCCESS))
+    {
+        nsfb_win  = pFrameInfo->sfb_per_win[group_end];
+        group_end = *pGroup++;
+
+        FOR(sfb = 0; sfb < nsfb_win; sfb++)
+        {
+            IF ((pHuffBookUsed[sfb] > 0)&&(pHuffBookUsed[sfb] < BOOKSCL))
+            {
+                cw_index = CALL decode_huff_cw_binary(pTable, pInputStream);
+
+                fac      += cw_index - MIDFAC;
+
+                IF((fac >= 2*TEXP) || (fac < 0))
+                {
+                    status = 1;
+                }
+                ELSE
+                {
+                    pFactors[sfb] = fac;
+                }
+                ENDIF (fac)
+
+            }
+            ELSE IF (pHuffBookUsed[sfb] == ZERO_HCB)
+            {
+                do nothing;
+            }
+
+            ELSE IF ((pHuffBookUsed[sfb] == INTENSITY_HCB)||
+                     (pHuffBookUsed[sfb] == INTENSITY_HCB2))
+            {
+                cw_index = CALL decode_huff_cw_binary(pTable, pInputStream);
+
+                is_pos        += cw_index - MIDFAC;
+                pFactors[sfb] =  is_pos;
+            }
+
+            ELSE IF (pHuffBookUsed[sfb] == NOISE_HCB)
+            {
+                IF (noise_pcm_flag == TRUE)
+                {
+                    noise_pcm_flag = FALSE;
+                    dpcm_noise_nrg = CALL getbits(
+                                              NOISE_PCM_BITS,
+                                              pInputStream);
+
+                    dpcm_noise_nrg -= NOISE_PCM_OFFSET;
+                }
+                ELSE
+                {
+                    dpcm_noise_nrg = CALL decode_huff_cw_binary(
+                                              pTable,
+                                              pInputStream);
+
+                    dpcm_noise_nrg -= MIDFAC;
+                }
+                ENDIF (noise_pcm_flag)
+
+                noise_nrg       += dpcm_noise_nrg;
+                pFactors[sfb]   =  noise_nrg;
+            }
+
+            ELSE IF (pHuffBookUsed[sfb] == BOOKSCL)
+            {
+                status = 1;
+            }
+            ENDIF (pHuffBookUsed[sfb])
+
+        }
+        ENDFOR (sfb)
+
+        IF (pFrameInfo->islong == FALSE)
+        {
+
+            FOR(group_win++; group_win < group_end; group_win++)
+            {
+                FOR (sfb=0; sfb < nsfb_win; sfb++)
+                {
+                    pFactors[sfb + nsfb_win]  =  pFactors[sfb];
+                }
+                ENDFOR
+
+                pFactors  +=  nsfb_win;
+            }
+            ENDFOR
+
+        }
+        ENDIF (pFrameInfo)
+
+        pHuffBookUsed   += nsfb_win;
+        pFactors        += nsfb_win;
+
+    }
+    ENDWHILE (group_end)
+
+    return status;
+
+------------------------------------------------------------------------------
+ RESOURCES USED
+   When the code is written for a specific target processor the
+     the resources used should be documented below.
+
+ STACK USAGE: [stack count for this module] + [variable to represent
+          stack usage for each subroutine called]
+
+     where: [stack usage variable] = stack usage for [subroutine
+         name] (see [filename].ext)
+
+ DATA MEMORY USED: x words
+
+ PROGRAM MEMORY USED: x words
+
+ CLOCK CYCLES: [cycle count equation for this module] + [variable
+           used to represent cycle count for each subroutine
+           called]
+
+     where: [cycle count variable] = cycle count for [subroutine
+        name] (see [filename].ext)
+
+------------------------------------------------------------------------------
+*/
+
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+#include    "pv_audio_type_defs.h"
+#include    "aac_mem_funcs.h"       /* pv_memset */
+#include    "s_frameinfo.h"
+#include    "s_bits.h"
+#include    "s_sectinfo.h"
+#include    "s_huffman.h"
+#include    "ibstream.h"
+
+#include    "hcbtables.h"
+#include    "e_huffmanconst.h"
+#include    "e_infoinitconst.h"
+#include    "huffman.h"
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here. Include conditional
+; compile variables also.
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; LOCAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; LOCAL STORE/BUFFER/POINTER DEFINITIONS
+; Variable declaration - defined here and used outside this module
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL FUNCTION REFERENCES
+; Declare functions defined elsewhere and referenced in this module
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL GLOBAL STORE/BUFFER/POINTER REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; FUNCTION CODE
+----------------------------------------------------------------------------*/
+Int hufffac(
+    FrameInfo   *pFrameInfo,
+    BITS        *pInputStream,
+    Int         *pGroup,    /* may be changed to Int */
+    Int         nsect,
+    SectInfo    *pSect,     /* may be changed to Int */
+    Int         global_gain,
+    Int         *pFactors,
+    Int         huffBookUsed[])
+{
+    Int     sect_idx;
+    Int     group_end;  /* index of 1st window in next group */
+    Int     group_win;  /* window index within group */
+    Int     cw_index;   /* huff codeword index */
+    Int     nsfb_win;   /* # of scfbands per window */
+    Int     sfb;        /* scalefactor band index */
+    Int     sect_cb;    /* huff codebook # for each section */
+    Int     fac;        /* decoded scf */
+    Int     is_pos;     /* intensity stereo position */
+    Int     noise_pcm_flag = TRUE;  /* first PNS sfb */
+    Int     dpcm_noise_nrg;     /* dpcm noise energy */
+    Int     noise_nrg;      /* noise energy */
+    Int     status = SUCCESS;  /* status of decoding */
+    Int     *pHuffBookUsed = &huffBookUsed[0];
+
+
+    pv_memset(pFactors,
+              ZERO_HCB,
+              MAXBANDS*sizeof(*pFactors));
+
+
+    if (nsect)
+    {
+        /* read section length and codebook */
+
+        if (nsect == 1) /* long window */
+        {
+            sect_cb  = pSect->sect_cb;  /* codebook for this section */
+
+            /* all sfbs in one section share the same codebook */
+
+            for (sfb = pSect->sect_end >> 2; sfb != 0; sfb--)
+            {
+                *(pHuffBookUsed++) = sect_cb;
+                *(pHuffBookUsed++) = sect_cb;
+                *(pHuffBookUsed++) = sect_cb;
+                *(pHuffBookUsed++) = sect_cb;
+            }
+            for (sfb = pSect->sect_end & 3; sfb != 0; sfb--)
+            {
+                *(pHuffBookUsed++) = sect_cb;
+            }
+
+        }
+        else            /* short */
+        {
+            Int sect_start = 0; /* start index of sfb for each section */
+            for (sect_idx = nsect; sect_idx > 0; sect_idx--)
+            {
+                sect_cb  = pSect->sect_cb;  /* codebook for this section */
+
+                /* all sfbs in one section share the same codebook */
+                for (sfb = sect_start; sfb < pSect->sect_end; sfb++)
+                {
+                    pHuffBookUsed[sfb] = sect_cb;
+                }
+
+                pSect++;
+                sect_start = sfb;
+
+            } /* for (sect_idx) */
+        }
+    }
+    else
+    {
+        /* clear array for the case of max_sfb == 0 */
+        pv_memset(pHuffBookUsed,
+                  ZERO_HCB,
+                  MAXBANDS*sizeof(*pHuffBookUsed));
+    }
+
+    pHuffBookUsed = &huffBookUsed[0];
+
+    /* scale factors and noise energy are dpcm relative to global gain
+     * intensity positions are dpcm relative to zero
+     */
+    fac       = global_gain;
+    is_pos    = 0;
+    noise_nrg = global_gain - NOISE_OFFSET;
+
+    /* get scale factors,
+     * use reserved Table entry = 12, see reference (2) p78 Table 4.6.2
+     */
+    group_win  = 0;
+    group_end  = 0;
+
+
+    /* group by group decoding scalefactors and/or noise energy
+     * and/or intensity position
+     */
+    while ((group_end < pFrameInfo->num_win) && (status == SUCCESS))
+    {
+        nsfb_win  = pFrameInfo->sfb_per_win[group_end];
+        group_end = *pGroup++;  /* index of 1st window in next group */
+
+        /* decode scf in first window of each group */
+
+        for (sfb = 0; sfb < nsfb_win; sfb++)
+        {
+
+            switch (pHuffBookUsed[sfb])
+            {
+                case ZERO_HCB:
+                    break;
+                case INTENSITY_HCB:
+                case INTENSITY_HCB2:
+                    /* intensity books */
+                    /* decode intensity position */
+                    cw_index = decode_huff_scl(pInputStream);
+
+                    is_pos        += cw_index - MIDFAC;
+                    pFactors[sfb] =  is_pos;
+                    break;
+                case NOISE_HCB:
+                    /* noise books */
+                    /* decode noise energy */
+                    if (noise_pcm_flag == TRUE)
+                    {
+                        noise_pcm_flag = FALSE;
+                        dpcm_noise_nrg = get9_n_lessbits(NOISE_PCM_BITS,
+                                                         pInputStream);
+
+                        dpcm_noise_nrg -= NOISE_PCM_OFFSET;
+                    }
+                    else
+                    {
+                        dpcm_noise_nrg = decode_huff_scl(pInputStream);
+
+                        dpcm_noise_nrg -= MIDFAC;
+                    } /* if (noise_pcm_flag) */
+
+                    noise_nrg       += dpcm_noise_nrg;
+                    pFactors[sfb]   =  noise_nrg;
+                    break;
+                case BOOKSCL:
+                    status = 1; /* invalid books */
+                    sfb = nsfb_win;  /* force out */
+                    break;
+                default:
+                    /* spectral books */
+                    /* decode scale factors */
+                    cw_index = decode_huff_scl(pInputStream);
+
+                    fac      += cw_index - MIDFAC;   /* 1.5 dB */
+                    if ((fac >= 2*TEXP) || (fac < 0))
+                    {
+                        status = 1;   /* error, MUST 0<=scf<256, Ref. p73 */
+                    }
+                    else
+                    {
+                        pFactors[sfb] = fac;  /* store scf */
+                    } /* if (fac) */
+            }
+
+        } /* for (sfb=0), first window decode ends */
+
+        /* expand scf to other windows in the same group */
+        if (pFrameInfo->islong == FALSE)
+        {
+
+            for (group_win++; group_win < group_end; group_win++)
+            {
+                for (sfb = 0; sfb < nsfb_win; sfb++)
+                {
+                    pFactors[sfb + nsfb_win]  =  pFactors[sfb];
+                }
+                pFactors  +=  nsfb_win;
+            }
+
+        } /* if (pFrameInfo->islong), one group decode ends */
+
+
+        /* points to next group */
+        pHuffBookUsed   += nsfb_win;
+        pFactors        += nsfb_win;
+
+    } /* while (group_end), all groups decode end */
+
+    return status;
+
+} /* hufffac */
+
diff --git a/media/libstagefright/codecs/aacdec/huffman.h b/media/libstagefright/codecs/aacdec/huffman.h
new file mode 100644
index 0000000..030ae23
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/huffman.h
@@ -0,0 +1,241 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Pathname: .huffman.h
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+ Description: Put declaration of getfill in this file.
+
+ Description: Remove prstflag from get_ics_info declaration.
+
+ Description: Trivial change of the data type of one of the parameters to
+              get_ics_info.
+
+ Description: Change where get_ics_info is declared.
+
+ Description: Clean up comments
+
+ Description: (1) Add declaration of binary tree search function for Huffman
+                  decoding
+              (2) #if the traditional and optimized linear seach methods.
+
+ Description: Modified per review comments
+              (1) delete #if traditional and optimized linear seach methods
+
+ Description: Merged Ken's change on getics: delete pFrameInfo from argument
+              list
+
+ Description: Added function definition for table specific huffman decoding
+              functions.
+
+ Who:                                         Date:
+ Description:
+
+------------------------------------------------------------------------------
+ INCLUDE DESCRIPTION
+
+ include function prototype definitions for Huffman decoding module
+
+------------------------------------------------------------------------------
+*/
+
+/*----------------------------------------------------------------------------
+; CONTINUE ONLY IF NOT ALREADY DEFINED
+----------------------------------------------------------------------------*/
+#ifndef HUFFMAN_H
+#define HUFFMAN_H
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+    /*----------------------------------------------------------------------------
+    ; INCLUDES
+    ----------------------------------------------------------------------------*/
+#include    "pv_audio_type_defs.h"
+#include    "s_frameinfo.h"
+#include    "s_sectinfo.h"
+#include    "s_pulseinfo.h"
+#include    "s_tdec_int_file.h"
+#include    "s_tdec_int_chan.h"
+#include    "ibstream.h"
+
+#include    "s_hcb.h"
+#include    "hcbtables.h"
+
+#include    "get_pulse_data.h"
+#include    "get_ics_info.h"
+
+    /*----------------------------------------------------------------------------
+    ; MACROS
+    ; Define module specific macros here
+    ----------------------------------------------------------------------------*/
+
+    /*----------------------------------------------------------------------------
+    ; DEFINES
+    ; Include all pre-processor statements here.
+    ----------------------------------------------------------------------------*/
+#define DIMENSION_4     4
+#define DIMENSION_2     2
+
+    /*----------------------------------------------------------------------------
+    ; EXTERNAL VARIABLES REFERENCES
+    ; Declare variables used in this module but defined elsewhere
+    ----------------------------------------------------------------------------*/
+
+    /*----------------------------------------------------------------------------
+    ; SIMPLE TYPEDEF'S
+    ----------------------------------------------------------------------------*/
+
+    /*----------------------------------------------------------------------------
+    ; ENUMERATED TYPEDEF'S
+    ----------------------------------------------------------------------------*/
+
+    /*----------------------------------------------------------------------------
+    ; STRUCTURES TYPEDEF'S
+    ----------------------------------------------------------------------------*/
+
+    /*----------------------------------------------------------------------------
+    ; GLOBAL FUNCTION DEFINITIONS
+    ; Function Prototype declaration
+    ----------------------------------------------------------------------------*/
+    Int decode_huff_cw_tab1(
+        BITS *pInputStream);
+
+    Int decode_huff_cw_tab2(
+        BITS *pInputStream);
+
+    Int decode_huff_cw_tab3(
+        BITS *pInputStream);
+
+    Int decode_huff_cw_tab4(
+        BITS *pInputStream);
+
+    Int decode_huff_cw_tab5(
+        BITS *pInputStream);
+
+    Int decode_huff_cw_tab6(
+        BITS *pInputStream);
+
+    Int decode_huff_cw_tab7(
+        BITS *pInputStream);
+
+    Int decode_huff_cw_tab8(
+        BITS *pInputStream);
+
+    Int decode_huff_cw_tab9(
+        BITS *pInputStream);
+
+    Int decode_huff_cw_tab10(
+        BITS *pInputStream);
+
+    Int decode_huff_cw_tab11(
+        BITS *pInputStream);
+
+    Int decode_huff_scl(
+        BITS          *pInputStream);
+
+    Int infoinit(
+        const  Int sampling_rate_idx,
+        FrameInfo   **ppWin_seq_info,
+        Int    *pSfbwidth128);
+
+    Int huffcb(
+        SectInfo *pSect,
+        BITS     *pInputStream,
+        Int      *pSectbits,
+        Int       tot_sfb,
+        Int       sfb_per_sbk,
+        Int       max_sfb);
+
+    Int hufffac(
+        FrameInfo   *pFrameInfo,
+        BITS        *pInputStream,
+        Int         *pGroup,
+        Int          nsect,
+        SectInfo    *pSect,
+        Int          global_gain,
+        Int         *pFactors,
+        Int          huffBookUsed[]);
+
+    Int huffspec_fxp(
+        FrameInfo *pFrameInfo,
+        BITS      *pInputStream,
+        Int       nsect,
+        SectInfo  *pSectInfo,
+        Int       factors[],
+        Int32     coef[],
+        Int16     quantSpec[],
+        Int16     tmp_spec[],
+        const FrameInfo  *pLongFrameInfo,
+        PulseInfo  *pPulseInfo,
+        Int         qFormat[]);
+
+    Int huffdecode(
+        Int           id_syn_ele,
+        BITS          *pInputStream,
+        tDec_Int_File *pVars,
+        tDec_Int_Chan *pChVars[]);
+
+    void deinterleave(
+        Int16          interleaved[],
+        Int16        deinterleaved[],
+        FrameInfo   *pFrameInfo);
+
+    Int getics(
+
+        BITS            *pInputStream,
+        Int             common_window,
+        tDec_Int_File   *pVars,
+        tDec_Int_Chan   *pChVars,
+        Int             group[],
+        Int             *pMax_sfb,
+        Int             *pCodebookMap,
+        TNS_frame_info  *pTnsInfo,
+        FrameInfo       **pWinMap,
+        PulseInfo       *pPulseInfo,
+        SectInfo        sect[]);
+
+    void  calc_gsfb_table(
+        FrameInfo   *pFrameInfo,
+        Int         group[]);
+
+    Int getmask(
+        FrameInfo   *pFrameInfo,
+        BITS        *pInputStream,
+        Int         *pGroup,
+        Int         max_sfb,
+        Int         *pMask);
+
+    void getgroup(
+        Int         group[],
+        BITS        *pInputStream);
+
+
+    /*----------------------------------------------------------------------------
+    ; END
+    ----------------------------------------------------------------------------*/
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/media/libstagefright/codecs/aacdec/huffspec_fxp.cpp b/media/libstagefright/codecs/aacdec/huffspec_fxp.cpp
new file mode 100644
index 0000000..b18c12d
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/huffspec_fxp.cpp
@@ -0,0 +1,671 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Pathname:  huffspec_fxp.c
+ Funtions:
+    huffspec_fxp
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+ Description:  Modified from original shareware code
+
+ Description:  Modified to pass variables by reference to eliminate use
+               of global variables.
+
+ Description: (1) Modified to keep in-line with PV standards
+              (2) Eliminated "continue" in if(sect_cb==ZERO_HCB||...)
+
+ Description: (1) Use SectInfo *pSect
+              (2) Convert 'Real' to 'Int32', float -> fixed-point
+              (3) move BITS *pInputStream to second parameter
+              (4) pass in quantSpec and tmp_spec, scratch shared with hufffac
+              (5) pass in FrameInfo *pLongFrameInfo, eliminate only_long_info
+
+ Description: (1) Eliminate parameter Hcb *book, because of eliminating
+                  function 'hufftab.c', Hcb hcbbook defined as a
+                  const structure in 'hcbtables.h'.
+              (2) Replace three nested 'for' loops with a for-while loop in
+                  the rescaling part.
+              (3) Change esc_iquant-> esc_iquant_fxp, call esc_iquant_fxp()
+                  by sfb
+
+ Description: Cleaned up include files.
+
+ Description:  Correct definition of stack variable "scale".
+        It was defined as Int, but it receives an UInt value,
+        this present a problem when Int is 16 bits and
+        the sign bit is not interpreted correctly. This does not
+        shows for 32-bit implementations. This problem manifest itself
+        as a flipping sign on some spectral coefficients (the ones
+        multiplied by 0x8000).
+
+ Description: Typecast b_low and b_high to 32-bits before multiplication, this
+              assures propoer compilation on a 16-bit platform (TI-C55x)
+
+ Description: Modified to speed up decode_huff_cw
+
+ Description: pass codebook index to decode_huff_cw, delete pointer to Huffman
+              structure
+
+ Description: keep memset to quantSpec, remove memset to temp_spec
+
+ Description: Modified per review comments
+
+ Description: Use Binary tree search in decode_huff_cw_binary
+
+ Description: Modified per review comments
+              (1) delete unused codes
+
+ Description: (1) Change the interface to decode huffman codeword.
+              (2) Move the scaling inside the inverse quantization.
+              (3) Change scaling factor accuracy to 10 bits.
+
+ Description:
+              (1) delete unused variable max_fac
+
+ Description: Addresses of huffman tables are now found by means of a
+              switch statement, this solve linking problem when using the
+              /ropi option (Read-only position independent) for some
+              compilers
+
+ Who:                                   Date: MM/DD/YYYY
+ Description:
+------------------------------------------------------------------------------
+ INPUT AND OUTPUT DEFINITIONS
+
+ Inputs:
+    pFrameInfo  = ptr to structure that holds Information of current Frame,
+                  type FrameInfo
+
+    pInputStream = ptr to structure of bitstream, type BITS
+
+    nsect       = number of sections in current Frame, at fs = 44.1 kHz,
+                  range [0, 49] long block, [0,112] short blocks. type Int
+
+    pSect       = ptr to structure that holds section codebook and boundary
+                  type SectInfo
+
+    factors[]   = array that contains scalefactors for each sfb, type Int16
+
+    coef[]      = array that holds inverse quantized coefs, Int32 QFormat.
+
+    quantSpec[] = array that holds quantized spectral coefs, type Int
+
+    tmp_spec[]  = temporary buffer to hold the de-interleaved coefs.
+
+    pLongFrameInfo = ptr to structure that holds long frame info
+
+ Local Stores/Buffers/Pointers Needed:
+    exptable = array contains the Q15 format data for 2^0, 2^0.25, 2^0.5,
+               and 2^0.75, type const Int.
+
+ Global Stores/Buffers/Pointers Needed:
+    None
+
+ Outputs:
+
+    return 0 if decoding properly.
+
+ Pointers and Buffers Modified:
+
+    pInputStream    read codeword index and/or sign bits and/or ESC value
+
+    coef            contains the newly inverse quantized 1024 spec coefs,
+                    type Int32 Q-format from esc_iquant()
+
+    quantSpec       contains decoded quantized 1024 spec coefs, type Int
+
+    tmp_spec        contains the de-interleaved version of quantSpec
+
+    qFormat         contains Q-Format for each scalefactor band
+
+ Local Stores Modified:
+    None
+
+ Global Stores Modified:
+    None
+
+------------------------------------------------------------------------------
+ FUNCTION DESCRIPTION
+
+ This function first reads the section info (codebook and boundary), then
+ decode the spectral coefficients if a spectral codebook is used.
+ If necessary, get the sign bits, ESC value or the NEC_pulse data. In case of
+ short window sequences, the decoded data is de-interleaved before
+ multiplied by scalefactors.
+
+------------------------------------------------------------------------------
+ REQUIREMENTS
+
+ This function should set the content of the array 'coef' with the inverse
+ quantized and rescaled value of spectral coefficients.
+
+------------------------------------------------------------------------------
+ REFERENCES
+
+ (1) MPEG-2 NBC Audio Decoder
+   "This software module was originally developed by AT&T, Dolby
+   Laboratories, Fraunhofer Gesellschaft IIS in the course of development
+   of the MPEG-2 NBC/MPEG-4 Audio standard ISO/IEC 13818-7, 14496-1,2 and
+   3. This software module is an implementation of a part of one or more
+   MPEG-2 NBC/MPEG-4 Audio tools as specified by the MPEG-2 NBC/MPEG-4
+   Audio standard. ISO/IEC  gives users of the MPEG-2 NBC/MPEG-4 Audio
+   standards free license to this software module or modifications thereof
+   for use in hardware or software products claiming conformance to the
+   MPEG-2 NBC/MPEG-4 Audio  standards. Those intending to use this software
+   module in hardware or software products are advised that this use may
+   infringe existing patents. The original developer of this software
+   module and his/her company, the subsequent editors and their companies,
+   and ISO/IEC have no liability for use of this software module or
+   modifications thereof in an implementation. Copyright is not released
+   for non MPEG-2 NBC/MPEG-4 Audio conforming products.The original
+   developer retains full right to use the code for his/her own purpose,
+   assign or donate the code to a third party and to inhibit third party
+   from using the code for non MPEG-2 NBC/MPEG-4 Audio conforming products.
+   This copyright notice must be included in all copies or derivative
+   works."
+   Copyright(c)1996.
+
+ (2) ISO/IEC 14496-3: 1999(E)
+    Subpart (4)         p56 (spectral_data() parsing and decoding)
+                        p26 (Syntax of spectral_data())
+                        p74-78 (decoding: unpack_idx, get_sign_bits,
+                                getescape, pulse_nc, deinterleave)
+                        p72 (inverse quantization: esc_iquant)
+
+------------------------------------------------------------------------------
+ PSEUDO-CODE
+
+
+------------------------------------------------------------------------------
+ RESOURCES USED
+   When the code is written for a specific target processor the
+     the resources used should be documented below.
+
+ STACK USAGE: [stack count for this module] + [variable to represent
+          stack usage for each subroutine called]
+
+     where: [stack usage variable] = stack usage for [subroutine
+         name] (see [filename].ext)
+
+ DATA MEMORY USED: x words
+
+ PROGRAM MEMORY USED: x words
+
+ CLOCK CYCLES: [cycle count equation for this module] + [variable
+           used to represent cycle count for each subroutine
+           called]
+
+     where: [cycle count variable] = cycle count for [subroutine
+        name] (see [filename].ext)
+
+------------------------------------------------------------------------------
+*/
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+#include    "pv_audio_type_defs.h"
+#include    "aac_mem_funcs.h"
+#include    "esc_iquant_scaling.h"
+#include    "huffman.h"
+#include    "unpack_idx.h"
+#include    "pulse_nc.h"
+#include    "iquant_table.h"
+#include    "e_huffmanconst.h"
+
+
+#include "pv_normalize.h"
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here. Include conditional
+; compile variables also.
+----------------------------------------------------------------------------*/
+#define ORDER        (3)
+
+/*
+ * Format the table is stored in.
+ */
+#define QTABLE       (27)
+
+/*
+ * Number of bits for data in a signed 32 bit integer.
+ */
+#define SIGNED32BITS  (31)
+
+/*
+ * Round up value for intermediate values obtained from the table
+ */
+#define ROUND_UP (( ((UInt32) 1) << (QTABLE) )-1)
+
+/*----------------------------------------------------------------------------
+; LOCAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; LOCAL STORE/BUFFER/POINTER DEFINITIONS
+; Variable declaration - defined here and used outside this module
+----------------------------------------------------------------------------*/
+const UInt16 exptable[4] =
+{
+    0,  /* (2^0.00)<<15 (Q10), use zero to signal no scaling required! */
+    19485,  /* (2^0.25)<<15 */
+    23171,  /* (2^0.50)<<15 */
+    27555   /* (2^0.75)<<15 */
+
+};
+
+
+/*----------------------------------------------------------------------------
+; EXTERNAL FUNCTION REFERENCES
+; Declare functions defined elsewhere and referenced in this module
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL GLOBAL STORE/BUFFER/POINTER REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; FUNCTION CODE
+----------------------------------------------------------------------------*/
+
+Int huffspec_fxp(
+    FrameInfo *pFrameInfo,
+    BITS      *pInputStream,
+    Int       nsect,
+    SectInfo  *pSectInfo,
+    Int       factors[],
+    Int32     coef[],
+    Int16     quantSpec[],
+    Int16     tmp_spec[],
+    const FrameInfo  *pLongFrameInfo,
+    PulseInfo  *pPulseInfo,
+    Int         qFormat[])
+{
+    /*----------------------------------------------------------------------------
+    ; Define all local variables
+    ----------------------------------------------------------------------------*/
+    const Hcb       *pHcb;
+    Int     i;
+    Int     sfb;
+    Int     idx_count;
+    Int     sect_cb;    /* section codebook */
+    Int     dim;
+    Int     idx;
+    Int     stop_idx;     /* index of 1st coef in next sfb */
+    Int     sect_start;   /* start index of sfb in one section*/
+    Int     sect_end;     /* index of 1st sfb in next section */
+    Int     *pSfbStart;
+    Int     *pSfb;
+    Int16     *pQuantSpec;        /* probably could be short */
+    Int     max = 0;
+    /* rescaling parameters */
+    Int     nsfb;
+    Int     tot_sfb;
+    Int     fac;
+
+    Int32   *pCoef; /* ptr to coef[], inverse quantized coefs */
+    UInt16     scale;
+
+    Int     power_scale_div_4;
+    Int     sfbWidth;
+
+    void (*pUnpack_idx)(
+        Int16  quant_spec[],
+        Int  codeword_indx,
+        const Hcb *pHuffCodebook,
+        BITS  *pInputStream,
+        Int *max);
+
+    Int(*pDec_huff_tab)(BITS *) = NULL;
+
+    UInt32 temp;
+    Int    binaryDigits, QFormat;
+
+    /*----------------------------------------------------------------------------
+    ; Function body here
+    ----------------------------------------------------------------------------*/
+
+    sect_start = 0;
+    stop_idx   = 0;
+
+    /* pSfb: ptr to array that holds stop index of each sfb */
+    pSfbStart = pFrameInfo->frame_sfb_top;
+
+    if (pSfbStart == NULL)
+    {
+        return (-1);   /*  error condition */
+    }
+
+    pSfb      = pSfbStart;
+
+    /* decoding spectral values section by section */
+    for (i = nsect; i > 0; i--)
+    {
+        /* read the codebook and section length */
+        sect_cb  =  pSectInfo->sect_cb;     /* codebook */
+        if ((sect_cb > 15) || (sect_cb < 0))
+        {
+            return (-1);   /*  error condition */
+        }
+        sect_end =  pSectInfo->sect_end;    /* # of sfbs */
+
+        if (sect_end < 0)
+        {
+            return (-1);   /*  error condition */
+        }
+
+        pSectInfo++;
+
+        /*  sect_cb       sect_cb - 1
+         *  ZERO_HCB        1111b
+         *    1             0000b
+         *    2             0001b
+         *    3             0010b
+         *    4             0011b
+         *    5             0100b
+         *    6             0101b
+         *    7             0110b
+         *    8             0111b
+         *    9             1000b
+         *    10            1001b
+         *    11            1010b
+         *    12            1011b
+         * NOISE_HCB        1100b
+         * INTENSITY_HCB2   1101b
+         * INTENSITY_HCB    1110b
+         * if ( ((sect_cb - 1) & 0xC) == 0xC ) is identical to
+         * if !((sect_cb == ZERO_HCB) || (sect_cb == NOISE_HCB) ||
+         *      (sec_cb == INTENSITY_HCB) || (sect_cb==INTENSITY_HCB2) )
+         * use this compare scheme to speed up the execution
+         */
+
+        if (((sect_cb - 1) & 0xC) != 0xC)
+        {
+            /* decode spec in one section */
+            if (sect_cb > BY4BOOKS)
+            {
+                dim = DIMENSION_2; /* set codebook dimension */
+            }
+            else
+            {
+                dim = DIMENSION_4;
+            }
+
+            pHcb        = &hcbbook_binary[sect_cb];
+
+            if (sect_cb == ESCBOOK)
+            {
+                pUnpack_idx = &unpack_idx_esc;
+            }
+            else if (pHcb->signed_cb == FALSE)
+            {
+                pUnpack_idx = &unpack_idx_sgn;
+            }
+            else
+            {
+                pUnpack_idx = &unpack_idx;
+            }
+
+
+            switch (sect_cb)
+            {
+                case 1:
+                    pDec_huff_tab = decode_huff_cw_tab1;
+                    break;
+                case 2:
+                    pDec_huff_tab = decode_huff_cw_tab2;
+                    break;
+                case 3:
+                    pDec_huff_tab = decode_huff_cw_tab3;
+                    break;
+                case 4:
+                    pDec_huff_tab = decode_huff_cw_tab4;
+                    break;
+                case 5:
+                    pDec_huff_tab = decode_huff_cw_tab5;
+                    break;
+                case 6:
+                    pDec_huff_tab = decode_huff_cw_tab6;
+                    break;
+                case 7:
+                    pDec_huff_tab = decode_huff_cw_tab7;
+                    break;
+                case 8:
+                    pDec_huff_tab = decode_huff_cw_tab8;
+                    break;
+                case 9:
+                    pDec_huff_tab = decode_huff_cw_tab9;
+                    break;
+                case 10:
+                    pDec_huff_tab = decode_huff_cw_tab10;
+                    break;
+                case 11:
+                    pDec_huff_tab = decode_huff_cw_tab11;
+                    break;
+                default:
+                    return (-1); /* error condition */
+            }
+
+            /* move ptr to first sfb of current section */
+            pQuantSpec  = quantSpec + stop_idx;
+
+            /* step through all sfbs in current section */
+            for (sfb = sect_start; sfb < sect_end; sfb++)
+            {
+                idx_count = *pSfb - stop_idx;
+                stop_idx  = *pSfb++;
+
+                /* decode all coefs for one sfb */
+                while ((idx_count > 0) && (idx_count < 1024))
+                {
+
+                    idx = (*pDec_huff_tab)(pInputStream);
+
+                    (*pUnpack_idx)(pQuantSpec,
+                                   idx,
+                                   pHcb,
+                                   pInputStream,
+                                   &max);      /* unpack idx -> coefs */
+
+                    pQuantSpec += dim;
+                    idx_count  -= dim;
+
+                } /* while(idx_count) */
+
+            } /* for (sfb=sect_start) */
+        }
+        else
+        {
+
+            /* current section uses ZERO_HCB, NOISE_HCB, etc */
+
+            /* move sfb pointer to the start sfb of next section */
+            pSfb        = pSfbStart + sect_end;
+            /* number of coefs in current section */
+            idx_count   = *(pSfb - 1) - stop_idx;
+
+            if ((idx_count > 1024) || (idx_count < 0))
+            {
+                return (-1);   /*  error condition */
+            }
+
+            /*
+             * This memset is necessary in terms of (1) net savings in total
+             * MIPS and (2) accurate Q-Formats for fft_rx2
+             * In case a scalefactor band uses ZERO_HCB, all coefficients of
+             * that sfb should be zeros. Without this call to memset, the
+             * coefficients for a ZERO_HCB sfb are the "leftovers" of the
+             * previous frame, which may not have all zero values. This leads
+             * to a drastical increase in the cycles consumed by esc_iquant_fxp
+             * and fft_rx2, which is the most "expensive" function of the
+             * library.
+             * This memset also guarantees the Q_Format for sfbs with all zero
+             * coefficients will be set properly.
+             * Profiling data on ARM and TMS320C55x proves that there is a net
+             * gain in total MIPS if a memset is called here.
+             */
+            pv_memset(&quantSpec[stop_idx],
+                      0,
+                      idx_count * sizeof(quantSpec[0]));
+
+            /*
+             * This memset is called because pQuantSpec points to tmp_spec
+             * after deinterleaving
+             */
+
+            pv_memset(&tmp_spec[stop_idx],
+                      0,
+                      idx_count * sizeof(tmp_spec[0]));
+
+
+            /* stop_idx is the index of the 1st coef of next section */
+            stop_idx    = *(pSfb - 1);
+
+        }/* if (sect_cb) */
+
+        sect_start = sect_end;
+
+    } /* for (i=nsect) */
+
+    /* noisless coding reconstruction */
+    if (pFrameInfo->islong != FALSE)
+    {
+        if (pPulseInfo->pulse_data_present == 1)
+        {
+            pulse_nc(quantSpec,
+                     pPulseInfo,
+                     pLongFrameInfo,
+                     &max);    /* add pulse data */
+        }
+
+        pQuantSpec = quantSpec;
+
+    }
+    else
+    {
+        deinterleave(quantSpec,
+                     tmp_spec,
+                     pFrameInfo);
+
+        pQuantSpec = tmp_spec;
+    }
+
+
+    /* inverse quantization, Q_format: Int32 */
+    /* rescaling */
+
+    /* what we can do here is assuming that we already know maxInput for each band, we have to go
+    though each one of them for re-quant and scaling, and pick the right qFormat to apply to
+    all spectral coeffs.*/
+
+    if ((max < 0) || (max > 8192))    /* (8192>>ORDER) == 1024 is the inverseQuantTable size */
+    {
+        return (-1);   /*  error condition */
+    }
+    else
+    {
+        /* Get  (max/SPACING) ^ (1/3), in Q Format  */
+        temp = inverseQuantTable[(max >> ORDER) + 1];
+    }
+
+
+    /* Round up before shifting down to Q0 */
+    temp += ROUND_UP;
+
+    /* shift down to Q0 and multiply by 2 (FACTOR) in one step */
+    temp >>= (QTABLE - 1);
+
+    /* Now get max ^ (4/3) in Q0 */
+    temp *= max;
+
+
+    binaryDigits = 31 - pv_normalize(temp);
+
+
+    /* Prevent negative shifts caused by low maximums. */
+    if (binaryDigits < (SIGNED32BITS - QTABLE))
+    {
+        binaryDigits = SIGNED32BITS - QTABLE;
+    }
+
+    QFormat = SIGNED32BITS - binaryDigits;
+
+    /********************/
+    tot_sfb = 0;
+    nsfb = pFrameInfo->sfb_per_win[0];
+    pCoef = coef;
+
+    for (i = pFrameInfo->num_win; i > 0; i--)
+    {
+        stop_idx  = 0;
+
+        for (sfb = 0; sfb < nsfb; sfb++)
+        {
+            sfbWidth   =  pFrameInfo->win_sfb_top[0][sfb] - stop_idx;
+
+            if ((sfbWidth < 0) || (sfbWidth > 1024))
+            {
+                return (-1);   /*  error condition */
+            }
+
+            stop_idx  += sfbWidth;
+
+            fac   = factors[tot_sfb] - SF_OFFSET;
+            scale = exptable[fac & 0x3];
+
+            power_scale_div_4 = fac >> 2;
+
+            power_scale_div_4++;
+
+            qFormat[tot_sfb] = QFormat;
+
+            esc_iquant_scaling(pQuantSpec,
+                               pCoef,
+                               sfbWidth,
+                               QFormat,
+                               scale,
+                               max);
+
+            pQuantSpec += sfbWidth;
+            qFormat[tot_sfb] -= power_scale_div_4;
+            pCoef += sfbWidth;
+
+            tot_sfb++;
+
+        } /* for (sfb) */
+    } /* for (i) */
+
+
+    /*----------------------------------------------------------------------------
+    ; Return status
+    ----------------------------------------------------------------------------*/
+    return SUCCESS;
+
+} /* huffspec_fxp */
diff --git a/media/libstagefright/codecs/aacdec/ibstream.h b/media/libstagefright/codecs/aacdec/ibstream.h
new file mode 100644
index 0000000..8b644dc
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/ibstream.h
@@ -0,0 +1,115 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Pathname: ibstream.h
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+ Description: Change names of constants.
+
+ Description: Change the buffer from UInt to UInt32
+
+ Description: Remove declaration of getbits and include header file
+
+ Description: Change input buffer to UChar
+              Add constant
+
+ Who:                                              Date:
+ Description:
+
+------------------------------------------------------------------------------
+ INCLUDE DESCRIPTION
+
+ Contains defines, structures, and function definitions for the
+ input bit stream used in the AAC Decoder.
+
+------------------------------------------------------------------------------
+*/
+
+/*----------------------------------------------------------------------------
+; CONTINUE ONLY IF NOT ALREADY DEFINED
+----------------------------------------------------------------------------*/
+#ifndef IBSTREAM_H
+#define IBSTREAM_H
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+#include    "pv_audio_type_defs.h"
+#include    "s_bits.h"
+#include    "getbits.h"
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here.
+----------------------------------------------------------------------------*/
+
+#define INBUF_ARRAY_INDEX_SHIFT  (3)
+#define INBUF_BIT_WIDTH         (1<<(INBUF_ARRAY_INDEX_SHIFT))
+#define INBUF_BIT_MODULO_MASK   ((INBUF_BIT_WIDTH)-1)
+
+#define MAX_GETBITS             (25)
+/*----------------------------------------------------------------------------
+; EXTERNAL VARIABLES REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; SIMPLE TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; ENUMERATED TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; STRUCTURES TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+
+/*----------------------------------------------------------------------------
+; GLOBAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+    void byte_align(
+        BITS  *pInputStream);
+
+
+#ifdef __cplusplus
+}
+#endif
+
+/*----------------------------------------------------------------------------
+; END
+----------------------------------------------------------------------------*/
+#endif /* IBSTREAM_H */
+
+
diff --git a/media/libstagefright/codecs/aacdec/idct16.cpp b/media/libstagefright/codecs/aacdec/idct16.cpp
new file mode 100644
index 0000000..324fe9e
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/idct16.cpp
@@ -0,0 +1,204 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Filename: idct16.c
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+
+ Who:                                   Date: MM/DD/YYYY
+ Description:
+
+------------------------------------------------------------------------------
+ INPUT AND OUTPUT DEFINITIONS
+
+    Int32 x             32-bit integer input length 16
+
+
+------------------------------------------------------------------------------
+ FUNCTION DESCRIPTION
+
+    Implement inverse discrete cosine transform of lenght 16
+
+------------------------------------------------------------------------------
+ REQUIREMENTS
+
+
+------------------------------------------------------------------------------
+ REFERENCES
+
+------------------------------------------------------------------------------
+ PSEUDO-CODE
+
+------------------------------------------------------------------------------
+*/
+
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+
+#ifdef AAC_PLUS
+
+
+#include "idct16.h"
+#include "idct8.h"
+
+#include "fxp_mul32.h"
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here. Include conditional
+; compile variables also.
+----------------------------------------------------------------------------*/
+
+
+#define R_SHIFT     28
+#define Qfmt(x)     (Int32)(x*((Int32)1<<R_SHIFT) + (x>=0?0.5F:-0.5F))
+#define Qfmt31(x)   (Int32)(x*(0x7FFFFFFF) + (x>=0?0.5F:-0.5F))
+
+const Int32 CosTable_8i[8] =
+{
+    Qfmt31(0.50241928618816F),   Qfmt31(0.52249861493969F),
+    Qfmt31(0.56694403481636F),   Qfmt31(0.64682178335999F),
+    Qfmt(0.78815462345125F),   Qfmt(1.06067768599035F),
+    Qfmt(1.72244709823833F),   Qfmt(5.10114861868916F)
+};
+
+
+
+/*----------------------------------------------------------------------------
+; LOCAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; LOCAL STORE/BUFFER/POINTER DEFINITIONS
+; Variable declaration - defined here and used outside this module
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL FUNCTION REFERENCES
+; Declare functions defined elsewhere and referenced in this module
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL GLOBAL STORE/BUFFER/POINTER REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; FUNCTION CODE
+----------------------------------------------------------------------------*/
+
+
+void idct_16(Int32 vec[], Int32 scratch_mem[])    /* scratch_mem size 8 */
+{
+    Int32 *temp_even = scratch_mem;
+
+    Int32 i;
+    const Int32 *pt_cos = CosTable_8i;
+    Int32 tmp1, tmp2;
+    Int32 *pt_even = temp_even;
+    Int32 *pt_odd  = vec;
+    Int32 *pt_vec  = vec;
+
+    Int32 tmp3;
+    Int32 *pt_vecN_1;
+
+
+    *(pt_even++) = *(pt_vec++);
+    tmp1         = *(pt_vec++);
+    *(pt_odd++) = tmp1;
+
+    for (i = 2; i != 0; i--)
+    {
+        *(pt_even++) = *(pt_vec++);
+        tmp2         = *(pt_vec++);
+        *(pt_even++) = *(pt_vec++);
+        tmp3         = *(pt_vec++);
+        *(pt_odd++) = tmp2 + tmp1;
+        *(pt_odd++) = tmp3 + tmp2;
+        tmp1         = tmp3;
+    }
+
+    *(pt_even++) = *(pt_vec++);
+    tmp2         = *(pt_vec++);
+    *(pt_even++) = *(pt_vec++);
+    tmp3         = *(pt_vec++);
+    *(pt_odd++) = tmp2 + tmp1;
+    *(pt_odd++) = tmp3 + tmp2;
+
+
+    *(pt_even)   = *(pt_vec++);
+    *(pt_odd++) = *(pt_vec) + tmp3;
+
+
+    idct_8(temp_even);
+    idct_8(vec);
+
+
+    pt_cos = &CosTable_8i[7];
+
+    pt_vec  = &vec[7];
+
+    pt_even = &temp_even[7];
+    pt_vecN_1  = &vec[8];
+
+    tmp1 = *(pt_even--);
+
+    for (i = 2; i != 0; i--)
+    {
+        tmp3  = fxp_mul32_Q28(*(pt_vec), *(pt_cos--));
+        tmp2 = *(pt_even--);
+        *(pt_vecN_1++)  = tmp1 - tmp3;
+        *(pt_vec--)     = tmp1 + tmp3;
+        tmp3  = fxp_mul32_Q28(*(pt_vec), *(pt_cos--));
+        tmp1 = *(pt_even--);
+        *(pt_vecN_1++)  = tmp2 - tmp3;
+        *(pt_vec--)     = tmp2 + tmp3;
+    }
+
+    tmp3  = fxp_mul32_Q31(*(pt_vec), *(pt_cos--)) << 1;
+    tmp2 = *(pt_even--);
+    *(pt_vecN_1++)  = tmp1 - tmp3;
+    *(pt_vec--)     = tmp1 + tmp3;
+    tmp3  = fxp_mul32_Q31(*(pt_vec), *(pt_cos--)) << 1;
+    tmp1 = *(pt_even--);
+    *(pt_vecN_1++)  = tmp2 - tmp3;
+    *(pt_vec--)     = tmp2 + tmp3;
+    tmp3  = fxp_mul32_Q31(*(pt_vec), *(pt_cos--)) << 1;
+    tmp2 = *(pt_even--);
+    *(pt_vecN_1++)  = tmp1 - tmp3;
+    *(pt_vec--)     = tmp1 + tmp3;
+    tmp3  = fxp_mul32_Q31(*(pt_vec), *(pt_cos)) << 1;
+    *(pt_vecN_1)  = tmp2 - tmp3;
+    *(pt_vec)     = tmp2 + tmp3;
+
+}
+
+
+#endif
diff --git a/media/libstagefright/codecs/aacdec/idct16.h b/media/libstagefright/codecs/aacdec/idct16.h
new file mode 100644
index 0000000..afade07
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/idct16.h
@@ -0,0 +1,69 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+  Pathname: idct16.h
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+ Who:                                       Date:
+ Description:
+------------------------------------------------------------------------------
+ INCLUDE DESCRIPTION
+
+------------------------------------------------------------------------------
+*/
+
+#ifndef IDCT16_H
+#define IDCT16_H
+
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+
+#include "pv_audio_type_defs.h"
+
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+    /*----------------------------------------------------------------------------
+    ; EXTERNAL VARIABLES REFERENCES
+    ----------------------------------------------------------------------------*/
+
+    /*----------------------------------------------------------------------------
+    ; DEFINES AND SIMPLE TYPEDEF'S
+    ----------------------------------------------------------------------------*/
+
+
+    void idct_16(Int32 vec[], Int32 scratch_mem[]);
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif  /* IDCT16_H */
diff --git a/media/libstagefright/codecs/aacdec/idct32.cpp b/media/libstagefright/codecs/aacdec/idct32.cpp
new file mode 100644
index 0000000..ac9773b
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/idct32.cpp
@@ -0,0 +1,196 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+  Filename: idct32.c
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+
+ Who:                                   Date: MM/DD/YYYY
+ Description:
+
+------------------------------------------------------------------------------
+ INPUT AND OUTPUT DEFINITIONS
+
+    Int32 x             32-bit integer input length 32
+
+
+------------------------------------------------------------------------------
+ FUNCTION DESCRIPTION
+
+    Implement inverse discrete cosine transform of lenght 32
+
+------------------------------------------------------------------------------
+ REQUIREMENTS
+
+
+------------------------------------------------------------------------------
+ REFERENCES
+
+------------------------------------------------------------------------------
+ PSEUDO-CODE
+
+------------------------------------------------------------------------------
+*/
+
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+
+#ifdef AAC_PLUS
+
+#include "idct32.h"
+#include "dst32.h"
+#include "idct16.h"
+
+#include "fxp_mul32.h"
+
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here. Include conditional
+; compile variables also.
+----------------------------------------------------------------------------*/
+
+
+
+#define R_SHIFT1     29
+#define Qfmt1(x)   (Int32)(x*((Int32)1<<R_SHIFT1) + (x>=0?0.5F:-0.5F))
+
+#define Qfmt3(a)   (Int32)(a*0x7FFFFFFF + (a>=0?0.5F:-0.5F))
+
+
+/*----------------------------------------------------------------------------
+; LOCAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; LOCAL STORE/BUFFER/POINTER DEFINITIONS
+; Variable declaration - defined here and used outside this module
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL FUNCTION REFERENCES
+; Declare functions defined elsewhere and referenced in this module
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL GLOBAL STORE/BUFFER/POINTER REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; FUNCTION CODE
+----------------------------------------------------------------------------*/
+
+void idct_32(Int32 vec[], Int32 scratch_mem[])   /* scratch_mem size 32 */
+{
+    Int32 *temp_even = scratch_mem;
+
+    Int32 i;
+    const Int32 *pt_cos = CosTable_16;
+    Int32 tmp1, tmp2;
+    Int32 *pt_even = temp_even;
+    Int32 *pt_odd  = vec;
+    Int32 *pt_vec  = vec;
+    Int32 *pt_vecN_1;
+    Int32 tmp3;
+
+
+    *(pt_even++) = *(pt_vec++);
+    tmp1         = *(pt_vec++);
+    tmp2 = 0;
+
+    for (i = 7; i != 0; i--)
+    {
+        *(pt_odd++) = tmp2 + tmp1;
+        *(pt_even++) = *(pt_vec++);
+        tmp2         = *(pt_vec++);
+        *(pt_even++) = *(pt_vec++);
+        *(pt_odd++) = tmp2 + tmp1;
+        tmp1         = *(pt_vec++);
+    }
+
+    *(pt_odd++) = tmp2 + tmp1;
+    *(pt_even++) = *(pt_vec++);
+    tmp2         = *(pt_vec++);
+    *(pt_odd++) = tmp2 + tmp1;
+
+
+    idct_16(temp_even, &scratch_mem[16]);
+    idct_16(vec, &scratch_mem[24]);
+
+
+    pt_cos = &CosTable_16[13];
+
+    pt_vec  = &vec[15];
+
+    pt_even = &temp_even[15];
+    pt_vecN_1  = &vec[16];
+
+    tmp1 = *(pt_even--);
+
+
+    tmp3  = fxp_mul32_Q31(*(pt_vec) << 3, Qfmt3(0.63687550772175F)) << 2;
+    tmp2 = *(pt_even--);
+    *(pt_vecN_1++)  = tmp1 - tmp3;
+    *(pt_vec--)     = tmp1 + tmp3;
+    tmp3  = fxp_mul32_Q31(*(pt_vec) << 3, Qfmt3(0.85190210461718F));
+
+    tmp1 = *(pt_even--);
+    *(pt_vecN_1++)  = tmp2 - tmp3;
+    *(pt_vec--)     = tmp2 + tmp3;
+
+    for (i = 2; i != 0; i--)
+    {
+        tmp3  = fxp_mul32_Q29(*(pt_vec), *(pt_cos--));
+        tmp2 = *(pt_even--);
+        *(pt_vecN_1++)  = tmp1 - tmp3;
+        *(pt_vec--)     = tmp1 + tmp3;
+        tmp3  = fxp_mul32_Q29(*(pt_vec), *(pt_cos--));
+        tmp1 = *(pt_even--);
+        *(pt_vecN_1++)  = tmp2 - tmp3;
+        *(pt_vec--)     = tmp2 + tmp3;
+    }
+
+    for (i = 5; i != 0; i--)
+    {
+        tmp3  = fxp_mul32_Q31(*(pt_vec) << 1, *(pt_cos--));
+        tmp2 = *(pt_even--);
+        *(pt_vecN_1++)  = tmp1 - tmp3;
+        *(pt_vec--)     = tmp1 + tmp3;
+        tmp3  = fxp_mul32_Q31(*(pt_vec) << 1, *(pt_cos--));
+        tmp1 = *(pt_even--);
+        *(pt_vecN_1++)  = tmp2 - tmp3;
+        *(pt_vec--)     = tmp2 + tmp3;
+    }
+}
+
+
+
+#endif
diff --git a/media/libstagefright/codecs/aacdec/idct32.h b/media/libstagefright/codecs/aacdec/idct32.h
new file mode 100644
index 0000000..12c685a
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/idct32.h
@@ -0,0 +1,69 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Pathname: idct32.h
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+ Who:                                       Date:
+ Description:
+------------------------------------------------------------------------------
+ INCLUDE DESCRIPTION
+
+------------------------------------------------------------------------------
+*/
+
+#ifndef IDCT32_H
+#define IDCT32_H
+
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+
+#include "pv_audio_type_defs.h"
+
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+    /*----------------------------------------------------------------------------
+    ; EXTERNAL VARIABLES REFERENCES
+    ----------------------------------------------------------------------------*/
+
+    /*----------------------------------------------------------------------------
+    ; DEFINES AND SIMPLE TYPEDEF'S
+    ----------------------------------------------------------------------------*/
+
+    void idct_32(Int32 vec[], Int32 scratch_mem[]);
+
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif  /* IDCT32_H */
diff --git a/media/libstagefright/codecs/aacdec/idct8.cpp b/media/libstagefright/codecs/aacdec/idct8.cpp
new file mode 100644
index 0000000..8f040ce
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/idct8.cpp
@@ -0,0 +1,168 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Filename: idct8.c
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+
+ Who:                                   Date: MM/DD/YYYY
+ Description:
+
+------------------------------------------------------------------------------
+ INPUT AND OUTPUT DEFINITIONS
+
+    Int32 x             32-bit integer input length 8
+
+
+------------------------------------------------------------------------------
+ FUNCTION DESCRIPTION
+
+    Implement inverse discrete cosine transform of lenght 8
+
+------------------------------------------------------------------------------
+ REQUIREMENTS
+
+
+------------------------------------------------------------------------------
+ REFERENCES
+
+------------------------------------------------------------------------------
+ PSEUDO-CODE
+
+------------------------------------------------------------------------------
+*/
+
+#ifdef AAC_PLUS
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+#include "idct8.h"
+
+#include "fxp_mul32.h"
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here. Include conditional
+; compile variables also.
+----------------------------------------------------------------------------*/
+
+
+#define R_SHIFT     29
+#define Qfmt(x)   (Int32)(x*((Int32)1<<R_SHIFT) + (x>=0?0.5F:-0.5F))
+
+#define Qfmt15(x)   (Int16)(x*((Int32)1<<15) + (x>=0?0.5F:-0.5F))
+
+
+/*----------------------------------------------------------------------------
+; LOCAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; LOCAL STORE/BUFFER/POINTER DEFINITIONS
+; Variable declaration - defined here and used outside this module
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL FUNCTION REFERENCES
+; Declare functions defined elsewhere and referenced in this module
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL GLOBAL STORE/BUFFER/POINTER REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; FUNCTION CODE
+----------------------------------------------------------------------------*/
+
+void idct_8(Int32 vec[])
+{
+
+    Int32 tmp0;
+    Int32 tmp1;
+    Int32 tmp2;
+    Int32 tmp3;
+    Int32 tmp4;
+    Int32 tmp5;
+    Int32 tmp6;
+    Int32 tmp7;
+    Int32 tmp8;
+
+
+    tmp5 = fxp_mul32_by_16(vec[4] << 1, Qfmt15(0.70710678118655F));
+
+    tmp1 =  vec[0] + tmp5;
+    tmp5 =  vec[0] - tmp5;
+
+    tmp3 = fxp_mul32_by_16(vec[2] << 1, Qfmt15(0.54119610014620F));     /* (1/(2*cos(2*phi)));*/
+    tmp7 = fxp_mul32_Q29(vec[6], Qfmt(1.30656296487638F));      /* (1/(2*cos(6*phi)));*/
+
+    tmp0  = fxp_mul32_by_16((tmp3 - tmp7) << 1, Qfmt15(0.70710678118655F)); /* (1/(2*cos(2*phi)));  */
+    tmp7 = (tmp3 + tmp7) + tmp0;
+
+    vec[0] = tmp1 + tmp7;
+    tmp2 = fxp_mul32_by_16(vec[1] << 1, Qfmt15(0.50979557910416F));     /* (1/(2*cos(  phi)));*/
+    vec[1] = tmp5 + tmp0;
+    vec[2] = tmp5 - tmp0;
+    tmp4 = fxp_mul32_by_16(vec[3] << 1, Qfmt15(0.60134488693505F));     /* (1/(2*cos(3*phi)));*/
+    vec[3] = tmp1 - tmp7;
+
+    tmp6 = fxp_mul32_by_16(vec[5] << 1, Qfmt15(0.89997622313642F));     /* (1/(2*cos(5*phi)));*/
+    tmp8 = fxp_mul32_Q29(vec[7], Qfmt(2.56291544774151F));      /* (1/(2*cos(7*phi)));*/
+
+    tmp7  =  tmp2 + tmp8;
+    tmp5  = fxp_mul32_by_16((tmp2 - tmp8) << 1, Qfmt15(0.54119610014620F));
+    tmp8  =  tmp4 + tmp6;
+    tmp6  = fxp_mul32_Q29((tmp4 - tmp6), Qfmt(1.30656296487638F));
+
+    tmp0 =  tmp7 + tmp8;
+    tmp2 = fxp_mul32_by_16((tmp7 - tmp8) << 1, Qfmt15(0.70710678118655F));
+
+    tmp3 = fxp_mul32_by_16((tmp5 - tmp6) << 1, Qfmt15(0.70710678118655F));
+    tmp1 = (tmp5 + tmp6) + tmp3;
+
+    tmp5 = tmp0 + tmp1;
+    tmp6 = tmp1 + tmp2;
+    tmp7 = tmp2 + tmp3;
+
+    vec[7]  = vec[0] - tmp5;
+    vec[0] +=          tmp5;
+    vec[6]  = vec[1] - tmp6;
+    vec[1] +=          tmp6;
+    vec[5]  = vec[2] - tmp7;
+    vec[2] +=          tmp7;
+    vec[4]  = vec[3] - tmp3;
+    vec[3] +=          tmp3;
+
+}
+
+
+#endif
+
diff --git a/media/libstagefright/codecs/aacdec/idct8.h b/media/libstagefright/codecs/aacdec/idct8.h
new file mode 100644
index 0000000..ad7eaae
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/idct8.h
@@ -0,0 +1,69 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Pathname: idct8.h
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+ Who:                                       Date:
+ Description:
+------------------------------------------------------------------------------
+ INCLUDE DESCRIPTION
+
+------------------------------------------------------------------------------
+*/
+
+#ifndef IDCT8_H
+#define IDCT8_H
+
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+
+#include "pv_audio_type_defs.h"
+
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+    /*----------------------------------------------------------------------------
+    ; EXTERNAL VARIABLES REFERENCES
+    ----------------------------------------------------------------------------*/
+
+    /*----------------------------------------------------------------------------
+    ; DEFINES AND SIMPLE TYPEDEF'S
+    ----------------------------------------------------------------------------*/
+
+    void idct_8(Int32 vec[]);
+
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif  /* IDCT8_H */
diff --git a/media/libstagefright/codecs/aacdec/imdct_fxp.cpp b/media/libstagefright/codecs/aacdec/imdct_fxp.cpp
new file mode 100644
index 0000000..ad67f20
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/imdct_fxp.cpp
@@ -0,0 +1,476 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Pathname: imdct_fxp.c
+ Funtions: imdct_fxp
+
+------------------------------------------------------------------------------
+ INPUT AND OUTPUT DEFINITIONS
+
+ Inputs:
+
+    data_quant    = Input vector, with quantized spectral lines:
+                    type Int32
+
+    freq_2_time_buffer =  Scratch memory used for in-place FFT calculation,
+                    min size required 1024,
+                    type Int32
+
+    n            =  Length of input vector "data_quant". Currently 256 or 2048
+                    type const Int
+
+    Q_format     =  Q_format of the input vector "data_quant"
+                    type Int
+
+    max          =  Maximum value inside input vector "data_quant"
+                    type Int32
+
+ Local Stores/Buffers/Pointers Needed:
+    None
+
+ Global Stores/Buffers/Pointers Needed:
+    None
+
+ Outputs:
+    shift = shift factor to reflect scaling introduced by IFFT and imdct_fxp,
+
+ Pointers and Buffers Modified:
+    Results are return in "Data_Int_precision"
+
+ Local Stores Modified:
+    None
+
+ Global Stores Modified:
+    None
+
+------------------------------------------------------------------------------
+ FUNCTION DESCRIPTION
+
+    The IMDCT is a linear orthogonal lapped transform, based on the idea of
+    time domain aliasing cancellation (TDAC).
+    IMDCT is critically sampled, which means that though it is 50% overlapped,
+    a sequence data after IMDCT has the same number of coefficients as samples
+    before the transform (after overlap-and-add). This means, that a single
+    block of IMDCT data does not correspond to the original block on which the
+    IMDCT was performed. When subsequent blocks of inverse transformed data
+    are added (still using 50% overlap), the errors introduced by the
+    transform cancels out.Thanks to the overlapping feature, the IMDCT is very
+    useful for quantization. It effectively removes the otherwise easily
+    detectable blocking artifact between transform blocks.
+
+    N = twice the length of input vector X
+    y = vector of length N, will hold fixed point IDCT
+    p = 0:1:N-1
+
+                    2   N/2-1
+            y(p) = ---   SUM   X(m)*cos(pi/(2*N)*(2*p+1+N/2)*(2*m+1))
+                    N    m=0
+
+    The window that completes the TDAC is applied before calling this function.
+    The IMDCT can be calculated using an IFFT, for this, the IMDCT need be
+    rewritten as an odd-time odd-frequency discrete Fourier transform. Thus,
+    the IMDCT can be calculated using only one n/4 point FFT and some pre and
+    post-rotation of the sample points.
+
+
+    where X(k) is the input with N frequency lines
+
+    X(k) ----------------------------
+                                     |
+                                     |
+                    Pre-rotation by exp(j(2pi/N)(k+1/8))
+                                     |
+                                     |
+                              N/4- point IFFT
+                                     |
+                                     |
+                    Post-rotation by exp(j(2pi/N)(n+1/8))
+                                     |
+                                     |
+                                      ------------- x(n)  In the time domain
+
+
+------------------------------------------------------------------------------
+ REQUIREMENTS
+
+    This function should provide a fixed point IMDCT with an average
+    quantization error less than 1 % (variance and mean).
+
+------------------------------------------------------------------------------
+ REFERENCES
+
+    [1] Analysis/Synthesis Filter Bank design based on time domain
+        aliasing cancellation
+        Jhon Princen, et. al.
+        IEEE Transactions on ASSP, vol ASSP-34, No. 5 October 1986
+        Pg 1153 - 1161
+
+    [2] Regular FFT-related transform kernels for DCT/DST based
+        polyphase filterbanks
+        Rolf Gluth
+        Proc. ICASSP 1991, pg. 2205 - 2208
+
+------------------------------------------------------------------------------
+ PSEUDO-CODE
+
+  Cx, Cy are complex number
+
+
+    exp = log2(n)-1
+
+    FOR ( k=0; k< n/2; k +=2)
+
+        Cx = - data_quant[k] + j data_quant[n/2-1 - k]
+
+        freq_2_time_buffer = Cx * exp(j(2pi/n)(k+1/8))
+
+    ENDFOR
+
+    CALL IFFT( freq_2_time_buffer, n/4)
+
+    MODIFYING( freq_2_time_buffer )
+
+    RETURNING( shift )
+
+    FOR ( k=0; k< n/4; k +=2)
+
+        Cx = freq_2_time_buffer[ k] + j freq_2_time_buffer[ k+1]
+
+        Cy = Cx * exp(j(2pi/n)(k+1/8))
+
+        data_quant[3n/4-1 - k ] =   Real(Cy)
+        data_quant[ n/4-1 - k ] = - Imag(Cy)
+        data_quant[3n/4   + k ] =   Real(Cy)
+        data_quant[ n/4   + k ] =   Imag(Cy)
+
+    ENDFOR
+
+    FOR ( k=n/4; k< n/2; k +=2)
+
+        Cx = freq_2_time_buffer[ k] + j freq_2_time_buffer[ k+1]
+
+        Cy = Cx * exp(j(2pi/n)(k+1/8))
+
+        data_quant[3n/4-1 - k ] =   Real(Cy)
+        data_quant[ n/4   + k ] = - Real(Cy)
+        data_quant[5n/4   - k ] =   Imag(Cy)
+        data_quant[ n/4   + k ] =   Imag(Cy)
+
+    ENDFOR
+
+    MODIFIED    data_quant[]
+
+    RETURN      (exp - shift)
+
+------------------------------------------------------------------------------
+ RESOURCES USED
+   When the code is written for a specific target processor the
+     the resources used should be documented below.
+
+ STACK USAGE: [stack count for this module] + [variable to represent
+          stack usage for each subroutine called]
+
+     where: [stack usage variable] = stack usage for [subroutine
+         name] (see [filename].ext)
+
+ DATA MEMORY USED: x words
+
+ PROGRAM MEMORY USED: x words
+
+ CLOCK CYCLES: [cycle count equation for this module] + [variable
+           used to represent cycle count for each subroutine
+           called]
+
+     where: [cycle count variable] = cycle count for [subroutine
+        name] (see [filename].ext)
+
+------------------------------------------------------------------------------
+*/
+
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+
+#include "pv_audio_type_defs.h"
+#include "imdct_fxp.h"
+
+
+#include "mix_radix_fft.h"
+#include "digit_reversal_tables.h"
+#include "fft_rx4.h"
+#include "inv_short_complex_rot.h"
+#include "inv_long_complex_rot.h"
+#include "pv_normalize.h"
+#include "fxp_mul32.h"
+#include "aac_mem_funcs.h"
+
+#include "window_block_fxp.h"
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here. Include conditional
+; compile variables also.
+----------------------------------------------------------------------------*/
+#define ERROR_IN_FRAME_SIZE 10
+
+/*----------------------------------------------------------------------------
+; LOCAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; LOCAL VARIABLE DEFINITIONS
+; Variable declaration - defined here and used outside this module
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL FUNCTION REFERENCES
+; Declare functions defined elsewhere and referenced in this module
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL VARIABLES REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+
+/*----------------------------------------------------------------------------
+; EXTERNAL GLOBAL STORE/BUFFER/POINTER REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; FUNCTION CODE
+----------------------------------------------------------------------------*/
+
+
+Int imdct_fxp(Int32   data_quant[],
+              Int32   freq_2_time_buffer[],
+              const   Int     n,
+              Int     Q_format,
+              Int32   max)
+{
+
+    Int32     exp_jw;
+    Int     shift = 0;
+
+    const   Int32 *p_rotate;
+    const   Int32 *p_rotate_2;
+
+    Int32   *p_data_1;
+    Int32   *p_data_2;
+
+    Int32   temp_re32;
+    Int32   temp_im32;
+
+    Int     shift1 = 0;
+    Int32   temp1;
+    Int32   temp2;
+
+    Int     k;
+    Int     n_2   = n >> 1;
+    Int     n_4   = n >> 2;
+
+
+
+    if (max != 0)
+    {
+
+        switch (n)
+        {
+            case SHORT_WINDOW_TYPE:
+                p_rotate = exp_rotation_N_256;
+                shift = 21;           /* log2(n)-1 + 14 acomodates 2/N factor */
+                break;
+
+            case LONG_WINDOW_TYPE:
+                p_rotate = exp_rotation_N_2048;
+                shift = 24;           /* log2(n)-1 +14 acomodates 2/N factor */
+                break;
+
+            default:
+                /*
+                 * There is no defined behavior for a non supported frame
+                 * size. By returning a fixed scaling factor, the input will
+                 * scaled down and the will be heard as a low level noise
+                 */
+                return(ERROR_IN_FRAME_SIZE);
+
+        }
+
+        /*
+         *   p_data_1                                        p_data_2
+         *       |                                            |
+         *       RIRIRIRIRIRIRIRIRIRIRIRIRIRIRI....RIRIRIRIRIRI
+         *        |                                          |
+         *
+         */
+
+        p_data_1 =  data_quant;             /* uses first  half of buffer */
+        p_data_2 = &data_quant[n_2 - 1];    /* uses second half of buffer */
+
+        p_rotate_2 = &p_rotate[n_4-1];
+
+        shift1 = pv_normalize(max) - 1;     /* -1 to leave room for addition */
+        Q_format -= (16 - shift1);
+        max = 0;
+
+
+        if (shift1 >= 0)
+        {
+            temp_re32 =   *(p_data_1++) << shift1;
+            temp_im32 =   *(p_data_2--) << shift1;
+
+            for (k = n_4 >> 1; k != 0; k--)
+            {
+                /*
+                 *  Real and Imag parts have been swaped to use FFT as IFFT
+                 */
+                /*
+                 * cos_n + j*sin_n == exp(j(2pi/N)(k+1/8))
+                 */
+                exp_jw = *p_rotate++;
+
+                temp1      =  cmplx_mul32_by_16(temp_im32, -temp_re32, exp_jw);
+                temp2      = -cmplx_mul32_by_16(temp_re32,  temp_im32, exp_jw);
+
+                temp_im32 =   *(p_data_1--) << shift1;
+                temp_re32 =   *(p_data_2--) << shift1;
+                *(p_data_1++) = temp1;
+                *(p_data_1++) = temp2;
+                max         |= (temp1 >> 31) ^ temp1;
+                max         |= (temp2 >> 31) ^ temp2;
+
+
+                /*
+                 *  Real and Imag parts have been swaped to use FFT as IFFT
+                 */
+
+                /*
+                 * cos_n + j*sin_n == exp(j(2pi/N)(k+1/8))
+                 */
+
+                exp_jw = *p_rotate_2--;
+
+                temp1      =  cmplx_mul32_by_16(temp_im32, -temp_re32, exp_jw);
+                temp2      = -cmplx_mul32_by_16(temp_re32,  temp_im32, exp_jw);
+
+
+                temp_re32 =   *(p_data_1++) << shift1;
+                temp_im32 =   *(p_data_2--) << shift1;
+
+                *(p_data_2 + 2) = temp1;
+                *(p_data_2 + 3) = temp2;
+                max         |= (temp1 >> 31) ^ temp1;
+                max         |= (temp2 >> 31) ^ temp2;
+
+            }
+        }
+        else
+        {
+            temp_re32 =   *(p_data_1++) >> 1;
+            temp_im32 =   *(p_data_2--) >> 1;
+
+            for (k = n_4 >> 1; k != 0; k--)
+            {
+                /*
+                 *  Real and Imag parts have been swaped to use FFT as IFFT
+                 */
+                /*
+                 * cos_n + j*sin_n == exp(j(2pi/N)(k+1/8))
+                 */
+                exp_jw = *p_rotate++;
+
+                temp1      =  cmplx_mul32_by_16(temp_im32, -temp_re32, exp_jw);
+                temp2      = -cmplx_mul32_by_16(temp_re32,  temp_im32, exp_jw);
+
+                temp_im32 =   *(p_data_1--) >> 1;
+                temp_re32 =   *(p_data_2--) >> 1;
+                *(p_data_1++) = temp1;
+                *(p_data_1++) = temp2;
+
+                max         |= (temp1 >> 31) ^ temp1;
+                max         |= (temp2 >> 31) ^ temp2;
+
+
+                /*
+                 *  Real and Imag parts have been swaped to use FFT as IFFT
+                 */
+
+                /*
+                 * cos_n + j*sin_n == exp(j(2pi/N)(k+1/8))
+                 */
+                exp_jw = *p_rotate_2--;
+
+                temp1      =  cmplx_mul32_by_16(temp_im32, -temp_re32, exp_jw);
+                temp2      = -cmplx_mul32_by_16(temp_re32,  temp_im32, exp_jw);
+
+                temp_re32 =   *(p_data_1++) >> 1;
+                temp_im32 =   *(p_data_2--) >> 1;
+
+                *(p_data_2 + 3) = temp2;
+                *(p_data_2 + 2) = temp1;
+
+                max         |= (temp1 >> 31) ^ temp1;
+                max         |= (temp2 >> 31) ^ temp2;
+
+            }
+        }
+
+
+        if (n != SHORT_WINDOW_TYPE)
+        {
+
+            shift -= mix_radix_fft(data_quant,
+                                   &max);
+
+            shift -= inv_long_complex_rot(data_quant,
+                                          max);
+
+        }
+        else        /*  n_4 is 64 */
+        {
+
+            shift -= fft_rx4_short(data_quant,   &max);
+
+
+            shift -= inv_short_complex_rot(data_quant,
+                                           freq_2_time_buffer,
+                                           max);
+
+            pv_memcpy(data_quant,
+                      freq_2_time_buffer,
+                      SHORT_WINDOW*sizeof(*data_quant));
+        }
+
+    }
+    else
+    {
+        Q_format = ALL_ZEROS_BUFFER;
+    }
+
+    return(shift + Q_format);
+
+} /* imdct_fxp */
diff --git a/media/libstagefright/codecs/aacdec/imdct_fxp.h b/media/libstagefright/codecs/aacdec/imdct_fxp.h
new file mode 100644
index 0000000..5837750
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/imdct_fxp.h
@@ -0,0 +1,122 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Pathname: imdct_fxp.h
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+ Description: This extern had the incorrect length of the arrays.  The true
+ lengths are 128 and 1024, not 64 and 512.
+
+ Description:  Modified interface so a vector with extended precision is
+               returned, this is a 32 bit vector whose MSB 16 bits will be
+               extracted later.  Added copyright notice.
+
+ Description:   Modified function interface to accomodate the normalization
+                that now is done in this function.
+
+ Who:                       Date:
+ Description:
+
+------------------------------------------------------------------------------
+ INCLUDE DESCRIPTION
+
+ Header file for function imdct_fxp()
+
+
+------------------------------------------------------------------------------
+*/
+
+/*----------------------------------------------------------------------------
+; CONTINUE ONLY IF NOT ALREADY DEFINED
+----------------------------------------------------------------------------*/
+#ifndef IMDCT_FXP_H
+#define IMDCT_FXP_H
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+    /*----------------------------------------------------------------------------
+    ; INCLUDES
+    ----------------------------------------------------------------------------*/
+#include "pv_audio_type_defs.h"
+
+    /*----------------------------------------------------------------------------
+    ; MACROS
+    ; Define module specific macros here
+    ----------------------------------------------------------------------------*/
+
+    /*----------------------------------------------------------------------------
+    ; DEFINES
+    ; Include all pre-processor statements here.
+    ----------------------------------------------------------------------------*/
+
+#define     LONG_WINDOW_TYPE  2048
+#define     SHORT_WINDOW_TYPE  256
+
+#define     ALL_ZEROS_BUFFER       31
+
+    /*----------------------------------------------------------------------------
+    ; EXTERNAL VARIABLES REFERENCES
+    ; Declare variables used in this module but defined elsewhere
+    ----------------------------------------------------------------------------*/
+
+    extern const Int32 exp_rotation_N_256[64];
+    extern const Int32 exp_rotation_N_2048[512];
+    /*
+    extern const Int exp_rotation_N_256[128];
+    extern const Int exp_rotation_N_2048[1024];
+    */
+
+    /*----------------------------------------------------------------------------
+    ; SIMPLE TYPEDEF'S
+    ----------------------------------------------------------------------------*/
+
+    /*----------------------------------------------------------------------------
+    ; ENUMERATED TYPEDEF'S
+    ----------------------------------------------------------------------------*/
+
+    /*----------------------------------------------------------------------------
+    ; STRUCTURES TYPEDEF'S
+    ----------------------------------------------------------------------------*/
+
+    /*----------------------------------------------------------------------------
+    ; GLOBAL FUNCTION DEFINITIONS
+    ; Function Prototype declaration
+    ----------------------------------------------------------------------------*/
+    Int imdct_fxp(
+        Int32   data_quant[],
+        Int32   freq_2_time_buffer[],
+        const   Int     n,
+        Int     Q_format,
+        Int32   max
+    );
+
+
+#ifdef __cplusplus
+}
+#endif
+
+/*----------------------------------------------------------------------------
+; END
+----------------------------------------------------------------------------*/
+#endif  /* IMDCT_FXP_H */
diff --git a/media/libstagefright/codecs/aacdec/infoinit.cpp b/media/libstagefright/codecs/aacdec/infoinit.cpp
new file mode 100644
index 0000000..7bdcdcd
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/infoinit.cpp
@@ -0,0 +1,355 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Pathname: infoinit.c
+
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+ Description:  Modified from original shareware code
+
+ Description:  Modified to pass variables by reference to eliminate use
+               of global variables.
+
+ Description:  Pass eight_short_info and the array 'sfbwidth128'.
+               Change function arguments' names for clarity
+
+ Description:  move sfb definitions to "sfb.h", and "sfb.c", eliminated
+               the function "huffbookinit.c"
+
+ Description:  Remove initialization of the never used array,
+               pFrameInfo->group_offs
+
+ Description:
+ (1) Changed "stdinc.h" to <stdlib.h> - this avoids linking in the math
+ library and stdio.h.  (All for just defining the NULL pointer macro)
+
+ (2) Updated copyright header.
+
+ Description: Updated the SW template to include the full pathname to the
+ source file and a slightly modified copyright header.
+
+ Description: Addresses of constant vectors are now found by means of a
+              switch statement, this solve linking problem when using the
+              /ropi option (Read-only position independent) for some
+              compilers
+
+ Who:                               Date:
+ Description:
+
+------------------------------------------------------------------------------
+ INPUT AND OUTPUT DEFINITIONS
+
+ Inputs:
+    pSi              = pointer to sampling rate info
+    ppWin_seq_info   = pointer array to window sequence Info struct
+    pSfbwidth128     = pointer to sfb bandwidth array of short window
+
+ Local Stores/Buffers/Pointers Needed:
+
+ Global Stores/Buffers/Pointers Needed:
+
+ Outputs:
+
+ Pointers and Buffers Modified:
+
+    ppWin_seq_info[ONLY_LONG_WINDOW]{all structure members} = setup values
+    ppWin_seq_info[EIGHT_SHORT_WINDOW]{all structure members} = setup values
+
+ Local Stores Modified:
+
+ Global Stores Modified:
+
+
+------------------------------------------------------------------------------
+ FUNCTION DESCRIPTION
+
+ This function sets the values of 'Info' structure for blocks containing long
+ and short window sequences, the following structures are being set:
+
+ win_seq_info[ONLY_LONG_WINDOW], win_seq_info[EIGHT_SHORT_WINDOW],
+ only_long_info and eight_short_info
+
+------------------------------------------------------------------------------
+ REQUIREMENTS
+
+------------------------------------------------------------------------------
+ REFERENCES
+
+ (1) MPEG-2 NBC Audio Decoder
+   "This software module was originally developed by AT&T, Dolby
+   Laboratories, Fraunhofer Gesellschaft IIS in the course of development
+   of the MPEG-2 NBC/MPEG-4 Audio standard ISO/IEC 13818-7, 14496-1,2 and
+   3. This software module is an implementation of a part of one or more
+   MPEG-2 NBC/MPEG-4 Audio tools as specified by the MPEG-2 NBC/MPEG-4
+   Audio standard. ISO/IEC  gives users of the MPEG-2 NBC/MPEG-4 Audio
+   standards free license to this software module or modifications thereof
+   for use in hardware or software products claiming conformance to the
+   MPEG-2 NBC/MPEG-4 Audio  standards. Those intending to use this software
+   module in hardware or software products are advised that this use may
+   infringe existing patents. The original developer of this software
+   module and his/her company, the subsequent editors and their companies,
+   and ISO/IEC have no liability for use of this software module or
+   modifications thereof in an implementation. Copyright is not released
+   for non MPEG-2 NBC/MPEG-4 Audio conforming products.The original
+   developer retains full right to use the code for his/her own purpose,
+   assign or donate the code to a third party and to inhibit third party
+   from using the code for non MPEG-2 NBC/MPEG-4 Audio conforming products.
+   This copyright notice must be included in all copies or derivative
+   works."
+   Copyright(c)1996.
+
+ (2) ISO/IEC 14496-3: 1999(E)
+    Subpart 4       p66     (sfb tables)
+                    p111    (4.6.10)
+                    p200    (Annex 4.B.5)
+------------------------------------------------------------------------------
+ PSEUDO-CODE
+
+    pFrameInfo  =   pointer to only_long_info;
+    win_seq_info[ONLY_LONG_WINDOW]  =   pFrameInfo;
+    pFrameInfo{all structure members} = setup values;
+
+
+    pFrameInfo  =   pointer to eight_short_info;
+    win_seq_info[EIGHT_SHORT_WINDOW]  =   pFrameInfo;
+    pFrameInfo{all structure.members} =   setup values;
+
+
+    FOR (window_seq = 0; window_seq < NUM_WIN_SEQ; win_seq++)
+
+        win_seq_info[window_seq].members = setup values;
+
+    ENDFOR
+
+------------------------------------------------------------------------------
+ RESOURCES USED
+   When the code is written for a specific target processor the
+     the resources used should be documented below.
+
+ STACK USAGE:
+
+ DATA MEMORY USED: x words
+
+ PROGRAM MEMORY USED: x words
+
+ CLOCK CYCLES:
+
+------------------------------------------------------------------------------
+*/
+
+
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+#include    "pv_audio_type_defs.h"
+#include    "s_sr_info.h"
+#include    "s_frameinfo.h"
+#include    "e_blockswitching.h"
+#include    "e_huffmanconst.h"
+#include    "sfb.h"
+#include    "huffman.h"
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here. Include conditional
+; compile variables also.
+----------------------------------------------------------------------------*/
+
+
+/*----------------------------------------------------------------------------
+; LOCAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+
+
+/*----------------------------------------------------------------------------
+; LOCAL STORE/BUFFER/POINTER DEFINITIONS
+; Variable declaration - defined here and used outside this module
+----------------------------------------------------------------------------*/
+
+
+/*----------------------------------------------------------------------------
+; EXTERNAL FUNCTION REFERENCES
+; Declare functions defined elsewhere and referenced in this module
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL GLOBAL STORE/BUFFER/POINTER REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; FUNCTION CODE
+----------------------------------------------------------------------------*/
+
+Int infoinit(
+    const Int samp_rate_idx,
+    FrameInfo   **ppWin_seq_info,
+    Int    *pSfbwidth128)
+
+{
+    /*----------------------------------------------------------------------------
+    ; Define all local variables
+    ----------------------------------------------------------------------------*/
+
+    Int     i;
+    Int     sfb_idx, sfb_sbk;
+    Int     bins_sbk;
+    Int     win_seq;
+    Int     start_idx, end_idx;
+    Int     nsfb_short;
+    Int16   *sfbands;
+    FrameInfo    *pFrameInfo;
+
+    const SR_Info *pSi = &(samp_rate_info[samp_rate_idx]);
+
+    const Int16 * pt_SFbands1024 = NULL;
+    const Int16 * pt_SFbands128  = NULL;
+
+    /*----------------------------------------------------------------------------
+    ; Function body here
+    ----------------------------------------------------------------------------*/
+
+    switch (pSi->samp_rate)
+    {
+        case 96000:
+        case 88200:
+            pt_SFbands1024  = sfb_96_1024;
+            pt_SFbands128   = sfb_64_128;  /* equal to table sfb_96_128, (eliminated) */
+            break;
+        case 64000:
+            pt_SFbands1024  = sfb_64_1024;
+            pt_SFbands128   = sfb_64_128;
+            break;
+        case 48000:
+        case 44100:
+            pt_SFbands1024  = sfb_48_1024;
+            pt_SFbands128   = sfb_48_128;
+            break;
+        case 32000:
+            pt_SFbands1024  = sfb_32_1024;
+            pt_SFbands128   = sfb_48_128;
+            break;
+        case 24000:
+        case 22050:
+            pt_SFbands1024  = sfb_24_1024;
+            pt_SFbands128   = sfb_24_128;
+            break;
+        case 16000:
+        case 12000:
+        case 11025:
+            pt_SFbands1024  = sfb_16_1024;
+            pt_SFbands128   = sfb_16_128;
+            break;
+        case 8000:
+            pt_SFbands1024  = sfb_8_1024;
+            pt_SFbands128   = sfb_8_128;
+            break;
+        default:
+            // sampling rate not supported
+            return -1;
+    }
+
+    /* long block info */
+
+    pFrameInfo = ppWin_seq_info[ONLY_LONG_WINDOW];
+    pFrameInfo->islong               = 1;
+    pFrameInfo->num_win              = 1;
+    pFrameInfo->coef_per_frame       = LN2; /* = 1024 */
+
+    pFrameInfo->sfb_per_win[0]  = pSi->nsfb1024;
+    pFrameInfo->sectbits[0]     = LONG_SECT_BITS;
+    pFrameInfo->win_sfb_top[0]  = (Int16 *)pt_SFbands1024;
+
+    pFrameInfo->sfb_width_128 = NULL; /* no short block sfb */
+    pFrameInfo->num_groups    = 1; /* long block, one group */
+    pFrameInfo->group_len[0]  = 1; /* only one window */
+
+    /* short block info */
+    pFrameInfo = ppWin_seq_info[EIGHT_SHORT_WINDOW];
+    pFrameInfo->islong                  = 0;
+    pFrameInfo->num_win                 = NSHORT;
+    pFrameInfo->coef_per_frame          = LN2;
+
+    for (i = 0; i < pFrameInfo->num_win; i++)
+    {
+        pFrameInfo->sfb_per_win[i] = pSi->nsfb128;
+        pFrameInfo->sectbits[i]    = SHORT_SECT_BITS;
+        pFrameInfo->win_sfb_top[i] = (Int16 *)pt_SFbands128;
+    }
+
+    /* construct sfb width table */
+    pFrameInfo->sfb_width_128 = pSfbwidth128;
+    for (i = 0, start_idx = 0, nsfb_short = pSi->nsfb128; i < nsfb_short; i++)
+    {
+        end_idx = pt_SFbands128[i];
+        pSfbwidth128[i] = end_idx - start_idx;
+        start_idx = end_idx;
+    }
+
+
+    /* common to long and short */
+    for (win_seq = 0; win_seq < NUM_WIN_SEQ; win_seq++)
+    {
+
+        if (ppWin_seq_info[win_seq] != NULL)
+        {
+            pFrameInfo                 = ppWin_seq_info[win_seq];
+            pFrameInfo->sfb_per_frame  = 0;
+            sfb_sbk                    = 0;
+            bins_sbk                   = 0;
+
+            for (i = 0; i < pFrameInfo->num_win; i++)
+            {
+
+                /* compute coef_per_win */
+                pFrameInfo->coef_per_win[i] =
+                    pFrameInfo->coef_per_frame / pFrameInfo->num_win;
+
+                /* compute sfb_per_frame */
+                pFrameInfo->sfb_per_frame += pFrameInfo->sfb_per_win[i];
+
+                /* construct default (non-interleaved) bk_sfb_top[] */
+                sfbands = pFrameInfo->win_sfb_top[i];
+                for (sfb_idx = 0; sfb_idx < pFrameInfo->sfb_per_win[i];
+                        sfb_idx++)
+                {
+                    pFrameInfo->frame_sfb_top[sfb_idx+sfb_sbk] =
+                        sfbands[sfb_idx] + bins_sbk;
+                }
+
+                bins_sbk += pFrameInfo->coef_per_win[i];
+                sfb_sbk  += pFrameInfo->sfb_per_win[i];
+            } /* for i = sbk ends */
+        }
+
+    } /* for win_seq ends */
+
+    return SUCCESS;
+
+} /* infoinit */
diff --git a/media/libstagefright/codecs/aacdec/init_sbr_dec.cpp b/media/libstagefright/codecs/aacdec/init_sbr_dec.cpp
new file mode 100644
index 0000000..fc47dd3
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/init_sbr_dec.cpp
@@ -0,0 +1,192 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Filename: init_sbr_dec.c
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+
+ Who:                                   Date: MM/DD/YYYY
+ Description:
+
+------------------------------------------------------------------------------
+ INPUT AND OUTPUT DEFINITIONS
+
+
+
+------------------------------------------------------------------------------
+ FUNCTION DESCRIPTION
+
+        initializes sbr decoder structure
+------------------------------------------------------------------------------
+ REQUIREMENTS
+
+
+------------------------------------------------------------------------------
+ REFERENCES
+
+SC 29 Software Copyright Licencing Disclaimer:
+
+This software module was originally developed by
+  Coding Technologies
+
+and edited by
+  -
+
+in the course of development of the ISO/IEC 13818-7 and ISO/IEC 14496-3
+standards for reference purposes and its performance may not have been
+optimized. This software module is an implementation of one or more tools as
+specified by the ISO/IEC 13818-7 and ISO/IEC 14496-3 standards.
+ISO/IEC gives users free license to this software module or modifications
+thereof for use in products claiming conformance to audiovisual and
+image-coding related ITU Recommendations and/or ISO/IEC International
+Standards. ISO/IEC gives users the same free license to this software module or
+modifications thereof for research purposes and further ISO/IEC standardisation.
+Those intending to use this software module in products are advised that its
+use may infringe existing patents. ISO/IEC have no liability for use of this
+software module or modifications thereof. Copyright is not released for
+products that do not conform to audiovisual and image-coding related ITU
+Recommendations and/or ISO/IEC International Standards.
+The original developer retains full right to modify and use the code for its
+own purpose, assign or donate the code to a third party and to inhibit third
+parties from using the code for products that do not conform to audiovisual and
+image-coding related ITU Recommendations and/or ISO/IEC International Standards.
+This copyright notice must be included in all copies or derivative works.
+Copyright (c) ISO/IEC 2002.
+
+------------------------------------------------------------------------------
+ PSEUDO-CODE
+
+------------------------------------------------------------------------------
+*/
+
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+
+#ifdef AAC_PLUS
+
+
+#include    "init_sbr_dec.h"
+#include    "aac_mem_funcs.h"
+#include    "extractframeinfo.h"
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here. Include conditional
+; compile variables also.
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; LOCAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; LOCAL STORE/BUFFER/POINTER DEFINITIONS
+; Variable declaration - defined here and used outside this module
+----------------------------------------------------------------------------*/
+
+
+
+/*----------------------------------------------------------------------------
+; EXTERNAL FUNCTION REFERENCES
+; Declare functions defined elsewhere and referenced in this module
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL GLOBAL STORE/BUFFER/POINTER REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; FUNCTION CODE
+----------------------------------------------------------------------------*/
+
+Int32 init_sbr_dec(Int32 codecSampleRate,
+                   Int   upsampleFac,
+                   SBR_DEC *sbrDec,
+                   SBR_FRAME_DATA *hFrameData)
+{
+    Int32 outFrameSize;
+    Int32 coreCodecFrameSize = 1024;
+#ifdef HQ_SBR
+    Int32 i;
+#endif
+
+
+    sbrDec->sbStopCodec    =  upsampleFac << 5;
+    sbrDec->prevLowSubband =  upsampleFac << 5;
+
+
+    /* set sbr sampling frequency */
+    sbrDec->outSampleRate = 2 * codecSampleRate;
+    outFrameSize = upsampleFac * coreCodecFrameSize;
+
+    hFrameData->nSfb[LO] = 0;    /* number of scale factor bands for high resp.low frequency resolution */
+    hFrameData->nSfb[HI] = 0;
+    hFrameData->offset   = 0;
+
+    hFrameData->nNfb = hFrameData->sbr_header.noNoiseBands;
+    hFrameData->prevEnvIsShort = -1;
+
+    /* Initializes pointers */
+#ifdef HQ_SBR
+    for (i = 0; i < 5; i++)
+    {
+        hFrameData->fBuf_man[i]  = hFrameData->fBuffer_man[i];
+        hFrameData->fBufN_man[i] = hFrameData->fBufferN_man[i];
+        hFrameData->fBuf_exp[i]  = hFrameData->fBuffer_exp[i];
+        hFrameData->fBufN_exp[i] = hFrameData->fBufferN_exp[i];
+    }
+#endif
+
+
+    pv_memset((void *)hFrameData->sbr_invf_mode_prev,
+              0,
+              MAX_NUM_NOISE_VALUES*sizeof(INVF_MODE));
+
+    /* Direct assignments */
+
+    sbrDec->noCols = 32;
+
+    sbrDec->bufWriteOffs = 6 + 2;
+    sbrDec->bufReadOffs  = 2;
+    sbrDec->qmfBufLen = sbrDec->noCols + sbrDec->bufWriteOffs;
+
+    sbrDec->lowBandAddSamples = 288;
+
+    sbrDec->startIndexCodecQmf = 0;
+
+    sbrDec->lowSubband =  32;
+
+
+    return outFrameSize;
+}
+
+#endif
+
diff --git a/media/libstagefright/codecs/aacdec/init_sbr_dec.h b/media/libstagefright/codecs/aacdec/init_sbr_dec.h
new file mode 100644
index 0000000..844fa0e
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/init_sbr_dec.h
@@ -0,0 +1,115 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Filename: init_sbr_dec.h
+ Funtions:
+    get_dse
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+
+ Who:                                   Date: MM/DD/YYYY
+ Description:
+------------------------------------------------------------------------------
+SC 29 Software Copyright Licencing Disclaimer:
+
+This software module was originally developed by
+  Coding Technologies
+
+and edited by
+  -
+
+in the course of development of the ISO/IEC 13818-7 and ISO/IEC 14496-3
+standards for reference purposes and its performance may not have been
+optimized. This software module is an implementation of one or more tools as
+specified by the ISO/IEC 13818-7 and ISO/IEC 14496-3 standards.
+ISO/IEC gives users free license to this software module or modifications
+thereof for use in products claiming conformance to audiovisual and
+image-coding related ITU Recommendations and/or ISO/IEC International
+Standards. ISO/IEC gives users the same free license to this software module or
+modifications thereof for research purposes and further ISO/IEC standardisation.
+Those intending to use this software module in products are advised that its
+use may infringe existing patents. ISO/IEC have no liability for use of this
+software module or modifications thereof. Copyright is not released for
+products that do not conform to audiovisual and image-coding related ITU
+Recommendations and/or ISO/IEC International Standards.
+The original developer retains full right to modify and use the code for its
+own purpose, assign or donate the code to a third party and to inhibit third
+parties from using the code for products that do not conform to audiovisual and
+image-coding related ITU Recommendations and/or ISO/IEC International Standards.
+This copyright notice must be included in all copies or derivative works.
+Copyright (c) ISO/IEC 2002.
+
+ $Id: ct_envcalc.h,v 1.3 2002/11/29 16:11:49 kaehleof Exp $
+*/
+
+/*----------------------------------------------------------------------------
+; CONTINUE ONLY IF NOT ALREADY DEFINED
+----------------------------------------------------------------------------*/
+#ifndef INIT_SBR_DEC_H
+#define INIT_SBR_DEC_H
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+#include "sbr_dec.h"
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here.
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL VARIABLES REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; SIMPLE TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; ENUMERATED TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; STRUCTURES TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; GLOBAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+
+Int32 init_sbr_dec(Int32 codecSampleRate,
+                   Int  upsampleFac,
+                   SBR_DEC *sbrDec,
+                   SBR_FRAME_DATA *hFrameData);
+
+/*----------------------------------------------------------------------------
+; END
+----------------------------------------------------------------------------*/
+#endif
+
+
diff --git a/media/libstagefright/codecs/aacdec/intensity_right.cpp b/media/libstagefright/codecs/aacdec/intensity_right.cpp
new file mode 100644
index 0000000..106298a
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/intensity_right.cpp
@@ -0,0 +1,457 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Pathname: intensity_right.c
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+ Description: Modified per review comments.
+
+ Description: Noticed that the code could be more efficient by
+ using some other method for storing the sign.  The code was changed to
+ use a signed Int to store the table, and an adjustment of the q-format to
+ reflect the difference between the data being shifted by 16 and the table
+ being stored in q-15 format.
+
+ Description: Updated pseudocode
+
+ Description: When the multiplication of two 16-bits variables is stored in
+              an 32-bits variable, the result should be typecasted explicitly
+              to Int32 before it is stored.
+              *(pCoefRight++) = (Int32) tempInt2 * multiplier;
+
+ Description:
+------------------------------------------------------------------------------
+ INPUT AND OUTPUT DEFINITIONS
+
+ Inputs:
+
+    scalefactor  =  Multiplier used to scale the data extracted from the left
+                    channel for use on the right.
+                    [const Int]
+
+    coef_per_win =  Number of coefficients per window.
+                    (128 for short, 1024 for long)
+                    [const Int]
+
+    sfb_per_win  =  Number of scalefactor bands per window.  This should be
+                    a number divisible by four.
+                    [const Int]
+
+    wins_in_group = The number of windows in the group being decoded.
+                    This number falls within the range 1-8.
+                    [const Int]
+
+    band_length  =  The length of the scalefactor band being decoded.
+                    This value is divisible by 4.
+                    [const Int]
+
+    codebook     =  Value that denotes which Huffman codebook was used for
+                    the encoding of this grouped scalefactor band.
+                    [const Int]
+
+    ms_used      =  Flag that denotes whether M/S is active for this band.
+                    [const Bool]
+
+    q_formatLeft = The Q-format for the left channel's fixed-point spectral
+                   coefficients, on a per-scalefactor band, non-grouped basis.
+                   [const Int *, length MAXBANDS]
+
+    q_formatRight = The Q-format for the right channel's fixed-point spectral
+                    coefficients, on a per-scalefactor band, non-grouped basis.
+                    [Int *, length MAXBANDS]
+
+    coefLeft =  Array containing the fixed-point spectral coefficients
+                for the left channel.
+                [const Int32 *, length 1024]
+
+    coefRight = Array containing the fixed-point spectral coefficients
+                for the right channel.
+                [Int32 *, length 1024]
+
+ Local Stores/Buffers/Pointers Needed:
+    intensity_factor =  Table which stores the values of
+                        0.5^(0), 0.5^(1/4), 0.5^(2/4) and 0.5^(3/4)
+                        [UInt, length 4]
+
+ Global Stores/Buffers/Pointers Needed:
+    None
+
+ Outputs:
+    None
+
+ Pointers and Buffers Modified:
+    coefRight[]         Contains the new spectral information
+
+    q_formatRight[]     Q-format may be updated with changed fixed-point
+                        data in coefRight.
+
+ Local Stores Modified:
+    None
+
+ Global Stores Modified:
+    None
+
+------------------------------------------------------------------------------
+ FUNCTION DESCRIPTION
+
+ This function applies Intensity Stereo, generating data on the right channel
+ that is derived from data on the Left.  A scalefactor is applied using the
+ following formula...
+
+ RightCh = LeftCh*0.5^(scalefactor/4)
+
+ This function works for one scalefactor band, which may belong to a group.
+ (i.e. the same scalefactor band repeated across multiple windows belonging
+  to one group.)
+
+------------------------------------------------------------------------------
+ REQUIREMENTS
+
+ codebook must be either INTENSITY_HCB or INTENSITY_HCB2 when this function
+ is called.
+
+ ms_used must be 1 when TRUE, 0 when FALSE.
+
+ wins_in_group falls within the range [1-8]
+
+------------------------------------------------------------------------------
+ REFERENCES
+
+ (1) ISO/IEC 14496-3:1999(E)
+     Part 3
+        Subpart 4.6.7.2.3 Decoding Process (Intensity Stereo)
+
+ (2) MPEG-2 NBC Audio Decoder
+   "This software module was originally developed by AT&T, Dolby
+   Laboratories, Fraunhofer Gesellschaft IIS in the course of development
+   of the MPEG-2 NBC/MPEG-4 Audio standard ISO/IEC 13818-7, 14496-1,2 and
+   3. This software module is an implementation of a part of one or more
+   MPEG-2 NBC/MPEG-4 Audio tools as specified by the MPEG-2 NBC/MPEG-4
+   Audio standard. ISO/IEC  gives users of the MPEG-2 NBC/MPEG-4 Audio
+   standards free license to this software module or modifications thereof
+   for use in hardware or software products claiming conformance to the
+   MPEG-2 NBC/MPEG-4 Audio  standards. Those intending to use this software
+   module in hardware or software products are advised that this use may
+   infringe existing patents. The original developer of this software
+   module and his/her company, the subsequent editors and their companies,
+   and ISO/IEC have no liability for use of this software module or
+   modifications thereof in an implementation. Copyright is not released
+   for non MPEG-2 NBC/MPEG-4 Audio conforming products.The original
+   developer retains full right to use the code for his/her  own purpose,
+   assign or donate the code to a third party and to inhibit third party
+   from using the code for non MPEG-2 NBC/MPEG-4 Audio conforming products.
+   This copyright notice must be included in all copies or derivative
+   works."
+   Copyright(c)1996.
+
+------------------------------------------------------------------------------
+ PSEUDO-CODE
+    multiplier = codebook AND 0x1;
+
+    multiplier = multiplier XOR ms_used;
+
+    multiplier = multiplier << 1;
+
+    multiplier = multiplier - 1;
+
+    multiplier = multiplier * intensity_factor[scalefactor & 0x3];
+
+    scf_div_4 = (scalefactor >> 2);
+
+    nextWinPtrUpdate = (coef_per_win - band_length);
+
+    FOR (win_indx = wins_in_group; win_indx > 0; win_indx--)
+
+        *(pQformatRight) = scf_div_4 + *(pQformatLeft) - 1;
+
+        FOR (tempInt = band_length; tempInt > 0; tempInt--)
+           tempInt2 = (Int)(*(pCoefLeft) >> 16);
+
+           *(pCoefRight) = tempInt2 * multiplier;
+
+           pCoefRight = pCoefRight + 1;
+           pCoefLeft  = pCoefLeft  + 1;
+
+        ENDFOR
+
+        pCoefRight = pCoefRight + nextWinPtrUpdate;
+        pCoefLeft  = pCoefLeft + nextWinPtrUpdate;
+
+        pQformatRight = pQformatRight + sfb_per_win;
+        pQformatLeft  = pQformatLeft  + sfb_per_win;
+    ENDFOR
+
+------------------------------------------------------------------------------
+ RESOURCES USED
+   When the code is written for a specific target processor the
+   resources used should be documented below.
+
+ STACK USAGE: [stack count for this module] + [variable to represent
+          stack usage for each subroutine called]
+
+     where: [stack usage variable] = stack usage for [subroutine
+         name] (see [filename].ext)
+
+ DATA MEMORY USED: x words
+
+ PROGRAM MEMORY USED: x words
+
+ CLOCK CYCLES: [cycle count equation for this module] + [variable
+           used to represent cycle count for each subroutine
+           called]
+
+     where: [cycle count variable] = cycle count for [subroutine
+        name] (see [filename].ext)
+
+------------------------------------------------------------------------------
+*/
+
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+#include "pv_audio_type_defs.h"
+#include "intensity_right.h"
+#include "e_huffmanconst.h"
+
+#include "fxp_mul32.h"
+#include "aac_mem_funcs.h"
+
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here. Include conditional
+; compile variables also.
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; LOCAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; LOCAL STORE/BUFFER/POINTER DEFINITIONS
+; Variable declaration - defined here and used outside this module
+----------------------------------------------------------------------------*/
+const Int16 intensity_factor[4] =
+{
+    32767,  /* (0.5^0.00)*2^15 - 1 (minus 1 for storage as type Int) */
+    27554,  /* (0.5^0.25)*2^15 */
+    23170,  /* (0.5^0.50)*2^15 */
+    19484
+}; /* (0.5^0.75)*2^15 */
+
+
+/*----------------------------------------------------------------------------
+; EXTERNAL FUNCTION REFERENCES
+; Declare functions defined elsewhere and referenced in this module
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL GLOBAL STORE/BUFFER/POINTER REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; FUNCTION CODE
+----------------------------------------------------------------------------*/
+
+void intensity_right(
+    const Int   scalefactor,
+    const Int   coef_per_win,
+    const Int   sfb_per_win,
+    const Int   wins_in_group,
+    const Int   band_length,
+    const Int   codebook,
+    const Bool  ms_used,
+    const Int   q_formatLeft[],
+    Int   q_formatRight[],
+    const Int32 coefLeft[],
+    Int32 coefRight[])
+
+{
+    const Int32 *pCoefLeft  = coefLeft;
+    Int32 *pCoefRight = coefRight;
+
+    const Int *pQformatLeft  = q_formatLeft;
+    Int *pQformatRight = q_formatRight;
+
+    Int   multiplier;
+    Int   scf_div_4;
+    Int   nextWinPtrUpdate;
+
+    /*
+     * The sign of the intensity multiplier obeys the following table...
+     *
+     * codebook       | ms_used | multiplier
+     * --------------------------------------
+     * INTENSITY_HCB  | TRUE    |    -1
+     * INTENSITY_HCB  | FALSE   |    +1
+     * INTENSITY_HCB2 | TRUE    |    +1
+     * INTENSITY_HCB2 | FALSE   |    -1
+     *
+     * In binary, the above table is represented as...
+     *
+     * codebook       | ms_used | multiplier
+     * --------------------------------------
+     * 1111b          | 1       |    -1
+     * 1111b          | 0       |    +1
+     * 1110b          | 1       |    +1
+     * 1110b          | 0       |    -1
+     *
+     */
+
+    /*
+     * Deriving the correct value for "multiplier" is illustrated
+     * below for all 4 possible combinations of codebook and ms_used
+     */
+
+    /*
+     * 1111b AND 0x1 = 1b
+     * 1111b AND 0x1 = 1b
+     * 1110b AND 0x1 = 0b
+     * 1110b AND 0x1 = 0b
+     */
+    multiplier  = (codebook & 0x1);
+
+    /*
+     * 1b XOR 1 = 0b
+     * 1b XOR 0 = 1b
+     * 0b XOR 1 = 1b
+     * 0b XOR 0 = 0b
+     */
+    multiplier ^= ms_used;
+
+    /*
+     * 0b << 1 = 0
+     * 1b << 1 = 2
+     * 1b << 1 = 2
+     * 0b << 1 = 0
+     */
+    multiplier <<= 1;
+
+    /*
+     * 0 - 1 = -1
+     * 2 - 1 = +1
+     * 2 - 1 = +1
+     * 0 - 1 = -1
+     */
+    multiplier--;
+
+    multiplier *= intensity_factor[scalefactor & 0x3];
+
+    scf_div_4 = (scalefactor >> 2);
+
+    /*
+     * Step through all the windows in this group, replacing this
+     * band in each window's spectrum with
+     * left-channel correlated data
+     */
+
+    nextWinPtrUpdate = (coef_per_win - band_length);
+
+    for (Int win_indx = wins_in_group; win_indx > 0; win_indx--)
+    {
+
+        /*
+         * Calculate q_formatRight
+         *
+         * q_formatLeft must be included, since the values
+         * on the right-channel are derived from the values
+         * on the left-channel.
+         *
+         * scalefactor/4 is included, since the intensity
+         * formula is RightCh = LeftCh*0.5^(scalefactor/4)
+         *
+         * powers of 0.5 increase the q_format by 1.
+         * (Another way to multiply something by 0.5^(x)
+         *  is to increase its q-format by x.)
+         *
+         * Finally the q-format must be decreased by 1.
+         * The reason for this is because the table is stored
+         * in q-15 format, but we are shifting by 16 to do
+         * a 16 x 16 multiply.
+         */
+
+        *(pQformatRight) = scf_div_4 + *(pQformatLeft);
+
+        /*
+         * reconstruct right intensity values
+         *
+         * to make things faster, this for loop
+         * can be partially unrolled, since band_length is a multiple
+         * of four.
+         */
+
+
+        if (multiplier == 32767)
+        {
+            Int32 tempInt2 = *(pCoefLeft++);
+            Int32 tempInt22 = *(pCoefLeft++);
+
+            for (Int tempInt = band_length >> 1; tempInt > 0; tempInt--)
+            {
+                *(pCoefRight++) = tempInt2;
+                *(pCoefRight++) = tempInt22;
+                tempInt2 = *(pCoefLeft++);
+                tempInt22 = *(pCoefLeft++);
+            }
+
+        }
+        else
+        {
+
+            Int32 tempInt2 = *(pCoefLeft++);
+            Int32 tempInt22 = *(pCoefLeft++);
+            for (Int tempInt = band_length >> 1; tempInt > 0; tempInt--)
+            {
+                *(pCoefRight++) = fxp_mul32_by_16(tempInt2, multiplier) << 1;
+                *(pCoefRight++) = fxp_mul32_by_16(tempInt22, multiplier) << 1;
+                tempInt2 = *(pCoefLeft++);
+                tempInt22 = *(pCoefLeft++);
+            }
+        }
+
+        /*
+         * Set pCoefRight and pCoefLeft to the beginning of
+         * this sfb in the next window in the group.
+         */
+
+        pCoefRight += nextWinPtrUpdate;
+        pCoefLeft  += (nextWinPtrUpdate - 2);
+
+        /*
+         * Update pQformatRight and pQformatLeft to this sfb in
+         * in the next window in the group.
+         */
+
+        pQformatRight += sfb_per_win;
+        pQformatLeft  += sfb_per_win;
+
+    } /* for (win_indx) */
+
+
+} /* void intensity_right */
diff --git a/media/libstagefright/codecs/aacdec/intensity_right.h b/media/libstagefright/codecs/aacdec/intensity_right.h
new file mode 100644
index 0000000..823da07
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/intensity_right.h
@@ -0,0 +1,97 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Pathname: intensity_right.h
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+ Description: Change ms_used from Int to Bool
+
+ Who:                       Date:
+ Description:
+
+------------------------------------------------------------------------------
+ INCLUDE DESCRIPTION
+
+ Contains the function definitions for intensity_right
+------------------------------------------------------------------------------
+*/
+
+/*----------------------------------------------------------------------------
+; CONTINUE ONLY IF NOT ALREADY DEFINED
+----------------------------------------------------------------------------*/
+#ifndef INTENSITY_RIGHT_H
+#define INTENSITY_RIGHT_H
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+#include "pv_audio_type_defs.h"
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here.
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL VARIABLES REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; SIMPLE TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; ENUMERATED TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; STRUCTURES TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; GLOBAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+
+void intensity_right(
+    const Int   scalefactor,
+    const Int   coef_per_win,
+    const Int   sfb_per_win,
+    const Int   wins_in_group,
+    const Int   band_length,
+    const Int   codebook,
+    const Bool  ms_used,
+    const Int   q_formatLeft[],
+    Int   q_formatRight[],
+    const Int32 coefLeft[],
+    Int32 coefRight[]);
+
+/*----------------------------------------------------------------------------
+; END
+----------------------------------------------------------------------------*/
+#endif
+
diff --git a/media/libstagefright/codecs/aacdec/inv_long_complex_rot.cpp b/media/libstagefright/codecs/aacdec/inv_long_complex_rot.cpp
new file mode 100644
index 0000000..84a7ec8
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/inv_long_complex_rot.cpp
@@ -0,0 +1,408 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Pathname: .inv_long_complex_rot.c
+ Funtions:  inv_long_complex_rot
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+ Description:  Change the input argument, no shifts information from long fft_rx4
+               , do not have to check for shifts.
+
+ Date: 10/18/2002
+ Description:
+            (1) Change the input argument, only a single max is passed.
+            (2) Eliminate search for max, a fixed shift has replaced the
+                search for max with minimal loss of precision.
+            (3) Eliminated unused variables
+
+ Date: 10/28/2002
+ Description:
+            (1) Added comments per code review
+
+ Description:
+
+ ------------------------------------------------------------------------------
+ INPUT AND OUTPUT DEFINITIONS
+
+ Inputs:
+
+    Data_in   = Input vector (sized for long windows
+                TWICE_INV_LONG_CX_ROT_LENGTH), with time domain samples
+                type Int32 *
+
+    Data_out  = Output vector with a post-rotation by exp(j(2pi/N)(k+1/8)),
+                (sized for long windows TWICE_INV_LONG_CX_ROT_LENGTH)
+                type Int32 *
+
+    max       = Input, carries the maximum value of the input vector
+                "Data_in"
+                type Int32
+
+
+ Local Stores/Buffers/Pointers Needed:
+    None
+
+ Global Stores/Buffers/Pointers Needed:
+    None
+
+ Outputs:
+    exp = shift factor to reflect signal scaling
+
+ Pointers and Buffers Modified:
+    Results are return in "Data_out"
+
+ Local Stores Modified:
+    None
+
+ Global Stores Modified:
+    None
+------------------------------------------------------------------------------
+ FUNCTION DESCRIPTION
+
+    inv_long_complex_rot() performs the complex rotation for the inverse MDCT
+    for the case of long windows. It also performs digit reverse ordering of
+    the first and second halves of the input vector "Data_in", as well as
+    reordering of the two half vectors (following radix-2 decomposition)
+    Word normalization is also done to ensure 16 by 16 bit multiplications.
+
+------------------------------------------------------------------------------
+ REQUIREMENTS
+
+    inv_long_complex_rot() should execute a post-rotation by
+    exp(-j(2pi/N)(k+1/8)), digit reverse ordering and word normalization
+
+------------------------------------------------------------------------------
+ REFERENCES
+
+------------------------------------------------------------------------------
+ RESOURCES USED
+   When the code is written for a specific target processor the
+     the resources used should be documented below.
+
+ STACK USAGE: [stack count for this module] + [variable to represent
+          stack usage for each subroutine called]
+
+     where: [stack usage variable] = stack usage for [subroutine
+         name] (see [filename].ext)
+
+ DATA MEMORY USED: x words
+
+ PROGRAM MEMORY USED: x words
+
+ CLOCK CYCLES: [cycle count equation for this module] + [variable
+           used to represent cycle count for each subroutine
+           called]
+
+     where: [cycle count variable] = cycle count for [subroutine
+        name] (see [filename].ext)
+
+------------------------------------------------------------------------------
+*/
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+
+#include "digit_reversal_tables.h"
+#include "inv_long_complex_rot.h"
+#include "imdct_fxp.h"
+#include "inv_long_complex_rot.h"
+#include "pv_normalize.h"
+
+#include "fxp_mul32.h"
+#include "aac_mem_funcs.h"
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here. Include conditional
+; compile variables also.
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; LOCAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; LOCAL VARIABLE DEFINITIONS
+; Variable declaration - defined here and used outside this module
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL FUNCTION REFERENCES
+; Declare functions defined elsewhere and referenced in this module
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL VARIABLES REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+
+
+Int inv_long_complex_rot(
+    Int32 *Data,
+    Int32  max)
+{
+    Int     i;
+    Int16     I;
+    const   Int32 *p_rotate;
+    Int32   temp_re;
+    Int32   temp_im;
+
+    Int32    exp_jw;
+    Int32   *pData_in_1;
+    Int32   *pData_in_2;
+    Int     exp;
+    Int32   *pData_in_ref1;
+    Int32   *pData_in_ref2;
+
+
+    Int16   temp_re_0;
+    Int16   temp_im_0;
+    Int16   temp_re_1;
+    Int16   temp_im_1;
+    Int16   *p_Data_Int_precision;
+    Int     n     = 2048;
+    Int     n_2   = n >> 1;
+    Int     n_4   = n >> 2;
+    Int     n_3_4 = n_2 + n_4;
+
+    Int16   *px_1;
+    Int16   *px_2;
+    Int16   *px_3;
+    Int16   *px_4;
+
+    Int16     J;
+    const   Int32 *p_rotate2;
+
+
+
+
+    p_rotate    =  &exp_rotation_N_2048[255];
+    p_rotate2   =  &exp_rotation_N_2048[256];
+
+    pData_in_ref1  =  Data;
+    pData_in_ref2  = &Data[TWICE_INV_LONG_CX_ROT_LENGTH];
+
+
+    /*
+     *  Apply  A/2^(diff) + B
+     */
+
+    p_Data_Int_precision = (Int16 *)Data;
+
+    exp = 16 - pv_normalize(max);
+
+
+    /*
+     *        px2-->               <--px1 px4-->               <--px3
+     *
+     *                     |                           |             |
+     *       |+++++++++++++|+++++++++++++|+++++++++++++|+++++++++++++|
+     *                     |             |             |             |
+     *                    n/4           n/2          3n/4
+     */
+
+    I = 255;
+    J = 256;
+
+    pData_in_1 = pData_in_ref2 + I;
+
+    px_1 = (Int16 *)pData_in_1;
+    px_1++;
+
+    pData_in_2 = pData_in_ref2 + J;
+
+    px_4 = (Int16 *)pData_in_2;
+
+
+
+    exp -= 1;
+
+
+    for (i = INV_LONG_CX_ROT_LENGTH >> 1; i != 0; i--)
+    {
+
+        pData_in_2 = pData_in_ref1 + J;
+
+        temp_im =  *(pData_in_2++);
+        temp_re =  *(pData_in_2);
+
+
+        /*
+         * cos_n + j*sin_n == exp(j(2pi/N)(k+1/8))
+         */
+        exp_jw = *p_rotate2++;
+
+        /*
+         *   Post-rotation
+         */
+
+
+
+        temp_re_0  = (Int16)(cmplx_mul32_by_16(temp_re,  -temp_im,  exp_jw) >> exp);
+        temp_im_0  = (Int16)(cmplx_mul32_by_16(temp_im,   temp_re,  exp_jw) >> exp);
+
+
+        pData_in_1 = pData_in_ref2 + I;
+
+        /*
+         *  Use auxiliary variables to avoid double accesses to memory.
+         *  Data in is scaled to use only lower 16 bits.
+         */
+
+        temp_re =  *(pData_in_1--);
+        temp_im =  *(pData_in_1);
+
+        /*
+         * cos_n + j*sin_n == exp(j(2pi/N)(k+1/8))
+         */
+        exp_jw = *p_rotate--;
+
+
+        /*
+         *   Post-rotation
+         */
+
+        temp_re_1  = (Int16)(cmplx_mul32_by_16(temp_re,  -temp_im,  exp_jw) >> exp);
+        temp_im_1  = (Int16)(cmplx_mul32_by_16(temp_im,   temp_re,  exp_jw) >> exp);
+
+
+        /*
+         *   Repeat procedure for odd index at the output
+         */
+
+        pData_in_2 = pData_in_ref2 + J;
+        J += 2;
+
+        temp_im =  *(pData_in_2++);
+        temp_re =  *(pData_in_2);
+
+
+        *(px_1--) =  temp_re_0;
+        *(px_1--) =  temp_im_1;
+        *(px_4++) =  temp_im_0;
+        *(px_4++) =  temp_re_1;
+
+
+        exp_jw = *p_rotate2++;
+
+
+        *(px_1--)  = (Int16)(cmplx_mul32_by_16(temp_re,  -temp_im,  exp_jw) >> exp);
+        *(px_4++)  = (Int16)(cmplx_mul32_by_16(temp_im,   temp_re,  exp_jw) >> exp);
+
+
+
+        /*
+         *   Repeat procedure for odd index at the output
+         */
+
+        pData_in_1 = pData_in_ref1 + I;
+        I -= 2;
+
+        temp_re =  *(pData_in_1--);
+        temp_im =  *(pData_in_1);
+
+
+        exp_jw = *p_rotate--;
+
+
+        *(px_4++)  = (Int16)(cmplx_mul32_by_16(temp_re,  -temp_im,  exp_jw) >> exp);
+        *(px_1--)  = (Int16)(cmplx_mul32_by_16(temp_im,   temp_re,  exp_jw) >> exp);
+
+    }
+
+    /*
+     *                                           <--px1 px4-->
+     *
+     *                     |                           |             |
+     *       |-------------|-------------|/////////////|\\\\\\\\\\\\\|
+     *                     |             |             |             |
+     *                    n/4           n/2          3n/4
+     */
+
+
+    px_1 = p_Data_Int_precision + n_2 - 1;
+    px_2 = p_Data_Int_precision;
+
+    px_4 = p_Data_Int_precision + n_3_4 - 1;
+
+    for (i = 0; i<INV_LONG_CX_ROT_LENGTH >> 1; i++)
+    {
+
+        Int16 temp_re_0 = *(px_4--);
+        Int16 temp_im_1 = *(px_4--);
+        Int16 temp_re_2 = *(px_4--);
+        Int16 temp_im_3 = *(px_4--);
+        *(px_1--) = temp_re_0;
+        *(px_1--) = temp_im_1;
+        *(px_1--) = temp_re_2;
+        *(px_1--) = temp_im_3;
+
+        *(px_2++) = (-temp_re_0);
+        *(px_2++) = (-temp_im_1);
+        *(px_2++) = (-temp_re_2);
+        *(px_2++) = (-temp_im_3);
+
+    }
+
+
+    px_4 = p_Data_Int_precision + n_2;
+
+
+    pv_memcpy(px_4, pData_in_ref2 + 256, TWICE_INV_LONG_CX_ROT_LENGTH*sizeof(*px_4));
+
+
+
+    /*
+     *        px2-->               <--px1 px4-->               <--px3
+     *
+     *                     |                           |             |
+     *       |+++++++++++++|+++++++++++++|+++++++++++++|+++++++++++++|
+     *                     |             |             |             |
+     *                    n/4           n/2          3n/4
+     */
+    px_3 = p_Data_Int_precision + n - 1;
+
+
+    for (i = 0; i<INV_LONG_CX_ROT_LENGTH >> 1; i++)
+    {
+
+        Int16 temp_im_0 = *(px_4++);
+        Int16 temp_re_1 = *(px_4++);
+        Int16 temp_im_2 = *(px_4++);
+        Int16 temp_re_3 = *(px_4++);
+        *(px_3--) =  temp_im_0;
+        *(px_3--) =  temp_re_1;
+        *(px_3--) =  temp_im_2;
+        *(px_3--) =  temp_re_3;
+
+    }
+
+
+    return (exp + 1);
+}
+
diff --git a/media/libstagefright/codecs/aacdec/inv_long_complex_rot.h b/media/libstagefright/codecs/aacdec/inv_long_complex_rot.h
new file mode 100644
index 0000000..8b95867
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/inv_long_complex_rot.h
@@ -0,0 +1,99 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Pathname: inv_long_complex_rot.h
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+
+ Who:                   Date:
+ Description:
+
+------------------------------------------------------------------------------
+ INCLUDE DESCRIPTION
+
+ Header file for function inv_long_complex_rot()
+
+
+------------------------------------------------------------------------------
+*/
+
+/*----------------------------------------------------------------------------
+; CONTINUE ONLY IF NOT ALREADY DEFINED
+----------------------------------------------------------------------------*/
+#ifndef INV_LONG_COMPLEX_ROT_H
+#define INV_LONG_COMPLEX_ROT_H
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+#include "pv_audio_type_defs.h"
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here.
+----------------------------------------------------------------------------*/
+#define INV_LONG_CX_ROT_LENGTH          256
+#define TWICE_INV_LONG_CX_ROT_LENGTH (INV_LONG_CX_ROT_LENGTH<<1)
+
+/*----------------------------------------------------------------------------
+; EXTERNAL VARIABLES REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; SIMPLE TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; ENUMERATED TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; STRUCTURES TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; GLOBAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+    Int inv_long_complex_rot(
+        Int32 *Data,
+        Int32  max);
+
+#ifdef __cplusplus
+}
+#endif
+
+/*----------------------------------------------------------------------------
+; END
+----------------------------------------------------------------------------*/
+#endif  /* INV_LONG_COMPLEX_ROT_H */
diff --git a/media/libstagefright/codecs/aacdec/inv_short_complex_rot.cpp b/media/libstagefright/codecs/aacdec/inv_short_complex_rot.cpp
new file mode 100644
index 0000000..5b4f1c5
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/inv_short_complex_rot.cpp
@@ -0,0 +1,305 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Pathname: inv_short_complex_rot.c
+ Funtions:  inv_short_complex_rot
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+ Date: 10/18/2002
+ Description:
+            (1) Change the input argument, only a single max is passed.
+            (2) Eliminate search for max, a fixed shift has replaced the
+                search for max with minimal loss of precision.
+            (3) Eliminated unused variables
+
+ Date: 10/28/2002
+ Description:
+            (1) Added comments per code review
+            (2) Eliminated hardly used condition on if-else (exp==0)
+
+ Description:
+
+ ------------------------------------------------------------------------------
+ INPUT AND OUTPUT DEFINITIONS
+
+ Inputs:
+
+    Data_in   = Input vector (sized for short windows
+                2*INV_SHORT_CX_ROT_LENGTH elements), with time domain samples
+                type Int32 *
+
+    Data_out  = Output vector with a post-rotation by exp(j(2pi/N)(k+1/8)),
+                (sized for short windows 2*INV_SHORT_CX_ROT_LENGTH)
+                type Int32 *
+
+    max       = Input, carries the maximum value of the input vector
+                "Data_in"
+                type Int32
+
+
+ Local Stores/Buffers/Pointers Needed:
+    None
+
+ Global Stores/Buffers/Pointers Needed:
+    None
+
+ Outputs:
+    exp = shift factor to reflect signal scaling
+
+ Pointers and Buffers Modified:
+    Results are return in "Data_out"
+
+ Local Stores Modified:
+    None
+
+ Global Stores Modified:
+    None
+------------------------------------------------------------------------------
+ FUNCTION DESCRIPTION
+
+    inv_short_complex_rot() performs the complex rotation for the inverse MDCT
+    for the case of short windows. It performs digit reverse ordering as well
+    word normalization to ensure 16 by 16 bit multiplications.
+
+------------------------------------------------------------------------------
+ REQUIREMENTS
+
+    inv_short_complex_rot() should execute a post-rotation by
+    exp( j(2pi/N)(k+1/8)), digit reverse ordering and word normalization
+
+------------------------------------------------------------------------------
+ REFERENCES
+
+------------------------------------------------------------------------------
+ RESOURCES USED
+   When the code is written for a specific target processor the
+     the resources used should be documented below.
+
+ STACK USAGE: [stack count for this module] + [variable to represent
+          stack usage for each subroutine called]
+
+     where: [stack usage variable] = stack usage for [subroutine
+         name] (see [filename].ext)
+
+ DATA MEMORY USED: x words
+
+ PROGRAM MEMORY USED: x words
+
+ CLOCK CYCLES: [cycle count equation for this module] + [variable
+           used to represent cycle count for each subroutine
+           called]
+
+     where: [cycle count variable] = cycle count for [subroutine
+        name] (see [filename].ext)
+
+------------------------------------------------------------------------------
+*/
+
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+
+#include "digit_reversal_tables.h"
+#include "imdct_fxp.h"
+#include "inv_short_complex_rot.h"
+#include "pv_normalize.h"
+#include "fxp_mul32.h"
+
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here. Include conditional
+; compile variables also.
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; LOCAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; LOCAL VARIABLE DEFINITIONS
+; Variable declaration - defined here and used outside this module
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL FUNCTION REFERENCES
+; Declare functions defined elsewhere and referenced in this module
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL VARIABLES REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+
+Int inv_short_complex_rot(
+    Int32 *Data_in,
+    Int32 *Data_out,
+    Int32  max)
+
+{
+    Int     i;
+    Int16     I;
+    const   Int16 *pTable;
+    const   Int32 *p_rotate;
+
+    Int32   *pData_in_1;
+    Int     exp;
+    Int32   temp_re;
+    Int32   temp_im;
+
+    Int32   exp_jw;
+    Int16   *pData_re;
+    Int16   *pData_im;
+    Int32   *pData_in_ref;
+
+    Int16   temp_re_0;
+    Int16   temp_im_0;
+    Int16   temp_re_1;
+    Int16   temp_im_1;
+    Int16   *p_data_1;
+    Int16   *p_data_2;
+    Int16   *p_Data_Int_precision;
+    Int16   *p_Data_Int_precision_1;
+    Int16   *p_Data_Int_precision_2;
+
+    Int     n     = 256;
+    Int     n_2   = n >> 1;
+    Int     n_4   = n >> 2;
+    Int     n_8   = n >> 3;
+    Int     n_3_4 = n_2 + n_4;
+
+
+    p_data_1 = (Int16 *)Data_out;
+    p_data_1 += n;
+    pData_re  = p_data_1;
+    pData_im  = p_data_1 + n_4;
+
+
+    p_rotate  =  exp_rotation_N_256;
+    pTable    =  digit_reverse_64;
+
+    pData_in_ref  =  Data_in;
+
+    exp = 16 - pv_normalize(max);
+
+
+    if (exp < 0)
+    {
+        exp = 0;
+    }
+
+    exp -= 1;
+
+    for (i = INV_SHORT_CX_ROT_LENGTH; i != 0; i--)
+    {
+
+        /*
+         * cos_n + j*sin_n == exp(j(2pi/N)(k+1/8))
+         */
+
+        /*
+         *   Perform digit reversal by accessing index I from table
+         */
+
+        I = *pTable++;
+        pData_in_1 = pData_in_ref + I;
+        /*
+         *  Use auxiliary variables to avoid double accesses to memory.
+         *  Data in is scaled to use only lower 16 bits.
+         */
+
+        temp_im =  *(pData_in_1++);
+        temp_re =  *(pData_in_1);
+
+        exp_jw = *p_rotate++;
+
+        /*
+         *   Post-rotation
+         */
+
+        *(pData_re++)  = (Int16)(cmplx_mul32_by_16(temp_re, -temp_im, exp_jw) >> exp);
+        *(pData_im++)  = (Int16)(cmplx_mul32_by_16(temp_im,  temp_re, exp_jw) >> exp);
+    }
+
+
+    p_data_2 = pData_im -  1;
+
+
+    p_Data_Int_precision = (Int16 *)Data_out;
+    p_Data_Int_precision_1 = p_Data_Int_precision + n_3_4 - 1;
+    p_Data_Int_precision_2 = p_Data_Int_precision + n_3_4;
+
+    for (i = n_8 >> 1; i != 0; i--)
+    {
+        temp_re_0 = (*(p_data_1++));
+        temp_re_1 = (*(p_data_1++));
+        temp_im_0 = (*(p_data_2--));
+        temp_im_1 = (*(p_data_2--));
+
+        *(p_Data_Int_precision_1--) =  temp_re_0;
+        *(p_Data_Int_precision_1--) =  temp_im_0;
+        *(p_Data_Int_precision_1--) =  temp_re_1;
+        *(p_Data_Int_precision_1--) =  temp_im_1;
+
+        *(p_Data_Int_precision_2++) =  temp_re_0;
+        *(p_Data_Int_precision_2++) =  temp_im_0;
+        *(p_Data_Int_precision_2++) =  temp_re_1;
+        *(p_Data_Int_precision_2++) =  temp_im_1;
+
+    }
+
+
+    /*
+     *  loop is split to avoid conditional testing inside loop
+     */
+
+    p_Data_Int_precision_2 = p_Data_Int_precision;
+
+    for (i = n_8 >> 1; i != 0; i--)
+    {
+
+        temp_re_0 = (*(p_data_1++));
+        temp_re_1 = (*(p_data_1++));
+        temp_im_0 = (*(p_data_2--));
+        temp_im_1 = (*(p_data_2--));
+
+        *(p_Data_Int_precision_1--) =   temp_re_0;
+        *(p_Data_Int_precision_1--) =   temp_im_0;
+        *(p_Data_Int_precision_1--) =   temp_re_1;
+        *(p_Data_Int_precision_1--) =   temp_im_1;
+
+        *(p_Data_Int_precision_2++) = (Int16)(-temp_re_0);
+        *(p_Data_Int_precision_2++) = (Int16)(-temp_im_0);
+        *(p_Data_Int_precision_2++) = (Int16)(-temp_re_1);
+        *(p_Data_Int_precision_2++) = (Int16)(-temp_im_1);
+
+    }
+
+    return (exp + 1);
+}
diff --git a/media/libstagefright/codecs/aacdec/inv_short_complex_rot.h b/media/libstagefright/codecs/aacdec/inv_short_complex_rot.h
new file mode 100644
index 0000000..97ed730
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/inv_short_complex_rot.h
@@ -0,0 +1,88 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Pathname: inv_short_complex_rot.h
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+ Who:                   Date:
+ Description:
+
+------------------------------------------------------------------------------
+ INCLUDE DESCRIPTION
+
+ Header file for functions inv_short_complex_rot()
+
+------------------------------------------------------------------------------
+*/
+
+/*----------------------------------------------------------------------------
+; CONTINUE ONLY IF NOT ALREADY DEFINED
+----------------------------------------------------------------------------*/
+#ifndef INV_SHORT_COMPLEX_ROT_H
+#define INV_SHORT_COMPLEX_ROT_H
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+#include "pv_audio_type_defs.h"
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here.
+----------------------------------------------------------------------------*/
+#define INV_SHORT_CX_ROT_LENGTH 64
+
+/*----------------------------------------------------------------------------
+; EXTERNAL VARIABLES REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; SIMPLE TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; ENUMERATED TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; STRUCTURES TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; GLOBAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+
+Int inv_short_complex_rot(
+    Int32 *Data_in,
+    Int32 *Data_out,
+    Int32  max);
+
+/*----------------------------------------------------------------------------
+; END
+----------------------------------------------------------------------------*/
+#endif  /* INV_SHORT_COMPLEX_ROT_H */
diff --git a/media/libstagefright/codecs/aacdec/iquant_table.cpp b/media/libstagefright/codecs/aacdec/iquant_table.cpp
new file mode 100644
index 0000000..aee47d6
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/iquant_table.cpp
@@ -0,0 +1,1131 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Pathname: iquant_table.c
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+ Who:                       Date:
+ Description:
+
+------------------------------------------------------------------------------
+ INPUT AND OUTPUT DEFINITIONS
+
+ None, just contains tables.
+------------------------------------------------------------------------------
+ FUNCTION DESCRIPTION
+
+ Holds a table used for esc_iquant, containing the values of x^1/3 in
+ Q format.
+------------------------------------------------------------------------------
+ REQUIREMENTS
+
+------------------------------------------------------------------------------
+ REFERENCES
+
+ (1) ISO/IEC 13818-7:1997 Titled "Information technology - Generic coding
+   of moving pictures and associated audio information - Part 7: Advanced
+   Audio Coding (AAC)", Section 10.3, "Decoding process", page 43.
+
+
+------------------------------------------------------------------------------
+ PSEUDO-CODE
+ None.
+
+------------------------------------------------------------------------------
+ RESOURCES USED
+ None.
+------------------------------------------------------------------------------
+*/
+
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+#include "pv_audio_type_defs.h"
+#include "iquant_table.h"
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here. Include conditional
+; compile variables also.
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; LOCAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; LOCAL STORE/BUFFER/POINTER DEFINITIONS
+; Variable declaration - defined here and used outside this module
+----------------------------------------------------------------------------*/
+
+/*
+   This table contains the value of x ^ (1/3) where x is in the range of
+   [0..1024], in Q27 format.
+   Note that the length of the table is 1025, and not 1024 - this is because
+   the function esc_iquant may need to do an interpolation for numbers near
+   8191, which in that case it needs to get 8192 ^(1/3).
+ */
+const UInt32 inverseQuantTable[] =
+{
+    0x00000000, /*    0 */
+    0x08000000, /*    1 */
+    0x0a14517d, /*    2 */
+    0x0b89ba25, /*    3 */
+    0x0cb2ff53, /*    4 */
+    0x0dae07de, /*    5 */
+    0x0e897685, /*    6 */
+    0x0f4daedd, /*    7 */
+    0x10000000, /*    8 */
+    0x10a402fd, /*    9 */
+    0x113c4841, /*   10 */
+    0x11cab613, /*   11 */
+    0x1250bfe2, /*   12 */
+    0x12cf8890, /*   13 */
+    0x1347f8ab, /*   14 */
+    0x13bacd65, /*   15 */
+    0x1428a2fa, /*   16 */
+    0x1491fc15, /*   17 */
+    0x14f74744, /*   18 */
+    0x1558e2f7, /*   19 */
+    0x15b72095, /*   20 */
+    0x161246d7, /*   21 */
+    0x166a9399, /*   22 */
+    0x16c03d55, /*   23 */
+    0x17137449, /*   24 */
+    0x17646369, /*   25 */
+    0x17b33124, /*   26 */
+    0x18000000, /*   27 */
+    0x184aef29, /*   28 */
+    0x18941ad8, /*   29 */
+    0x18db9cb7, /*   30 */
+    0x19218c2e, /*   31 */
+    0x1965fea5, /*   32 */
+    0x19a907c2, /*   33 */
+    0x19eab998, /*   34 */
+    0x1a2b24d0, /*   35 */
+    0x1a6a58d5, /*   36 */
+    0x1aa863ee, /*   37 */
+    0x1ae5535d, /*   38 */
+    0x1b213377, /*   39 */
+    0x1b5c0fbd, /*   40 */
+    0x1b95f2ec, /*   41 */
+    0x1bcee70f, /*   42 */
+    0x1c06f590, /*   43 */
+    0x1c3e2745, /*   44 */
+    0x1c74847a, /*   45 */
+    0x1caa1501, /*   46 */
+    0x1cdee035, /*   47 */
+    0x1d12ed0b, /*   48 */
+    0x1d464212, /*   49 */
+    0x1d78e582, /*   50 */
+    0x1daadd3a, /*   51 */
+    0x1ddc2ecf, /*   52 */
+    0x1e0cdf8c, /*   53 */
+    0x1e3cf476, /*   54 */
+    0x1e6c7257, /*   55 */
+    0x1e9b5dba, /*   56 */
+    0x1ec9baf6, /*   57 */
+    0x1ef78e2c, /*   58 */
+    0x1f24db4e, /*   59 */
+    0x1f51a620, /*   60 */
+    0x1f7df23c, /*   61 */
+    0x1fa9c314, /*   62 */
+    0x1fd51bf2, /*   63 */
+    0x20000000, /*   64 */
+    0x202a7244, /*   65 */
+    0x205475a6, /*   66 */
+    0x207e0cee, /*   67 */
+    0x20a73aca, /*   68 */
+    0x20d001cc, /*   69 */
+    0x20f8646d, /*   70 */
+    0x2120650e, /*   71 */
+    0x214805fa, /*   72 */
+    0x216f4963, /*   73 */
+    0x2196316c, /*   74 */
+    0x21bcc020, /*   75 */
+    0x21e2f77a, /*   76 */
+    0x2208d961, /*   77 */
+    0x222e67ad, /*   78 */
+    0x2253a425, /*   79 */
+    0x22789082, /*   80 */
+    0x229d2e6e, /*   81 */
+    0x22c17f82, /*   82 */
+    0x22e5854f, /*   83 */
+    0x23094155, /*   84 */
+    0x232cb509, /*   85 */
+    0x234fe1d5, /*   86 */
+    0x2372c918, /*   87 */
+    0x23956c26, /*   88 */
+    0x23b7cc47, /*   89 */
+    0x23d9eabb, /*   90 */
+    0x23fbc8b9, /*   91 */
+    0x241d676e, /*   92 */
+    0x243ec7ff, /*   93 */
+    0x245feb86, /*   94 */
+    0x2480d319, /*   95 */
+    0x24a17fc3, /*   96 */
+    0x24c1f28b, /*   97 */
+    0x24e22c6c, /*   98 */
+    0x25022e5f, /*   99 */
+    0x2521f954, /*  100 */
+    0x25418e33, /*  101 */
+    0x2560ede2, /*  102 */
+    0x2580193e, /*  103 */
+    0x259f111f, /*  104 */
+    0x25bdd657, /*  105 */
+    0x25dc69b4, /*  106 */
+    0x25facbfe, /*  107 */
+    0x2618fdf8, /*  108 */
+    0x26370060, /*  109 */
+    0x2654d3ef, /*  110 */
+    0x2672795c, /*  111 */
+    0x268ff156, /*  112 */
+    0x26ad3c8a, /*  113 */
+    0x26ca5ba2, /*  114 */
+    0x26e74f41, /*  115 */
+    0x27041808, /*  116 */
+    0x2720b695, /*  117 */
+    0x273d2b81, /*  118 */
+    0x27597762, /*  119 */
+    0x27759acb, /*  120 */
+    0x2791964b, /*  121 */
+    0x27ad6a6f, /*  122 */
+    0x27c917c0, /*  123 */
+    0x27e49ec5, /*  124 */
+    0x28000000, /*  125 */
+    0x281b3bf3, /*  126 */
+    0x2836531b, /*  127 */
+    0x285145f3, /*  128 */
+    0x286c14f5, /*  129 */
+    0x2886c096, /*  130 */
+    0x28a1494b, /*  131 */
+    0x28bbaf85, /*  132 */
+    0x28d5f3b3, /*  133 */
+    0x28f01641, /*  134 */
+    0x290a179b, /*  135 */
+    0x2923f82a, /*  136 */
+    0x293db854, /*  137 */
+    0x2957587e, /*  138 */
+    0x2970d90a, /*  139 */
+    0x298a3a59, /*  140 */
+    0x29a37cca, /*  141 */
+    0x29bca0bb, /*  142 */
+    0x29d5a687, /*  143 */
+    0x29ee8e87, /*  144 */
+    0x2a075914, /*  145 */
+    0x2a200684, /*  146 */
+    0x2a38972c, /*  147 */
+    0x2a510b5f, /*  148 */
+    0x2a696370, /*  149 */
+    0x2a819fae, /*  150 */
+    0x2a99c069, /*  151 */
+    0x2ab1c5ed, /*  152 */
+    0x2ac9b088, /*  153 */
+    0x2ae18085, /*  154 */
+    0x2af9362c, /*  155 */
+    0x2b10d1c6, /*  156 */
+    0x2b28539b, /*  157 */
+    0x2b3fbbef, /*  158 */
+    0x2b570b09, /*  159 */
+    0x2b6e412b, /*  160 */
+    0x2b855e97, /*  161 */
+    0x2b9c6390, /*  162 */
+    0x2bb35056, /*  163 */
+    0x2bca2527, /*  164 */
+    0x2be0e242, /*  165 */
+    0x2bf787e4, /*  166 */
+    0x2c0e1649, /*  167 */
+    0x2c248dad, /*  168 */
+    0x2c3aee4a, /*  169 */
+    0x2c513859, /*  170 */
+    0x2c676c13, /*  171 */
+    0x2c7d89af, /*  172 */
+    0x2c939164, /*  173 */
+    0x2ca98368, /*  174 */
+    0x2cbf5ff1, /*  175 */
+    0x2cd52731, /*  176 */
+    0x2cead95e, /*  177 */
+    0x2d0076a9, /*  178 */
+    0x2d15ff45, /*  179 */
+    0x2d2b7363, /*  180 */
+    0x2d40d332, /*  181 */
+    0x2d561ee4, /*  182 */
+    0x2d6b56a7, /*  183 */
+    0x2d807aaa, /*  184 */
+    0x2d958b19, /*  185 */
+    0x2daa8823, /*  186 */
+    0x2dbf71f4, /*  187 */
+    0x2dd448b7, /*  188 */
+    0x2de90c98, /*  189 */
+    0x2dfdbdc0, /*  190 */
+    0x2e125c5c, /*  191 */
+    0x2e26e892, /*  192 */
+    0x2e3b628d, /*  193 */
+    0x2e4fca75, /*  194 */
+    0x2e642070, /*  195 */
+    0x2e7864a8, /*  196 */
+    0x2e8c9741, /*  197 */
+    0x2ea0b862, /*  198 */
+    0x2eb4c831, /*  199 */
+    0x2ec8c6d3, /*  200 */
+    0x2edcb46c, /*  201 */
+    0x2ef09121, /*  202 */
+    0x2f045d14, /*  203 */
+    0x2f18186a, /*  204 */
+    0x2f2bc345, /*  205 */
+    0x2f3f5dc7, /*  206 */
+    0x2f52e812, /*  207 */
+    0x2f666247, /*  208 */
+    0x2f79cc88, /*  209 */
+    0x2f8d26f4, /*  210 */
+    0x2fa071ac, /*  211 */
+    0x2fb3acd0, /*  212 */
+    0x2fc6d87f, /*  213 */
+    0x2fd9f4d7, /*  214 */
+    0x2fed01f8, /*  215 */
+    0x30000000, /*  216 */
+    0x3012ef0c, /*  217 */
+    0x3025cf39, /*  218 */
+    0x3038a0a6, /*  219 */
+    0x304b636d, /*  220 */
+    0x305e17ad, /*  221 */
+    0x3070bd81, /*  222 */
+    0x30835504, /*  223 */
+    0x3095de51, /*  224 */
+    0x30a85985, /*  225 */
+    0x30bac6b9, /*  226 */
+    0x30cd2609, /*  227 */
+    0x30df778d, /*  228 */
+    0x30f1bb60, /*  229 */
+    0x3103f19c, /*  230 */
+    0x31161a59, /*  231 */
+    0x312835b0, /*  232 */
+    0x313a43ba, /*  233 */
+    0x314c4490, /*  234 */
+    0x315e3849, /*  235 */
+    0x31701efd, /*  236 */
+    0x3181f8c4, /*  237 */
+    0x3193c5b4, /*  238 */
+    0x31a585e6, /*  239 */
+    0x31b7396f, /*  240 */
+    0x31c8e066, /*  241 */
+    0x31da7ae1, /*  242 */
+    0x31ec08f6, /*  243 */
+    0x31fd8abc, /*  244 */
+    0x320f0047, /*  245 */
+    0x322069ac, /*  246 */
+    0x3231c702, /*  247 */
+    0x3243185c, /*  248 */
+    0x32545dcf, /*  249 */
+    0x32659770, /*  250 */
+    0x3276c552, /*  251 */
+    0x3287e78a, /*  252 */
+    0x3298fe2c, /*  253 */
+    0x32aa094a, /*  254 */
+    0x32bb08f9, /*  255 */
+    0x32cbfd4a, /*  256 */
+    0x32dce652, /*  257 */
+    0x32edc423, /*  258 */
+    0x32fe96d0, /*  259 */
+    0x330f5e6a, /*  260 */
+    0x33201b04, /*  261 */
+    0x3330ccb0, /*  262 */
+    0x33417380, /*  263 */
+    0x33520f85, /*  264 */
+    0x3362a0d0, /*  265 */
+    0x33732774, /*  266 */
+    0x3383a380, /*  267 */
+    0x33941506, /*  268 */
+    0x33a47c17, /*  269 */
+    0x33b4d8c4, /*  270 */
+    0x33c52b1b, /*  271 */
+    0x33d5732f, /*  272 */
+    0x33e5b10f, /*  273 */
+    0x33f5e4ca, /*  274 */
+    0x34060e71, /*  275 */
+    0x34162e14, /*  276 */
+    0x342643c1, /*  277 */
+    0x34364f88, /*  278 */
+    0x34465178, /*  279 */
+    0x345649a1, /*  280 */
+    0x34663810, /*  281 */
+    0x34761cd6, /*  282 */
+    0x3485f800, /*  283 */
+    0x3495c99d, /*  284 */
+    0x34a591bb, /*  285 */
+    0x34b55069, /*  286 */
+    0x34c505b4, /*  287 */
+    0x34d4b1ab, /*  288 */
+    0x34e4545b, /*  289 */
+    0x34f3edd2, /*  290 */
+    0x35037e1d, /*  291 */
+    0x3513054b, /*  292 */
+    0x35228367, /*  293 */
+    0x3531f881, /*  294 */
+    0x354164a3, /*  295 */
+    0x3550c7dc, /*  296 */
+    0x35602239, /*  297 */
+    0x356f73c5, /*  298 */
+    0x357ebc8e, /*  299 */
+    0x358dfca0, /*  300 */
+    0x359d3408, /*  301 */
+    0x35ac62d1, /*  302 */
+    0x35bb8908, /*  303 */
+    0x35caa6b9, /*  304 */
+    0x35d9bbf0, /*  305 */
+    0x35e8c8b9, /*  306 */
+    0x35f7cd20, /*  307 */
+    0x3606c92f, /*  308 */
+    0x3615bcf3, /*  309 */
+    0x3624a878, /*  310 */
+    0x36338bc8, /*  311 */
+    0x364266ee, /*  312 */
+    0x365139f6, /*  313 */
+    0x366004ec, /*  314 */
+    0x366ec7d9, /*  315 */
+    0x367d82c9, /*  316 */
+    0x368c35c6, /*  317 */
+    0x369ae0dc, /*  318 */
+    0x36a98414, /*  319 */
+    0x36b81f7a, /*  320 */
+    0x36c6b317, /*  321 */
+    0x36d53ef7, /*  322 */
+    0x36e3c323, /*  323 */
+    0x36f23fa5, /*  324 */
+    0x3700b488, /*  325 */
+    0x370f21d5, /*  326 */
+    0x371d8797, /*  327 */
+    0x372be5d7, /*  328 */
+    0x373a3ca0, /*  329 */
+    0x37488bf9, /*  330 */
+    0x3756d3ef, /*  331 */
+    0x37651489, /*  332 */
+    0x37734dd1, /*  333 */
+    0x37817fd1, /*  334 */
+    0x378faa92, /*  335 */
+    0x379dce1d, /*  336 */
+    0x37abea7c, /*  337 */
+    0x37b9ffb7, /*  338 */
+    0x37c80dd7, /*  339 */
+    0x37d614e6, /*  340 */
+    0x37e414ec, /*  341 */
+    0x37f20df1, /*  342 */
+    0x38000000, /*  343 */
+    0x380deb20, /*  344 */
+    0x381bcf5a, /*  345 */
+    0x3829acb6, /*  346 */
+    0x3837833d, /*  347 */
+    0x384552f8, /*  348 */
+    0x38531bee, /*  349 */
+    0x3860de28, /*  350 */
+    0x386e99af, /*  351 */
+    0x387c4e89, /*  352 */
+    0x3889fcc0, /*  353 */
+    0x3897a45b, /*  354 */
+    0x38a54563, /*  355 */
+    0x38b2dfdf, /*  356 */
+    0x38c073d7, /*  357 */
+    0x38ce0152, /*  358 */
+    0x38db885a, /*  359 */
+    0x38e908f4, /*  360 */
+    0x38f68329, /*  361 */
+    0x3903f701, /*  362 */
+    0x39116483, /*  363 */
+    0x391ecbb6, /*  364 */
+    0x392c2ca1, /*  365 */
+    0x3939874d, /*  366 */
+    0x3946dbc0, /*  367 */
+    0x39542a01, /*  368 */
+    0x39617218, /*  369 */
+    0x396eb40c, /*  370 */
+    0x397befe4, /*  371 */
+    0x398925a7, /*  372 */
+    0x3996555c, /*  373 */
+    0x39a37f09, /*  374 */
+    0x39b0a2b7, /*  375 */
+    0x39bdc06a, /*  376 */
+    0x39cad82b, /*  377 */
+    0x39d7ea01, /*  378 */
+    0x39e4f5f0, /*  379 */
+    0x39f1fc01, /*  380 */
+    0x39fefc3a, /*  381 */
+    0x3a0bf6a2, /*  382 */
+    0x3a18eb3e, /*  383 */
+    0x3a25da16, /*  384 */
+    0x3a32c32f, /*  385 */
+    0x3a3fa691, /*  386 */
+    0x3a4c8441, /*  387 */
+    0x3a595c46, /*  388 */
+    0x3a662ea6, /*  389 */
+    0x3a72fb67, /*  390 */
+    0x3a7fc28f, /*  391 */
+    0x3a8c8425, /*  392 */
+    0x3a99402e, /*  393 */
+    0x3aa5f6b1, /*  394 */
+    0x3ab2a7b3, /*  395 */
+    0x3abf533a, /*  396 */
+    0x3acbf94d, /*  397 */
+    0x3ad899f1, /*  398 */
+    0x3ae5352c, /*  399 */
+    0x3af1cb03, /*  400 */
+    0x3afe5b7d, /*  401 */
+    0x3b0ae6a0, /*  402 */
+    0x3b176c70, /*  403 */
+    0x3b23ecf3, /*  404 */
+    0x3b306830, /*  405 */
+    0x3b3cde2c, /*  406 */
+    0x3b494eeb, /*  407 */
+    0x3b55ba74, /*  408 */
+    0x3b6220cc, /*  409 */
+    0x3b6e81f9, /*  410 */
+    0x3b7ade00, /*  411 */
+    0x3b8734e5, /*  412 */
+    0x3b9386b0, /*  413 */
+    0x3b9fd364, /*  414 */
+    0x3bac1b07, /*  415 */
+    0x3bb85d9e, /*  416 */
+    0x3bc49b2f, /*  417 */
+    0x3bd0d3be, /*  418 */
+    0x3bdd0751, /*  419 */
+    0x3be935ed, /*  420 */
+    0x3bf55f97, /*  421 */
+    0x3c018453, /*  422 */
+    0x3c0da427, /*  423 */
+    0x3c19bf17, /*  424 */
+    0x3c25d52a, /*  425 */
+    0x3c31e662, /*  426 */
+    0x3c3df2c6, /*  427 */
+    0x3c49fa5b, /*  428 */
+    0x3c55fd24, /*  429 */
+    0x3c61fb27, /*  430 */
+    0x3c6df468, /*  431 */
+    0x3c79e8ed, /*  432 */
+    0x3c85d8b9, /*  433 */
+    0x3c91c3d2, /*  434 */
+    0x3c9daa3c, /*  435 */
+    0x3ca98bfc, /*  436 */
+    0x3cb56915, /*  437 */
+    0x3cc1418e, /*  438 */
+    0x3ccd156a, /*  439 */
+    0x3cd8e4ae, /*  440 */
+    0x3ce4af5e, /*  441 */
+    0x3cf0757f, /*  442 */
+    0x3cfc3714, /*  443 */
+    0x3d07f423, /*  444 */
+    0x3d13acb0, /*  445 */
+    0x3d1f60bf, /*  446 */
+    0x3d2b1055, /*  447 */
+    0x3d36bb75, /*  448 */
+    0x3d426224, /*  449 */
+    0x3d4e0466, /*  450 */
+    0x3d59a23f, /*  451 */
+    0x3d653bb4, /*  452 */
+    0x3d70d0c8, /*  453 */
+    0x3d7c6180, /*  454 */
+    0x3d87ede0, /*  455 */
+    0x3d9375ec, /*  456 */
+    0x3d9ef9a8, /*  457 */
+    0x3daa7918, /*  458 */
+    0x3db5f43f, /*  459 */
+    0x3dc16b23, /*  460 */
+    0x3dccddc7, /*  461 */
+    0x3dd84c2e, /*  462 */
+    0x3de3b65d, /*  463 */
+    0x3def1c58, /*  464 */
+    0x3dfa7e22, /*  465 */
+    0x3e05dbc0, /*  466 */
+    0x3e113535, /*  467 */
+    0x3e1c8a85, /*  468 */
+    0x3e27dbb3, /*  469 */
+    0x3e3328c4, /*  470 */
+    0x3e3e71bb, /*  471 */
+    0x3e49b69c, /*  472 */
+    0x3e54f76b, /*  473 */
+    0x3e60342b, /*  474 */
+    0x3e6b6ce0, /*  475 */
+    0x3e76a18d, /*  476 */
+    0x3e81d237, /*  477 */
+    0x3e8cfee0, /*  478 */
+    0x3e98278d, /*  479 */
+    0x3ea34c40, /*  480 */
+    0x3eae6cfe, /*  481 */
+    0x3eb989ca, /*  482 */
+    0x3ec4a2a8, /*  483 */
+    0x3ecfb79a, /*  484 */
+    0x3edac8a5, /*  485 */
+    0x3ee5d5cb, /*  486 */
+    0x3ef0df10, /*  487 */
+    0x3efbe478, /*  488 */
+    0x3f06e606, /*  489 */
+    0x3f11e3be, /*  490 */
+    0x3f1cdda2, /*  491 */
+    0x3f27d3b6, /*  492 */
+    0x3f32c5fd, /*  493 */
+    0x3f3db47b, /*  494 */
+    0x3f489f32, /*  495 */
+    0x3f538627, /*  496 */
+    0x3f5e695c, /*  497 */
+    0x3f6948d5, /*  498 */
+    0x3f742494, /*  499 */
+    0x3f7efc9d, /*  500 */
+    0x3f89d0f3, /*  501 */
+    0x3f94a19a, /*  502 */
+    0x3f9f6e94, /*  503 */
+    0x3faa37e4, /*  504 */
+    0x3fb4fd8e, /*  505 */
+    0x3fbfbf94, /*  506 */
+    0x3fca7dfb, /*  507 */
+    0x3fd538c4, /*  508 */
+    0x3fdfeff3, /*  509 */
+    0x3feaa38a, /*  510 */
+    0x3ff5538e, /*  511 */
+    0x40000000, /*  512 */
+    0x400aa8e4, /*  513 */
+    0x40154e3d, /*  514 */
+    0x401ff00d, /*  515 */
+    0x402a8e58, /*  516 */
+    0x40352921, /*  517 */
+    0x403fc06a, /*  518 */
+    0x404a5436, /*  519 */
+    0x4054e488, /*  520 */
+    0x405f7164, /*  521 */
+    0x4069facb, /*  522 */
+    0x407480c1, /*  523 */
+    0x407f0348, /*  524 */
+    0x40898264, /*  525 */
+    0x4093fe16, /*  526 */
+    0x409e7663, /*  527 */
+    0x40a8eb4c, /*  528 */
+    0x40b35cd4, /*  529 */
+    0x40bdcafe, /*  530 */
+    0x40c835cd, /*  531 */
+    0x40d29d43, /*  532 */
+    0x40dd0164, /*  533 */
+    0x40e76231, /*  534 */
+    0x40f1bfae, /*  535 */
+    0x40fc19dc, /*  536 */
+    0x410670c0, /*  537 */
+    0x4110c45a, /*  538 */
+    0x411b14af, /*  539 */
+    0x412561c0, /*  540 */
+    0x412fab90, /*  541 */
+    0x4139f222, /*  542 */
+    0x41443578, /*  543 */
+    0x414e7595, /*  544 */
+    0x4158b27a, /*  545 */
+    0x4162ec2c, /*  546 */
+    0x416d22ac, /*  547 */
+    0x417755fd, /*  548 */
+    0x41818621, /*  549 */
+    0x418bb31a, /*  550 */
+    0x4195dcec, /*  551 */
+    0x41a00399, /*  552 */
+    0x41aa2722, /*  553 */
+    0x41b4478b, /*  554 */
+    0x41be64d6, /*  555 */
+    0x41c87f05, /*  556 */
+    0x41d2961a, /*  557 */
+    0x41dcaa19, /*  558 */
+    0x41e6bb03, /*  559 */
+    0x41f0c8db, /*  560 */
+    0x41fad3a3, /*  561 */
+    0x4204db5d, /*  562 */
+    0x420ee00c, /*  563 */
+    0x4218e1b1, /*  564 */
+    0x4222e051, /*  565 */
+    0x422cdbeb, /*  566 */
+    0x4236d484, /*  567 */
+    0x4240ca1d, /*  568 */
+    0x424abcb8, /*  569 */
+    0x4254ac58, /*  570 */
+    0x425e98fe, /*  571 */
+    0x426882ae, /*  572 */
+    0x42726969, /*  573 */
+    0x427c4d31, /*  574 */
+    0x42862e09, /*  575 */
+    0x42900bf3, /*  576 */
+    0x4299e6f1, /*  577 */
+    0x42a3bf05, /*  578 */
+    0x42ad9432, /*  579 */
+    0x42b76678, /*  580 */
+    0x42c135dc, /*  581 */
+    0x42cb025e, /*  582 */
+    0x42d4cc01, /*  583 */
+    0x42de92c7, /*  584 */
+    0x42e856b2, /*  585 */
+    0x42f217c4, /*  586 */
+    0x42fbd5ff, /*  587 */
+    0x43059166, /*  588 */
+    0x430f49f9, /*  589 */
+    0x4318ffbc, /*  590 */
+    0x4322b2b1, /*  591 */
+    0x432c62d8, /*  592 */
+    0x43361036, /*  593 */
+    0x433fbaca, /*  594 */
+    0x43496298, /*  595 */
+    0x435307a2, /*  596 */
+    0x435ca9e8, /*  597 */
+    0x4366496e, /*  598 */
+    0x436fe636, /*  599 */
+    0x43798041, /*  600 */
+    0x43831790, /*  601 */
+    0x438cac28, /*  602 */
+    0x43963e08, /*  603 */
+    0x439fcd33, /*  604 */
+    0x43a959ab, /*  605 */
+    0x43b2e372, /*  606 */
+    0x43bc6a89, /*  607 */
+    0x43c5eef3, /*  608 */
+    0x43cf70b2, /*  609 */
+    0x43d8efc7, /*  610 */
+    0x43e26c34, /*  611 */
+    0x43ebe5fb, /*  612 */
+    0x43f55d1e, /*  613 */
+    0x43fed19f, /*  614 */
+    0x44084380, /*  615 */
+    0x4411b2c1, /*  616 */
+    0x441b1f66, /*  617 */
+    0x44248970, /*  618 */
+    0x442df0e1, /*  619 */
+    0x443755bb, /*  620 */
+    0x4440b7fe, /*  621 */
+    0x444a17ae, /*  622 */
+    0x445374cc, /*  623 */
+    0x445ccf5a, /*  624 */
+    0x44662758, /*  625 */
+    0x446f7ccb, /*  626 */
+    0x4478cfb2, /*  627 */
+    0x4482200f, /*  628 */
+    0x448b6de5, /*  629 */
+    0x4494b935, /*  630 */
+    0x449e0201, /*  631 */
+    0x44a7484b, /*  632 */
+    0x44b08c13, /*  633 */
+    0x44b9cd5d, /*  634 */
+    0x44c30c29, /*  635 */
+    0x44cc4879, /*  636 */
+    0x44d5824f, /*  637 */
+    0x44deb9ac, /*  638 */
+    0x44e7ee93, /*  639 */
+    0x44f12105, /*  640 */
+    0x44fa5103, /*  641 */
+    0x45037e8f, /*  642 */
+    0x450ca9ab, /*  643 */
+    0x4515d258, /*  644 */
+    0x451ef899, /*  645 */
+    0x45281c6e, /*  646 */
+    0x45313dd8, /*  647 */
+    0x453a5cdb, /*  648 */
+    0x45437977, /*  649 */
+    0x454c93ae, /*  650 */
+    0x4555ab82, /*  651 */
+    0x455ec0f3, /*  652 */
+    0x4567d404, /*  653 */
+    0x4570e4b7, /*  654 */
+    0x4579f30c, /*  655 */
+    0x4582ff05, /*  656 */
+    0x458c08a4, /*  657 */
+    0x45950fea, /*  658 */
+    0x459e14d9, /*  659 */
+    0x45a71773, /*  660 */
+    0x45b017b8, /*  661 */
+    0x45b915aa, /*  662 */
+    0x45c2114c, /*  663 */
+    0x45cb0a9e, /*  664 */
+    0x45d401a1, /*  665 */
+    0x45dcf658, /*  666 */
+    0x45e5e8c4, /*  667 */
+    0x45eed8e6, /*  668 */
+    0x45f7c6c0, /*  669 */
+    0x4600b253, /*  670 */
+    0x46099ba0, /*  671 */
+    0x461282a9, /*  672 */
+    0x461b6770, /*  673 */
+    0x462449f6, /*  674 */
+    0x462d2a3c, /*  675 */
+    0x46360844, /*  676 */
+    0x463ee40f, /*  677 */
+    0x4647bd9f, /*  678 */
+    0x465094f5, /*  679 */
+    0x46596a12, /*  680 */
+    0x46623cf8, /*  681 */
+    0x466b0da8, /*  682 */
+    0x4673dc24, /*  683 */
+    0x467ca86c, /*  684 */
+    0x46857283, /*  685 */
+    0x468e3a69, /*  686 */
+    0x46970021, /*  687 */
+    0x469fc3ab, /*  688 */
+    0x46a88509, /*  689 */
+    0x46b1443b, /*  690 */
+    0x46ba0144, /*  691 */
+    0x46c2bc25, /*  692 */
+    0x46cb74df, /*  693 */
+    0x46d42b74, /*  694 */
+    0x46dcdfe4, /*  695 */
+    0x46e59231, /*  696 */
+    0x46ee425c, /*  697 */
+    0x46f6f068, /*  698 */
+    0x46ff9c54, /*  699 */
+    0x47084622, /*  700 */
+    0x4710edd4, /*  701 */
+    0x4719936b, /*  702 */
+    0x472236e7, /*  703 */
+    0x472ad84b, /*  704 */
+    0x47337798, /*  705 */
+    0x473c14cf, /*  706 */
+    0x4744aff1, /*  707 */
+    0x474d48ff, /*  708 */
+    0x4755dffb, /*  709 */
+    0x475e74e6, /*  710 */
+    0x476707c1, /*  711 */
+    0x476f988e, /*  712 */
+    0x4778274d, /*  713 */
+    0x4780b400, /*  714 */
+    0x47893ea8, /*  715 */
+    0x4791c746, /*  716 */
+    0x479a4ddc, /*  717 */
+    0x47a2d26b, /*  718 */
+    0x47ab54f3, /*  719 */
+    0x47b3d577, /*  720 */
+    0x47bc53f7, /*  721 */
+    0x47c4d074, /*  722 */
+    0x47cd4af0, /*  723 */
+    0x47d5c36c, /*  724 */
+    0x47de39e9, /*  725 */
+    0x47e6ae69, /*  726 */
+    0x47ef20ec, /*  727 */
+    0x47f79173, /*  728 */
+    0x48000000, /*  729 */
+    0x48086c94, /*  730 */
+    0x4810d730, /*  731 */
+    0x48193fd5, /*  732 */
+    0x4821a685, /*  733 */
+    0x482a0b40, /*  734 */
+    0x48326e07, /*  735 */
+    0x483acedd, /*  736 */
+    0x48432dc1, /*  737 */
+    0x484b8ab5, /*  738 */
+    0x4853e5bb, /*  739 */
+    0x485c3ed2, /*  740 */
+    0x486495fd, /*  741 */
+    0x486ceb3c, /*  742 */
+    0x48753e91, /*  743 */
+    0x487d8ffd, /*  744 */
+    0x4885df80, /*  745 */
+    0x488e2d1d, /*  746 */
+    0x489678d3, /*  747 */
+    0x489ec2a4, /*  748 */
+    0x48a70a91, /*  749 */
+    0x48af509b, /*  750 */
+    0x48b794c4, /*  751 */
+    0x48bfd70c, /*  752 */
+    0x48c81774, /*  753 */
+    0x48d055fe, /*  754 */
+    0x48d892aa, /*  755 */
+    0x48e0cd7a, /*  756 */
+    0x48e9066e, /*  757 */
+    0x48f13d88, /*  758 */
+    0x48f972c9, /*  759 */
+    0x4901a632, /*  760 */
+    0x4909d7c3, /*  761 */
+    0x4912077e, /*  762 */
+    0x491a3564, /*  763 */
+    0x49226175, /*  764 */
+    0x492a8bb4, /*  765 */
+    0x4932b420, /*  766 */
+    0x493adabc, /*  767 */
+    0x4942ff87, /*  768 */
+    0x494b2283, /*  769 */
+    0x495343b1, /*  770 */
+    0x495b6312, /*  771 */
+    0x496380a7, /*  772 */
+    0x496b9c71, /*  773 */
+    0x4973b670, /*  774 */
+    0x497bcea7, /*  775 */
+    0x4983e515, /*  776 */
+    0x498bf9bc, /*  777 */
+    0x49940c9e, /*  778 */
+    0x499c1db9, /*  779 */
+    0x49a42d11, /*  780 */
+    0x49ac3aa5, /*  781 */
+    0x49b44677, /*  782 */
+    0x49bc5088, /*  783 */
+    0x49c458d8, /*  784 */
+    0x49cc5f69, /*  785 */
+    0x49d4643c, /*  786 */
+    0x49dc6750, /*  787 */
+    0x49e468a9, /*  788 */
+    0x49ec6845, /*  789 */
+    0x49f46627, /*  790 */
+    0x49fc624f, /*  791 */
+    0x4a045cbe, /*  792 */
+    0x4a0c5575, /*  793 */
+    0x4a144c76, /*  794 */
+    0x4a1c41c0, /*  795 */
+    0x4a243555, /*  796 */
+    0x4a2c2735, /*  797 */
+    0x4a341763, /*  798 */
+    0x4a3c05de, /*  799 */
+    0x4a43f2a7, /*  800 */
+    0x4a4bddc0, /*  801 */
+    0x4a53c729, /*  802 */
+    0x4a5baee3, /*  803 */
+    0x4a6394ef, /*  804 */
+    0x4a6b794f, /*  805 */
+    0x4a735c02, /*  806 */
+    0x4a7b3d09, /*  807 */
+    0x4a831c67, /*  808 */
+    0x4a8afa1b, /*  809 */
+    0x4a92d626, /*  810 */
+    0x4a9ab089, /*  811 */
+    0x4aa28946, /*  812 */
+    0x4aaa605d, /*  813 */
+    0x4ab235ce, /*  814 */
+    0x4aba099b, /*  815 */
+    0x4ac1dbc5, /*  816 */
+    0x4ac9ac4c, /*  817 */
+    0x4ad17b31, /*  818 */
+    0x4ad94876, /*  819 */
+    0x4ae1141a, /*  820 */
+    0x4ae8de1f, /*  821 */
+    0x4af0a686, /*  822 */
+    0x4af86d50, /*  823 */
+    0x4b00327d, /*  824 */
+    0x4b07f60d, /*  825 */
+    0x4b0fb803, /*  826 */
+    0x4b17785f, /*  827 */
+    0x4b1f3722, /*  828 */
+    0x4b26f44b, /*  829 */
+    0x4b2eafde, /*  830 */
+    0x4b3669d9, /*  831 */
+    0x4b3e223e, /*  832 */
+    0x4b45d90e, /*  833 */
+    0x4b4d8e4a, /*  834 */
+    0x4b5541f2, /*  835 */
+    0x4b5cf407, /*  836 */
+    0x4b64a48a, /*  837 */
+    0x4b6c537c, /*  838 */
+    0x4b7400dd, /*  839 */
+    0x4b7bacaf, /*  840 */
+    0x4b8356f2, /*  841 */
+    0x4b8affa7, /*  842 */
+    0x4b92a6ce, /*  843 */
+    0x4b9a4c69, /*  844 */
+    0x4ba1f079, /*  845 */
+    0x4ba992fd, /*  846 */
+    0x4bb133f8, /*  847 */
+    0x4bb8d369, /*  848 */
+    0x4bc07151, /*  849 */
+    0x4bc80db2, /*  850 */
+    0x4bcfa88c, /*  851 */
+    0x4bd741df, /*  852 */
+    0x4bded9ad, /*  853 */
+    0x4be66ff6, /*  854 */
+    0x4bee04bb, /*  855 */
+    0x4bf597fc, /*  856 */
+    0x4bfd29bc, /*  857 */
+    0x4c04b9f9, /*  858 */
+    0x4c0c48b6, /*  859 */
+    0x4c13d5f2, /*  860 */
+    0x4c1b61af, /*  861 */
+    0x4c22ebed, /*  862 */
+    0x4c2a74ad, /*  863 */
+    0x4c31fbf0, /*  864 */
+    0x4c3981b6, /*  865 */
+    0x4c410600, /*  866 */
+    0x4c4888d0, /*  867 */
+    0x4c500a25, /*  868 */
+    0x4c578a00, /*  869 */
+    0x4c5f0862, /*  870 */
+    0x4c66854c, /*  871 */
+    0x4c6e00bf, /*  872 */
+    0x4c757abb, /*  873 */
+    0x4c7cf341, /*  874 */
+    0x4c846a52, /*  875 */
+    0x4c8bdfee, /*  876 */
+    0x4c935416, /*  877 */
+    0x4c9ac6cb, /*  878 */
+    0x4ca2380e, /*  879 */
+    0x4ca9a7de, /*  880 */
+    0x4cb1163e, /*  881 */
+    0x4cb8832d, /*  882 */
+    0x4cbfeead, /*  883 */
+    0x4cc758bd, /*  884 */
+    0x4ccec15f, /*  885 */
+    0x4cd62894, /*  886 */
+    0x4cdd8e5c, /*  887 */
+    0x4ce4f2b7, /*  888 */
+    0x4cec55a7, /*  889 */
+    0x4cf3b72c, /*  890 */
+    0x4cfb1747, /*  891 */
+    0x4d0275f8, /*  892 */
+    0x4d09d340, /*  893 */
+    0x4d112f21, /*  894 */
+    0x4d188999, /*  895 */
+    0x4d1fe2ab, /*  896 */
+    0x4d273a57, /*  897 */
+    0x4d2e909d, /*  898 */
+    0x4d35e57f, /*  899 */
+    0x4d3d38fc, /*  900 */
+    0x4d448b16, /*  901 */
+    0x4d4bdbcd, /*  902 */
+    0x4d532b21, /*  903 */
+    0x4d5a7914, /*  904 */
+    0x4d61c5a7, /*  905 */
+    0x4d6910d9, /*  906 */
+    0x4d705aab, /*  907 */
+    0x4d77a31e, /*  908 */
+    0x4d7eea34, /*  909 */
+    0x4d862feb, /*  910 */
+    0x4d8d7445, /*  911 */
+    0x4d94b743, /*  912 */
+    0x4d9bf8e6, /*  913 */
+    0x4da3392d, /*  914 */
+    0x4daa7819, /*  915 */
+    0x4db1b5ac, /*  916 */
+    0x4db8f1e6, /*  917 */
+    0x4dc02cc7, /*  918 */
+    0x4dc76650, /*  919 */
+    0x4dce9e81, /*  920 */
+    0x4dd5d55c, /*  921 */
+    0x4ddd0ae1, /*  922 */
+    0x4de43f10, /*  923 */
+    0x4deb71eb, /*  924 */
+    0x4df2a371, /*  925 */
+    0x4df9d3a3, /*  926 */
+    0x4e010283, /*  927 */
+    0x4e083010, /*  928 */
+    0x4e0f5c4b, /*  929 */
+    0x4e168735, /*  930 */
+    0x4e1db0cf, /*  931 */
+    0x4e24d918, /*  932 */
+    0x4e2c0012, /*  933 */
+    0x4e3325bd, /*  934 */
+    0x4e3a4a1a, /*  935 */
+    0x4e416d2a, /*  936 */
+    0x4e488eec, /*  937 */
+    0x4e4faf62, /*  938 */
+    0x4e56ce8c, /*  939 */
+    0x4e5dec6b, /*  940 */
+    0x4e6508ff, /*  941 */
+    0x4e6c2449, /*  942 */
+    0x4e733e4a, /*  943 */
+    0x4e7a5702, /*  944 */
+    0x4e816e71, /*  945 */
+    0x4e888498, /*  946 */
+    0x4e8f9979, /*  947 */
+    0x4e96ad13, /*  948 */
+    0x4e9dbf67, /*  949 */
+    0x4ea4d075, /*  950 */
+    0x4eabe03e, /*  951 */
+    0x4eb2eec4, /*  952 */
+    0x4eb9fc05, /*  953 */
+    0x4ec10803, /*  954 */
+    0x4ec812bf, /*  955 */
+    0x4ecf1c39, /*  956 */
+    0x4ed62471, /*  957 */
+    0x4edd2b68, /*  958 */
+    0x4ee4311f, /*  959 */
+    0x4eeb3596, /*  960 */
+    0x4ef238cd, /*  961 */
+    0x4ef93ac6, /*  962 */
+    0x4f003b81, /*  963 */
+    0x4f073afe, /*  964 */
+    0x4f0e393f, /*  965 */
+    0x4f153642, /*  966 */
+    0x4f1c320a, /*  967 */
+    0x4f232c96, /*  968 */
+    0x4f2a25e8, /*  969 */
+    0x4f311dff, /*  970 */
+    0x4f3814dc, /*  971 */
+    0x4f3f0a80, /*  972 */
+    0x4f45feeb, /*  973 */
+    0x4f4cf21f, /*  974 */
+    0x4f53e41a, /*  975 */
+    0x4f5ad4de, /*  976 */
+    0x4f61c46c, /*  977 */
+    0x4f68b2c4, /*  978 */
+    0x4f6f9fe6, /*  979 */
+    0x4f768bd3, /*  980 */
+    0x4f7d768c, /*  981 */
+    0x4f846011, /*  982 */
+    0x4f8b4862, /*  983 */
+    0x4f922f81, /*  984 */
+    0x4f99156d, /*  985 */
+    0x4f9ffa27, /*  986 */
+    0x4fa6ddb0, /*  987 */
+    0x4fadc008, /*  988 */
+    0x4fb4a12f, /*  989 */
+    0x4fbb8127, /*  990 */
+    0x4fc25ff0, /*  991 */
+    0x4fc93d8a, /*  992 */
+    0x4fd019f5, /*  993 */
+    0x4fd6f533, /*  994 */
+    0x4fddcf43, /*  995 */
+    0x4fe4a827, /*  996 */
+    0x4feb7fde, /*  997 */
+    0x4ff2566a, /*  998 */
+    0x4ff92bca, /*  999 */
+    0x50000000, /* 1000 */
+    0x5006d30b, /* 1001 */
+    0x500da4ed, /* 1002 */
+    0x501475a5, /* 1003 */
+    0x501b4535, /* 1004 */
+    0x5022139c, /* 1005 */
+    0x5028e0dc, /* 1006 */
+    0x502facf4, /* 1007 */
+    0x503677e5, /* 1008 */
+    0x503d41b0, /* 1009 */
+    0x50440a55, /* 1010 */
+    0x504ad1d5, /* 1011 */
+    0x50519830, /* 1012 */
+    0x50585d67, /* 1013 */
+    0x505f217a, /* 1014 */
+    0x5065e469, /* 1015 */
+    0x506ca635, /* 1016 */
+    0x507366df, /* 1017 */
+    0x507a2667, /* 1018 */
+    0x5080e4cd, /* 1019 */
+    0x5087a212, /* 1020 */
+    0x508e5e37, /* 1021 */
+    0x5095193c, /* 1022 */
+    0x509bd320, /* 1023 */
+    0x50a28be6, /* 1024 */
+};
+
+/*----------------------------------------------------------------------------
+; EXTERNAL FUNCTION REFERENCES
+; Declare functions defined elsewhere and referenced in this module
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL GLOBAL STORE/BUFFER/POINTER REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
diff --git a/media/libstagefright/codecs/aacdec/iquant_table.h b/media/libstagefright/codecs/aacdec/iquant_table.h
new file mode 100644
index 0000000..dadc3d0
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/iquant_table.h
@@ -0,0 +1,85 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Pathname: iquant_table.h
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+ Who:                       Date:
+ Description:
+
+------------------------------------------------------------------------------
+ INCLUDE DESCRIPTION
+
+ Header file for iquant_table.c, which contains a table used with
+ esc_iquant.c
+
+------------------------------------------------------------------------------
+*/
+
+/*----------------------------------------------------------------------------
+; CONTINUE ONLY IF NOT ALREADY DEFINED
+----------------------------------------------------------------------------*/
+#ifndef IQUANT_TABLE_H
+#define IQUANT_TABLE_H
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+#include "pv_audio_type_defs.h"
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here.
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL VARIABLES REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+extern const UInt32 inverseQuantTable[];
+/*----------------------------------------------------------------------------
+; SIMPLE TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; ENUMERATED TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; STRUCTURES TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; GLOBAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; END
+----------------------------------------------------------------------------*/
+#endif
+
+
diff --git a/media/libstagefright/codecs/aacdec/long_term_prediction.cpp b/media/libstagefright/codecs/aacdec/long_term_prediction.cpp
new file mode 100644
index 0000000..69e4c46
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/long_term_prediction.cpp
@@ -0,0 +1,648 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Pathname: long_term_prediction.c
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+ Description: Made changes based on comments and experiment results.
+
+ Description: Passed in buffer sizes based on review comments and prototype
+              agreements.
+
+ Description: 1. Passed in "weight_index" instead of "weight".
+              2. Added weight table.
+
+ Description: 1. Removed some passed in buffer size variables since they are
+                 not used for long window.
+              2. Modified comments format.
+
+ Description:
+    Modified casting to ensure proper operations for different platforms
+
+ Description:
+    Implemented circular buffer techniques, which save 4096 memmoves per
+    frame.
+
+ Description:
+    Implemented some optimizations found during the code review of this
+    module.  The optimizations related to the rules on the range of
+    ltp_buffer_index and num_samples, which allows for a simpler
+    code construct to be used in the processing of the predicted samples.
+
+ Description:
+    Add max calculation on the filter implementation, this to eliminate
+    function buffer_adaptation() on the time to frequency transformation.
+    Function interface changed. It now return the amount of shifting needed
+    to garb only the top 16 MSB.
+
+ Description:
+     Replace clearing memory with for-loop with pvmemset function
+
+ Description:
+
+------------------------------------------------------------------------------
+ INPUT AND OUTPUT DEFINITIONS
+
+ Inputs:
+    win_seq = type of window sequence (WINDOW_SEQUENCE).
+
+    weight_index = index (Int) of LTP coefficient table for all windows in
+                   current frame.
+
+    delay = buffer (Int) containing delays for each window.
+
+    buffer = history buffer (Int16) containing the reconstructed time domain
+             signals of previous frames.
+
+    buffer_offset = value (Int) that indicates the location of the first
+                    element in the LTP circular buffer.  (Either 0 or 1024)
+
+    time_quant    = filterbank buffer (Int32) This buffer is used by the
+                    filterbank, but it's first 1024 elements are equivalent
+                    to the last 1024 elements in the conventionally
+                    implemented LTP buffer.  Using this buffer directly avoids
+                    costly duplication of memory.
+
+    predicted_samples = buffer (Int32) with length of 2048 to hold
+                        predicted time domain signals.
+
+    buffer_index = index into buffer where the first sample of data from
+                   the frame (t-2) (two frames ago) resides.  (Int)
+
+    frame_length = length of one frame, type of Int.
+
+ Local Stores/Buffers/Pointers Needed:
+    None
+
+ Global Stores/Buffers/Pointers Needed:
+    None
+
+ Outputs:
+    Amount of shifting needed to grab the top 16 MSB from teh predicted buffer
+
+ Pointers and Buffers Modified:
+    predicted_samples contents are the newly calculated predicted time
+    domain signals
+
+ Local Stores Modified:
+    None
+
+ Global Stores Modified:
+    None
+
+------------------------------------------------------------------------------
+ FUNCTION DESCRIPTION
+
+ Long term prediction (LTP) is used to reduce the redundancy of a signal
+ between successive coding frames. This function performs prediction by
+ applying 1-tap IIR filtering to calculate the predicted time domain
+ signals of current frame from previous reconstructed frames stored in
+ time domain history buffer.
+
+ The equation used for IIR filter is as following.
+
+            y(n) = weight * x(n - delay)
+
+    where   y(n) ----- predicted time domain signals
+            x(n) ----- reconstructed time domain signals
+            weight ----- LTP coefficient
+            delay ----- optimal delay from 0 to 2047
+
+------------------------------------------------------------------------------
+ REQUIREMENTS
+
+ None
+
+------------------------------------------------------------------------------
+ REFERENCES
+
+ (1) ISO/IEC 14496-3:1999(E)
+     Part 3: Audio
+        Subpart 4.6.6   Long Term Prediction (LTP)
+
+ (2) MPEG-2 NBC Audio Decoder
+     "This software module was originally developed by Nokia in the course
+     of development of the MPEG-2 AAC/MPEG-4 Audio standard ISO/IEC13818-7,
+     14496-1, 2 and 3. This software module is an implementation of a part
+     of one or more MPEG-2 AAC/MPEG-4 Audio tools as specified by the MPEG-2
+     aac/MPEG-4 Audio standard. ISO/IEC  gives users of the MPEG-2aac/MPEG-4
+     Audio standards free license to this software module or modifications
+     thereof for use in hardware or software products claiming conformance
+     to the MPEG-2 aac/MPEG-4 Audio  standards. Those intending to use this
+     software module in hardware or software products are advised that this
+     use may infringe existing patents. The original developer of this
+     software module, the subsequent editors and their companies, and ISO/IEC
+     have no liability for use of this software module or modifications
+     thereof in an implementation. Copyright is not released for non MPEG-2
+     aac/MPEG-4 Audio conforming products. The original developer retains
+     full right to use the code for the developer's own purpose, assign or
+     donate the code to a third party and to inhibit third party from using
+     the code for non MPEG-2 aac/MPEG-4 Audio conforming products. This
+     copyright notice must be included in all copies or derivative works.
+     Copyright (c)1997.
+
+------------------------------------------------------------------------------
+ PSEUDO-CODE
+
+    pPredicted_samples = &predicted_samples[0];
+
+    weight = codebook[weight_index];
+
+    IF (win_seq != EIGHT_SHORT_SEQUENCE)
+    THEN
+
+        block_length = frame_length << 1;
+
+        lag = delay[0];
+
+        j = block_length - lag;
+
+        IF (lag < frame_length)
+        THEN
+
+            num_samples = frame_length + lag;
+
+        ELSE
+
+            num_samples = block_length;
+
+        ENDIF
+
+        pBuffer = &buffer[j];
+
+        FOR (i = num_samples; i>0; i--)
+
+            *pPredicted_samples = weight * (*pBuffer);
+            pPredicted_samples = pPredicted_samples + 1;
+            pBuffer = pBuffer + 1;
+
+        ENDFOR
+
+        FOR (i = block_length - num_samples; i>0; i--)
+
+            *pPredicted_samples = 0;
+            pPredicted_samples = pPredicted_samples + 1;
+
+        ENDFOR
+
+    ELSE
+
+        FOR (wnd = 0; wnd < short_window_num; wnd++)
+
+            IF (win_prediction_used[wnd] != FALSE)
+            THEN
+
+                delay[wnd] = delay[0] + ltp_short_lag[wnd];
+
+                lag = delay[wnd];
+
+                j = wnd*short_block_length - lag;
+
+                IF (lag < short_frame_length)
+                THEN
+
+                    num_samples = short_frame_length + lag;
+
+                ELSE
+
+                    num_samples = short_block_length;
+
+                ENDIF
+
+                pBuffer = &buffer[j];
+
+                FOR (i = num_samples; i>0; i--)
+
+                    *pPredicted_samples = weight * (*pBuffer);
+                    pPredicted_samples = pPredicted_samples + 1;
+                    pBuffer = pBuffer + 1;
+
+                ENDFOR
+
+                FOR (i = short_block_length - num_samples; i>0; i--)
+
+                    *pPredicted_samples = 0;
+                    pPredicted_samples = pPredicted_samples + 1;
+
+                ENDFOR
+
+            ELSE
+
+                CALL pv_memset(
+                        pPredicted_samples,
+                        0,
+                        sizeof(*pPredicted_samples)*short_block_length);
+                MODIFYING (predicted_samples[]);
+
+                pPredicted_samples = pPredicted_samples + short_block_length;
+
+            ENDIF [ IF (win_prediction_used[wnd] != FALSE) ]
+
+        ENDFOR [ FOR (wnd=0; wnd<short_window_num; wnd++) ]
+
+    ENDIF [ IF (win_seq != EIGHT_SHORT_SEQUENCE) ]
+
+    RETURN
+
+------------------------------------------------------------------------------
+ RESOURCES USED
+   When the code is written for a specific target processor the
+     the resources used should be documented below.
+
+ STACK USAGE: [stack count for this module] + [variable to represent
+          stack usage for each subroutine called]
+
+     where: [stack usage variable] = stack usage for [subroutine
+         name] (see [filename].ext)
+
+ DATA MEMORY USED: x words
+
+ PROGRAM MEMORY USED: x words
+
+ CLOCK CYCLES: [cycle count equation for this module] + [variable
+           used to represent cycle count for each subroutine
+           called]
+
+     where: [cycle count variable] = cycle count for [subroutine
+        name] (see [filename].ext)
+
+------------------------------------------------------------------------------
+*/
+
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+#include "pv_audio_type_defs.h"
+#include "e_window_sequence.h"
+#include "ltp_common_internal.h"
+#include "long_term_prediction.h"
+#include "aac_mem_funcs.h"
+#include "pv_normalize.h"
+#include "window_block_fxp.h"
+
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here. Include conditional
+; compile variables also.
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; LOCAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; LOCAL STORE/BUFFER/POINTER DEFINITIONS
+; Variable declaration - defined here and used outside this module
+----------------------------------------------------------------------------*/
+/* Purpose: Codebook for LTP weight coefficients. Stored in Q15 format */
+const UInt codebook[CODESIZE] =
+{
+    18705,  /* 0 */
+    22827,  /* 1 */
+    26641,  /* 2 */
+    29862,  /* 3 */
+    32273,  /* 4 */
+    34993,  /* 5 */
+    39145,  /* 6 */
+    44877   /* 7 */
+};
+
+/*----------------------------------------------------------------------------
+; EXTERNAL FUNCTION REFERENCES
+; Declare functions defined elsewhere and referenced in this module
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL GLOBAL STORE/BUFFER/POINTER REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; FUNCTION CODE
+----------------------------------------------------------------------------*/
+Int long_term_prediction(
+    WINDOW_SEQUENCE     win_seq,
+    const Int           weight_index,
+    const Int           delay[],
+    const Int16         buffer[],
+    const Int           buffer_offset,
+    const Int32         time_quant[],
+    Int32         predicted_samples[],    /* Q15 */
+    const Int           frame_length)
+{
+    /*----------------------------------------------------------------------------
+    ; Define all local variables
+    ----------------------------------------------------------------------------*/
+    /*
+     * Window index
+     *
+     * Int wnd;
+     *
+     * will be enabled when short window information is available.
+     */
+
+    /* Pointer to time domain history buffer */
+
+    const Int16 *pBuffer;
+
+    const Int32 *pTimeQuant = time_quant;
+
+    /* Pointer to array containing predicted samples */
+    Int32 *pPredicted_samples;
+
+    Int32   test;
+    Int32   datum;
+
+    /* IIR coefficient with Q15 format */
+    UInt    weight;
+
+    /* Length of one block (two frames) */
+    Int     block_length;
+
+    Int     shift;
+    Int     k;
+    Int     ltp_buffer_index;
+    Int     jump_point;
+    Int     lag;
+    Int     num_samples;
+
+    Int32   max = 0;
+
+    /*----------------------------------------------------------------------------
+    ; Function body here
+    ----------------------------------------------------------------------------*/
+    /* Initialize pointers */
+    pPredicted_samples = &predicted_samples[0];
+
+    weight = codebook[weight_index];
+
+    /****************************************/
+    /* LTP decoding process for long window */
+    /****************************************/
+
+    if (win_seq != EIGHT_SHORT_SEQUENCE)
+    {
+        /****************************************************/
+        /* Prediction based on previous time domain signals */
+        /****************************************************/
+        block_length = frame_length << 1;
+
+        /* Calculate time lag for 1-tap IIR filter */
+        lag = delay[0];
+
+        ltp_buffer_index = block_length - lag;
+
+        /* Calculate number of samples used in IIR filter */
+        if (lag < frame_length)
+        {
+            num_samples = frame_length + lag;
+        }
+        else
+        {
+            num_samples = block_length;
+        }
+
+
+        /*
+         * Calculate the predicted time domain signals from the
+         * reconstructed time domain signals of previous frames.
+         */
+
+        /* The data is stored in TWO buffers, either as...
+         *
+         *                                       [   t ==  0  ]
+         *
+         * [   t == -1   ][   t == -2   ]
+         *
+         * OR...
+         *                                       [   t ==  0  ]
+         *
+         * [   t == -2   ][   t == -1   ]
+         *
+         *
+         *
+         * In the first case, all of the buffers are non-contiguous,
+         * and each must be handled separately.  Code for this first case
+         * will function correctly for both cases.
+         *
+         * In the second case, the buffers storing t == -2, and t == -1
+         * data are contiguous, and an optimization could take advantage
+         * of this, at the cost of an increase in code size for this function.
+         */
+
+        /* Decrement block_length by num_samples.  This is important
+         * for the loop at the end of the "ACCESS DATA IN THE LTP BUFFERS"
+         * section that sets all remaining samples in the block to zero.
+         */
+
+        block_length -= num_samples;
+
+
+
+
+
+
+        /*
+         ************************************ ACCESS DATA IN THE LTP BUFFERS
+         */
+
+        /*
+         * This section of the code handles the t == -2
+         * buffer, which corresponds to 0 <= ltp_buffer_index < 1024
+         *
+         * BUFFER t == -2
+         *
+         * [0][][][][][][][][][][][...][][][][][][][][][][][][1023]
+         *
+         */
+
+        jump_point = (frame_length - ltp_buffer_index);
+
+        if (jump_point > 0)
+        {
+            pBuffer = &(buffer[ltp_buffer_index + buffer_offset]);
+
+            for (k = jump_point; k > 0; k--)
+            {
+                /* Q15 = Q15 * Q0 */
+                test = (Int32) weight * (*(pBuffer++));
+                *(pPredicted_samples++) =  test;
+                max                   |= (test >> 31) ^ test;
+            }
+
+            num_samples -= jump_point;
+
+            ltp_buffer_index += jump_point;
+        }
+
+        /*
+         * This section of the code handles the t == -1
+         * buffer, which corresponds to 1024 <= ltp_buffer_index < 2048
+         *
+         * BUFFER t == -1
+         *
+         * [1024][][][][][][][][][][][...][][][][][][][][][][][][2047]
+         *
+         */
+
+        jump_point = 2 * frame_length - ltp_buffer_index;
+
+        pBuffer = &(buffer[ltp_buffer_index - buffer_offset]);
+
+        if (num_samples < jump_point)
+        {
+            jump_point = num_samples;
+        }
+
+        for (k = jump_point; k > 0; k--)
+        {
+            /* Q15 = Q15 * Q0 */
+            test = (Int32) weight * (*(pBuffer++));
+            *(pPredicted_samples++) =  test;
+            max                   |= (test >> 31) ^ test;
+        }
+
+        num_samples -= jump_point;
+
+        ltp_buffer_index += jump_point;
+
+        /*
+         * This section of the code handles the t == 0
+         * buffer, which corresponds to 2048 <= ltp_buffer_index < 3072
+         *
+         * BUFFER t == 0
+         *
+         * [2048][][][][][][][][][][][...][][][][][][][][][][][][3071]
+         *
+         */
+        for (k = num_samples; k > 0; k--)
+        {
+
+            datum = *(pTimeQuant++) >> SCALING;
+
+            /*
+             * Limit the values in the 32-bit filterbank's buffer to
+             * 16-bit resolution.
+             *
+             * Value's greater than 32767 or less than -32768 are saturated
+             * to 32767 and -32768, respectively.
+             */
+
+            test                    = (Int32)datum * weight;
+            *(pPredicted_samples++) =  test;
+            max                    |= (test >> 31) ^ test;
+
+        }
+
+        /* Set any remaining samples in the block to 0. */
+
+        pv_memset(
+            pPredicted_samples,
+            0,
+            block_length*sizeof(*pPredicted_samples));
+
+    } /* if (win_seq != EIGHT_SHORT_SEQUENCE) */
+
+
+    /*****************************************/
+    /* LTP decoding process for short window */
+    /*****************************************/
+
+    /*
+     * For short window LTP, since there is no "ltp_short_lag"
+     * information being passed, the following code for short
+     * window LTP will be applied in the future when those
+     * information are available.
+     */
+
+    /*
+     *----------------------------------------------------------------------------
+     *  else
+     *  {
+     *      for (wnd = 0; wnd < short_window_num; wnd++)
+     *      {
+     *          if (win_prediction_used[wnd] != FALSE)
+     *          {
+     *              delay[wnd] = delay[0] + ltp_short_lag[wnd];
+     *
+     *              lag = delay[wnd];
+     *
+     *              j = wnd*short_block_length - lag;
+     *
+     *              if (lag < short_frame_length)
+     *              {
+     *                  num_samples = short_frame_length + lag;
+     *              }
+     *              else
+     *              {
+     *                  num_samples = short_block_length;
+     *              }
+     *
+     *              pBuffer = &buffer[j];
+     *
+     *              for(i = num_samples; i>0; i--)
+     *              {
+     *                  *(pPredicted_samples++) = weight * (*(pBuffer++));
+     *              }
+     *
+     *              for(i = short_block_length - num_samples; i>0; i--)
+     *              {
+     *                  *(pPredicted_samples++) = 0;
+     *              }
+     *          }
+     *          else
+     *          {
+     *              pv_memset(
+     *                  pPredicted_samples,
+     *                  0,
+     *                  sizeof(*pPredicted_samples)*short_block_length);
+     *
+     *              pPredicted_samples += short_block_length;
+     *          }
+     *      }
+     *  }
+     *----------------------------------------------------------------------------
+     */
+
+    shift = 16 - pv_normalize(max);
+
+    if (shift < 0)
+    {
+        shift = 0;
+    }
+
+    /*----------------------------------------------------------------------------
+    ; Return nothing or data or data pointer
+    ----------------------------------------------------------------------------*/
+    return (shift);
+} /* long_term_prediction */
+
+
+
+
diff --git a/media/libstagefright/codecs/aacdec/long_term_prediction.h b/media/libstagefright/codecs/aacdec/long_term_prediction.h
new file mode 100644
index 0000000..014934b
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/long_term_prediction.h
@@ -0,0 +1,122 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Pathname: long_term_prediction.h
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+ Description: Modified prototype with array size passed in per review
+              comments.
+
+ Description: Changed prototype with "weight_index" instead of "weight".
+
+ Description: Removed some passed in buffer size variables since they are
+              not being used for long window.
+
+ Description: Temporarily define LTP_Q_FORMAT for current release.
+              Need to change function prototype and pass out Q_format
+              information later.
+
+ Description: Updated function prototype to reflect the usage of a
+ circular buffer by LTP.
+
+ Description:  Updated function interface with new return type
+
+ Who:                                   Date:
+ Description:
+
+------------------------------------------------------------------------------
+ INCLUDE DESCRIPTION
+
+ This file includes function prototype declaration for long_term_prediction().
+
+------------------------------------------------------------------------------
+*/
+
+/*----------------------------------------------------------------------------
+; CONTINUE ONLY IF NOT ALREADY DEFINED
+----------------------------------------------------------------------------*/
+#ifndef LONG_TERM_PREDICTION_H
+#define LONG_TERM_PREDICTION_H
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+#include "pv_audio_type_defs.h"
+#include "e_window_sequence.h"
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here.
+----------------------------------------------------------------------------*/
+#define LTP_Q_FORMAT    (15)
+
+/*----------------------------------------------------------------------------
+; EXTERNAL VARIABLES REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; SIMPLE TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; ENUMERATED TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; STRUCTURES TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; GLOBAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+
+    Int long_term_prediction(
+        WINDOW_SEQUENCE     win_seq,
+        const Int           weight_index,
+        const Int           delay[],
+        const Int16         buffer[],
+        const Int           buffer_offset,
+        const Int32         time_quant[],
+        Int32               predicted_samples[],    /* Q15 */
+        const Int           frame_length);
+
+#ifdef __cplusplus
+}
+#endif
+
+/*----------------------------------------------------------------------------
+; END
+----------------------------------------------------------------------------*/
+#endif
+
+
diff --git a/media/libstagefright/codecs/aacdec/long_term_synthesis.cpp b/media/libstagefright/codecs/aacdec/long_term_synthesis.cpp
new file mode 100644
index 0000000..c361db1
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/long_term_synthesis.cpp
@@ -0,0 +1,1158 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Pathname: long_term_synthesis.c
+
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+ Description: Made the following changes based on the review comments.
+              1. Separated "shift_factor>=0" on line 395 to "shift_factor>0"
+                 and "shift_factor=0" two cases.
+              2. Added comments on line 393 to explain why factor 2 is being
+                 used to calculate shift_factor.
+              3. Added comments for short window implementation.
+              4. Changed "*(pPredicted_spectral++) = *pPredicted_spectral>>2"
+                 to "*(pPredicted++)>>=2" although they are the same.
+              5. Changed pseudo code "X+=Y" to "X=X+Y".
+              6. Fixed ending comment of "for" loop.
+              7. Passed in the size of the array and deleted some of the
+                 include files.
+
+ Description: Unroll the loops.
+
+ Description: Changed index "wnd" in previous line 584 with "wnd_offset"
+              and made other correspondent changes to the code.
+
+
+ Description: Based on Ken's suggestion, modified the function with the
+              passing-in Q format as scalefactor band basis in order to
+              simplify TNS block functions.
+
+ Description: Optimization.
+
+ Description: Made changes based on review comments.
+              1. Changed misspellings.
+              2. Changed win_sfb_top[] from two dimensional array to one
+              dimensional array and correspondently changed the code.
+              3. Changed function prototype to remove some redundant
+              informations.
+              4. Fixed the adjusting Q format part code.
+              5. Fixed lines 825, 826 with correct updating pointers.
+
+ Description: Due to TNS and LTP Q format issue, added code to adjust
+              predicted_spectral() to maximum resolution before perform
+              long term synthesis.
+
+ Description: Modified based on review comments.
+
+ Description: Changed "max" data type from UInt to UInt32.
+
+ Description: Changed so that nothing is done for the case of "all zero"
+ data coming from the output of Trans4m_time_2_freq. Also, included more
+ efficient calculation of the abs(x).  And, I updated the pseudocode.
+
+ Description: Use an auxiliary variable temp, to avoid using the same
+    pointer and a post-increment pointer in the same line. This may not
+    work with all compilers.
+
+ Who:                                   Date:
+ Description:
+
+------------------------------------------------------------------------------
+ INPUT AND OUTPUT DEFINITIONS
+
+ Inputs:
+    win_seq = type of window sequence (WINDOW_SEQUENCE).
+    sfb_per_win = number of scalefactor bands for each window, 1024 for
+                  long window, 128 for short window, type of Int.
+    win_sfb_top = buffer (Int16) containing the top coefficient per
+                  scalefactor band for each window.
+    win_prediction_used = buffer (Int) containing the prediction flag
+                          information for short windows. Each item in the
+                          buffer toggles prediction on(1)/off(0) for each
+                          window separately.
+    sfb_prediction_used = buffer (Int) containing the prediction flag
+                          information for scalefactor band(sfb). Each item
+                          toggle prediction on(1)/off(0) on each scalefactor
+                          band of every window.
+    current_frame = channel buffer (Int32) containing the dequantized
+                    spectral coefficients or errors of current frame.
+    q_format = buffer (Int) containing Q format for each scalefactor band of
+               input current_frame.
+    predicted_spectral = buffer (Int32) containing predicted spectral
+                         components of current frame.
+    pred_q_format = Q format (Int) for predicted spectral components of
+                    current frame.
+    coef_per_win = number of coefficients per window for short windows.
+                   type of Int.
+    short_window_num = number of short windows, type of Int.
+    reconstruct_sfb_num = number of scalefactor bands used for reconstruction
+                          for short windows, type of Int.
+
+ Local Stores/Buffers/Pointers Needed:
+    None
+
+ Global Stores/Buffers/Pointers Needed:
+    None
+
+ Outputs:
+    None
+
+ Pointers and Buffers Modified:
+    current_frame contents are the dequantized spectrum with a prediction
+    vector added when prediction is turned on.
+
+    q_format contents are updated with the new Q format (Int) for each
+    scalefactor band of output current_frame buffer.
+
+ Local Stores Modified:
+    None
+
+ Global Stores Modified:
+    None
+
+------------------------------------------------------------------------------
+ FUNCTION DESCRIPTION
+
+ This function performs long term synthesis using transmitted spectral
+ coeffients or errors and predicted spectral components.
+
+ Long term synthesis is part of long term prediction (LTP) which is used to
+ reduce the redundancy of a signal between successive coding frames. The
+ functionality of long term synthesis is to reconstruct the frequency domain
+ spectral by adding the predicted spectral components and the transmitted
+ spectral error when prediction is turned on.
+
+------------------------------------------------------------------------------
+ REQUIREMENTS
+
+ None
+
+------------------------------------------------------------------------------
+ REFERENCES
+
+ (1) ISO/IEC 14496-3:1999(E)
+     Part 3: Audio
+        Subpart 4.6.6   Long Term Prediction (LTP)
+
+ (2) MPEG-2 NBC Audio Decoder
+     "This software module was originally developed by Nokia in the course
+     of development of the MPEG-2 AAC/MPEG-4 Audio standard ISO/IEC13818-7,
+     14496-1, 2 and 3. This software module is an implementation of a part
+     of one or more MPEG-2 AAC/MPEG-4 Audio tools as specified by the MPEG-2
+     aac/MPEG-4 Audio standard. ISO/IEC  gives users of the MPEG-2aac/MPEG-4
+     Audio standards free license to this software module or modifications
+     thereof for use in hardware or software products claiming conformance
+     to the MPEG-2 aac/MPEG-4 Audio  standards. Those intending to use this
+     software module in hardware or software products are advised that this
+     use may infringe existing patents. The original developer of this
+     software module, the subsequent editors and their companies, and ISO/IEC
+     have no liability for use of this software module or modifications
+     thereof in an implementation. Copyright is not released for non MPEG-2
+     aac/MPEG-4 Audio conforming products. The original developer retains
+     full right to use the code for the developer's own purpose, assign or
+     donate the code to a third party and to inhibit third party from using
+     the code for non MPEG-2 aac/MPEG-4 Audio conforming products. This
+     copyright notice must be included in all copies or derivative works.
+     Copyright (c)1997.
+
+------------------------------------------------------------------------------
+ PSEUDO-CODE
+
+    pPredicted_spectral = &predicted_spectral[0];
+    pPredicted_spectral_start = pPredicted_spectral;
+    pSfb_prediction_used = &sfb_prediction_used[0];
+
+    IF (win_seq != EIGHT_SHORT_SEQUENCE)
+    THEN
+
+        sfb_offset = 0;
+
+        pWinSfbTop = &pWin_sfb_top[0];
+
+        pQ_format = &q_format[0];
+
+        FOR (i = sfb_per_frame; i>0; i--)
+
+            IF (*(pSfb_prediction_used++) != FALSE)
+            THEN
+
+                pPredicted_offset = pPredicted_spectral_start +
+                                                            sfb_offset;
+                pCurrent_frame = &current_frame[sfb_offset];
+
+                quarter_sfb_width = (*pWinSfbTop - sfb_offset) >> 2;
+
+                max = 0;
+
+                pPredicted_spectral = pPredicted_offset;
+
+                FOR (j = (*pWinSfbTop - sfb_offset); j>0 ; j--)
+
+                    tmpInt32 = *(pPredicted_spectral++);
+
+                    IF (tmpInt32 < 0)
+                    THEN
+
+                        tmpInt32 = -tmpInt32;
+
+                    ENDIF
+
+                    max |= tmpInt32;
+
+                ENDFOR
+
+                tmpInt = 0;
+
+                IF (max != 0)
+                THEN
+
+                    WHILE (max < 0x40000000L)
+
+                        max <<= 1;
+                        tmpInt++;
+
+                    ENDWHILE
+
+                    pPredicted_spectral = pPredicted_offset;
+
+                    FOR (j = quarter_sfb_width; j>0 ; j--)
+
+                        *(pPredicted_spectral++) <<= tmpInt;
+                        *(pPredicted_spectral++) <<= tmpInt;
+                        *(pPredicted_spectral++) <<= tmpInt;
+                        *(pPredicted_spectral++) <<= tmpInt;
+
+                    ENDFOR
+
+                    adjusted_pred_q = pred_q_format + tmpInt;
+
+                    pPredicted_spectral = pPredicted_offset;
+
+                    shift_factor = *(pQ_format) - adjusted_pred_q;
+
+                    IF ((shift_factor >= 0) && (shift_factor < 31))
+                    THEN
+
+                        shift_factor = shift_factor + 1;
+
+                        FOR (j = quarter_sfb_width; j>0 ; j--)
+
+                            *(pCurrent_frame++) =
+                                (*pCurrent_frame>>shift_factor)
+                              + (*(pPredicted_spectral++)>>1);
+                            *(pCurrent_frame++) =
+                                (*pCurrent_frame>>shift_factor)
+                              + (*(pPredicted_spectral++)>>1);
+                            *(pCurrent_frame++) =
+                                (*pCurrent_frame>>shift_factor)
+                              + (*(pPredicted_spectral++)>>1);
+                            *(pCurrent_frame++) =
+                                (*pCurrent_frame>>shift_factor)
+                              + (*(pPredicted_spectral++)>>1);
+
+                        ENDFOR
+
+                        *(pQ_format) = adjusted_pred_q - 1;
+
+                    ELSEIF (shift_factor >= 31)
+                    THEN
+
+                        FOR (j = quarter_sfb_width; j>0 ; j--)
+
+                            *(pCurrent_frame++) = *(pPredicted_spectral++);
+                            *(pCurrent_frame++) = *(pPredicted_spectral++);
+                            *(pCurrent_frame++) = *(pPredicted_spectral++);
+                            *(pCurrent_frame++) = *(pPredicted_spectral++);
+
+                        ENDFOR
+
+                        *(pQ_format) = adjusted_pred_q;
+
+                    ELSEIF ((shift_factor < 0) && (shift_factor > -31))
+                    THEN
+
+                        shift_factor = 1 - shift_factor;
+
+                        FOR (j = quarter_sfb_width; j>0 ; j--)
+
+                            *(pCurrent_frame++) = (*pCurrent_frame>>1) +
+                                (*(pPredicted_spectral++)>>shift_factor);
+                            *(pCurrent_frame++) = (*pCurrent_frame>>1) +
+                                (*(pPredicted_spectral++)>>shift_factor);
+                            *(pCurrent_frame++) = (*pCurrent_frame>>1) +
+                                (*(pPredicted_spectral++)>>shift_factor);
+                            *(pCurrent_frame++) = (*pCurrent_frame>>1) +
+                                (*(pPredicted_spectral++)>>shift_factor);
+
+                        ENDFOR
+
+                        *(pQ_format) = *(pQ_format) - 1;
+
+                    ENDIF
+
+                ENDIF
+
+            ENDIF [ IF (*(pSfb_prediction_used++) != FALSE) ]
+
+            sfb_offset = *pWinSfbTop;
+            pWinSfbTop = pWinSfbTop + 1;
+            pQ_format = pQ_format + 1;
+
+        ENDFOR [ FOR (i = sfb_per_frame; i>0; i--) ]
+
+    ELSE
+
+        pCurrent_frame_start = &current_frame[0];
+
+        pQ_format_start = &q_format[0];
+
+        num_sfb = sfb_per_win[0];
+
+        FOR (wnd=0; wnd<short_window_num; wnd++)
+
+            pWinSfbTop = &pWin_sfb_top[0];
+
+            pQ_format = pQ_format_start;
+
+            IF (win_prediction_used[wnd] != FALSE)
+            THEN
+
+                sfb_offset = 0;
+
+                FOR (i = reconstruct_sfb_num; i > 0; i--)
+
+                    pPredicted_offset = pPredicted_spectral_start +
+                                                                sfb_offset;
+                    pCurrent_frame = pCurrent_frame_start + sfb_offset;
+
+                    quarter_sfb_width = (*pWinSfbTop - sfb_offset) >> 2;
+
+                    max = 0;
+
+                    pPredicted_spectral = pPredicted_offset;
+
+                    FOR (j = (*pWinSfbTop - sfb_offset); j>0 ; j--)
+
+                        tmpInt32 = *(pPredicted_spectral++);
+
+                        IF (tmpInt32 < 0)
+                        THEN
+
+                            tmpInt32 = -tmpInt32;
+
+                        ENDIF
+
+                        max |= tmpInt32;
+
+                    ENDFOR
+
+                    tmpInt = 0;
+
+                    IF (max != 0)
+                    THEN
+
+                        WHILE (max < 0x40000000L)
+
+                            max <<= 1;
+                            tmpInt++;
+
+                        ENDWHILE
+
+
+                        pPredicted_spectral = pPredicted_offset;
+
+                        FOR (j = quarter_sfb_width; j>0 ; j--)
+
+                            *(pPredicted_spectral++) <<= tmpInt;
+                            *(pPredicted_spectral++) <<= tmpInt;
+                            *(pPredicted_spectral++) <<= tmpInt;
+                            *(pPredicted_spectral++) <<= tmpInt;
+
+                        ENDFOR
+
+                        adjusted_pred_q = pred_q_format + tmpInt;
+
+                        pPredicted_spectral = pPredicted_offset;
+
+                        shift_factor = *(pQ_format) - adjusted_pred_q;
+
+                        IF ((shift_factor >= 0) && (shift_factor < 31))
+                        THEN
+
+                            shift_factor = shift_factor + 1;
+
+                            FOR (j = quarter_sfb_width; j>0 ; j--)
+
+                                *(pCurrent_frame++) =
+                                    (*pCurrent_frame>>shift_factor) +
+                                                (*(pPredicted_spectral++)>>1);
+                                *(pCurrent_frame++) =
+                                    (*pCurrent_frame>>shift_factor) +
+                                                (*(pPredicted_spectral++)>>1);
+                                *(pCurrent_frame++) =
+                                    (*pCurrent_frame>>shift_factor) +
+                                                (*(pPredicted_spectral++)>>1);
+                                *(pCurrent_frame++) =
+                                    (*pCurrent_frame>>shift_factor) +
+                                                (*(pPredicted_spectral++)>>1);
+
+                            ENDFOR
+
+                            *(pQ_format) = adjusted_pred_q - 1;
+
+                        ELSEIF (shift_factor >= 31)
+                        THEN
+
+                            FOR (j = quarter_sfb_width; j>0 ; j--)
+
+                                *(pCurrent_frame++) = *(pPredicted_spectral++);
+                                *(pCurrent_frame++) = *(pPredicted_spectral++);
+                                *(pCurrent_frame++) = *(pPredicted_spectral++);
+                                *(pCurrent_frame++) = *(pPredicted_spectral++);
+
+                            ENDFOR
+
+                            *(pQ_format) = adjusted_pred_q;
+
+                        ELSEIF ((shift_factor < 0) && (shift_factor > -31))
+                        THEN
+
+                            shift_factor = 1 - shift_factor;
+
+                            FOR (j = quarter_sfb_width; j>0 ; j--)
+
+                                *(pCurrent_frame++) = (*pCurrent_frame>>1) +
+                                    (*(pPredicted_spectral++)>>shift_factor);
+                                *(pCurrent_frame++) = (*pCurrent_frame>>1) +
+                                    (*(pPredicted_spectral++)>>shift_factor);
+                                *(pCurrent_frame++) = (*pCurrent_frame>>1) +
+                                    (*(pPredicted_spectral++)>>shift_factor);
+                                *(pCurrent_frame++) = (*pCurrent_frame>>1) +
+                                    (*(pPredicted_spectral++)>>shift_factor);
+
+                            ENDFOR
+
+                            *(pQ_format) = *(pQ_format) - 1;
+
+                        ENDIF
+
+                    ENDIF
+
+                    sfb_offset = *pWinSfbTop;
+                    pWinSfbTop = pWinSfbTop + 1;
+                    pQ_format = pQ_format + 1;
+
+                ENDFOR [ FOR (i = reconstruct_sfb_num; i > 0; i--) ]
+
+            ENDIF [ IF (win_prediction_used[wnd] != FALSE) ]
+
+            pPredicted_spectral_start = pPredicted_spectral_start + num_sfb;
+            pCurrent_frame_start = pCurrent_frame_start + num_sfb;
+            wnd_offset = wnd_offset + num_sfb;
+            pQ_format_start = pQ_format_start + num_sfb;
+
+        ENDFOR [ FOR (wnd=0; wnd<short_window_num; wnd++) ]
+
+    ENDIF [ IF (win_seq != EIGHT_SHORT_SEQUENCE) ]
+
+    RETURN
+
+------------------------------------------------------------------------------
+ RESOURCES USED
+   When the code is written for a specific target processor the
+     the resources used should be documented below.
+
+ STACK USAGE: [stack count for this module] + [variable to represent
+          stack usage for each subroutine called]
+
+     where: [stack usage variable] = stack usage for [subroutine
+         name] (see [filename].ext)
+
+ DATA MEMORY USED: x words
+
+ PROGRAM MEMORY USED: x words
+
+ CLOCK CYCLES: [cycle count equation for this module] + [variable
+           used to represent cycle count for each subroutine
+           called]
+
+     where: [cycle count variable] = cycle count for [subroutine
+        name] (see [filename].ext)
+
+------------------------------------------------------------------------------
+*/
+
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+#include "pv_audio_type_defs.h"
+#include "e_window_sequence.h"
+#include "long_term_synthesis.h"
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here. Include conditional
+; compile variables also.
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; LOCAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; LOCAL STORE/BUFFER/POINTER DEFINITIONS
+; Variable declaration - defined here and used outside this module
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL FUNCTION REFERENCES
+; Declare functions defined elsewhere and referenced in this module
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL GLOBAL STORE/BUFFER/POINTER REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; FUNCTION CODE
+----------------------------------------------------------------------------*/
+void long_term_synthesis(
+    WINDOW_SEQUENCE     win_seq,
+    Int                 sfb_per_win,
+    Int16               win_sfb_top[],
+    Int                 win_prediction_used[],
+    Int                 sfb_prediction_used[],
+    Int32               current_frame[],
+    Int                 q_format[],         /* for each sfb */
+    Int32               predicted_spectral[],
+    Int                 pred_q_format,      /* for predicted_spectral[] */
+    Int                 coef_per_win,
+    Int                 short_window_num,
+    Int                 reconstruct_sfb_num)
+{
+    /*----------------------------------------------------------------------------
+    ; Define all local variables
+    ----------------------------------------------------------------------------*/
+    /* Scalefactor band offset */
+    Int sfb_offset;
+
+    /* Window index */
+    Int wnd;
+
+    /* Pointer to array containing predicted samples */
+    Int32 *pPredicted_spectral;
+
+    /* Pointer to the beginning of array containing predicted samples */
+    Int32 *pPredicted_spectral_start;
+
+    Int32 *pPredicted_offset;
+
+    /* Pointer to array containing current spectral components for a channel*/
+    Int32 *pCurrent_frame;
+
+    /* Another pointer to array containing current spectral components */
+    Int32 *pCurrent_frame_start;
+
+    /* Pointer to prediction flag for each scalefactor band */
+    Int *pSfb_prediction_used;
+
+    /* Pointer to top coef per scalefactor band */
+    Int16 *pWinSfbTop;
+
+    /* Pointer to q_format array */
+    Int *pQ_format;
+    Int *pQ_format_start;
+    Int32   temp;
+
+    Int i;
+    Int j;
+
+    Int quarter_sfb_width;
+    Int num_sfb;
+    Int shift_factor;
+
+    UInt32  max;
+    Int32   tmpInt32;
+
+    Int tmpInt;
+    Int adjusted_pred_q;
+    Int pred_shift;
+
+    /*----------------------------------------------------------------------------
+    ; Function body here
+    ----------------------------------------------------------------------------*/
+    /* Initialize pointers */
+    pPredicted_spectral = &predicted_spectral[0];
+    pPredicted_spectral_start = pPredicted_spectral;
+
+    /*
+     * NOTE:
+     * sfb_prediction_used[] start from 0 or 1 depending on nok_lt_decode.c;
+     * currently we agree to make it start from 0;
+     */
+    pSfb_prediction_used = &sfb_prediction_used[0];
+
+    /*********************************/
+    /* LTP synthesis for long window */
+    /*********************************/
+    if (win_seq != EIGHT_SHORT_SEQUENCE)
+    {
+
+        /*******************************************************/
+        /* Reconstruction of current frequency domain spectrum */
+        /*******************************************************/
+
+        /* Initialize scalefactor band offset */
+        sfb_offset = 0;
+
+        /*
+         * Reconstruction is processed on scalefactor band basis.
+         * 1. When prediction is turned on, all the predicted spectral
+         * components will be used for reconstruction.
+         * 2. When prediction is turned off, reconstruction is not
+         * needed. Spectral components of current frame will directly
+         * come from the transmitted data.
+         */
+        pWinSfbTop = &win_sfb_top[0];
+
+        pQ_format = &q_format[0];
+
+        for (i = sfb_per_win; i > 0; i--)
+        {
+            /* Check prediction flag for each scalefactor band. */
+            if (*(pSfb_prediction_used++) != FALSE)
+            {
+                /*
+                 * Prediction is on. Do reconstruction routine.
+                 * Reconstruct spectral component of current
+                 * frame by adding the predicted spectral
+                 * components and the quantized prediction
+                 * errors that reconstructed from transmitted
+                 * data when prediction is turned on.
+                 */
+
+                /* Set pointers to the offset of scalefactor bands */
+                pPredicted_offset = pPredicted_spectral_start +
+                                    sfb_offset;
+                pCurrent_frame = &current_frame[sfb_offset];
+
+                /*
+                 * (*pWinSfbTop - sfb_offset) is number of coefficients
+                 * of the scalefactor band.
+                 * ">>2" is used to set up for later unrolling the loop.
+                 */
+                quarter_sfb_width = (*pWinSfbTop - sfb_offset) >> 2;
+
+                /*
+                 * Adjust pred_q_format and predicted_spectral() to
+                 * maximum resolution.
+                 */
+                max = 0;
+
+                pPredicted_spectral = pPredicted_offset;
+
+                /* Find the maximum absolute value */
+                for (j = (*pWinSfbTop - sfb_offset); j > 0 ; j--)
+                {
+                    tmpInt32 = *(pPredicted_spectral++);
+
+                    /*
+                     * Note: overflow is protected here even though
+                     * tmpInt32 = 0x80000000 is very rare case.
+                     *
+                     *  if (tmpInt32 == LONG_MIN)
+                     *  {
+                     *      tmpInt32 = LONG_MAX;
+                     *  }
+                     *  if (tmpInt32 < 0)
+                     *  {
+                     *      tmpInt32 = -tmpInt32;
+                     *  }
+                     */
+
+                    max |= tmpInt32 ^(tmpInt32 >> 31);
+                }
+
+                /*
+                 * IF the LTP data is all zeros
+                 * (max == 0) - do nothing for this sfb.
+                 */
+
+                if (max != 0)
+                {
+                    /* Find the number of bits to reach the max resolution */
+                    tmpInt = 0;
+
+                    while (max < 0x40000000L)
+                    {
+                        max <<= 1;
+                        tmpInt++;
+                    }
+
+                    /*
+                     * The following codes are combinded into shift factor
+                     * adjusting and reconstruction section.
+                     *
+                     * pPredicted_spectral = pPredicted_offset;
+                     * for(j = quarter_sfb_width; j>0 ; j--)
+                     * {
+                     *      *(pPredicted_spectral++) <<= tmpInt;
+                     *      *(pPredicted_spectral++) <<= tmpInt;
+                     *      *(pPredicted_spectral++) <<= tmpInt;
+                     *      *(pPredicted_spectral++) <<= tmpInt;
+                     * }
+                     *
+                     */
+
+                    /* Adjust Q format for predicted_spectral() */
+                    adjusted_pred_q = pred_q_format + tmpInt;
+
+                    /*
+                     * Adjust Q format to prevent overflow that may occur during
+                     * frequency domain reconstruction.
+                     *
+                     */
+                    pPredicted_spectral = pPredicted_offset;
+
+                    shift_factor = *(pQ_format) - adjusted_pred_q;
+
+                    if ((shift_factor >= 0) && (shift_factor < 31))
+                    {
+                        shift_factor = shift_factor + 1;
+                        pred_shift = tmpInt - 1;
+
+                        if (pred_shift >= 0)
+                        {
+                            for (j = quarter_sfb_width; j > 0 ; j--)
+                            {
+                                temp = *pCurrent_frame >> shift_factor;
+                                *(pCurrent_frame++) = temp
+                                                      + (*(pPredicted_spectral++) << pred_shift);
+                                temp = *pCurrent_frame >> shift_factor;
+                                *(pCurrent_frame++) = temp
+                                                      + (*(pPredicted_spectral++) << pred_shift);
+                                temp = *pCurrent_frame >> shift_factor;
+                                *(pCurrent_frame++) = temp
+                                                      + (*(pPredicted_spectral++) << pred_shift);
+                                temp = *pCurrent_frame >> shift_factor;
+                                *(pCurrent_frame++) = temp
+                                                      + (*(pPredicted_spectral++) << pred_shift);
+                            }
+                        }
+                        else
+                        {
+                            for (j = quarter_sfb_width; j > 0 ; j--)
+                            {
+                                temp = *pCurrent_frame >> shift_factor;
+                                *(pCurrent_frame++) = temp
+                                                      + (*(pPredicted_spectral++) >> 1);
+                                temp = *pCurrent_frame >> shift_factor;
+                                *(pCurrent_frame++) = temp
+                                                      + (*(pPredicted_spectral++) >> 1);
+                                temp = *pCurrent_frame >> shift_factor;
+                                *(pCurrent_frame++) = temp
+                                                      + (*(pPredicted_spectral++) >> 1);
+                                temp = *pCurrent_frame >> shift_factor;
+                                *(pCurrent_frame++) = temp
+                                                      + (*(pPredicted_spectral++) >> 1);
+                            }
+                        }
+
+                        /* Updated new Q format for current scalefactor band */
+                        *(pQ_format) = adjusted_pred_q  - 1;
+                    }
+                    else if (shift_factor >= 31)
+                    {
+                        for (j = quarter_sfb_width; j > 0 ; j--)
+                        {
+                            *(pCurrent_frame++) =
+                                *(pPredicted_spectral++) << tmpInt;
+                            *(pCurrent_frame++) =
+                                *(pPredicted_spectral++) << tmpInt;
+                            *(pCurrent_frame++) =
+                                *(pPredicted_spectral++) << tmpInt;
+                            *(pCurrent_frame++) =
+                                *(pPredicted_spectral++) << tmpInt;
+                        }
+
+                        /* Updated new Q format for current scalefactor band */
+                        *(pQ_format) = adjusted_pred_q ;
+                    }
+                    else if ((shift_factor < 0) && (shift_factor > -31))
+                    {
+                        shift_factor = 1 - shift_factor;
+                        pred_shift = tmpInt - shift_factor;
+
+                        if (pred_shift >= 0)
+                        {
+                            for (j = quarter_sfb_width; j > 0 ; j--)
+                            {
+                                temp = *pCurrent_frame >> 1;
+                                *(pCurrent_frame++) =  temp +
+                                                       (*(pPredicted_spectral++) << pred_shift);
+                                temp = *pCurrent_frame >> 1;
+                                *(pCurrent_frame++) =  temp +
+                                                       (*(pPredicted_spectral++) << pred_shift);
+                                temp = *pCurrent_frame >> 1;
+                                *(pCurrent_frame++) =  temp +
+                                                       (*(pPredicted_spectral++) << pred_shift);
+                                temp = *pCurrent_frame >> 1;
+                                *(pCurrent_frame++) =  temp +
+                                                       (*(pPredicted_spectral++) << pred_shift);
+                            }
+                        }
+                        else
+                        {
+                            pred_shift = -pred_shift;
+
+                            for (j = quarter_sfb_width; j > 0 ; j--)
+                            {
+                                temp = *pCurrent_frame >> 1;
+                                *(pCurrent_frame++) =  temp +
+                                                       (*(pPredicted_spectral++) >> pred_shift);
+                                temp = *pCurrent_frame >> 1;
+                                *(pCurrent_frame++) =  temp +
+                                                       (*(pPredicted_spectral++) >> pred_shift);
+                                temp = *pCurrent_frame >> 1;
+                                *(pCurrent_frame++) =  temp +
+                                                       (*(pPredicted_spectral++) >> pred_shift);
+                                temp = *pCurrent_frame >> 1;
+                                *(pCurrent_frame++) =  temp +
+                                                       (*(pPredicted_spectral++) >> pred_shift);
+                            }
+                        }
+
+                        /*
+                         * Updated new Q format for current scalefactor band
+                         *
+                         * This is NOT a pointer decrement
+                         */
+                        (*pQ_format)--;
+                    }
+
+                } /* if (max != 0) */
+
+                /*
+                 * For case (shift_factor <= -31), *pCurrent_frame and
+                 * *pQ_format do not need to be updated.
+                 */
+
+            } /* if (*(pSfb_prediction_used++) != FALSE) */
+
+            /* Updated to next scalefactor band. */
+            sfb_offset = *(pWinSfbTop++);
+
+            /* Updated pointer to next scalefactor band's Q-format */
+            pQ_format++;
+
+        } /* for (i = sfb_per_frame; i>0; i--) */
+
+    } /* if (win_seq!=EIGHT_SHORT_SEQUENCE) */
+
+    /**********************************/
+    /* LTP synthesis for short window */
+    /**********************************/
+    else
+    {
+        /******************************************************/
+        /*Reconstruction of current frequency domain spectrum */
+        /******************************************************/
+        pCurrent_frame_start = &current_frame[0];
+
+        pQ_format_start = &q_format[0];
+
+        num_sfb = sfb_per_win;
+
+        /* Reconstruction is processed on window basis */
+        for (wnd = 0; wnd < short_window_num; wnd++)
+        {
+            pWinSfbTop = &win_sfb_top[0];
+
+            pQ_format = pQ_format_start;
+
+            /* Check if prediction flag is on for each window */
+            if (win_prediction_used[wnd] != FALSE)
+            {
+                /* Initialize scalefactor band offset */
+                sfb_offset = 0;
+
+                /*
+                 * Reconstruction is processed on scalefactor band basis.
+                 * 1. When prediction is turned on, all the predicted
+                 * spectral components will be used for reconstruction.
+                 * 2. When prediction is turned off, reconstruction is
+                 * not needed. Spectral components of current frame
+                 * will directly come from the transmitted data.
+                 */
+
+                /*
+                 * According to ISO/IEC 14496-3 pg.91
+                 * Only the spectral components in first eight scalefactor
+                 * bands are added to the quantized prediction error.
+                 */
+                for (i = reconstruct_sfb_num; i > 0; i--)
+                {
+                    /* Set pointer to the offset of scalefactor bands */
+                    pPredicted_offset = pPredicted_spectral_start +
+                                        sfb_offset;
+                    pCurrent_frame = pCurrent_frame_start + sfb_offset;
+
+                    /*
+                     * Prediction is on. Do reconstruction routine.
+                     * Reconstruct spectral component of
+                     * current frame by adding the predicted
+                     * spectral components and the quantized
+                     * prediction errors that reconstructed
+                     * from transmitted data when prediction
+                     * is turned on.
+                     */
+
+                    /*
+                     * (*pWinSfbTop - sfb_offset) is number of coefficients
+                     * of the scalefactor band.
+                     * ">>2" is used to set up for later unrolling the loop.
+                     */
+                    quarter_sfb_width = (*pWinSfbTop - sfb_offset) >> 2;
+
+                    /*
+                     * Adjust pred_q_format and predicted_spectral() to
+                     * maximum resolution.
+                     */
+                    max = 0;
+                    pPredicted_spectral = pPredicted_offset;
+
+                    /* Find the maximum absolute value */
+                    for (j = (*pWinSfbTop - sfb_offset); j > 0 ; j--)
+                    {
+                        tmpInt32 = *(pPredicted_spectral++);
+
+
+                        /*
+                         * Note: overflow is protected here even though
+                         * tmpInt32 = 0x80000000 is very rare case.
+                         *
+                         *  if (tmpInt32 == LONG_MIN)
+                         *  {
+                         *      tmpInt32 = LONG_MAX;
+                         *  }
+                         *  if (tmpInt32 < 0)
+                         *  {
+                         *      tmpInt32 = -tmpInt32;
+                         *  }
+                         */
+
+                        max |= tmpInt32 ^(tmpInt32 >> 31);
+                    }
+
+                    if (max != 0)
+                    {
+                        /* Find the number of bits to reach
+                         * the max resolution
+                         */
+                        tmpInt = 0;
+
+                        while (max < 0x40000000L)
+                        {
+                            max <<= 1;
+                            tmpInt++;
+                        }
+                        /*
+                         * The following codes are combined into shift factor
+                         * adjusting and reconstruction section.
+                         *
+                         * pPredicted_spectral = pPredicted_offset;
+                         * for(j = quarter_sfb_width; j>0 ; j--)
+                         * {
+                         *      *(pPredicted_spectral++) <<= tmpInt;
+                         *      *(pPredicted_spectral++) <<= tmpInt;
+                         *      *(pPredicted_spectral++) <<= tmpInt;
+                         *      *(pPredicted_spectral++) <<= tmpInt;
+                         * }
+                         *
+                         */
+
+                        /* Adjust Q format for predicted_spectral() */
+                        adjusted_pred_q = pred_q_format + tmpInt;
+
+                        /*
+                         * Adjust Q format to prevent overflow that may occur
+                         * during frequency domain reconstruction.
+                         */
+                        pPredicted_spectral = pPredicted_offset;
+
+                        shift_factor = *(pQ_format) - adjusted_pred_q;
+
+                        if ((shift_factor >= 0) && (shift_factor < 31))
+                        {
+                            shift_factor = shift_factor + 1;
+
+                            pred_shift = tmpInt - 1;
+
+                            if (pred_shift >= 0)
+                            {
+                                for (j = quarter_sfb_width; j > 0 ; j--)
+                                {
+                                    temp = *pCurrent_frame >> shift_factor;
+                                    *(pCurrent_frame++) = temp
+                                                          + (*(pPredicted_spectral++) << pred_shift);
+                                    temp = *pCurrent_frame >> shift_factor;
+                                    *(pCurrent_frame++) = temp
+                                                          + (*(pPredicted_spectral++) << pred_shift);
+                                    temp = *pCurrent_frame >> shift_factor;
+                                    *(pCurrent_frame++) = temp
+                                                          + (*(pPredicted_spectral++) << pred_shift);
+                                    temp = *pCurrent_frame >> shift_factor;
+                                    *(pCurrent_frame++) = temp
+                                                          + (*(pPredicted_spectral++) << pred_shift);
+
+                                }
+                            }
+                            else
+                            {
+                                for (j = quarter_sfb_width; j > 0 ; j--)
+                                {
+                                    temp = *pCurrent_frame >> shift_factor;
+                                    *(pCurrent_frame++) = temp
+                                                          + (*(pPredicted_spectral++) >> 1);
+                                    temp = *pCurrent_frame >> shift_factor;
+                                    *(pCurrent_frame++) = temp
+                                                          + (*(pPredicted_spectral++) >> 1);
+                                    temp = *pCurrent_frame >> shift_factor;
+                                    *(pCurrent_frame++) = temp
+                                                          + (*(pPredicted_spectral++) >> 1);
+                                    temp = *pCurrent_frame >> shift_factor;
+                                    *(pCurrent_frame++) = temp
+                                                          + (*(pPredicted_spectral++) >> 1);
+                                }
+                            }
+
+                            /* Updated new Q format for current scalefactor band*/
+                            *(pQ_format) = adjusted_pred_q - 1;
+                        }
+                        else if (shift_factor >= 31)
+                        {
+                            for (j = quarter_sfb_width; j > 0 ; j--)
+                            {
+                                *(pCurrent_frame++) =
+                                    *(pPredicted_spectral++) << tmpInt;
+                                *(pCurrent_frame++) =
+                                    *(pPredicted_spectral++) << tmpInt;
+                                *(pCurrent_frame++) =
+                                    *(pPredicted_spectral++) << tmpInt;
+                                *(pCurrent_frame++) =
+                                    *(pPredicted_spectral++) << tmpInt;
+                            }
+
+                            /* Updated new Q format for current scalefactor band*/
+                            *(pQ_format) = adjusted_pred_q;
+                        }
+                        else if ((shift_factor < 0) && (shift_factor > -31))
+                        {
+                            shift_factor = 1 - shift_factor;
+
+                            pred_shift = tmpInt - shift_factor;
+
+                            if (pred_shift >= 0)
+                            {
+                                for (j = quarter_sfb_width; j > 0 ; j--)
+                                {
+                                    temp = *pCurrent_frame >> 1;
+                                    *(pCurrent_frame++) =  temp +
+                                                           (*(pPredicted_spectral++) << pred_shift);
+                                    temp = *pCurrent_frame >> 1;
+                                    *(pCurrent_frame++) =  temp +
+                                                           (*(pPredicted_spectral++) << pred_shift);
+                                    temp = *pCurrent_frame >> 1;
+                                    *(pCurrent_frame++) =  temp +
+                                                           (*(pPredicted_spectral++) << pred_shift);
+                                    temp = *pCurrent_frame >> 1;
+                                    *(pCurrent_frame++) =  temp +
+                                                           (*(pPredicted_spectral++) << pred_shift);
+
+                                }
+                            }
+                            else
+                            {
+                                pred_shift = -pred_shift;
+
+                                for (j = quarter_sfb_width; j > 0 ; j--)
+                                {
+                                    temp = *pCurrent_frame >> 1;
+                                    *(pCurrent_frame++) =  temp +
+                                                           (*(pPredicted_spectral++) >> pred_shift);
+                                    temp = *pCurrent_frame >> 1;
+                                    *(pCurrent_frame++) =  temp +
+                                                           (*(pPredicted_spectral++) >> pred_shift);
+                                    temp = *pCurrent_frame >> 1;
+                                    *(pCurrent_frame++) =  temp +
+                                                           (*(pPredicted_spectral++) >> pred_shift);
+                                    temp = *pCurrent_frame >> 1;
+                                    *(pCurrent_frame++) =  temp +
+                                                           (*(pPredicted_spectral++) >> pred_shift);
+                                }
+                            }
+
+                            /* Updated new Q format for current scalefactor band*/
+                            *(pQ_format) = *(pQ_format) - 1;
+                        }
+
+                        /*
+                         * For case (shift_factor <= -31), *pCurrent_frame and
+                         * *pQ_format do not need to be updated.
+                         */
+
+                    } /* if (max != 0) */
+
+                    /* Updated to next scalefactor band. */
+                    sfb_offset = *(pWinSfbTop++);
+
+                    /* Updated pointer to next scalefactor band's Q-format */
+                    pQ_format++;
+
+                } /* for (i = reconstruct_sfb_num; i > 0; i--) */
+
+            } /* if (win_prediction_used[wnd] != FALSE) */
+
+            /* Updated to next window */
+            pPredicted_spectral_start += coef_per_win;
+            pCurrent_frame_start += coef_per_win;
+            pQ_format_start += num_sfb;
+
+        } /* for (wnd=0; wnd<short_window_num; wnd++) */
+
+    } /* else */
+
+    /*----------------------------------------------------------------------------
+    ; Return nothing or data or data pointer
+    ----------------------------------------------------------------------------*/
+    return;
+} /* long_term_synthesis */
+
+
diff --git a/media/libstagefright/codecs/aacdec/long_term_synthesis.h b/media/libstagefright/codecs/aacdec/long_term_synthesis.h
new file mode 100644
index 0000000..1195709
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/long_term_synthesis.h
@@ -0,0 +1,105 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Pathname: long_term_synthesis.h
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+ Description: 1. Changed protoype with array size passed in per review
+                 comments.
+              2. Moved #define NUM_RECONSTRUCTED_SFB to ltp_common_internal.h
+
+ Description: Modified prototype based on review comments for new version
+          long_term_synthesis.c.
+
+ Who:                                   Date:
+ Description:
+
+------------------------------------------------------------------------------
+ INCLUDE DESCRIPTION
+
+ This file includes function prototype declaration for long_term_synthesis().
+
+------------------------------------------------------------------------------
+*/
+
+/*----------------------------------------------------------------------------
+; CONTINUE ONLY IF NOT ALREADY DEFINED
+----------------------------------------------------------------------------*/
+#ifndef LONG_TERM_SYNTHESIS_H
+#define LONG_TERM_SYNTHESIS_H
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+#include "pv_audio_type_defs.h"
+#include "e_window_sequence.h"
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here.
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL VARIABLES REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; SIMPLE TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; ENUMERATED TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; STRUCTURES TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; GLOBAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+void long_term_synthesis(
+    WINDOW_SEQUENCE     win_seq,
+    Int                 sfb_per_win,
+    Int16               win_sfb_top[],
+    Int                 win_prediction_used[],
+    Int                 sfb_prediction_used[],
+    Int32               current_frame[],
+    Int                 q_format[],
+    Int32               predicted_spectral[],
+    Int                 pred_q_format,
+    Int                 coef_per_win,
+    Int                 short_window_num,
+    Int                 reconstruct_sfb_num);
+
+/*----------------------------------------------------------------------------
+; END
+----------------------------------------------------------------------------*/
+#endif
+
+
diff --git a/media/libstagefright/codecs/aacdec/lt_decode.cpp b/media/libstagefright/codecs/aacdec/lt_decode.cpp
new file mode 100644
index 0000000..e5f5f91
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/lt_decode.cpp
@@ -0,0 +1,507 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Pathname: lt_decode.c
+
+
+------------------------------------------------------------------------------
+
+ REVISION HISTORY
+
+ Description:  Modified from original shareware code
+
+ Description:  Modified to pass variables by reference to eliminate use
+               of global variables.
+
+ Description:  First round of optimizations.
+
+ Description:  pInputStream is now the 2nd parameter to this function.
+
+ Description:  Changed to work with MT's new get_ics_info.c function, which
+ only calls lt_decode if LTP is enabled.  This removes one grab from the
+ bitstream and one "if" from this code.  Also, changed setting of weight.
+ Now, rather than setting the actual weight, I only set the index into
+ a table in this function.
+
+ Description: Replace some instances of getbits to get9_n_lessbits
+              when the number of bits read is 9 or less and get1bits
+              when only 1 bit is read.
+
+ Who:                                   Date:
+ Description:
+------------------------------------------------------------------------------
+ INPUT AND OUTPUT DEFINITIONS
+
+ Inputs:
+    win_type        Type of window (SHORT or LONG)
+                    [WINDOW_TYPE]
+
+    max_sfb         Maximum number of active scalefactor bands
+                    [Int]
+
+    pLt_pred        Pointer to structure containing information for
+                    long-term prediction.
+                    [LT_PRED_STATUS *]
+
+    pInputStream    Pointer to structure containing bitstream
+                    information.
+                    [BITS *]
+
+ Local Stores/Buffers/Pointers Needed:
+    None
+
+ Global Stores/Buffers/Pointers Needed:
+    None
+
+ Outputs:
+    None
+
+ Pointers and Buffers Modified:
+    pLt_pred->weight_index - updated with index into weight table for LTP.
+
+ Local Stores Modified:
+    None
+
+ Global Stores Modified:
+    None
+
+------------------------------------------------------------------------------
+ FUNCTION DESCRIPTION
+
+ This function decodes the bitstream elements for long term prediction
+
+------------------------------------------------------------------------------
+ REQUIREMENTS
+
+
+------------------------------------------------------------------------------
+ REFERENCES
+
+ (1) MPEG-2 NBC Audio Decoder
+   "This software module was originally developed by Nokia
+   in the course of development of the MPEG-2 AAC/MPEG-4 Audio standard
+   ISO/IEC13818-7, 14496-1, 2 and 3.  This software module is an implementation
+   of a part of one or more MPEG-2 AAC/MPEG-4 Audio tools as specified by the
+   MPEG-2 aac/MPEG-4 Audio standard. ISO/IEC  gives users of the
+   MPEG-2aac/MPEG-4 Audio standards free license to this software module or
+   modifications thereof for use in hardware or software products claiming
+   conformance to the MPEG-2 aac/MPEG-4 Audio  standards. Those intending to
+   use this software module in hardware or software products are advised that
+   this use may infringe existing patents. The original developer of this
+   software module, the subsequent editors and their companies, and ISO/IEC
+   have no liability for use of this software module or modifications thereof
+   in an implementation. Copyright is not released for non MPEG-2 aac/MPEG-4
+   Audio conforming products. The original developer retains full right to use
+   the code for the developer's own purpose, assign or donate the code to a
+   third party and to inhibit third party from using the code for non
+   MPEG-2 aac/MPEG-4 Audio conforming products. This copyright notice
+   must be included in all copies or derivative works."
+   Copyright (c)1997.
+
+------------------------------------------------------------------------------
+ PSEUDO-CODE
+
+    pDelay[0] = (Int) getbits(
+                        LEN_LTP_LAG,
+                        pInputStream);
+
+    temp_reg  = (Int) getbits(
+                        LEN_LTP_COEF,
+                        pInputStream);
+
+    pLt_pred->weight = codebook[temp_reg];
+
+    last_band = max_sfb;
+
+    IF (win_type != EIGHT_SHORT_SEQUENCE)
+
+        IF (last_band > MAX_LT_PRED_LONG_SFB)
+
+            last_band = MAX_LT_PRED_LONG_SFB;
+
+        ENDIF
+
+        FOR (m = last_band; m > 0; m--)
+
+            *(pSfbPredictionUsed++) = (Int) getbits(
+                                               LEN_LTP_LONG_USED,
+                                               pInputStream);
+        ENDFOR
+
+        FOR (m = (max_sfb - last_band); m > 0; m--)
+
+            *(pSfbPredictionUsed++) = 0;
+
+        ENDFOR
+
+    ELSE
+
+        IF (last_band > MAX_LT_PRED_SHORT_SFB)
+
+            last_band = MAX_LT_PRED_SHORT_SFB;
+
+        ENDIF
+
+        prev_subblock = pDelay[0];
+
+        pWinPredictionUsed++;
+
+        pTempPtr = &pSfbPredictionUsed[0];
+
+        FOR (m = NUM_SHORT_WINDOWS; m > 0;)
+
+            m--;
+            temp_reg = (Int) getbits(
+                                LEN_LTP_SHORT_USED,
+                                pInputStream);
+
+            *(pWinPredictionUsed++) = temp_reg;
+
+            IF (temp_reg != FALSE)
+            {
+                *(pDelay++) = prev_subblock;
+
+                FOR (k = last_band; k > 0; k--)
+                {
+                    *(pTempPtr++) = 1;
+                }
+                break;
+            ELSE
+            {
+                pDelay++;
+                pTempPtr += last_band;
+            }
+
+        ENDFOR (m = NUM_SHORT_WINDOWS; m > 0;)
+
+        prev_subblock += LTP_LAG_OFFSET;
+
+        FOR (; m > 0; m--)
+
+            temp_reg = (Int) getbits (
+                                LEN_LTP_SHORT_USED,
+                                pInputStream);
+
+            *(pWinPredictionUsed++) = temp_reg;
+
+            IF (temp_reg != FALSE)
+
+                temp_reg = (Int) getbits(
+                                    LEN_LTP_SHORT_LAG_PRESENT,
+                                    pInputStream);
+                IF (temp_reg != 0)
+
+                    temp_reg  = (Int) getbits(
+                                         LEN_LTP_SHORT_LAG,
+                                         pInputStream);
+
+                    *(pDelay++) = prev_subblock - temp_reg;
+
+                ELSE
+
+                    *(pDelay++) = prev_subblock - LTP_LAG_OFFSET;
+
+                ENDIF
+
+                FOR (k = last_band; k > 0; k--)
+                    *(pTempPtr++) = 1;
+                ENDFOR
+
+            ELSE
+
+                pDelay++;
+                pTempPtr += last_band;
+
+            ENDIF
+
+        ENDFOR (; m > 0; m--)
+
+    ENDIF (win_type != EIGHT_SHORT_SEQUENCE)
+
+------------------------------------------------------------------------------
+ RESOURCES USED
+   When the code is written for a specific target processor the
+     the resources used should be documented below.
+
+ STACK USAGE: [stack count for this module] + [variable to represent
+          stack usage for each subroutine called]
+
+     where: [stack usage variable] = stack usage for [subroutine
+         name] (see [filename].ext)
+
+ DATA MEMORY USED: x words
+
+ PROGRAM MEMORY USED: x words
+
+ CLOCK CYCLES: [cycle count equation for this module] + [variable
+           used to represent cycle count for each subroutine
+           called]
+
+     where: [cycle count variable] = cycle count for [subroutine
+        name] (see [filename].ext)
+
+------------------------------------------------------------------------------
+*/
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+#include "pv_audio_type_defs.h"
+#include "lt_decode.h"
+#include "ltp_common_internal.h"
+#include "window_block_fxp.h"
+#include "e_window_sequence.h"
+#include "s_lt_pred_status.h"
+#include "s_bits.h"
+#include "ibstream.h"
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here. Include conditional
+; compile variables also.
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; LOCAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; LOCAL STORE/BUFFER/POINTER DEFINITIONS
+; Variable declaration - defined here and used outside this module
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL FUNCTION REFERENCES
+; Declare functions defined elsewhere and referenced in this module
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL GLOBAL STORE/BUFFER/POINTER REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; FUNCTION CODE
+----------------------------------------------------------------------------*/
+void lt_decode(
+    const WINDOW_SEQUENCE  win_type,
+    BITS            *pInputStream,
+    const Int              max_sfb,
+    LT_PRED_STATUS  *pLt_pred)
+{
+    Int wnd_num;
+    Int k;
+    Int last_band;
+    Int prev_subblock;
+    Int prev_subblock_nonzero;
+    Int temp_reg;
+
+    Bool *pWinPredictionUsed = pLt_pred->win_prediction_used;
+    Bool *pSfbPredictionUsed = pLt_pred->sfb_prediction_used;
+    Int  *pTempPtr;
+    Int  *pDelay = pLt_pred->delay;
+
+    pDelay[0] = (Int) get17_n_lessbits(
+                    LEN_LTP_LAG,  /* 11 bits */
+                    pInputStream);
+
+    pLt_pred->weight_index  = (Int) get9_n_lessbits(
+                                  LEN_LTP_COEF, /*  3 bits */
+                                  pInputStream);
+
+    last_band = max_sfb;
+
+    if (win_type != EIGHT_SHORT_SEQUENCE)
+    {
+
+        /* last_band = min(MAX_LT_PRED_LONG_SFB, max_sfb) MAX_SCFAC_BANDS */
+        if (last_band > MAX_LT_PRED_LONG_SFB)
+        {
+            last_band = MAX_LT_PRED_LONG_SFB;
+        }
+
+        for (k = last_band; k > 0; k--)
+        {
+            *(pSfbPredictionUsed++) = (Int) get1bits(pInputStream);
+        }
+
+        /*
+         * This is not a call to memset, because
+         * (max_sfb - last_band) should typically be a small value.
+         */
+        for (k = (max_sfb - last_band); k > 0; k--)
+        {
+            *(pSfbPredictionUsed++) = FALSE;
+        }
+    }
+    else /* (win_type == EIGHT_SHORT_SEQUENCE) */
+    {
+        /* last_band = min(MAX_LT_PRED_SHORT_SFB, max_sfb) */
+
+        if (last_band > MAX_LT_PRED_SHORT_SFB)
+        {
+            last_band = MAX_LT_PRED_SHORT_SFB;
+        }
+
+        /*
+         * The following two coding constructs are equivalent...
+         *
+         *  first_time == 1
+         *  for (wnd_num=NUM_SHORT_WINDOWS; wnd_num > 0; wnd_num--)
+         *  {
+         *     if (condition)
+         *     {
+         *       if (first_time == 1)
+         *       {
+         *           CODE SECTION A
+         *           first_time = 0;
+         *       }
+         *       else
+         *       {
+         *           CODE SECTION B
+         *       }
+         *     }
+         *  }
+         *
+         * -----------------------------------EQUIVALENT TO------------
+         *
+         *  wnd_num=NUM_SHORT_WINDOWS;
+         *
+         *  do
+         *  {
+         *     wnd_num--;
+         *     if (condition)
+         *     {
+         *         CODE SECTION A
+         *         break;
+         *     }
+         *  } while( wnd_num > 0)
+         *
+         *  while (wnd_num > 0)
+         *  {
+         *     if (condition)
+         *     {
+         *         CODE SECTION B
+         *     }
+         *     wnd_num--;
+         *  }
+         *
+         */
+
+        prev_subblock = pDelay[0];
+
+        pTempPtr = &pSfbPredictionUsed[0];
+
+        wnd_num = NUM_SHORT_WINDOWS;
+
+        prev_subblock_nonzero = prev_subblock;
+        prev_subblock += LTP_LAG_OFFSET;
+
+        do
+        {
+            /*
+             * Place decrement of wnd_num here, to insure
+             * that the decrement occurs before the
+             * break out of the do-while loop.
+             */
+            wnd_num--;
+
+            temp_reg = (Int) get1bits(pInputStream);
+
+            *(pWinPredictionUsed++) = temp_reg;
+
+            if (temp_reg != FALSE)
+            {
+                *(pDelay++) = prev_subblock_nonzero;
+
+                for (k = last_band; k > 0; k--)
+                {
+                    *(pTempPtr++) = TRUE;
+                }
+                for (k = (max_sfb - last_band); k > 0; k--)
+                {
+                    *(pTempPtr++) = FALSE;
+                }
+                break;
+
+            } /* if(pWinPredictionUsed) */
+            else
+            {
+                pDelay++;
+                pTempPtr += max_sfb;
+            }
+
+        }
+        while (wnd_num > 0);
+
+        /*
+         * This while loop picks up where the previous one left off.
+         * Notice that the code functions differently inside the loop
+         */
+
+        while (wnd_num > 0)
+        {
+            temp_reg = (Int) get1bits(pInputStream);
+
+            *(pWinPredictionUsed++) = temp_reg;
+
+            if (temp_reg != FALSE)
+            {
+                temp_reg = (Int) get1bits(pInputStream);
+                if (temp_reg != 0)
+                {
+                    temp_reg  = (Int) get9_n_lessbits(
+                                    LEN_LTP_SHORT_LAG,
+                                    pInputStream);
+
+                    *(pDelay++) = prev_subblock - temp_reg;
+                }
+                else
+                {
+                    *(pDelay++) = prev_subblock_nonzero;
+                }
+                for (k = last_band; k > 0; k--)
+                {
+                    *(pTempPtr++) = TRUE;
+                }
+                for (k = (max_sfb - last_band); k > 0; k--)
+                {
+                    *(pTempPtr++) = FALSE;
+                }
+
+            } /* if (temp_reg) */
+            else
+            {
+                pDelay++;
+                pTempPtr += max_sfb;
+            }
+
+            wnd_num--;
+
+        } /* while(wnd_num) */
+
+    } /* else (win_type == EIGHT_SHORT_SEQUENCE) */
+
+} /* lt_decode */
diff --git a/media/libstagefright/codecs/aacdec/lt_decode.h b/media/libstagefright/codecs/aacdec/lt_decode.h
new file mode 100644
index 0000000..c655270
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/lt_decode.h
@@ -0,0 +1,96 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Pathname: lt_decode.h
+
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+ Description: Changing to move pInputStream to 2nd parameter.
+
+ Description: Replaced "e_WINDOW_TYPE.h" with "e_WINDOW_SEQUENCE.h"
+
+ Who:                       Date:
+ Description:
+------------------------------------------------------------------------------
+ INCLUDE DESCRIPTION
+
+ This include file contains the global function declaration for lt_decode
+
+------------------------------------------------------------------------------
+*/
+
+/*----------------------------------------------------------------------------
+; CONTINUE ONLY IF NOT ALREADY DEFINED
+----------------------------------------------------------------------------*/
+#ifndef LT_DECODE_H
+#define LT_DECODE_H
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+#include "pv_audio_type_defs.h"
+#include "e_window_sequence.h"
+#include "s_lt_pred_status.h"
+#include "s_bits.h"
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here.
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL VARIABLES REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; SIMPLE TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; ENUMERATED TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; STRUCTURES TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; GLOBAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+void lt_decode(
+    const WINDOW_SEQUENCE win_type,
+    BITS           *pInputStream,
+    const Int             max_sfb,
+    LT_PRED_STATUS *pLt_pred);
+
+/*----------------------------------------------------------------------------
+; END
+----------------------------------------------------------------------------*/
+#endif
+
+
diff --git a/media/libstagefright/codecs/aacdec/lt_prediction.h b/media/libstagefright/codecs/aacdec/lt_prediction.h
new file mode 100644
index 0000000..e52a1e8
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/lt_prediction.h
@@ -0,0 +1,69 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/**************************************************************************
+
+This software module was originally developed by
+Nokia in the course of development of the MPEG-2 AAC/MPEG-4
+Audio standard ISO/IEC13818-7, 14496-1, 2 and 3.
+This software module is an implementation of a part
+of one or more MPEG-2 AAC/MPEG-4 Audio tools as specified by the
+MPEG-2 aac/MPEG-4 Audio standard. ISO/IEC  gives users of the
+MPEG-2aac/MPEG-4 Audio standards free license to this software module
+or modifications thereof for use in hardware or software products
+claiming conformance to the MPEG-2 aac/MPEG-4 Audio  standards. Those
+intending to use this software module in hardware or software products
+are advised that this use may infringe existing patents. The original
+developer of this software module, the subsequent
+editors and their companies, and ISO/IEC have no liability for use of
+this software module or modifications thereof in an
+implementation. Copyright is not released for non MPEG-2 aac/MPEG-4
+Audio conforming products. The original developer retains full right to
+use the code for the developer's own purpose, assign or donate the code to a
+third party and to inhibit third party from using the code for non
+MPEG-2 aac/MPEG-4 Audio conforming products. This copyright notice
+must be included in all copies or derivative works.
+Copyright (c)1997.
+
+***************************************************************************/
+
+#ifndef _LT_PREDICTION_H
+#define _LT_PREDICTION_H
+
+#include "block.h"
+#include "ltp_common.h"
+#include "ibstream.h"
+#include "lt_decode.h"
+#include "s_frameinfo.h"
+#include "window_block.h"
+
+void init_lt_pred(LT_PRED_STATUS * lt_status);
+
+void lt_predict(
+    Int                  object,
+    FrameInfo           *pFrameInfo,
+    WINDOW_SEQUENCE      win_seq,
+    Wnd_Shape           *pWin_shape,
+    LT_PRED_STATUS  *pLt_status,
+    Real                *pPredicted_samples,
+    Real                *pOverlap_buffer,
+    Real                *pCurrent_frame_copy,
+    Real                 current_frame[]);
+
+short double_to_int(double sig_in);
+
+#endif /* not defined _LT_PREDICTION_H */
diff --git a/media/libstagefright/codecs/aacdec/ltp_common_internal.h b/media/libstagefright/codecs/aacdec/ltp_common_internal.h
new file mode 100644
index 0000000..d76ac75
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/ltp_common_internal.h
@@ -0,0 +1,115 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/**************************************************************************
+
+This software module was originally developed by
+
+Mikko Suonio (Nokia)
+
+in the course of development of the MPEG-2 NBC/MPEG-4 Audio standard
+ISO/IEC 13818-7, 14496-1,2 and 3. This software module is an
+implementation of a part of one or more MPEG-2 NBC/MPEG-4 Audio tools
+as specified by the MPEG-2 NBC/MPEG-4 Audio standard. ISO/IEC gives
+users of the MPEG-2 NBC/MPEG-4 Audio standards free license to this
+software module or modifications thereof for use in hardware or
+software products claiming conformance to the MPEG-2 NBC/ MPEG-4 Audio
+standards. Those intending to use this software module in hardware or
+software products are advised that this use may infringe existing
+patents. The original developer of this software module and his/her
+company, the subsequent editors and their companies, and ISO/IEC have
+no liability for use of this software module or modifications thereof
+in an implementation. Copyright is not released for non MPEG-2
+NBC/MPEG-4 Audio conforming products. The original developer retains
+full right to use the code for his/her own purpose, assign or donate
+the code to a third party and to inhibit third party from using the
+code for non MPEG-2 NBC/MPEG-4 Audio conforming products. This
+copyright notice must be included in all copies or derivative works.
+
+Copyright (c) 1997.
+
+***************************************************************************/
+
+#ifndef _LTP_COMMON_INTERNAL_H
+#define _LTP_COMMON_INTERNAL_H
+
+
+/*
+  Purpose:      Number of LTP coefficients. */
+#define LPC 1
+
+/*
+  Purpose:      Maximum LTP lag.  */
+#define DELAY 2048
+
+/*
+  Purpose:  Length of the bitstream element ltp_data_present.  */
+#define LEN_LTP_DATA_PRESENT 1
+
+/*
+  Purpose:  Length of the bitstream element ltp_lag.  */
+#define LEN_LTP_LAG 11
+
+/*
+  Purpose:  Length of the bitstream element ltp_coef.  */
+#define LEN_LTP_COEF 3
+
+/*
+  Purpose:  Length of the bitstream element ltp_short_used.  */
+#define LEN_LTP_SHORT_USED 1
+
+/*
+  Purpose:  Length of the bitstream element ltp_short_lag_present.  */
+#define LEN_LTP_SHORT_LAG_PRESENT 1
+
+/*
+  Purpose:  Length of the bitstream element ltp_short_lag.  */
+#define LEN_LTP_SHORT_LAG 5
+
+/*
+  Purpose:  Offset of the lags written in the bitstream.  */
+#define LTP_LAG_OFFSET 16
+
+/*
+  Purpose:  Length of the bitstream element ltp_long_used.  */
+#define LEN_LTP_LONG_USED 1
+
+/*
+  Purpose:  Upper limit for the number of scalefactor bands
+        which can use lt prediction with long windows.
+  Explanation:  Bands 0..MAX_LT_PRED_SFB-1 can use lt prediction.  */
+#define MAX_LT_PRED_LONG_SFB 40
+
+/*
+  Purpose:  Upper limit for the number of scalefactor bands
+        which can use lt prediction with short windows.
+  Explanation:  Bands 0..MAX_LT_PRED_SFB-1 can use lt prediction.  */
+#define MAX_LT_PRED_SHORT_SFB 13
+
+/*
+   Purpose:      Buffer offset to maintain block alignment.
+   Explanation:  This is only used for a short window sequence.  */
+#define SHORT_SQ_OFFSET (BLOCK_LEN_LONG-(BLOCK_LEN_SHORT*4+BLOCK_LEN_SHORT/2))
+
+/*
+  Purpose:  Number of codes for LTP weight. */
+#define CODESIZE 8
+
+/* number of scalefactor bands used for reconstruction for short windows */
+#define NUM_RECONSTRUCTED_SFB (8)
+
+#endif /* _LTP_COMMON_INTERNAL_H */
diff --git a/media/libstagefright/codecs/aacdec/mdct_fxp.cpp b/media/libstagefright/codecs/aacdec/mdct_fxp.cpp
new file mode 100644
index 0000000..df371e8
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/mdct_fxp.cpp
@@ -0,0 +1,450 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Pathname: mdct_fxp.c
+ Funtions: fft_rx2
+
+------------------------------------------------------------------------------
+ INPUT AND OUTPUT DEFINITIONS
+
+ Inputs:
+    data_quant  = Input vector, with quantized Q15 spectral lines:
+                  type Int32
+
+    Q_FFTarray  = Scratch memory used for in-place IFFT calculation,
+                  min size required 1024, type Int32
+
+    n           = Length of input vector "data_quant". Currently 256 or 2048.
+                  type const Int
+
+ Local Stores/Buffers/Pointers Needed:
+    None
+
+ Global Stores/Buffers/Pointers Needed:
+    None
+
+ Outputs:
+    shift = shift factor to reflect scaling introduced by FFT and mdct_fxp,
+
+ Pointers and Buffers Modified:
+    calculation are done in-place and returned in "data_quant"
+
+ Local Stores Modified:
+     None
+
+ Global Stores Modified:
+     None
+
+------------------------------------------------------------------------------
+ FUNCTION DESCRIPTION
+
+    The MDCT is a linear orthogonal lapped transform, based on the idea of
+    time domain aliasing cancellation (TDAC).
+    MDCT is critically sampled, which means that though it is 50% overlapped,
+    a sequence data after MDCT has the same number of coefficients as samples
+    before the transform (after overlap-and-add). This means, that a single
+    block of MDCT data does not correspond to the original block on which the
+    MDCT was performed. When subsequent blocks of data are added (still using
+    50% overlap), the errors introduced by the transform cancels out.
+    Thanks to the overlapping feature, the MDCT is very useful for
+    quantization. It effectively removes the otherwise easily detectable
+    blocking artifact between transform blocks.
+    N = length of input vector X
+    X = vector of length N/2, will hold fixed point DCT
+    k = 0:1:N-1
+
+                        N-1
+            X(m) =  2   SUM   x(k)*cos(pi/(2*N)*(2*k+1+N/2)*(2*m+1))
+                        k=0
+
+
+    The window that completes the TDAC is applied before calling this function.
+    The MDCT can be calculated using an FFT, for this, the MDCT needs to be
+    rewritten as an odd-time odd-frequency discrete Fourier transform. Thus,
+    the MDCT can be calculated using only one n/4 point FFT and some pre and
+    post-rotation of the sample points.
+
+    Computation of the MDCT implies computing
+
+        x  = ( y   - y        ) + j( y       +  y       )
+         n      2n    N/2-1-2n        N-1-2n     N/2+2n
+
+    using the Fast discrete cosine transform as described in [2]
+
+    where x(n) is an input with N points
+
+    x(n) ----------------------------
+                                     |
+                                     |
+                    Pre-rotation by exp(j(2pi/N)(n+1/8))
+                                     |
+                                     |
+                              N/4- point FFT
+                                     |
+                                     |
+                    Post-rotation by exp(j(2pi/N)(k+1/8))
+                                     |
+                                     |
+                                      ------------- DCT
+
+    By considering the N/2 overlap, a relation between successive input blocks
+    is found:
+
+        x   (2n) = x (N/2 + 2n)
+         m+1        m
+------------------------------------------------------------------------------
+ REQUIREMENTS
+
+    This function should provide a fixed point MDCT with an average
+    quantization error less than 1 %.
+
+------------------------------------------------------------------------------
+ REFERENCES
+
+    [1] Analysis/Synthesis Filter Bank design based on time domain
+        aliasing cancellation
+        Jhon Princen, et. al.
+        IEEE Transactions on ASSP, vol ASSP-34, No. 5 October 1986
+        Pg 1153 - 1161
+
+    [2] Regular FFT-related transform kernels for DCT/DST based
+        polyphase filterbanks
+        Rolf Gluth
+        Proc. ICASSP 1991, pg. 2205 - 2208
+
+------------------------------------------------------------------------------
+  PSEUDO-CODE
+
+  Cx, Cy are complex number
+
+
+    exp = log2(n)-1
+
+    FOR ( k=0; k< n/4; k +=2)
+
+        Cx =   (data_quant[3n/4 + k] + data_quant[3n/4 - 1 - k]) +
+             j (data_quant[ n/4 + k] - data_quant[ n/4 - 1 - k])
+
+        Q_FFTarray = Cx * exp(-j(2pi/n)(k+1/8))
+
+    ENDFOR
+
+    FOR ( k=n/4; k< n/2; k +=2)
+
+        Cx =   (data_quant[3n/4 - 1 - k] + data_quant[ - n/4 + k]) +
+             j (data_quant[5n/4 - 1 - k] - data_quant[   n/4 + k])
+
+        Q_FFTarray = Cx * exp(-j(2pi/n)(k+1/8))
+
+    ENDFOR
+
+    CALL FFT( Q_FFTarray, n/4)
+
+    MODIFYING( Q_FFTarray )
+
+    RETURNING( shift )
+
+    FOR ( k=0; k< n/2; k +=2)
+
+        Cx = Q_FFTarray[ k] + j Q_FFTarray[ k+1]
+
+        Cy = 2 * Cx * exp(-j(2pi/n)(k+1/8))
+
+        data_quant[           k ] = - Real(Cy)
+        data_quant[ n/2 - 1 - k ] =   Imag(Cy)
+        data_quant[ n/2     + k ] = - Imag(Cy)
+        data_quant[ n       - k ] =   Real(Cy)
+
+    ENDFOR
+
+    MODIFIED    data_quant[]
+
+    RETURN      (-shift-1)
+
+------------------------------------------------------------------------------
+ RESOURCES USED
+   When the code is written for a specific target processor the
+     the resources used should be documented below.
+
+ STACK USAGE: [stack count for this module] + [variable to represent
+          stack usage for each subroutine called]
+
+     where: [stack usage variable] = stack usage for [subroutine
+         name] (see [filename].ext)
+
+ DATA MEMORY USED: x words
+
+ PROGRAM MEMORY USED: x words
+
+ CLOCK CYCLES: [cycle count equation for this module] + [variable
+           used to represent cycle count for each subroutine
+           called]
+
+     where: [cycle count variable] = cycle count for [subroutine
+        name] (see [filename].ext)
+
+------------------------------------------------------------------------------
+*/
+
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+
+#include "pv_audio_type_defs.h"
+#include "mdct_fxp.h"
+#include "fft_rx4.h"
+#include "mix_radix_fft.h"
+#include "fwd_long_complex_rot.h"
+#include "fwd_short_complex_rot.h"
+
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here. Include conditional
+; compile variables also.
+----------------------------------------------------------------------------*/
+#define ERROR_IN_FRAME_SIZE 10
+
+
+/*----------------------------------------------------------------------------
+; LOCAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; LOCAL VARIABLE DEFINITIONS
+; Variable declaration - defined here and used outside this module
+----------------------------------------------------------------------------*/
+
+
+/*----------------------------------------------------------------------------
+; EXTERNAL FUNCTION REFERENCES
+; Declare functions defined elsewhere and referenced in this module
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL VARIABLES REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL GLOBAL STORE/BUFFER/POINTER REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+
+/*----------------------------------------------------------------------------
+; FUNCTION CODE
+----------------------------------------------------------------------------*/
+
+
+Int mdct_fxp(
+    Int32   data_quant[],
+    Int32   Q_FFTarray[],
+    Int     n)
+{
+
+    Int32   temp_re;
+    Int32   temp_im;
+
+    Int32   temp_re_32;
+    Int32   temp_im_32;
+
+    Int16     cos_n;
+    Int16     sin_n;
+    Int32     exp_jw;
+    Int     shift;
+
+
+    const Int32 *p_rotate;
+
+
+    Int32   *p_data_1;
+    Int32   *p_data_2;
+    Int32   *p_data_3;
+    Int32   *p_data_4;
+
+    Int32 *p_Q_FFTarray;
+
+    Int32   max1;
+
+    Int k;
+    Int n_2   = n >> 1;
+    Int n_4   = n >> 2;
+    Int n_8   = n >> 3;
+    Int n_3_4 = 3 * n_4;
+
+    switch (n)
+    {
+        case SHORT_WINDOW_TYPE:
+            p_rotate = (Int32 *)exp_rotation_N_256;
+            break;
+
+        case LONG_WINDOW_TYPE:
+            p_rotate = (Int32 *)exp_rotation_N_2048;
+            break;
+
+        default:
+            /*
+             *  There is no defined behavior for a non supported frame
+             *  size. By returning a fixed scaling factor, the input will
+             *  scaled down and this will be heard as a low level noise
+             */
+            return(ERROR_IN_FRAME_SIZE);
+
+    }
+
+    /*--- Reordering and Pre-rotation by exp(-j(2pi/N)(r+1/8))   */
+    p_data_1 = &data_quant[n_3_4];
+    p_data_2 = &data_quant[n_3_4 - 1];
+    p_data_3 = &data_quant[n_4];
+    p_data_4 = &data_quant[n_4 - 1];
+
+    p_Q_FFTarray = Q_FFTarray;
+
+    max1 = 0;
+
+    for (k = n_8; k > 0; k--)
+    {
+        /*
+         *  scale down to ensure numbers are Q15
+         *  temp_re and temp_im are 32-bit but
+         *  only the lower 16 bits are used
+         */
+
+        temp_re = (*(p_data_1++) + *(p_data_2--)) >> 1;
+        temp_im = (*(p_data_3++) - *(p_data_4--)) >> 1;
+
+
+        /*
+         * cos_n + j*sin_n == exp(j(2pi/N)(k+1/8))
+         */
+
+        exp_jw = *p_rotate++;
+
+        cos_n = (Int16)(exp_jw >> 16);
+        sin_n = (Int16)(exp_jw & 0xFFFF);
+
+        temp_re_32 = temp_re * cos_n + temp_im * sin_n;
+        temp_im_32 = temp_im * cos_n - temp_re * sin_n;
+        *(p_Q_FFTarray++) = temp_re_32;
+        *(p_Q_FFTarray++) = temp_im_32;
+        max1         |= (temp_re_32 >> 31) ^ temp_re_32;
+        max1         |= (temp_im_32 >> 31) ^ temp_im_32;
+
+
+        p_data_1++;
+        p_data_2--;
+        p_data_4--;
+        p_data_3++;
+    }
+
+
+    p_data_1 = &data_quant[n - 1];
+    p_data_2 = &data_quant[n_2 - 1];
+    p_data_3 = &data_quant[n_2];
+    p_data_4 =  data_quant;
+
+    for (k = n_8; k > 0; k--)
+    {
+        /*
+         *  scale down to ensure numbers are Q15
+         */
+        temp_re = (*(p_data_2--) - *(p_data_4++)) >> 1;
+        temp_im = (*(p_data_1--) + *(p_data_3++)) >> 1;
+
+        p_data_2--;
+        p_data_1--;
+        p_data_4++;
+        p_data_3++;
+
+        /*
+         * cos_n + j*sin_n == exp(j(2pi/N)(k+1/8))
+         */
+
+        exp_jw = *p_rotate++;
+
+        cos_n = (Int16)(exp_jw >> 16);
+        sin_n = (Int16)(exp_jw & 0xFFFF);
+
+        temp_re_32 = temp_re * cos_n + temp_im * sin_n;
+        temp_im_32 = temp_im * cos_n - temp_re * sin_n;
+
+        *(p_Q_FFTarray++) = temp_re_32;
+        *(p_Q_FFTarray++) = temp_im_32;
+        max1         |= (temp_re_32 >> 31) ^ temp_re_32;
+        max1         |= (temp_im_32 >> 31) ^ temp_im_32;
+
+
+    } /* for(k) */
+
+
+
+    p_Q_FFTarray = Q_FFTarray;
+
+    if (max1)
+    {
+
+        if (n != SHORT_WINDOW_TYPE)
+        {
+
+            shift = mix_radix_fft(
+                        Q_FFTarray,
+                        &max1);
+
+            shift += fwd_long_complex_rot(
+                         Q_FFTarray,
+                         data_quant,
+                         max1);
+
+        }
+        else        /*  n_4 is 64 */
+        {
+
+            shift = fft_rx4_short(
+                        Q_FFTarray,
+                        &max1);
+
+            shift += fwd_short_complex_rot(
+                         Q_FFTarray,
+                         data_quant,
+                         max1);
+        }
+
+    }
+    else
+    {
+        shift = -31;
+    }
+
+    /*
+     *  returns shift introduced by FFT and mdct_fxp, 12 accounts for
+     *  regular downshift (14) and MDCT scale factor (-2)
+     *  number are returned as 16 bits
+     */
+    return (12 - shift);
+
+} /* mdct_fxp */
+
diff --git a/media/libstagefright/codecs/aacdec/mdct_fxp.h b/media/libstagefright/codecs/aacdec/mdct_fxp.h
new file mode 100644
index 0000000..b8d5a80
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/mdct_fxp.h
@@ -0,0 +1,107 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Pathname: mdct_fxp.h
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+ Description: This extern had the incorrect length of the arrays.  The true
+ lengths are 128 and 1024, not 64 and 512.
+
+ Description:  Modified interface so a vector with extended precision is
+               returned. Added copyright notice.
+
+ Who:                       Date:
+ Description:
+
+------------------------------------------------------------------------------
+ INCLUDE DESCRIPTION
+
+ Header file for function mdct_fxp()
+
+
+------------------------------------------------------------------------------
+*/
+
+/*----------------------------------------------------------------------------
+; CONTINUE ONLY IF NOT ALREADY DEFINED
+----------------------------------------------------------------------------*/
+#ifndef MDCT_FXP_H
+#define MDCT_FXP_H
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+    /*----------------------------------------------------------------------------
+    ; INCLUDES
+    ----------------------------------------------------------------------------*/
+#include "pv_audio_type_defs.h"
+
+    /*----------------------------------------------------------------------------
+    ; MACROS
+    ; Define module specific macros here
+    ----------------------------------------------------------------------------*/
+
+    /*----------------------------------------------------------------------------
+    ; DEFINES
+    ; Include all pre-processor statements here.
+    ----------------------------------------------------------------------------*/
+#define     LONG_WINDOW_TYPE  2048
+#define     SHORT_WINDOW_TYPE  256
+
+    /*----------------------------------------------------------------------------
+    ; EXTERNAL VARIABLES REFERENCES
+    ; Declare variables used in this module but defined elsewhere
+    ----------------------------------------------------------------------------*/
+
+    extern const Int exp_rotation_N_256[128];
+    extern const Int exp_rotation_N_2048[1024];
+
+    /*----------------------------------------------------------------------------
+    ; SIMPLE TYPEDEF'S
+    ----------------------------------------------------------------------------*/
+
+    /*----------------------------------------------------------------------------
+    ; ENUMERATED TYPEDEF'S
+    ----------------------------------------------------------------------------*/
+
+    /*----------------------------------------------------------------------------
+    ; STRUCTURES TYPEDEF'S
+    ----------------------------------------------------------------------------*/
+
+    /*----------------------------------------------------------------------------
+    ; GLOBAL FUNCTION DEFINITIONS
+    ; Function Prototype declaration
+    ----------------------------------------------------------------------------*/
+    Int mdct_fxp(
+        Int32   data_quant[],
+        Int32   Q_FFTarray[],
+        Int     n);
+
+#ifdef __cplusplus
+}
+#endif
+
+/*----------------------------------------------------------------------------
+; END
+----------------------------------------------------------------------------*/
+#endif  /* MDCT_FXP_H */
diff --git a/media/libstagefright/codecs/aacdec/mdct_tables_fxp.cpp b/media/libstagefright/codecs/aacdec/mdct_tables_fxp.cpp
new file mode 100644
index 0000000..709cbf2
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/mdct_tables_fxp.cpp
@@ -0,0 +1,253 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Pathname: mdct_tables_fxp.c
+ Funtions:
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+ Description:  Created from fft_rx2.c
+
+ Description:  Modified to include forward and inverse tables
+
+ Who:                       Date:
+ Description:
+
+  ------------------------------------------------------------------------------
+ MODULE DESCRIPTION
+
+    MDCT rotation tables fixpoint tables
+
+    For a table with N complex points:
+
+    cos_n + j*sin_n == exp(j(2pi/N)(n+1/8))
+
+------------------------------------------------------------------------------
+*/
+
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+#include "pv_audio_type_defs.h"
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+    /*----------------------------------------------------------------------------
+    ; MACROS
+    ; Define module specific macros here
+    ----------------------------------------------------------------------------*/
+
+    /*----------------------------------------------------------------------------
+    ; DEFINES
+    ; Include all pre-processor statements here. Include conditional
+    ; compile variables also.
+    ----------------------------------------------------------------------------*/
+
+    /*----------------------------------------------------------------------------
+    ; LOCAL FUNCTION DEFINITIONS
+    ; Function Prototype declaration
+    ----------------------------------------------------------------------------*/
+
+    /*----------------------------------------------------------------------------
+    ; LOCAL VARIABLE DEFINITIONS
+    ; Variable declaration - defined here and used outside this module
+    ----------------------------------------------------------------------------*/
+
+
+    /*----------------------------------------------------------------------------
+    ; EXTERNAL FUNCTION REFERENCES
+    ; Declare functions defined elsewhere and referenced in this module
+    ----------------------------------------------------------------------------*/
+
+    /*----------------------------------------------------------------------------
+    ; EXTERNAL VARIABLES REFERENCES
+    ; Declare variables used in this module but defined elsewhere
+    ----------------------------------------------------------------------------*/
+
+
+
+
+    extern const Int32 exp_rotation_N_256[64] =
+    {
+
+        0x5A820047,  0x5A7A0280, 0x5A6304B8, 0x5A3E06EF,
+        0x5A0C0926,  0x59CB0B5B, 0x597D0D8E, 0x59210FBF,
+        0x58B711EE,  0x5840141A, 0x57BB1643, 0x57281868,
+        0x56881A8A,  0x55DB1CA8, 0x55201EC1, 0x545820D5,
+        0x538322E5,  0x52A224EF, 0x51B326F3, 0x50B828F1,
+        0x4FB12AE9,  0x4E9D2CDA, 0x4D7D2EC5, 0x4C5230A8,
+        0x4B1A3284,  0x49D73458, 0x48883624, 0x472F37E7,
+        0x45CA39A2,  0x445A3B54, 0x42E03CFD, 0x415C3E9C,
+        0x3FCE4032,  0x3E3541BE, 0x3C944340, 0x3AE844B7,
+        0x39344624,  0x37774786, 0x35B148DD, 0x33E44A29,
+        0x320E4B69,  0x30304C9E, 0x2E4B4DC6, 0x2C5F4EE3,
+        0x2A6C4FF4,  0x287250F8, 0x267251F0, 0x246D52DB,
+        0x226153BA,  0x2051548B, 0x1E3B5550, 0x1C215607,
+        0x1A0256B1,  0x17DF574E, 0x15B957DD, 0x138F585F,
+        0x116358D3,  0x0F335939, 0x0D015992, 0x0ACE59DD,
+        0x08985A1A,  0x06625A49, 0x042A5A6A, 0x01F25A7D
+    };
+
+
+
+
+
+
+    extern const Int32 exp_rotation_N_2048[512] =
+    {
+
+        0x5A820009,  0x5A820050, 0x5A820097, 0x5A8100DE,
+        0x5A810125,  0x5A80016C, 0x5A7E01B3, 0x5A7D01FA,
+        0x5A7B0242,  0x5A790289, 0x5A7702D0, 0x5A750317,
+        0x5A72035E,  0x5A7003A5, 0x5A6D03EC, 0x5A6A0433,
+        0x5A66047A,  0x5A6304C1, 0x5A5F0508, 0x5A5B054F,
+        0x5A560596,  0x5A5205DD, 0x5A4D0624, 0x5A48066A,
+        0x5A4306B1,  0x5A3E06F8, 0x5A38073F, 0x5A320786,
+        0x5A2C07CD,  0x5A260814, 0x5A20085A, 0x5A1908A1,
+        0x5A1208E8,  0x5A0B092F, 0x5A040975, 0x59FC09BC,
+        0x59F40A03,  0x59EC0A49, 0x59E40A90, 0x59DC0AD7,
+        0x59D30B1D,  0x59CA0B64, 0x59C10BAA, 0x59B80BF1,
+        0x59AE0C37,  0x59A50C7E, 0x599B0CC4, 0x59910D0A,
+        0x59860D51,  0x597C0D97, 0x59710DDD, 0x59660E23,
+        0x595B0E6A,  0x594F0EB0, 0x59440EF6, 0x59380F3C,
+        0x592C0F82,  0x59200FC8, 0x5913100E, 0x59061054,
+        0x58F9109A,  0x58EC10E0, 0x58DF1126, 0x58D1116B,
+        0x58C411B1,  0x58B611F7, 0x58A7123C, 0x58991282,
+        0x588A12C8,  0x587B130D, 0x586C1353, 0x585D1398,
+        0x584E13DD,  0x583E1423, 0x582E1468, 0x581E14AD,
+        0x580D14F2,  0x57FD1538, 0x57EC157D, 0x57DB15C2,
+        0x57CA1607,  0x57B9164C, 0x57A71690, 0x579516D5,
+        0x5783171A,  0x5771175F, 0x575E17A3, 0x574C17E8,
+        0x5739182C,  0x57261871, 0x571218B5, 0x56FF18FA,
+        0x56EB193E,  0x56D71982, 0x56C319C6, 0x56AF1A0A,
+        0x569A1A4F,  0x56851A93, 0x56701AD6, 0x565B1B1A,
+        0x56461B5E,  0x56301BA2, 0x561A1BE5, 0x56041C29,
+        0x55EE1C6D,  0x55D81CB0, 0x55C11CF3, 0x55AA1D37,
+        0x55931D7A,  0x557C1DBD, 0x55651E00, 0x554D1E43,
+        0x55351E86,  0x551D1EC9, 0x55051F0C, 0x54EC1F4F,
+        0x54D31F91,  0x54BB1FD4, 0x54A12016, 0x54882059,
+        0x546F209B,  0x545520DE, 0x543B2120, 0x54212162,
+        0x540721A4,  0x53EC21E6, 0x53D12228, 0x53B62269,
+        0x539B22AB,  0x538022ED, 0x5364232E, 0x53492370,
+        0x532D23B1,  0x531123F2, 0x52F42434, 0x52D82475,
+        0x52BB24B6,  0x529E24F7, 0x52812538, 0x52642578,
+        0x524625B9,  0x522825FA, 0x520B263A, 0x51EC267A,
+        0x51CE26BB,  0x51B026FB, 0x5191273B, 0x5172277B,
+        0x515327BB,  0x513427FB, 0x5114283A, 0x50F4287A,
+        0x50D428BA,  0x50B428F9, 0x50942938, 0x50742978,
+        0x505329B7,  0x503229F6, 0x50112A35, 0x4FF02A74,
+        0x4FCE2AB2,  0x4FAD2AF1, 0x4F8B2B2F, 0x4F692B6E,
+        0x4F472BAC,  0x4F242BEA, 0x4F022C29, 0x4EDF2C67,
+        0x4EBC2CA4,  0x4E992CE2, 0x4E752D20, 0x4E522D5D,
+        0x4E2E2D9B,  0x4E0A2DD8, 0x4DE62E15, 0x4DC22E53,
+        0x4D9D2E90,  0x4D792ECD, 0x4D542F09, 0x4D2F2F46,
+        0x4D0A2F83,  0x4CE42FBF, 0x4CBF2FFB, 0x4C993038,
+        0x4C733074,  0x4C4D30B0, 0x4C2630EC, 0x4C003127,
+        0x4BD93163,  0x4BB2319E, 0x4B8B31DA, 0x4B643215,
+        0x4B3D3250,  0x4B15328B, 0x4AED32C6, 0x4AC53301,
+        0x4A9D333C,  0x4A753376, 0x4A4C33B1, 0x4A2433EB,
+        0x49FB3425,  0x49D2345F, 0x49A83499, 0x497F34D3,
+        0x4955350C,  0x492C3546, 0x4902357F, 0x48D835B9,
+        0x48AD35F2,  0x4883362B, 0x48583664, 0x482E369C,
+        0x480336D5,  0x47D7370E, 0x47AC3746, 0x4781377E,
+        0x475537B6,  0x472937EE, 0x46FD3826, 0x46D1385E,
+        0x46A43895,  0x467838CD, 0x464B3904, 0x461E393B,
+        0x45F13972,  0x45C439A9, 0x459739E0, 0x45693A16,
+        0x453C3A4D,  0x450E3A83, 0x44E03AB9, 0x44B13AEF,
+        0x44833B25,  0x44553B5B, 0x44263B90, 0x43F73BC6,
+        0x43C83BFB,  0x43993C30, 0x43693C65, 0x433A3C9A,
+        0x430A3CCF,  0x42DA3D04, 0x42AA3D38, 0x427A3D6C,
+        0x424A3DA0,  0x42193DD4, 0x41E93E08, 0x41B83E3C,
+        0x41873E6F,  0x41563EA3, 0x41253ED6, 0x40F33F09,
+        0x40C23F3C,  0x40903F6F, 0x405E3FA1, 0x402C3FD4,
+        0x3FFA4006,  0x3FC74038, 0x3F95406A, 0x3F62409C,
+        0x3F2F40CE,  0x3EFC4100, 0x3EC94131, 0x3E964162,
+        0x3E634193,  0x3E2F41C4, 0x3DFB41F5, 0x3DC74226,
+        0x3D934256,  0x3D5F4286, 0x3D2B42B6, 0x3CF642E6,
+        0x3CC24316,  0x3C8D4346, 0x3C584375, 0x3C2343A5,
+        0x3BEE43D4,  0x3BB84403, 0x3B834432, 0x3B4D4460,
+        0x3B18448F,  0x3AE244BD, 0x3AAC44EB, 0x3A754519,
+        0x3A3F4547,  0x3A094575, 0x39D245A2, 0x399B45CF,
+        0x396445FD,  0x392D462A, 0x38F64656, 0x38BF4683,
+        0x388746B0,  0x385046DC, 0x38184708, 0x37E04734,
+        0x37A84760,  0x3770478B, 0x373847B7, 0x36FF47E2,
+        0x36C7480D,  0x368E4838, 0x36554863, 0x361D488E,
+        0x35E348B8,  0x35AA48E2, 0x3571490C, 0x35384936,
+        0x34FE4960,  0x34C44989, 0x348B49B3, 0x345149DC,
+        0x34164A05,  0x33DC4A2E, 0x33A24A56, 0x33684A7F,
+        0x332D4AA7,  0x32F24ACF, 0x32B74AF7, 0x327C4B1F,
+        0x32414B46,  0x32064B6E, 0x31CB4B95, 0x31904BBC,
+        0x31544BE3,  0x31184C0A, 0x30DD4C30, 0x30A14C56,
+        0x30654C7C,  0x30294CA2, 0x2FEC4CC8, 0x2FB04CEE,
+        0x2F734D13,  0x2F374D38, 0x2EFA4D5D, 0x2EBD4D82,
+        0x2E804DA7,  0x2E434DCB, 0x2E064DEF, 0x2DC94E13,
+        0x2D8C4E37,  0x2D4E4E5B, 0x2D104E7E, 0x2CD34EA2,
+        0x2C954EC5,  0x2C574EE8, 0x2C194F0A, 0x2BDB4F2D,
+        0x2B9D4F4F,  0x2B5E4F71, 0x2B204F93, 0x2AE14FB5,
+        0x2AA34FD7,  0x2A644FF8, 0x2A255019, 0x29E6503A,
+        0x29A7505B,  0x2968507C, 0x2929509C, 0x28E950BC,
+        0x28AA50DC,  0x286A50FC, 0x282B511C, 0x27EB513B,
+        0x27AB515B,  0x276B517A, 0x272B5199, 0x26EB51B7,
+        0x26AB51D6,  0x266A51F4, 0x262A5212, 0x25E95230,
+        0x25A9524E,  0x2568526B, 0x25275288, 0x24E652A5,
+        0x24A652C2,  0x246452DF, 0x242352FB, 0x23E25318,
+        0x23A15334,  0x235F5350, 0x231E536B, 0x22DC5387,
+        0x229B53A2,  0x225953BD, 0x221753D8, 0x21D553F3,
+        0x2193540D,  0x21515427, 0x210F5442, 0x20CD545B,
+        0x208B5475,  0x2048548F, 0x200654A8, 0x1FC354C1,
+        0x1F8154DA,  0x1F3E54F2, 0x1EFB550B, 0x1EB85523,
+        0x1E76553B,  0x1E335553, 0x1DF0556A, 0x1DAC5582,
+        0x1D695599,  0x1D2655B0, 0x1CE355C7, 0x1C9F55DD,
+        0x1C5C55F4,  0x1C18560A, 0x1BD55620, 0x1B915636,
+        0x1B4D564B,  0x1B095661, 0x1AC55676, 0x1A82568B,
+        0x1A3E569F,  0x19F956B4, 0x19B556C8, 0x197156DC,
+        0x192D56F0,  0x18E95704, 0x18A45717, 0x1860572A,
+        0x181B573E,  0x17D75750, 0x17925763, 0x174D5775,
+        0x17095788,  0x16C4579A, 0x167F57AB, 0x163A57BD,
+        0x15F557CE,  0x15B057DF, 0x156B57F0, 0x15265801,
+        0x14E15812,  0x149C5822, 0x14575832, 0x14115842,
+        0x13CC5851,  0x13875861, 0x13415870, 0x12FC587F,
+        0x12B6588E,  0x1271589D, 0x122B58AB, 0x11E558B9,
+        0x11A058C7,  0x115A58D5, 0x111458E2, 0x10CE58F0,
+        0x108858FD,  0x1042590A, 0x0FFD5916, 0x0FB75923,
+        0x0F71592F,  0x0F2A593B, 0x0EE45947, 0x0E9E5952,
+        0x0E58595E,  0x0E125969, 0x0DCC5974, 0x0D85597E,
+        0x0D3F5989,  0x0CF95993, 0x0CB2599D, 0x0C6C59A7,
+        0x0C2559B1,  0x0BDF59BA, 0x0B9959C4, 0x0B5259CD,
+        0x0B0B59D5,  0x0AC559DE, 0x0A7E59E6, 0x0A3859EE,
+        0x09F159F6,  0x09AA59FE, 0x09645A05, 0x091D5A0D,
+        0x08D65A14,  0x08905A1B, 0x08495A21, 0x08025A28,
+        0x07BB5A2E,  0x07745A34, 0x072D5A3A, 0x06E75A3F,
+        0x06A05A44,  0x06595A49, 0x06125A4E, 0x05CB5A53,
+        0x05845A57,  0x053D5A5C, 0x04F65A60, 0x04AF5A63,
+        0x04685A67,  0x04215A6A, 0x03DA5A6D, 0x03935A70,
+        0x034C5A73,  0x03055A76, 0x02BE5A78, 0x02775A7A,
+        0x02305A7C,  0x01E95A7D, 0x01A25A7F, 0x015B5A80,
+        0x01135A81,  0x00CC5A82, 0x00855A82, 0x003E5A82
+    };
+
+
+#ifdef __cplusplus
+}
+#endif
diff --git a/media/libstagefright/codecs/aacdec/mdst.cpp b/media/libstagefright/codecs/aacdec/mdst.cpp
new file mode 100644
index 0000000..19f82e3
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/mdst.cpp
@@ -0,0 +1,294 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Filename: mdst.c
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+
+ Who:                                   Date: MM/DD/YYYY
+ Description:
+
+------------------------------------------------------------------------------
+ INPUT AND OUTPUT DEFINITIONS
+
+    Int32 x             32-bit integer input length 64
+
+
+------------------------------------------------------------------------------
+ FUNCTION DESCRIPTION
+
+    mdst
+
+------------------------------------------------------------------------------
+ REQUIREMENTS
+
+
+------------------------------------------------------------------------------
+ REFERENCES
+
+------------------------------------------------------------------------------
+ PSEUDO-CODE
+
+------------------------------------------------------------------------------
+*/
+
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+
+#ifdef AAC_PLUS
+
+#include "pv_audio_type_defs.h"
+#include "synthesis_sub_band.h"
+#include "dct16.h"
+#include "dct64.h"
+#include "mdst.h"
+
+#ifdef HQ_SBR
+
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here. Include conditional
+; compile variables also.
+----------------------------------------------------------------------------*/
+
+#include "fxp_mul32.h"
+#include "dst32.h"
+
+
+#define Qfmt1(a)   (Int32)(a*0x7FFFFFFF + (a>=0?0.5F:-0.5F))
+#define Qfmt(a)   (Int32)(a*((Int32)1<<27) + (a>=0?0.5F:-0.5F))
+
+const Int32 CosTable_32[32] =
+{
+    Qfmt1(0.50015063602065F),  Qfmt1(0.50135845244641F),
+    Qfmt1(0.50378872568104F),  Qfmt1(0.50747117207256F),
+    Qfmt1(0.51245147940822F),  Qfmt1(0.51879271310533F),
+    Qfmt1(0.52657731515427F),  Qfmt1(0.53590981690799F),
+    Qfmt1(0.54692043798551F),  Qfmt1(0.55976981294708F),
+    Qfmt1(0.57465518403266F),  Qfmt1(0.59181853585742F),
+    Qfmt1(0.61155734788251F),  Qfmt1(0.63423893668840F),
+    Qfmt1(0.66031980781371F),  Qfmt1(0.69037212820021F),
+    Qfmt1(0.72512052237720F),  Qfmt1(0.76549416497309F),
+    Qfmt1(0.81270209081449F),  Qfmt1(0.86834471522335F),
+    Qfmt(0.93458359703641F),  Qfmt(1.01440826499705F),
+    Qfmt(1.11207162057972F),  Qfmt(1.23383273797657F),
+    Qfmt(1.38929395863283F),  Qfmt(1.59397228338563F),
+    Qfmt(1.87467598000841F),  Qfmt(2.28205006800516F),
+    Qfmt(2.92462842815822F),  Qfmt(4.08461107812925F),
+    Qfmt(6.79675071167363F),  Qfmt(10.18693908361573F)
+};
+
+
+
+/*----------------------------------------------------------------------------
+; LOCAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; LOCAL STORE/BUFFER/POINTER DEFINITIONS
+; Variable declaration - defined here and used outside this module
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL FUNCTION REFERENCES
+; Declare functions defined elsewhere and referenced in this module
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL GLOBAL STORE/BUFFER/POINTER REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; FUNCTION CODE
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; mdst_32
+----------------------------------------------------------------------------*/
+
+void mdst_32(Int32 vec[], Int32 scratch_mem[])
+{
+
+    Int i;
+    const Int32 *pt_cos = CosTable_32;
+    Int32 *pt_vec = vec;
+    Int32 tmp1;
+    Int32 tmp2;
+
+
+
+    Int32 tmp3;
+
+    tmp3 = *(pt_vec++);
+    tmp2 = *(pt_vec);
+
+    for (i = 5; i != 0; i--)
+    {
+        *(pt_vec++)  += tmp3;
+        tmp1 = *(pt_vec);
+        *(pt_vec++)  += tmp2;
+        tmp3 = *(pt_vec);
+        *(pt_vec++)  += tmp1;
+        tmp2 = *(pt_vec);
+        *(pt_vec++)  += tmp3;
+        tmp1 = *(pt_vec);
+        *(pt_vec++)  += tmp2;
+        tmp3 = *(pt_vec);
+        *(pt_vec++)  += tmp1;
+        tmp2 = *(pt_vec);
+    }
+
+    *(pt_vec)  += tmp3;
+
+    dst_32(vec, scratch_mem);
+
+    pt_vec = vec;
+
+    for (i = 5; i != 0; i--)
+    {
+        *(pt_vec)   = fxp_mul32_Q31((*(pt_vec) << 1) + tmp2, *(pt_cos++));
+        pt_vec++;
+        *(pt_vec)   = fxp_mul32_Q31((*(pt_vec) << 1) - tmp2, *(pt_cos++));
+        pt_vec++;
+        *(pt_vec)   = fxp_mul32_Q31((*(pt_vec) << 1) + tmp2, *(pt_cos++));
+        pt_vec++;
+        *(pt_vec)   = fxp_mul32_Q31((*(pt_vec) << 1) - tmp2, *(pt_cos++));
+        pt_vec++;
+    }
+
+    tmp2 >>= 1;
+    for (i = 3; i != 0; i--)
+    {
+        *(pt_vec)   = fxp_mul32_Q27((*(pt_vec) + tmp2), *(pt_cos++));
+        pt_vec++;
+        *(pt_vec)   = fxp_mul32_Q27((*(pt_vec) - tmp2), *(pt_cos++));
+        pt_vec++;
+        *(pt_vec)   = fxp_mul32_Q27((*(pt_vec) + tmp2), *(pt_cos++));
+        pt_vec++;
+        *(pt_vec)   = fxp_mul32_Q27((*(pt_vec) - tmp2), *(pt_cos++));
+        pt_vec++;
+    }
+
+    *(pt_vec - 1)   <<= 1;
+
+}
+
+
+
+/*----------------------------------------------------------------------------
+; mdct_32
+----------------------------------------------------------------------------*/
+
+void mdct_32(Int32 vec[])
+{
+    Int i;
+    Int32 *pt_vec  = vec;
+    Int32 tmp1, tmp2;
+
+
+    const Int32 *pt_CosTable = CosTable_32;
+
+
+    for (i = 5; i != 0; i--)
+    {
+        *(pt_vec) = fxp_mul32_Q31(*(pt_vec) << 1, *(pt_CosTable++));
+        pt_vec++;
+        *(pt_vec) = fxp_mul32_Q31(*(pt_vec) << 1, *(pt_CosTable++));
+        pt_vec++;
+        *(pt_vec) = fxp_mul32_Q31(*(pt_vec) << 1, *(pt_CosTable++));
+        pt_vec++;
+        *(pt_vec) = fxp_mul32_Q31(*(pt_vec) << 1, *(pt_CosTable++));
+        pt_vec++;
+    }
+    for (i = 3; i != 0; i--)
+    {
+        *(pt_vec) = fxp_mul32_Q27(*(pt_vec), *(pt_CosTable++));
+        pt_vec++;
+        *(pt_vec) = fxp_mul32_Q27(*(pt_vec), *(pt_CosTable++));
+        pt_vec++;
+        *(pt_vec) = fxp_mul32_Q27(*(pt_vec), *(pt_CosTable++));
+        pt_vec++;
+        *(pt_vec) = fxp_mul32_Q27(*(pt_vec), *(pt_CosTable++));
+        pt_vec++;
+    }
+    *(pt_vec - 1)   <<= 1;
+
+
+    dct_32(vec);
+
+
+    pt_vec  = &vec[31];
+
+    tmp1 = *(pt_vec--);
+
+    for (i = 5; i != 0; i--)
+    {
+        tmp2 = *(pt_vec);
+        *(pt_vec--)  += tmp1;
+        tmp1 = *(pt_vec);
+        *(pt_vec--)  += tmp2;
+        tmp2 = *(pt_vec);
+        *(pt_vec--)  += tmp1;
+        tmp1 = *(pt_vec);
+        *(pt_vec--)  += tmp2;
+        tmp2 = *(pt_vec);
+        *(pt_vec--)  += tmp1;
+        tmp1 = *(pt_vec);
+        *(pt_vec--)  += tmp2;
+    }
+
+    *(pt_vec)  += tmp1;
+
+}
+
+#endif /*  HQ_SBR  */
+
+
+/*----------------------------------------------------------------------------
+; dct_32
+----------------------------------------------------------------------------*/
+
+
+void dct_32(Int32 vec[])
+{
+
+    pv_split(&vec[16]);
+
+    dct_16(&vec[16], 0);
+    dct_16(vec, 1);     // Even terms
+
+    pv_merge_in_place_N32(vec);
+}
+
+#endif  /* AAC_PLUS */
+
+
diff --git a/media/libstagefright/codecs/aacdec/mdst.h b/media/libstagefright/codecs/aacdec/mdst.h
new file mode 100644
index 0000000..5b3e1c9
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/mdst.h
@@ -0,0 +1,73 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Pathname: mdst.h
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+ Who:                                       Date:
+ Description:
+------------------------------------------------------------------------------
+ INCLUDE DESCRIPTION
+
+------------------------------------------------------------------------------
+*/
+
+#ifndef MDST_H
+#define MDST_H
+
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+
+#include "pv_audio_type_defs.h"
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+    /*----------------------------------------------------------------------------
+    ; EXTERNAL VARIABLES REFERENCES
+    ----------------------------------------------------------------------------*/
+
+    /*----------------------------------------------------------------------------
+    ; DEFINES AND SIMPLE TYPEDEF'S
+    ----------------------------------------------------------------------------*/
+
+
+    void mdst_32(Int32 vec[], Int32 scratch_mem[]);
+
+    void  dct_32(Int32 vec[]);
+
+    void mdct_32(Int32 vec[]);
+
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif  /* MDST_H */
diff --git a/media/libstagefright/codecs/aacdec/mix_radix_fft.cpp b/media/libstagefright/codecs/aacdec/mix_radix_fft.cpp
new file mode 100644
index 0000000..6081c46
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/mix_radix_fft.cpp
@@ -0,0 +1,319 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Pathname: mix_radix_fft.c
+ Funtions: mix_radix_fft
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+ Description:  Eliminated pointer dependency ( pData_1) on Buffer address.
+               Modified for-loop to countdown loops.
+
+ Description:  No shift information going in/out from fft_rx4_long.
+
+ Description:
+            (1) Increased precision on the radix 2 fft coeff. (from Q10 to Q12)
+            (2) Increased precision on the input (from 0.5 to 1.0).
+            (3) Eliminated hardly used condition (exp = 0).
+            (4) Change interface to fft_rx4_long, so now the same function is
+                used for forward and inverse calculations.
+
+ Description:  per code review comments, eliminated unnecessary headers
+
+ Who:                       Date:
+ Description:
+
+------------------------------------------------------------------------------
+ INPUT AND OUTPUT DEFINITIONS
+
+ Inputs:
+    Data         = Input vector, with quantized spectral with a pre-rotation
+                   by exp(j(2pi/N)(k+1/8))
+                   type Int32 *
+
+    peak_value   = Input, carries the maximum value in input vector "Data"
+                   Output, maximum value computed in the first FFT, used
+                   to set precision on next stages
+                   type Int32 *
+
+
+ Local Stores/Buffers/Pointers Needed:
+    None
+
+ Global Stores/Buffers/Pointers Needed:
+    None
+
+ Outputs:
+    exponent = shift factor to reflect signal scaling
+
+ Pointers and Buffers Modified:
+    Results are return in "Data"
+
+ Local Stores Modified:
+    None
+
+ Global Stores Modified:
+    None
+------------------------------------------------------------------------------
+ FUNCTION DESCRIPTION
+
+    mix_radix_fft() mixes radix-2 and radix-4 FFT. This is needed to be able
+    to use power of 4 length when the input length sequence is a power of 2.
+------------------------------------------------------------------------------
+ REQUIREMENTS
+
+    mix_radix_fft() should support only the FFT for the long window case of
+    the inverse modified cosine transform (IMDCT)
+------------------------------------------------------------------------------
+ REFERENCES
+
+  ------------------------------------------------------------------------------
+ PSEUDO-CODE
+
+
+   MODIFY( x[] )
+   RETURN( exponent )
+
+------------------------------------------------------------------------------
+ RESOURCES USED
+   When the code is written for a specific target processor the
+     the resources used should be documented below.
+
+ STACK USAGE: [stack count for this module] + [variable to represent
+          stack usage for each subroutine called]
+
+     where: [stack usage variable] = stack usage for [subroutine
+         name] (see [filename].ext)
+
+ DATA MEMORY USED: x words
+
+ PROGRAM MEMORY USED: x words
+
+ CLOCK CYCLES: [cycle count equation for this module] + [variable
+           used to represent cycle count for each subroutine
+           called]
+
+     where: [cycle count variable] = cycle count for [subroutine
+        name] (see [filename].ext)
+
+------------------------------------------------------------------------------
+*/
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+
+#include "fft_rx4.h"
+#include "mix_radix_fft.h"
+#include "pv_normalize.h"
+
+#include "fxp_mul32.h"
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here. Include conditional
+; compile variables also.
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; LOCAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; LOCAL VARIABLE DEFINITIONS
+; Variable declaration - defined here and used outside this module
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL FUNCTION REFERENCES
+; Declare functions defined elsewhere and referenced in this module
+----------------------------------------------------------------------------*/
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+    void digit_reversal_swapping(Int32 *y, Int32 *x);
+
+#ifdef __cplusplus
+}
+#endif
+
+/*----------------------------------------------------------------------------
+; EXTERNAL VARIABLES REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL GLOBAL STORE/BUFFER/POINTER REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; FUNCTION CODE
+----------------------------------------------------------------------------*/
+
+Int mix_radix_fft(
+    Int32   *Data,
+    Int32   *peak_value
+)
+
+{
+
+    const Int32     *p_w;
+    Int32   *pData_1;
+    Int32   *pData_2;
+
+    Int32   *pData_3;
+    Int32   *pData_4;
+
+    Int32   exp_jw;
+    Int32   max1;
+    Int32   max2;
+    Int32   temp1;
+    Int32   temp2;
+    Int32   temp3;
+    Int32   temp4;
+    Int32   diff1;
+    Int32   diff2;
+    Int     i;
+    Int   exp;
+
+    max1 = *peak_value;
+    p_w  = w_512rx2;
+
+    pData_1 = Data;
+    pData_3 = Data + HALF_FFT_RX4_LENGTH_FOR_LONG;
+
+
+    /*
+     * normalization to 0.9999 (0x7FFF) guarantees proper operation
+     */
+
+    exp = 8 - pv_normalize(max1);   /* use 24 bits for mix radix fft */
+
+    if (exp < 4)
+    {
+        exp = 4;
+    }
+
+
+    temp1      = (*pData_3);
+    pData_4    = pData_3 + FFT_RX4_LENGTH_FOR_LONG;
+    temp2      = (*pData_4++);
+
+
+
+    diff1      = (temp1  - temp2) >> exp;
+    *pData_3++ = (temp1  + temp2) >> exp;
+
+    temp3      = (*pData_3);
+    temp4      = (*pData_4);
+
+    *pData_4-- = -diff1;
+    *pData_3++ = (temp3  + temp4) >> exp;
+    *pData_4   = (temp3  - temp4) >> exp;
+
+    temp1      = (*pData_1);
+    pData_2    = pData_1 + FFT_RX4_LENGTH_FOR_LONG;
+    temp2      = (*pData_2++);
+    temp4      = (*pData_2);
+
+    *pData_1++ = (temp1  + temp2) >> exp;
+
+    temp3      = (*pData_1);
+    diff1      = (temp1  - temp2) >> exp ;
+
+    *pData_1++ = (temp3  + temp4) >> exp;
+    *pData_2-- = (temp3  - temp4) >> exp;
+    *pData_2   =  diff1;
+
+    temp1      = (*pData_3);
+    pData_4    = pData_3 + FFT_RX4_LENGTH_FOR_LONG;
+    temp2      = (*pData_4++);
+
+
+    for (i = ONE_FOURTH_FFT_RX4_LENGTH_FOR_LONG - 1; i != 0; i--)
+    {
+        /*
+         * radix 2 Butterfly
+         */
+
+        diff1      = (temp1  - temp2) >> (exp - 4);
+        *pData_3++ = (temp1  + temp2) >> exp;
+
+        temp3      = (*pData_3);
+        temp4      = (*pData_4);
+
+        exp_jw     = *p_w++;
+
+
+        diff2      = (temp3  - temp4) >> (exp - 4);
+        *pData_3++ = (temp3  + temp4) >> exp;
+
+        *pData_4-- = -cmplx_mul32_by_16(diff1,  diff2, exp_jw) >> 3;
+        *pData_4   =  cmplx_mul32_by_16(diff2, -diff1, exp_jw) >> 3;
+
+
+        temp1      = (*pData_1);
+        pData_2    = pData_1 + FFT_RX4_LENGTH_FOR_LONG;
+        temp2      = (*pData_2++);
+        temp4      = (*pData_2);
+
+        *pData_1++ = (temp1  + temp2) >> exp;
+
+        temp3      = (*pData_1);
+        diff1      = (temp1  - temp2) >> (exp - 4);
+
+        diff2      = (temp3  - temp4) >> (exp - 4);
+        *pData_1++ = (temp3  + temp4) >> exp;
+
+        *pData_2-- =  cmplx_mul32_by_16(diff2, -diff1, exp_jw) >> 3;
+        *pData_2   =  cmplx_mul32_by_16(diff1,  diff2, exp_jw) >> 3;
+
+        temp1      = (*pData_3);
+        pData_4    = pData_3 + FFT_RX4_LENGTH_FOR_LONG;
+        temp2      = (*pData_4++);
+
+    }/* for i  */
+
+
+    fft_rx4_long(
+        Data,
+        &max1);
+
+
+    fft_rx4_long(
+        &Data[FFT_RX4_LENGTH_FOR_LONG],
+        &max2);
+
+    digit_reversal_swapping(Data, &Data[FFT_RX4_LENGTH_FOR_LONG]);
+
+    *peak_value = max1 | max2;
+
+    return(exp);
+}
+
diff --git a/media/libstagefright/codecs/aacdec/mix_radix_fft.h b/media/libstagefright/codecs/aacdec/mix_radix_fft.h
new file mode 100644
index 0000000..563c280
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/mix_radix_fft.h
@@ -0,0 +1,98 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Pathname: mix_radix_fft.h
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+ Who:                   Date:
+ Description:
+
+------------------------------------------------------------------------------
+ INCLUDE DESCRIPTION
+
+ Header file for functions mix_radix_fft
+
+------------------------------------------------------------------------------
+*/
+
+/*----------------------------------------------------------------------------
+; CONTINUE ONLY IF NOT ALREADY DEFINED
+----------------------------------------------------------------------------*/
+#ifndef MIX_RADIX_FFT_H
+#define MIX_RADIX_FFT_H
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+#include "pv_audio_type_defs.h"
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here.
+----------------------------------------------------------------------------*/
+#define     FFT_RX4_LENGTH_FOR_LONG         512
+#define     HALF_FFT_RX4_LENGTH_FOR_LONG    (FFT_RX4_LENGTH_FOR_LONG>>1)
+#define     ONE_FOURTH_FFT_RX4_LENGTH_FOR_LONG   (FFT_RX4_LENGTH_FOR_LONG>>2)
+
+/*----------------------------------------------------------------------------
+; EXTERNAL VARIABLES REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; SIMPLE TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; ENUMERATED TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; STRUCTURES TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; GLOBAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+    Int mix_radix_fft(
+        Int32   *Data,
+        Int32   *peak_value);
+
+#ifdef __cplusplus
+}
+#endif
+
+/*----------------------------------------------------------------------------
+; END
+----------------------------------------------------------------------------*/
+#endif  /* MIX_RADIX_FFT_H */
diff --git a/media/libstagefright/codecs/aacdec/ms_map_mask.h b/media/libstagefright/codecs/aacdec/ms_map_mask.h
new file mode 100644
index 0000000..fbbec78
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/ms_map_mask.h
@@ -0,0 +1,87 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+ Who:                       Date:
+ Description:
+
+------------------------------------------------------------------------------
+ INCLUDE DESCRIPTION
+
+ [Describe the contents of the include file.]
+
+------------------------------------------------------------------------------
+*/
+
+/*----------------------------------------------------------------------------
+; CONTINUE ONLY IF NOT ALREADY DEFINED
+----------------------------------------------------------------------------*/
+#ifndef MS_MAP_MASK_H
+#define MS_MAP_MASK_H
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here.
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL VARIABLES REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; SIMPLE TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+
+/*----------------------------------------------------------------------------
+; ENUMERATED TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; STRUCTURES TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; GLOBAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+void MS_map_mask(
+    FrameInfo  *info,
+    Int        *group,
+    Int        *mask,
+    Int        *cb_map);
+
+/*----------------------------------------------------------------------------
+; END
+----------------------------------------------------------------------------*/
+#endif
+
+
diff --git a/media/libstagefright/codecs/aacdec/ms_synt.cpp b/media/libstagefright/codecs/aacdec/ms_synt.cpp
new file mode 100644
index 0000000..1f25516
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/ms_synt.cpp
@@ -0,0 +1,403 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Pathname: ms_synt.c
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+ Description:  Modified from original shareware code
+
+ Description:  Cleaned up a bit, not finished.
+
+ Description:
+ Copied in code from pns_intensity_right.c, which has the same structure as
+ this file.  Also, merged in code from ms_map_mask.c
+
+ Description:
+ (1) Various optimizations (eliminated extra variables by making use of a
+ single temporary register throughout the code, etc.)
+ (2) Wrote pseudocode, pasted in correct function template, etc.
+
+ Description:  Unrolled loops to get speed up code
+
+------------------------------------------------------------------------------
+ INPUT AND OUTPUT DEFINITIONS
+
+ Inputs:
+    wins_in_group        = Number of windows in the current group.
+                           [const Int]
+
+    coef_per_win         = Number of coefficients per window.
+                           [const Int]
+
+    num_bands            = Number of scalefactor bands.
+                           [const Int]
+
+    band_length          = Number of coefficients per scalefactor band.
+                           [const Int]
+
+    pFirst_Window_CoefsL = Array containing the spectral coefficients for
+                           the left channel.
+                           [Int32 *, length LN]
+    pFirst_Window_CoefsR = Array containing the spectral coefficients for
+                           the right channel.
+                           [Int32 *, length LN]
+    q_formatLeft         = Array containing the q-format used to encode each
+                           scalefactor band's data on the left channel.
+                           [Int *, length MAXBANDS]
+    q_formatRight        = Array containing the q-format used to encode each
+                           scalefactor band's data on the right channel.
+                           [Int *, length MAXBANDS]
+
+ Local Stores/Buffers/Pointers Needed:
+    None
+
+ Global Stores/Buffers/Pointers Needed:
+    None
+
+ Outputs:
+    None
+
+ Pointers and Buffers Modified:
+   pFirst_Window_CoefsL  The coefficients in the group will be modified per the
+                         formula for M/S stereo on each scalefactor band where
+                         M/S stereo is active.
+
+   pFirst_Window_CoefsR  The coefficients in the group will be modified per the
+                         formula for M/S stereo on each scalefactor band where
+                         M/S stereo is active.
+
+   q_formatLeft          The q_format may be modified on scalefactor bands
+                         where M/S stereo is active.
+
+   q_formatRight         The q_format may be modified on scalefactor bands
+                         where M/S stereo is active.
+
+ Local Stores Modified:
+
+ Global Stores Modified:
+
+------------------------------------------------------------------------------
+ FUNCTION DESCRIPTION
+
+ This module applies the formula for M/S coding to one grouped scalefactor
+ band.  The ISO code has a similar function which applies M/S coding to an
+ entire frame.
+
+ It is the calling function's responsibility to check the map_mask array, which
+ is filled by the function getmask.  If a scalefactor band is identified as
+ using M/S stereo, the coefficients in that array are calculated using
+ the following formula...
+
+ TempLeft = LeftCoefficient;
+
+ LeftCoefficient  = LeftCoefficient  + RightCoefficient;
+ RightCoefficient = TempLeft         - RightCoefficient;
+
+ This function should be inlined if the compiler supports C99 inlining,
+ as this short function is only called by sfb_tools_ms().
+ Therefore, inlining will not increase the code size.
+
+------------------------------------------------------------------------------
+ REQUIREMENTS
+
+
+------------------------------------------------------------------------------
+ REFERENCES
+
+ (1) ISO/IEC 14496-3:1999(E)
+     Part 3
+        Subpart 4.6.7.1   M/S stereo
+        Subpart 4.6.2     ScaleFactors
+
+ (2) MPEG-2 NBC Audio Decoder
+   "This software module was originally developed by AT&T, Dolby
+   Laboratories, Fraunhofer Gesellschaft IIS in the course of development
+   of the MPEG-2 NBC/MPEG-4 Audio standard ISO/IEC 13818-7, 14496-1,2 and
+   3. This software module is an implementation of a part of one or more
+   MPEG-2 NBC/MPEG-4 Audio tools as specified by the MPEG-2 NBC/MPEG-4
+   Audio standard. ISO/IEC  gives users of the MPEG-2 NBC/MPEG-4 Audio
+   standards free license to this software module or modifications thereof
+   for use in hardware or software products claiming conformance to the
+   MPEG-2 NBC/MPEG-4 Audio  standards. Those intending to use this software
+   module in hardware or software products are advised that this use may
+   infringe existing patents. The original developer of this software
+   module and his/her company, the subsequent editors and their companies,
+   and ISO/IEC have no liability for use of this software module or
+   modifications thereof in an implementation. Copyright is not released
+   for non MPEG-2 NBC/MPEG-4 Audio conforming products.The original
+   developer retains full right to use the code for his/her  own purpose,
+   assign or donate the code to a third party and to inhibit third party
+   from using the code for non MPEG-2 NBC/MPEG-4 Audio conforming products.
+   This copyright notice must be included in all copies or derivative
+   works."
+   Copyright(c)1996.
+
+------------------------------------------------------------------------------
+ PSEUDO-CODE
+
+    start_indx = 0;
+
+    pCoefR = coefLeft;
+    pCoefL = coefRight;
+
+    FOR (win_indx = wins_in_group; win_indx > 0; win_indx--)
+
+
+        tempInt = q_formatLeft[start_indx] - q_formatRight[start_indx];
+
+        IF (tempInt > 0)
+        THEN
+
+            shift_left_chan  = 1 + tempInt;
+            shift_right_chan = 1;
+
+            q_formatLeft[start_indx]  = (q_formatRight[start_indx] - 1);
+            q_formatRight[start_indx] = (q_formatRight[start_indx] - 1);
+
+        ELSE
+            shift_left_chan  = 1;
+            shift_right_chan = 1 - tempInt;
+
+            q_formatRight[start_indx] = (q_formatLeft[start_indx] - 1);
+            q_formatLeft[start_indx]  = (q_formatLeft[start_indx] - 1);
+
+        ENDIF
+
+        FOR (tempInt = band_length; tempInt > 0; tempInt--)
+
+            temp_left  = *(pCoefL) >> shift_left_chan;
+            temp_right = *(pCoefR) >> shift_right_chan;
+
+            *(pCoefL++) = temp_left + temp_right;
+            *(pCoefR++) = temp_left - temp_right;
+
+        ENDFOR
+
+        tempInt = (coef_per_win - band_length);
+
+        pCoefR = pCoefR + tempInt;
+        pCoefL = pCoefL + tempInt;
+
+        start_indx = start_indx + num_bands;
+
+    ENDFOR
+
+------------------------------------------------------------------------------
+ RESOURCES USED
+   When the code is written for a specific target processor the
+   resources used should be documented below.
+
+ STACK USAGE: [stack count for this module] + [variable to represent
+          stack usage for each subroutine called]
+
+     where: [stack usage variable] = stack usage for [subroutine
+         name] (see [filename].ext)
+
+ DATA MEMORY USED: x words
+
+ PROGRAM MEMORY USED: x words
+
+ CLOCK CYCLES: [cycle count equation for this module] + [variable
+           used to represent cycle count for each subroutine
+           called]
+
+     where: [cycle count variable] = cycle count for [subroutine
+        name] (see [filename].ext)
+
+------------------------------------------------------------------------------
+*/
+
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+#include "pv_audio_type_defs.h"
+#include "ms_synt.h"
+#include "fxp_mul32.h"
+#include "aac_mem_funcs.h"
+#include "window_block_fxp.h"
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here. Include conditional
+; compile variables also.
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; LOCAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; LOCAL STORE/BUFFER/POINTER DEFINITIONS
+; Variable declaration - defined here and used outside this module
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL FUNCTION REFERENCES
+; Declare functions defined elsewhere and referenced in this module
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL GLOBAL STORE/BUFFER/POINTER REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; FUNCTION CODE
+----------------------------------------------------------------------------*/
+
+void ms_synt(
+    const Int   wins_in_group,
+    const Int   coef_per_win,
+    const Int   num_bands,
+    const Int   band_length,
+    Int32 coefLeft[],
+    Int32 coefRight[],
+    Int q_formatLeft[],
+    Int q_formatRight[])
+{
+
+    Int32 *pCoefL = coefLeft;
+    Int32 *pCoefR = coefRight;
+    Int start_indx = 0;
+
+
+    if (band_length < 0 || band_length > LONG_WINDOW)
+    {
+        return;     /*  avoid any processing on error condition */
+    }
+
+
+    Int nextWinPtrUpdate = (coef_per_win - band_length);
+
+    for (Int win_indx = wins_in_group; win_indx > 0; win_indx--)
+    {
+
+        if (q_formatRight[start_indx] < 31)
+        {
+            Int tempInt = q_formatLeft[start_indx] - q_formatRight[start_indx];
+
+            /* Normalize the left and right channel to the same q-format */
+            if (tempInt > 0)
+            {
+                /*
+                 * shift_left_chan and shift_right_chan each have an offset
+                 * of 1.  Even if the left and right channel share the same
+                 * q-format, we must shift each by 1 to guard against
+                 * overflow.
+                 */
+                Int shift_left_chan  = 1 + tempInt;
+
+                /*
+                 * Following code line is equivalent to...
+                 * q_formatLeft  = q_formatRight - 1;
+                 * q_formatRight = q_formatRight - 1;
+                 */
+                q_formatLeft[start_indx] = --(q_formatRight[start_indx]);
+
+
+                /*
+                 *  band_length is always an even number (check tables in pg.66 IS0 14496-3)
+                 */
+
+                Int32 temp_left  = *(pCoefL) >> shift_left_chan;
+                Int32 temp_right = *(pCoefR) >> 1;
+
+
+
+                for (Int i = band_length; i != 0; i--)
+                {
+                    *(pCoefL++) = temp_left + temp_right;
+                    *(pCoefR++) = temp_left - temp_right;
+                    temp_left  = *(pCoefL) >> shift_left_chan;
+                    temp_right = *(pCoefR) >> 1;
+
+                }
+
+            }
+            else
+            {
+                /*
+                 * shift_left_chan and shift_right_chan each have an offset
+                 * of 1.  Even if the left and right channel share the same
+                 * q-format, we must shift each by 1 to guard against
+                 * overflow.
+                 */
+                Int shift_right_chan = 1 - tempInt;
+
+                /*
+                 * Following code line is equivalent to...
+                 * q_formatRight = q_formatLeft - 1;
+                 * q_formatLeft  = q_formatLeft - 1;
+                 */
+                q_formatRight[start_indx] = --(q_formatLeft[start_indx]);
+
+                /*
+                 *  band_length is always an even number (check tables in pg.66 IS0 14496-3)
+                 */
+
+                Int32 temp_left  = *(pCoefL) >> 1;
+                Int32 temp_right = *(pCoefR) >> shift_right_chan;
+
+                for (Int i = band_length; i != 0; i--)
+                {
+                    *(pCoefL++) = temp_left + temp_right;
+                    *(pCoefR++) = temp_left - temp_right;
+
+                    temp_left  = *(pCoefL) >> 1;
+                    temp_right = *(pCoefR) >> shift_right_chan;
+
+                }
+            }
+
+        }
+        else
+        {
+            /*
+             *  Nothing on right channel, just copy left into right
+             */
+            q_formatRight[start_indx] = (q_formatLeft[start_indx]);
+
+            pv_memcpy(pCoefR, pCoefL, band_length*sizeof(*pCoefR));
+            pCoefR += band_length;
+            pCoefL += band_length;
+        }
+
+        /*
+         * Increment the window pointers so they point
+         * to the next window in the group
+         */
+        pCoefL += nextWinPtrUpdate;
+        pCoefR += nextWinPtrUpdate;
+
+        start_indx += num_bands;
+
+    } /* for (win_indx) */
+
+    return;
+
+} /* MS_synt */
diff --git a/media/libstagefright/codecs/aacdec/ms_synt.h b/media/libstagefright/codecs/aacdec/ms_synt.h
new file mode 100644
index 0000000..a00e6e2
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/ms_synt.h
@@ -0,0 +1,96 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Pathname: ms_synt.h
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+ Description:  Updated to reflect new functionality of ms_synt() routine.
+ (ms_synt now only decodes one grouped scalefactor band at a time.)
+
+ Who:                       Date:
+ Description:
+------------------------------------------------------------------------------
+ INCLUDE DESCRIPTION
+
+ This file includes the function declaration for ms_synt().
+
+------------------------------------------------------------------------------
+*/
+
+/*----------------------------------------------------------------------------
+; CONTINUE ONLY IF NOT ALREADY DEFINED
+----------------------------------------------------------------------------*/
+#ifndef MS_SYNT_H
+#define MS_SYNT_H
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+#include "pv_audio_type_defs.h"
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here.
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL VARIABLES REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; SIMPLE TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; ENUMERATED TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; STRUCTURES TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; GLOBAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+
+void ms_synt(
+    const Int   wins_in_group,
+    const Int   coef_per_win,
+    const Int   num_bands,
+    const Int   band_length,
+    Int32 spectralCoefLeft[],
+    Int32 spectralCoefRight[],
+    Int   q_formatLeft[],
+    Int   q_formatRight[]);
+
+/*----------------------------------------------------------------------------
+; END
+----------------------------------------------------------------------------*/
+#endif
+
+
diff --git a/media/libstagefright/codecs/aacdec/pns_corr.cpp b/media/libstagefright/codecs/aacdec/pns_corr.cpp
new file mode 100644
index 0000000..4cfe720
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/pns_corr.cpp
@@ -0,0 +1,342 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Pathname: pns_corr.c
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+ Description: Made changes per review comments, the most major of which
+ being the change of the scaling into a 16 x 16 multiply.
+
+ Description: When the multiplication of two 16-bits variables is stored in
+              an 32-bits variable, the result should be typecasted explicitly
+              to Int32 before it is stored.
+              *(pCoefRight++) = (Int32) tempInt2 * multiplier;
+
+ Who:                       Date:
+ Description:
+------------------------------------------------------------------------------
+ INPUT AND OUTPUT DEFINITIONS
+
+ Inputs:
+
+    scale        =  Multiplier used to scale the noise extracted from the left
+                    channel for use on the right.
+                    [const Int]
+
+    coef_per_win =  Number of coefficients per window.
+                    (128 for short, 1024 for long)
+                    [const Int]
+
+    sfb_per_win  =  Number of scalefactors per window.
+                    [const Int]
+
+    wins_in_group = The number of windows in the group being decoded.
+                    [const Int]
+
+    band_length  =  The length of the scalefactor band being decoded.
+                    [const Int]
+
+    sfb_prediction_used =  Flag that denotes the activation of long term
+                           prediction on a per-scalefactor band,
+                           non-grouped basis.
+                           [const Int *, length MAX_SFB]
+
+    q_formatLeft = The Q-format for the left channel's fixed-point spectral
+                   coefficients, on a per-scalefactor band, non-grouped basis.
+                   [const Int]
+
+    q_formatRight = The Q-format for the right channel's fixed-point spectral
+                    coefficients, on a per-scalefactor band, non-grouped basis.
+                    [Int *, length MAX_SFB]
+
+    coefLeft = Array containing the fixed-point spectral coefficients
+               for the left channel.
+               [const Int32 *, length 1024]
+
+    coefRight = Array containing the fixed-point spectral coefficients
+                for the right channel.
+                [Int32 *, length 1024]
+
+ Local Stores/Buffers/Pointers Needed:
+
+ Global Stores/Buffers/Pointers Needed:
+
+ Outputs:
+
+ Pointers and Buffers Modified:
+    pcoefRight  Contains the new spectral information
+
+    q_formatRight       Q-format may be updated with changed to fixed-point
+                        data in coefRight.
+
+    sfb_prediction_used              LTP may be disabled by presence of PNS tool on the
+                        same scalefactor band.
+
+ Local Stores Modified:
+
+ Global Stores Modified:
+
+------------------------------------------------------------------------------
+ FUNCTION DESCRIPTION
+
+ This function derives noise from the left channel.  The PNS tool is assumed
+ to have been used on the same scalefactor band on the left channel.  The
+ noise on the left/right channels are not necessarily of the same amplitude,
+ and therefore have separate scalefactors.  The noise is thus scaled by the
+ difference between the two transmitted scalefactors.  This scaling is done
+ in fixed-point using a constant 4-element table.
+
+------------------------------------------------------------------------------
+ REQUIREMENTS
+
+
+------------------------------------------------------------------------------
+ REFERENCES
+
+ (1) ISO/IEC 14496-3:1999(E)
+     Part 3
+        Subpart 4.6.7.1   M/S stereo
+        Subpart 4.6.12.3  Decoding Process (PNS)
+        Subpart 4.6.2     ScaleFactors
+
+ (2) MPEG-2 NBC Audio Decoder
+   "This software module was originally developed by AT&T, Dolby
+   Laboratories, Fraunhofer Gesellschaft IIS in the course of development
+   of the MPEG-2 NBC/MPEG-4 Audio standard ISO/IEC 13818-7, 14496-1,2 and
+   3. This software module is an implementation of a part of one or more
+   MPEG-2 NBC/MPEG-4 Audio tools as specified by the MPEG-2 NBC/MPEG-4
+   Audio standard. ISO/IEC  gives users of the MPEG-2 NBC/MPEG-4 Audio
+   standards free license to this software module or modifications thereof
+   for use in hardware or software products claiming conformance to the
+   MPEG-2 NBC/MPEG-4 Audio  standards. Those intending to use this software
+   module in hardware or software products are advised that this use may
+   infringe existing patents. The original developer of this software
+   module and his/her company, the subsequent editors and their companies,
+   and ISO/IEC have no liability for use of this software module or
+   modifications thereof in an implementation. Copyright is not released
+   for non MPEG-2 NBC/MPEG-4 Audio conforming products.The original
+   developer retains full right to use the code for his/her own purpose,
+   assign or donate the code to a third party and to inhibit third party
+   from using the code for non MPEG-2 NBC/MPEG-4 Audio conforming products.
+   This copyright notice must be included in all copies or derivative
+   works."
+   Copyright(c)1996.
+
+------------------------------------------------------------------------------
+ PSEUDO-CODE
+
+    q_format = q_formatLeft - (scale >> 2);
+    q_format = q_format - 1;
+    q_formatRight = q_format;
+
+    multiplier = hcb2_scale_mod_4[scale & 0x3];
+
+    pCoefLeft = coefLeft;
+    pCoefRight = coefRight;
+
+    start_indx = 0;
+
+    FOR (win_indx = wins_in_group; win_indx > 0; win_indx--)
+
+        q_formatRight[start_indx] = q_format;
+
+        sfb_prediction_used[start_indx] = FALSE;
+
+        start_indx = start_indx + sfb_per_win;
+
+        FOR (tempInt = band_length; tempInt > 0; tempInt--)
+
+            *(pCoefRight) = (*(pCoefLeft) >> 9) * multiplier;
+            pCoefRight = pCoefRight + 1;
+            pCoefLeft = pCoefLeft + 1;
+
+        ENDFOR
+
+        tempInt = (coef_per_win - band_length);
+        pCoefRight = pCoefRight + tempInt;
+        pCoefLeft = pCoefLeft + tempInt;
+
+    ENDFOR
+
+------------------------------------------------------------------------------
+ RESOURCES USED
+   When the code is written for a specific target processor the
+     resources used should be documented below.
+
+ STACK USAGE: [stack count for this module] + [variable to represent
+          stack usage for each subroutine called]
+
+     where: [stack usage variable] = stack usage for [subroutine
+         name] (see [filename].ext)
+
+ DATA MEMORY USED: x words
+
+ PROGRAM MEMORY USED: x words
+
+ CLOCK CYCLES: [cycle count equation for this module] + [variable
+           used to represent cycle count for each subroutine
+           called]
+
+     where: [cycle count variable] = cycle count for [subroutine
+        name] (see [filename].ext)
+
+------------------------------------------------------------------------------
+*/
+
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+#include "pv_audio_type_defs.h"
+#include "pns_corr.h"
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here. Include conditional
+; compile variables also.
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; LOCAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; LOCAL STORE/BUFFER/POINTER DEFINITIONS
+; Variable declaration - defined here and used outside this module
+----------------------------------------------------------------------------*/
+
+const UInt hcb2_scale_mod_4[4] =
+{
+    32768,  /* (2.0^0.00)*2^15 */
+    38968,  /* (2.0^0.25)*2^15 */
+    46341,  /* (2.0^0.50)*2^15 */
+    55109
+}; /* (2.0^0.75)*2^15 */
+
+/*----------------------------------------------------------------------------
+; EXTERNAL FUNCTION REFERENCES
+; Declare functions defined elsewhere and referenced in this module
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL GLOBAL STORE/BUFFER/POINTER REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; FUNCTION CODE
+----------------------------------------------------------------------------*/
+
+void pns_corr(
+    const Int scale,
+    const Int coef_per_win,
+    const Int sfb_per_win,
+    const Int wins_in_group,
+    const Int band_length,
+    const Int q_formatLeft,
+    Int q_formatRight[],
+    const Int32 coefLeft[],
+    Int32 coefRight[])
+{
+    Int tempInt;
+    Int nextWinPtrUpdate;
+
+    Int q_format;
+
+    Int start_indx;
+    Int win_indx;
+
+    const Int32   *pCoefLeft;
+    Int32   *pCoefRight;
+
+    UInt multiplier;
+
+    /*
+     * Generate noise correlated with the noise on the left channel
+     *
+     */
+
+    /*
+     * scale is interpreted as 2^(scale/4)
+     * Therefore, we can adjust the q-format by floor(scale/4)
+     * and save some complexity in the multiplier.
+     */
+    q_format = q_formatLeft - (scale >> 2);
+
+    /*
+     * Reduce the q-format by 1 to guard against overflow.
+     * This must be done because the hcb2_scale_mod_4 table
+     * must be stored in a common q-format, and we must shift
+     * by 16 to get *pCoefLeft into a 16-bit value, but we
+     * cannot store 2^0*2^16 and 2^0.75*2^16 in a table.
+     */
+    q_format--;
+
+    multiplier = hcb2_scale_mod_4[scale & 0x3];
+
+    pCoefLeft  = coefLeft;
+    pCoefRight = coefRight;
+
+    nextWinPtrUpdate = (coef_per_win - band_length);
+
+    /*
+     * Step through all the windows in this group, replacing this
+     * band in each window's spectrum with correlated random noise
+     */
+
+    start_indx = 0;
+
+    for (win_indx = wins_in_group; win_indx > 0; win_indx--)
+    {
+        /*
+         * Set the q-format for all scalefactor bands in the group.
+         * Normally, we could not assume that grouped scalefactors
+         * share the same q-format.
+         * However, here we can make this assumption.  The reason
+         * being -- if this function is called, it is assumed
+         * PNS was used on the left channel.  When PNS is used,
+         * all scalefactors in a group share the same q-format.
+         *
+         */
+        q_formatRight[start_indx] = q_format;
+
+        start_indx += sfb_per_win;
+
+        /* reconstruct right noise values */
+        for (tempInt = band_length; tempInt > 0; tempInt--)
+        {
+            *(pCoefRight++) = (Int32)(*(pCoefLeft++) >> 16) * multiplier;
+        }
+
+        pCoefRight += nextWinPtrUpdate;
+        pCoefLeft  += nextWinPtrUpdate;
+
+    } /* for (win_indx) */
+
+    return;
+
+} /* void pns_corr */
diff --git a/media/libstagefright/codecs/aacdec/pns_corr.h b/media/libstagefright/codecs/aacdec/pns_corr.h
new file mode 100644
index 0000000..c892a8c
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/pns_corr.h
@@ -0,0 +1,95 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Pathname: pns_corr.h
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+ Description: Made changes per review comments.
+
+ Who:                       Date:
+ Description:
+------------------------------------------------------------------------------
+ INCLUDE DESCRIPTION
+
+ Contains the function declaration for pns_corr.c
+------------------------------------------------------------------------------
+*/
+
+/*----------------------------------------------------------------------------
+; CONTINUE ONLY IF NOT ALREADY DEFINED
+----------------------------------------------------------------------------*/
+#ifndef PNS_CORR_H
+#define PNS_CORR_H
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+#include "pv_audio_type_defs.h"
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here.
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL VARIABLES REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; SIMPLE TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; ENUMERATED TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; STRUCTURES TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; GLOBAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+
+void pns_corr(
+    const Int scale,
+    const Int coef_per_win,
+    const Int sfb_per_win,
+    const Int wins_in_group,
+    const Int band_length,
+    const Int q_formatLeft,
+    Int q_formatRight[],
+    const Int32 coefLeft[],
+    Int32 coefRight[]);
+
+/*----------------------------------------------------------------------------
+; END
+----------------------------------------------------------------------------*/
+#endif
+
+
diff --git a/media/libstagefright/codecs/aacdec/pns_intensity_right.cpp b/media/libstagefright/codecs/aacdec/pns_intensity_right.cpp
new file mode 100644
index 0000000..f2d50c1
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/pns_intensity_right.cpp
@@ -0,0 +1,653 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Pathname: pns_intensity_right.c
+
+------------------------------------------------------------------------------
+ INPUT AND OUTPUT DEFINITIONS
+
+ Inputs:
+
+    hasmask    = mask status for the frame. Enumerated.
+
+    pFrameInfo = Pointer to structure that holds information about each group.
+                 (long block flag, number of windows, scalefactor bands
+                  per group, etc.)
+                 [const pFrameInfo * const]
+
+    group      = Array that contains indexes of the
+                 first window in the next group.
+                 [const Int *, length num_win]
+
+    mask_map   = Array that denotes whether M/S stereo is turned on for
+                 each grouped scalefactor band.
+                 [const Int *, length MAX_SFB]
+
+    codebook_map = Array that denotes which Huffman codebook was used for
+                   the encoding of each grouped scalefactor band.
+                   [const Int *, length MAX_SFB]
+
+    factorsL     =  Array of grouped scalefactors for left chan.
+                    [const Int *, length MAX_SFB]
+
+    factorsR     =  Array of scalefactors for right chan.
+                    [const Int *, length MAX_SFB]
+
+    sfb_prediction_used =  Flag that denotes the activation of long term prediction
+                           on a per-scalefactor band, non-grouped basis.
+                           [const Int *, length MAX_SFB]
+
+    ltp_data_present = Flag that indicates whether LTP is enbaled for this frame.
+                       [const Bool]
+
+    coefLeft = Array containing the fixed-point spectral coefficients
+                       for the left channel.
+                       [Int32 *, length 1024]
+
+    coefRight = Array containing the fixed-point spectral coefficients
+                        for the right channel.
+                        [Int32 *, length 1024]
+
+    q_formatLeft = The Q-format for the left channel's fixed-point spectral
+                   coefficients, on a per-scalefactor band, non-grouped basis.
+                   [Int *, length MAX_SFB]
+
+    q_formatRight = The Q-format for the right channel's fixed-point spectral
+                    coefficients, on a per-scalefactor band, non-grouped basis.
+                    [Int *, length MAX_SFB]
+
+    pCurrentSeed  = Pointer to the current seed for the random number
+                    generator in the function gen_rand_vector().
+                    [Int32 * const]
+
+ Local Stores/Buffers/Pointers Needed:
+    None
+
+ Global Stores/Buffers/Pointers Needed:
+    None
+
+ Outputs:
+    None
+
+ Pointers and Buffers Modified:
+    coefLeft  = Contains the new spectral information.
+
+    coefRight = Contains the new spectral information.
+
+    q_formatLeft      = Q-format may be updated with changed to fixed-point
+                        data in coefLeft.
+
+    q_formatRight     = Q-format may be updated with changed to fixed-point
+                        data in coefRight.
+
+    pCurrentSeed      = Value pointed to by pCurrentSeed updated by calls
+                        to gen_rand_vector().
+
+ Local Stores Modified:
+    None
+
+ Global Stores Modified:
+    None
+
+------------------------------------------------------------------------------
+ FUNCTION DESCRIPTION
+
+ This function steps through all of the scalefactor bands, looking for
+ either PNS or IS to be enabled on the right channel.
+
+ If the codebook used is >= NOISE_HCB, the code then checks for the use
+ of Huffman codebooks NOISE_HCB, INTENSITY_HCB, or INTENSITY_HCB2.
+
+ When a SFB utilizing the codebook NOISE_HCB is detected, a check is made to
+ see if M/S has also been enabled for that SFB.
+
+ If M/S is not enabled, the band's spectral information is filled with
+ scaled random data.   The scaled random data is generated by the function
+ gen_rand_vector.  This is done across all windows in the group.
+
+ If M/S is enabled, the band's spectral information is derived from the data
+ residing in the same band on the left channel.  The information on the right
+ channel has independent scaling, so this is a bit more involved than a
+ direct copy of the information on the left channel.  This is done by calling
+ the inline function pns_corr().
+
+ When a SFB utilizing an intensity codebook is detected, the band's spectral
+ information is generated from the information on the left channel.
+ This is done across all windows in the group.  M/S being enabled has the
+ effect of reversing the sign of the data on the right channel.  This code
+ resides in the inline function intensity_right().
+
+------------------------------------------------------------------------------
+ REQUIREMENTS
+
+
+------------------------------------------------------------------------------
+ REFERENCES
+
+ (1) ISO/IEC 14496-3:1999(E)
+     Part 3
+        Subpart 4.6.7.1   M/S stereo
+        Subpart 4.6.7.2.3 Decoding Process (Intensity Stereo)
+        Subpart 4.6.12.3  Decoding Process (PNS)
+        Subpart 4.6.2     ScaleFactors
+
+ (2) MPEG-2 NBC Audio Decoder
+   "This software module was originally developed by AT&T, Dolby
+   Laboratories, Fraunhofer Gesellschaft IIS in the course of development
+   of the MPEG-2 NBC/MPEG-4 Audio standard ISO/IEC 13818-7, 14496-1,2 and
+   3. This software module is an implementation of a part of one or more
+   MPEG-2 NBC/MPEG-4 Audio tools as specified by the MPEG-2 NBC/MPEG-4
+   Audio standard. ISO/IEC  gives users of the MPEG-2 NBC/MPEG-4 Audio
+   standards free license to this software module or modifications thereof
+   for use in hardware or software products claiming conformance to the
+   MPEG-2 NBC/MPEG-4 Audio  standards. Those intending to use this software
+   module in hardware or software products are advised that this use may
+   infringe existing patents. The original developer of this software
+   module and his/her company, the subsequent editors and their companies,
+   and ISO/IEC have no liability for use of this software module or
+   modifications thereof in an implementation. Copyright is not released
+   for non MPEG-2 NBC/MPEG-4 Audio conforming products.The original
+   developer retains full right to use the code for his/her own purpose,
+   assign or donate the code to a third party and to inhibit third party
+   from using the code for non MPEG-2 NBC/MPEG-4 Audio conforming products.
+   This copyright notice must be included in all copies or derivative
+   works."
+   Copyright(c)1996.
+
+------------------------------------------------------------------------------
+ PSEUDO-CODE
+    pCoefRight = coefRight;
+    pCoefLeft = coefLeft;
+
+    window_start = 0;
+    tot_sfb = 0;
+    start_indx = 0;
+
+    coef_per_win = pFrameInfo->coef_per_win[0];
+
+    sfb_per_win = pFrameInfo->sfb_per_win[0];
+
+    DO
+        pBand     = pFrameInfo->win_sfb_top[window_start];
+
+        partition = *pGroup;
+        pGroup = pGroup + 1;
+
+        band_start = 0;
+
+        wins_in_group = (partition - window_start);
+
+        FOR (sfb = sfb_per_win; sfb > 0; sfb--)
+
+            band_stop = *(pBand);
+            pBand = pBand + 1;
+
+            codebook = *(pCodebookMap);
+            pCodebookMap = pCodebookMap + 1;
+
+            mask_enabled = *(pMaskMap);
+            pMaskMap = pMaskMap + 1;
+
+            band_length = band_stop - band_start;
+
+            IF (codebook == NOISE_HCB)
+
+                sfb_prediction_used[tot_sfb] &= ltp_data_present;
+
+                IF (sfb_prediction_used[tot_sfb] == FALSE)
+
+                    mask_enabled = mask_enabled AND hasmask;
+
+                    IF (mask_enabled == FALSE)
+
+                        pWindow_CoefR = &(pCoefRight[band_start]);
+
+                        start_indx = tot_sfb;
+
+                        FOR (win_indx = wins_in_group;
+                             win_indx > 0;
+                             win_indx--)
+
+                            CALL
+                            q_formatRight[start_indx] =
+                                 gen_rand_vector(
+                                     pWindow_CoefR,
+                                     band_length,
+                                     pCurrentSeed,
+                                     *(pFactorsRight));
+                            MODIFYING
+                                pCoefRight[band_start]
+                            RETURNING
+                                q_formatRight[start_indx]
+
+                            pWindow_CoefR += coef_per_win;
+
+                            start_indx = start_indx + sfb_per_win;
+
+                        ENDFOR
+
+                    ELSE
+                        CALL
+                        pns_corr(
+                             (*(pFactorsRight) -
+                              *(pFactorsLeft) ),
+                             coef_per_win,
+                             sfb_per_win,
+                             wins_in_group,
+                             band_length,
+                             q_formatLeft[tot_sfb],
+                            &(q_formatRight[tot_sfb]),
+                            &(pCoefLeft[band_start]),
+                            &(pCoefRight[band_start]));
+
+                        MODIFYING
+                            pCoefRightt[band_start]
+                            q_formatRight[tot_sfb]
+                        RETURNING
+                NONE
+                    ENDIF
+
+                ENDIF
+
+            ELSE IF (codebook >= INTENSITY_HCB2)
+
+                mask_enabled = mask_enabled AND hasmask;
+
+                CALL
+                    intensity_right(
+                        *(pFactorsRight),
+                        coef_per_win,
+                        sfb_per_win,
+                        wins_in_group,
+                        band_length,
+                        codebook,
+                        mask_enabled,
+                       &(q_formatLeft[tot_sfb]),
+                       &(q_formatRight[tot_sfb]),
+                       &(pCoefLeft[band_start]),
+                       &(pCoefRight[band_start]));
+
+                MODIFYING
+                    pCoefRightt[band_start]
+                    q_formatRight[tot_sfb]
+                RETURNING
+                    NONE
+
+            ENDIF
+
+            band_start = band_stop;
+
+            tot_sfb = tot_sfb + 1;
+
+        ENDFOR
+
+        coef_per_win = coef_per_win * (wins_in_group);
+
+        wins_in_group = wins_in_group - 1;
+
+        tot_sfb = tot_sfb + sfb_per_win * wins_in_group;
+        pFactorsRight = pFactorsRight + sfb_per_win * wins_in_group;
+        pFactorsLeft  = pFactorsLeft + sfb_per_win * wins_in_group;
+
+        pCoefRight = pCoefRight + coef_per_win;
+        pCoefLeft  = pCoefLeft + coef_per_win;
+
+        window_start = partition;
+
+    WHILE (partition < pFrameInfo->num_win);
+
+    return;
+
+------------------------------------------------------------------------------
+ RESOURCES USED
+   When the code is written for a specific target processor the
+     resources used should be documented below.
+
+ STACK USAGE: [stack count for this module] + [variable to represent
+          stack usage for each subroutine called]
+
+     where: [stack usage variable] = stack usage for [subroutine
+         name] (see [filename].ext)
+
+ DATA MEMORY USED: x words
+
+ PROGRAM MEMORY USED: x words
+
+ CLOCK CYCLES: [cycle count equation for this module] + [variable
+           used to represent cycle count for each subroutine
+           called]
+
+     where: [cycle count variable] = cycle count for [subroutine
+        name] (see [filename].ext)
+
+------------------------------------------------------------------------------
+*/
+
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+#include "pv_audio_type_defs.h"
+#include "pns_intensity_right.h"
+#include "e_huffmanconst.h"
+#include "gen_rand_vector.h"
+#include "intensity_right.h"
+#include "pns_corr.h"
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here. Include conditional
+; compile variables also.
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; LOCAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; LOCAL STORE/BUFFER/POINTER DEFINITIONS
+; Variable declaration - defined here and used outside this module
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL FUNCTION REFERENCES
+; Declare functions defined elsewhere and referenced in this module
+----------------------------------------------------------------------------*/
+
+
+/*----------------------------------------------------------------------------
+; EXTERNAL GLOBAL STORE/BUFFER/POINTER REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; FUNCTION CODE
+----------------------------------------------------------------------------*/
+
+void pns_intensity_right(
+    const Int        hasmask,
+    const FrameInfo * const pFrameInfo,
+    const Int        group[],
+    const Bool       mask_map[],
+    const Int        codebook_map[],
+    const Int        factorsL[],
+    const Int        factorsR[],
+    Int        sfb_prediction_used[],
+    const Bool       ltp_data_present,
+    Int32      coefLeft[],
+    Int32      coefRight[],
+    Int        q_formatLeft[MAXBANDS],
+    Int        q_formatRight[MAXBANDS],
+    Int32 * const pCurrentSeed)
+{
+
+    Int32   *pCoefRight;
+    Int32   *pWindow_CoefR;
+
+    Int32   *pCoefLeft;
+
+    Int     tot_sfb;
+    Int     start_indx;
+    Int     sfb;
+
+    Int     band_length;
+    Int     band_start;
+    Int     band_stop;
+    Int     coef_per_win;
+
+    Int     codebook;
+    Int     partition;
+    Int     window_start;
+
+    Int     sfb_per_win;
+    Int     wins_in_group;
+    Int     win_indx;
+
+    const Int16 *pBand;
+    const Int   *pFactorsLeft  = factorsL;
+    const Int   *pFactorsRight = factorsR;
+    const Int   *pCodebookMap  = codebook_map;
+    const Int   *pGroup        = group;
+    const Bool  *pMaskMap      = mask_map;
+
+    Bool mask_enabled;
+
+    pCoefRight = coefRight;
+    pCoefLeft = coefLeft;
+
+    window_start = 0;
+    tot_sfb = 0;
+    start_indx = 0;
+
+    /*
+     * Each window in the frame should have the same number of coef's,
+     * so coef_per_win is constant in all the loops
+     */
+    coef_per_win = pFrameInfo->coef_per_win[0];
+
+    /*
+     * Because the number of scalefactor bands per window should be
+     * constant for each frame, sfb_per_win can be determined outside
+     * of the loop.
+     *
+     * For 44.1 kHz sampling rate   sfb_per_win = 14 for short windows
+     *                              sfb_per_win = 49 for long  windows
+     */
+
+    sfb_per_win = pFrameInfo->sfb_per_win[0];
+
+    do
+    {
+        pBand     = pFrameInfo->win_sfb_top[window_start];
+
+        /*----------------------------------------------------------
+        Partition is equal to the first window in the next group
+
+        { Group 0    }{      Group 1      }{    Group 2 }{Group 3}
+        [win 0][win 1][win 2][win 3][win 4][win 5][win 6][win 7]
+
+        pGroup[0] = 2
+        pGroup[1] = 5
+        pGroup[2] = 7
+        pGroup[3] = 8
+        -----------------------------------------------------------*/
+        partition = *(pGroup++);
+
+        band_start = 0;
+
+        wins_in_group = (partition - window_start);
+
+        for (sfb = sfb_per_win; sfb > 0; sfb--)
+        {
+            /* band is offset table, band_stop is last coef in band */
+            band_stop = *(pBand++);
+
+            codebook = *(pCodebookMap++);
+
+            mask_enabled = *(pMaskMap++);
+
+            /*
+             * When a tool utilizing sfb is found, apply the correct tool
+             * to that sfb in each window in the group
+             *
+             * Example...  sfb[3] == NOISE_HCB
+             *
+             * [ Group 1                                      ]
+             * [win 0                 ][win 1                 ]
+             * [0][1][2][X][4][5][6][7][0][1][2][X][4][5][6][7]
+             *
+             * The for(sfb) steps through the sfb's 0-7 in win 0.
+             *
+             * Finding sfb[3]'s codebook == NOISE_HCB, the code
+             * steps through all the windows in the group (they share
+             * the same scalefactors) and replaces that sfb with noise.
+             */
+
+            /*
+             * Experimental results suggest that ms_synt is the most
+             * commonly used tool, so check for it first.
+             *
+             */
+
+            band_length = band_stop - band_start;
+
+            if (codebook == NOISE_HCB)
+            {
+                sfb_prediction_used[tot_sfb] &= ltp_data_present;
+
+                if (sfb_prediction_used[tot_sfb] == FALSE)
+                {
+                    /*
+                     * The branch and the logical AND interact in the
+                     * following manner...
+                     *
+                     * mask_enabled == 0 hasmask == X -- gen_rand_vector
+                     * mask_enabled == 1 hasmask == 1 -- pns_corr
+                     * mask_enabled == 0 hasmask == 1 -- gen_rand_vector
+                     * mask_enabled == 1 hasmask == 2 -- gen_rand_vector
+                     * mask_enabled == 0 hasmask == 2 -- gen_rand_vector
+                     */
+
+                    mask_enabled &= hasmask;
+
+                    if (mask_enabled == FALSE)
+                    {
+                        pWindow_CoefR = &(pCoefRight[band_start]);
+
+                        /*
+                         * Step through all the windows in this group,
+                         * replacing this band in each window's
+                         * spectrum with random noise
+                         */
+                        start_indx = tot_sfb;
+
+                        for (win_indx = wins_in_group;
+                                win_indx > 0;
+                                win_indx--)
+                        {
+
+                            /* generate random noise */
+                            q_formatRight[start_indx] =
+                                gen_rand_vector(
+                                    pWindow_CoefR,
+                                    band_length,
+                                    pCurrentSeed,
+                                    *(pFactorsRight));
+
+                            pWindow_CoefR += coef_per_win;
+
+                            start_indx += sfb_per_win;
+                        }
+
+                    }
+                    else
+                    {
+                        pns_corr(
+                            (*(pFactorsRight) -
+                             *(pFactorsLeft)),
+                            coef_per_win,
+                            sfb_per_win,
+                            wins_in_group,
+                            band_length,
+                            q_formatLeft[tot_sfb],
+                            &(q_formatRight[tot_sfb]),
+                            &(pCoefLeft[band_start]),
+                            &(pCoefRight[band_start]));
+
+                    } /* if (mask_map == FALSE) */
+
+                } /* if (sfb_prediction_used[tot_sfb] == FALSE) */
+
+            } /* if (codebook == 0) */
+            else if (codebook >= INTENSITY_HCB2)
+            {
+                /*
+                 * The logical AND flags the inversion of intensity
+                 * in the following manner.
+                 *
+                 * mask_enabled == X hasmask == 0 -- DO NOT INVERT
+                 * mask_enabled == 0 hasmask == X -- DO NOT INVERT
+                 * mask_enabled == 1 hasmask == 1 -- DO     INVERT
+                 * mask_enabled == 0 hasmask == 1 -- DO NOT INVERT
+                 * mask_enabled == 1 hasmask == 2 -- DO NOT INVERT
+                 * mask_enabled == 0 hasmask == 2 -- DO NOT INVERT
+                 */
+
+                mask_enabled &= hasmask;
+
+                intensity_right(
+                    *(pFactorsRight),
+                    coef_per_win,
+                    sfb_per_win,
+                    wins_in_group,
+                    band_length,
+                    codebook,
+                    mask_enabled,
+                    &(q_formatLeft[tot_sfb]),
+                    &(q_formatRight[tot_sfb]),
+                    &(pCoefLeft[band_start]),
+                    &(pCoefRight[band_start]));
+
+            } /* END else codebook must be INTENSITY_HCB or ... */
+
+            band_start = band_stop;
+
+            tot_sfb++;
+
+            pFactorsLeft++;
+            pFactorsRight++;
+
+        } /* for (sfb) */
+
+        /*
+         * Increment pCoefRight and pCoefLeft by
+         * coef_per_win * the number of windows
+         */
+
+        pCoefRight += coef_per_win * wins_in_group;
+        pCoefLeft  += coef_per_win * wins_in_group--;
+
+        /*
+         * Increase tot_sfb by sfb_per_win times the number of windows minus 1.
+         * The minus 1 comes from the fact that tot_sfb is already pointing
+         * to the first sfb in the 2nd window of the group.
+         */
+        tot_sfb += sfb_per_win * wins_in_group;
+
+        pFactorsRight += sfb_per_win * wins_in_group;
+        pFactorsLeft  += sfb_per_win * wins_in_group;
+
+        window_start = partition;
+
+    }
+    while (partition < pFrameInfo->num_win);
+
+    /* pFrameInfo->num_win = 1 for long windows, 8 for short_windows */
+
+    return;
+
+} /* pns_intensity_right() */
+
+
diff --git a/media/libstagefright/codecs/aacdec/pns_intensity_right.h b/media/libstagefright/codecs/aacdec/pns_intensity_right.h
new file mode 100644
index 0000000..7b6f79f
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/pns_intensity_right.h
@@ -0,0 +1,106 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Pathname: pns_intensity_right.h
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+ Description: Add hasmask parameter
+
+ Description: Changed name to from right_ch_sfb_tools_ms to intensity_right
+ to more correct reflect the purpose of the function.
+
+ Who:                                  Date:
+ Description:
+
+------------------------------------------------------------------------------
+ INCLUDE DESCRIPTION
+
+ This include file contains the function declaration for
+ pns_intensity_right.c
+
+------------------------------------------------------------------------------
+*/
+
+/*----------------------------------------------------------------------------
+; CONTINUE ONLY IF NOT ALREADY DEFINED
+----------------------------------------------------------------------------*/
+#ifndef PNS_INTENSITY_RIGHT_H
+#define PNS_INTENSITY_RIGHT_H
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+#include    "pv_audio_type_defs.h"
+#include    "s_frameinfo.h"
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here.
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL VARIABLES REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; SIMPLE TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; ENUMERATED TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; STRUCTURES TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; GLOBAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+void pns_intensity_right(
+    const Int        hasmask,
+    const FrameInfo * const pFrameInfo,
+    const Int        group[],
+    const Bool       mask_map[],
+    const Int        codebook_map[],
+    const Int        factorsL[],
+    const Int        factorsR[],
+    Int        sfb_prediction_used[],
+    const Bool       ltp_data_present,
+    Int32      spectralCoefLeft[],
+    Int32      spectralCoefRight[],
+    Int        q_formatLeft[MAXBANDS],
+    Int        q_formatRight[MAXBANDS],
+    Int32     * const pCurrentSeed);
+
+/*----------------------------------------------------------------------------
+; END
+----------------------------------------------------------------------------*/
+#endif
+
+
diff --git a/media/libstagefright/codecs/aacdec/pns_left.cpp b/media/libstagefright/codecs/aacdec/pns_left.cpp
new file mode 100644
index 0000000..2446de2
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/pns_left.cpp
@@ -0,0 +1,431 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+ Pathname: pns_left.c
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+ Description:  Modified from original shareware code
+
+ Description:  Brought code in-line with PV standards.
+               Merged PNS and Intensity blocks into one function.
+               Modified routine to interface with a fixed-point implementation.
+               Modified variable names for clarity.
+               Improved for-loop structure that was previously checking
+               the codebook used in each scale factor band multiple times.
+
+ Description:  Added some comments for clarity.
+
+ Description:  Changed strategy for q-format.  Q-format for SFBs should not
+ be grouped.
+
+ Description: Function had to be modified to obey new interpretation of the
+ sfb_prediction_used flag.  LTP takes precedence, and PNS should not be
+ executed when a collision occurs between these two tools.
+
+ Description:
+ (1) Added flag "ltp_data_present"
+ (2) Where feasible, I updated the code to resemble right_ch_sfb_tools_ms.c
+     Just for conformance, readability.
+
+ Description: Added include file - "e_huffmanconst.h"
+
+ Description: The same "Factors" pointer indexing problem that existed in
+ right_ch_sfb_tools_ms also existed here in pns_left.c
+
+ Description:  Modified how groups and windows are handled, as the multigroup
+ case was not correct
+
+ Who:                       Date:
+ Description:
+------------------------------------------------------------------------------
+ INPUT AND OUTPUT DEFINITIONS
+
+ Inputs:
+
+    const FrameInfo *pFrameInfo         = Pointer to structure that holds
+                                          information about each group.
+                                          (long block flag,
+                                           number of windows,
+                                           scalefactor bands per group, etc.)
+
+    const Int        group[]            = Array that contains indexes of the
+                                          the first window in the next group.
+
+    const Int        codebook_map[]     = Array that denotes which Huffman
+                                          codebook was used for the encoding
+                                          of each scalefactor band.
+
+    const Int        factors[]          = Array of scalefactors
+
+    Int              sfb_prediction_used[] = Flag that denotes the activation
+                                             of long term prediction on a sfb
+                                             basis.
+
+    Bool             ltp_data_present   = Flag that denotes whether LTP
+                                          is active for the entire frame.  If
+                                          this flag is FALSE,
+                                          sfb_prediction_used is garbage.
+
+    Int32            spectral_coef[]    = Array of pointers pointing to the
+                                          spectral coef's for the LEFT channel.
+
+    Int              q_format[]           = Q-format for the information
+                                            pointed to by spectral_coef.
+                                            Indexed by scalefactor band.
+
+    Int32           *pCurrentSeed         = Pointer to the current seed for the
+                                            random number generator.
+                                            (gen_rand_vector)
+
+ Local Stores/Buffers/Pointers Needed:
+
+ Global Stores/Buffers/Pointers Needed:
+
+ Outputs:
+
+ Pointers and Buffers Modified:
+    Int32  spectral_coef[]    =   Contains the new spectral information
+
+ Local Stores Modified:
+
+ Global Stores Modified:
+
+------------------------------------------------------------------------------
+ FUNCTION DESCRIPTION
+
+ The function steps through each scalefactor band in the group, and
+ checks for the use of Huffman codebook NOISE_HCB.
+
+ When a SFB utilizing NOISE_HCB is detected, the band in every window in the
+ group has its spectral information filled with scaled random data.
+
+ The scaled random data is generated by the function gen_rand_vector.
+
+------------------------------------------------------------------------------
+ REQUIREMENTS
+
+ This module shall replace bands that were encoded with the Huffman codebook
+ NOISE_HCB with random noise as returned from gen_rand_vector().  The result
+ shall be perceptually indistinguishable from the result obtained by the
+ ISO decoder.
+
+------------------------------------------------------------------------------
+ REFERENCES
+
+ (1) ISO/IEC 14496-3:1999(E)
+     Part 3
+        Subpart 4.5.5   Figures
+        Subpart 4.6.2   ScaleFactors
+        Subpart 4.6.12  Perceptual Noise Substituion (PNS)
+
+ (2) MPEG-2 NBC Audio Decoder
+   "This software module was originally developed by AT&T, Dolby
+   Laboratories, Fraunhofer Gesellschaft IIS in the course of development
+   of the MPEG-2 NBC/MPEG-4 Audio standard ISO/IEC 13818-7, 14496-1,2 and
+   3. This software module is an implementation of a part of one or more
+   MPEG-2 NBC/MPEG-4 Audio tools as specified by the MPEG-2 NBC/MPEG-4
+   Audio standard. ISO/IEC  gives users of the MPEG-2 NBC/MPEG-4 Audio
+   standards free license to this software module or modifications thereof
+   for use in hardware or software products claiming conformance to the
+   MPEG-2 NBC/MPEG-4 Audio  standards. Those intending to use this software
+   module in hardware or software products are advised that this use may
+   infringe existing patents. The original developer of this software
+   module and his/her company, the subsequent editors and their companies,
+   and ISO/IEC have no liability for use of this software module or
+   modifications thereof in an implementation. Copyright is not released
+   for non MPEG-2 NBC/MPEG-4 Audio conforming products.The original
+   developer retains full right to use the code for his/her own purpose,
+   assign or donate the code to a third party and to inhibit third party
+   from using the code for non MPEG-2 NBC/MPEG-4 Audio conforming products.
+   This copyright notice must be included in all copies or derivative
+   works."
+   Copyright(c)1996.
+
+------------------------------------------------------------------------------
+ PSEUDO-CODE
+
+    pFirst_Window_Coefs = spectral_coef;
+
+    window_start = 0;
+
+    tot_sfb = 0;
+
+    DO
+
+        num_bands = pFrameInfo->sfb_per_win[window_start];
+        pBand     = pFrameInfo->win_sfb_top[window_start];
+
+        partition = *(pGroup);
+        pGroup = pGroup + 1;
+
+        band_start = 0;
+
+        coef_per_win = pFrameInfo->coef_per_win[window_start];
+
+        wins_in_group = (partition - window_start);
+
+        FOR (sfb = num_bands; sfb > 0; sfb--)
+
+            band_stop = *pBand;
+            pBand = pBand + 1;
+
+            IF (*(pCodebookMap++) == NOISE_HCB )
+
+                tempInt = sfb_prediction_used[tot_sfb] AND ltp_data_present;
+
+                IF (tempInt == FALSE)
+
+                    pWindow_Coef = pFirst_Window_Coefs + band_start;
+
+                    band_length = (band_stop - band_start);
+
+                    start_indx = tot_sfb;
+
+                    tempInt = *(pFactors);
+
+                    FOR (win_indx = wins_in_group; win_indx > 0; win_indx--)
+
+                        CALL gen_rand_vector( pWindow_CoefR,
+                                              band_length,
+                                              pCurrentSeed,
+                                              tempInt);
+
+                        MODIFYING pWindow_CoefR = scaled random noise
+                                  pCurrentSeed  = current state of the random
+                                                  noise generator.
+
+                        RETURNING q_format[start_indx] = q-format for this sfb.
+
+                        pWindow_Coef = pWindow_Coef + coef_per_win;
+
+                        start_indx = start_indx +
+                                     pFrameInfo->sfb_per_win[win_indx];
+
+                    ENDFOR
+
+                ENDIF
+
+            ENDIF
+
+            band_start = band_stop;
+
+            tot_sfb = tot_sfb + 1;
+
+            pFactors = pFactors + 1;
+
+        ENDFOR
+
+        coef_per_win = coef_per_win * wins_in_group;
+        wins_in_group = wins_in_group - 1;
+
+        tot_sfb = tot_sfb + num_bands * wins_in_group;
+        pFactors = pFactors + num_bands * wins_in_group;
+
+        pFirst_Window_Coefs = pFirst_Window_Coefs + coef_per_win;
+
+        window_start = partition;
+
+    WHILE (partition < pFrameInfo->num_win);
+
+------------------------------------------------------------------------------
+ RESOURCES USED
+   When the code is written for a specific target processor the
+     the resources used should be documented below.
+
+ STACK USAGE: [stack count for this module] + [variable to represent
+          stack usage for each subroutine called]
+
+     where: [stack usage variable] = stack usage for [subroutine
+         name] (see [filename].ext)
+
+ DATA MEMORY USED: x words
+
+ PROGRAM MEMORY USED: x words
+
+ CLOCK CYCLES: [cycle count equation for this module] + [variable
+           used to represent cycle count for each subroutine
+           called]
+
+     where: [cycle count variable] = cycle count for [subroutine
+        name] (see [filename].ext)
+
+------------------------------------------------------------------------------
+*/
+
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+#include "pv_audio_type_defs.h"
+#include "pns_left.h"
+#include "e_huffmanconst.h"
+#include "gen_rand_vector.h"
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here. Include conditional
+; compile variables also.
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; LOCAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; LOCAL STORE/BUFFER/POINTER DEFINITIONS
+; Variable declaration - defined here and used outside this module
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL FUNCTION REFERENCES
+; Declare functions defined elsewhere and referenced in this module
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL GLOBAL STORE/BUFFER/POINTER REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; FUNCTION CODE
+----------------------------------------------------------------------------*/
+
+void pns_left(
+    const FrameInfo *pFrameInfo,
+    const Int        group[],
+    const Int        codebook_map[],
+    const Int        factors[],
+    const Int        sfb_prediction_used[],
+    const Bool       ltp_data_present,
+    Int32      spectral_coef[],
+    Int        q_format[],
+    Int32     *pCurrentSeed)
+{
+
+    Int     tot_sfb;
+    Int     start_indx;
+
+    Int     sfb;
+    Int     band_stop;
+
+    const Int16  *pBand;
+
+    const Int *pCodebookMap = &(codebook_map[0]);
+    const Int *pGroup   = &(group[0]);
+    const Int *pFactors = &(factors[0]);
+
+    Int     tempInt;
+    Int32  *pWindow_Coef;
+
+
+    Int32   *spec;
+
+    Int partition;
+    Int win_indx;
+
+    tot_sfb = 0;
+
+    spec = spectral_coef;
+
+    /* PNS goes by group */
+    win_indx = 0;
+    partition = 0;
+    do
+    {
+        Int num_bands = pFrameInfo->sfb_per_win[partition];
+        pBand = pFrameInfo->win_sfb_top[partition];
+
+        /*----------------------------------------------------------
+        Partition is equal to the first window in the next group
+
+        { Group 0    }{      Group 1      }{    Group 2 }{Group 3}
+        [win 0][win 1][win 2][win 3][win 4][win 5][win 6][win 7]
+
+        pGroup[0] = 2
+        pGroup[1] = 5
+        pGroup[2] = 7
+        pGroup[3] = 8
+        -----------------------------------------------------------*/
+
+        partition = *pGroup++;      /* partition = index of last sbk in group */
+
+        do
+        {
+            Int band_start = 0;
+            for (sfb = 0; sfb < num_bands; sfb++)
+            {
+                band_stop = pBand[sfb]; /* band is offset table, band_stop is last coef in band */
+
+                Int band_length =  band_stop - band_start;
+                if (pCodebookMap[sfb] == NOISE_HCB)
+                {
+
+                    tempInt = sfb_prediction_used[tot_sfb] & ltp_data_present;
+
+                    if (tempInt == FALSE)
+                    {
+                        /* generate random noise */
+                        pWindow_Coef = spec + band_start;
+
+                        tempInt = pFactors[sfb];
+
+                        start_indx = tot_sfb++;
+
+                        /* reconstruct noise substituted values */
+                        /* generate random noise */
+
+                        q_format[start_indx] = gen_rand_vector(pWindow_Coef,
+                                                               band_length,
+                                                               pCurrentSeed,
+                                                               tempInt);
+
+                    }   /* if (sfb_prediction_used[tot_sfb] == FALSE) */
+
+                }   /* if (*(pCodebookMap++) == NOISE_HCB) */
+                else
+                {
+                    tot_sfb ++;     /*  update absolute sfb counter  */
+                }
+
+                band_start = band_stop;
+
+            }   /* for (sfb) */
+
+            spec += pFrameInfo->coef_per_win[win_indx++];
+            pFactors += num_bands;
+
+        }
+        while (win_indx < partition);
+
+        pCodebookMap += pFrameInfo->sfb_per_win[win_indx-1];
+
+    }
+    while (partition < pFrameInfo->num_win);
+
+
+    return;
+
+} /* pns */
diff --git a/media/libstagefright/codecs/aacdec/pns_left.h b/media/libstagefright/codecs/aacdec/pns_left.h
new file mode 100644
index 0000000..c44b13c
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/pns_left.h
@@ -0,0 +1,113 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Pathname: pns_left.h
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+ Description: Removed #defines of LEFT and RIGHT, and the extra include
+ file "e_huffmanconst.h"
+
+ Who:                       Date:
+ Description:
+------------------------------------------------------------------------------
+ INCLUDE DESCRIPTION
+
+ Contains the function definition for pns_left.c
+
+------------------------------------------------------------------------------
+*/
+
+/*----------------------------------------------------------------------------
+; CONTINUE ONLY IF NOT ALREADY DEFINED
+----------------------------------------------------------------------------*/
+#ifndef PNS_LEFT_H
+#define PNS_LEFT_H
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+#include "pv_audio_type_defs.h"
+#include "s_frameinfo.h"
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here.
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL VARIABLES REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; SIMPLE TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; ENUMERATED TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; STRUCTURES TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; GLOBAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+    void pns_left(
+        const FrameInfo *pFrameInfo,
+        const Int        group[],
+        const Int        codebook_map[],
+        const Int        factors[],
+        const Int        sfb_prediction_used[],
+        const Bool       ltp_data_present,
+        Int32      spectral_coef[],
+        Int        q_format[],
+        Int32     *pCurrentSeed);
+
+#ifdef __cplusplus
+}
+#endif
+
+/*----------------------------------------------------------------------------
+; END
+----------------------------------------------------------------------------*/
+#endif
+
+
+
+
+
+
+
+
diff --git a/media/libstagefright/codecs/aacdec/ps_all_pass_filter_coeff.cpp b/media/libstagefright/codecs/aacdec/ps_all_pass_filter_coeff.cpp
new file mode 100644
index 0000000..48432f8
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/ps_all_pass_filter_coeff.cpp
@@ -0,0 +1,311 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Filename: ps_all_pass_filter_coeff.c
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+
+ Who:                                   Date: MM/DD/YYYY
+ Description:
+
+------------------------------------------------------------------------------
+ INPUT AND OUTPUT DEFINITIONS
+
+
+
+------------------------------------------------------------------------------
+ FUNCTION DESCRIPTION
+
+  Decorrelation is achieved by means of all-pass filtering
+
+
+     _______                                              ________
+    |       |                                  _______   |        |
+  ->|Hybrid | LF ----                         |       |->| Hybrid |-->
+    | Anal. |        |                        |       |  | Synth  |   QMF -> L
+     -------         o----------------------->|       |   --------    Synth
+QMF                  |                s_k(n)  |Stereo |-------------->
+Anal.              -------------------------->|       |
+     _______       | |                        |       |   ________
+    |       | HF --o |   -----------          |Process|  |        |
+  ->| Delay |      |  ->|           |-------->|       |->| Hybrid |-->
+     -------       |    |decorrelate| d_k(n)  |       |  | Synth  |   QMF -> R
+                   ---->|           |-------->|       |   --------    Synth
+                         -----------          |_______|-------------->
+
+
+------------------------------------------------------------------------------
+ REQUIREMENTS
+
+
+------------------------------------------------------------------------------
+ REFERENCES
+
+SC 29 Software Copyright Licencing Disclaimer:
+
+This software module was originally developed by
+  Coding Technologies
+
+and edited by
+  -
+
+in the course of development of the ISO/IEC 13818-7 and ISO/IEC 14496-3
+standards for reference purposes and its performance may not have been
+optimized. This software module is an implementation of one or more tools as
+specified by the ISO/IEC 13818-7 and ISO/IEC 14496-3 standards.
+ISO/IEC gives users free license to this software module or modifications
+thereof for use in products claiming conformance to audiovisual and
+image-coding related ITU Recommendations and/or ISO/IEC International
+Standards. ISO/IEC gives users the same free license to this software module or
+modifications thereof for research purposes and further ISO/IEC standardisation.
+Those intending to use this software module in products are advised that its
+use may infringe existing patents. ISO/IEC have no liability for use of this
+software module or modifications thereof. Copyright is not released for
+products that do not conform to audiovisual and image-coding related ITU
+Recommendations and/or ISO/IEC International Standards.
+The original developer retains full right to modify and use the code for its
+own purpose, assign or donate the code to a third party and to inhibit third
+parties from using the code for products that do not conform to audiovisual and
+image-coding related ITU Recommendations and/or ISO/IEC International Standards.
+This copyright notice must be included in all copies or derivative works.
+Copyright (c) ISO/IEC 2003.
+
+------------------------------------------------------------------------------
+ PSEUDO-CODE
+
+------------------------------------------------------------------------------
+*/
+
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+
+#ifdef AAC_PLUS
+
+#ifdef PARAMETRICSTEREO
+
+#include    "pv_audio_type_defs.h"
+#include    "s_ps_dec.h"
+#include    "ps_all_pass_filter_coeff.h"
+#include    "ps_all_pass_fract_delay_filter.h"
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here. Include conditional
+; compile variables also.
+----------------------------------------------------------------------------*/
+
+
+/*----------------------------------------------------------------------------
+; LOCAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; LOCAL STORE/BUFFER/POINTER DEFINITIONS
+; Variable declaration - defined here and used outside this module
+----------------------------------------------------------------------------*/
+
+
+/*----------------------------------------------------------------------------
+; EXTERNAL FUNCTION REFERENCES
+; Declare functions defined elsewhere and referenced in this module
+----------------------------------------------------------------------------*/
+
+
+const Int16 aRevLinkDecaySerCoeff[NO_ALLPASS_CHANNELS][NO_SERIAL_ALLPASS_LINKS] =
+{
+
+
+    { Qfmt15(0.74915491616071f),  Qfmt15(0.64942584030892f),  Qfmt15(0.56297290849050f) },
+    { Qfmt15(0.71658296328416f),  Qfmt15(0.62118993420853f),  Qfmt15(0.53849582551265f) },
+    { Qfmt15(0.68401101040761f),  Qfmt15(0.59295402810815f),  Qfmt15(0.51401874253480f) },
+    { Qfmt15(0.65143905753106f),  Qfmt15(0.56471812200776f),  Qfmt15(0.97908331911390f) },      /*  3  */
+    { Qfmt15(0.61886710465450f),  Qfmt15(0.53648221590737f),  Qfmt15(0.93012915315822f) },
+    { Qfmt15(0.58629515177795f),  Qfmt15(0.50824630980698f),  Qfmt15(0.88117498720252f) },
+    { Qfmt15(0.55372319890140f),  Qfmt15(0.48001040370660f),  Qfmt15(0.83222082124682f) },
+    { Qfmt15(0.52115124602484f),  Qfmt15(0.45177449760621f),  Qfmt15(0.78326665529112f) },
+    { Qfmt15(0.48857929314829f),  Qfmt15(0.42353859150582f),  Qfmt15(0.73431248933542f) },
+    { Qfmt15(0.45600734027174f),  Qfmt15(0.39530268540543f),  Qfmt15(0.68535832337974f) },
+    { Qfmt15(0.42343538739519f),  Qfmt15(0.36706677930504f),  Qfmt15(0.63640415742404f) },
+    { Qfmt15(0.39086343451863f),  Qfmt15(0.33883087320466f),  Qfmt15(0.58744999146834f) },
+    { Qfmt15(0.35829148164208f),  Qfmt15(0.31059496710427f),  Qfmt15(0.53849582551265f) },
+    { Qfmt15(0.32571952876553f),  Qfmt15(0.28235906100388f),  Qfmt15(0.48954165955695f) },
+    { Qfmt15(0.29314757588898f),  Qfmt15(0.25412315490349f),  Qfmt15(0.44058749360126f) },
+    { Qfmt15(0.26057562301242f),  Qfmt15(0.22588724880310f),  Qfmt15(0.39163332764556f) },
+    { Qfmt15(0.22800367013587f),  Qfmt15(0.19765134270272f),  Qfmt15(0.34267916168986f) },
+    { Qfmt15(0.19543171725932f),  Qfmt15(0.16941543660233f),  Qfmt15(0.29372499573418f) },
+    { Qfmt15(0.16285976438276f),  Qfmt15(0.14117953050194f),  Qfmt15(0.24477082977848f) },
+    { Qfmt15(0.13028781150621f),  Qfmt15(0.11294362440155f),  Qfmt15(0.19581666382278f) },
+    { Qfmt15(0.09771585862966f),  Qfmt15(0.08470771830116f),  Qfmt15(0.14686249786708f) },
+    { Qfmt15(0.06514390575311f),  Qfmt15(0.05647181220078f),  Qfmt15(0.09790833191140f) },
+    { Qfmt15(0.03257195287655f),  Qfmt15(0.02823590610039f),  Qfmt15(0.04895416595570f) }
+
+};
+
+
+
+
+
+const Char groupBorders[NO_IID_GROUPS + 1] =
+{
+    4,  5,  0,  1,  2,  3,  7,  6,   8,  9,  3,  4,
+    5,  6,  7,  8,  9,  11, 14, 18, 23, 35, 64
+};
+
+const Char bins2groupMap[NO_IID_GROUPS] =
+{
+    1, 0, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19
+};
+
+
+
+
+/*
+ *  q_phi = 0.39
+ *
+ *  cos(pi*([3:22]+0.5)*q_phi)
+ */
+
+
+/*
+ *  sin(-pi*([3:22]+0.5)*q_phi)
+ */
+
+
+const Int32 aFractDelayPhaseFactor[NO_QMF_ALLPASS_CHANNELS] =
+{
+    0xCB5474A9,  0x5BEC5914, 0x72F3C7B0, 0xF1F480C6, 0x8389E21E,
+    0xB9BA6AFC,  0x4CDB665C, 0x7A57DA5D, 0x06088024, 0x89BECF04,
+    0xA9DB5EAC,  0x3BE5711F, 0x7EB9EDF7, 0x19F582A9, 0x92DDBD1F,
+    0x9C1B5008,  0x29767919, 0x7FFC0203, 0x2D3F8843, 0x9EABACDF
+};
+
+/*
+ *  q(m) = { 0.43, 0.75, 0.347 }
+ *
+ *  cos(pi*([3:22]+0.5)*q(m))        cos(pi*([3:22]+0.5)'*q)
+ *
+ *  sin(-pi*([3:22]+0.5)*q(m))
+ *
+ */
+
+
+const Int32 aaFractDelayPhaseFactorSerQmf[NO_QMF_ALLPASS_CHANNELS][3] =
+{
+    { 0x02037FFC,  0xCF0489BE, 0x9BFB4FE0 },
+    { 0x7D5719F5,  0xCF047642, 0x18947D9E },
+    { 0x34AD8B57,  0x7642CF04, 0x7ABF244A },
+    { 0x99A4B325,  0x89BECF04, 0x58EFA3F1 },
+    { 0x9EAB5321,  0x30FC7642, 0xD77E8694 },
+    { 0x3BE5711F,  0x30FC89BE, 0x819CEBC7 },
+    { 0x7B77DE39,  0x89BE30FC, 0xB3A166B8 },
+    { 0xF9F88024,  0x764230FC, 0x37C57336 },
+    { 0x81E8E9FE,  0xCF0489BE, 0x7FF103D2 },
+    { 0xCF047642,  0xCF047642, 0x3E8B9052 },
+    { 0x68B9499A,  0x7642CF04, 0xB9E594E8 },
+    { 0x5EACA9DB,  0x89BECF04, 0x80A00CA5 },
+    { 0xC09590D1,  0x30FC7642, 0xD05276CA },
+    { 0x85A925A3,  0x30FC89BE, 0x53486134 },
+    { 0x0A0B7F9B,  0x89BE30FC, 0x7CB2E319 },
+    { 0x7EB91209,  0x764230FC, 0x20078412 },
+    { 0x2D3F8843,  0xCF0489BE, 0xA0ECAA4D },
+    { 0x9504B9BA,  0xCF047642, 0x880D2CAE },
+    { 0xA4145914,  0x7642CF04, 0xF0287F04 },
+    { 0x42E16D23,  0x89BECF04, 0x694C48C7 }
+};
+
+/*
+ *  Fractional delay vector
+ *
+ *  phi_fract(k) = exp(-j*pi*q_phi*f_center(k))       0<= k <= SUBQMF_GROUPS
+ *
+ *  q_phi = 0.39
+ *  f_center(k) frequency vector
+ *
+ *
+ *  f_center(k) = {0.5/4,  1.5/4,  2.5/4,  3.5/4,
+ *                -1.5/4, -0.5/4,
+ *                 3.5/2,  2.5/2,  4.5/2,  5.5/2};
+ */
+
+
+
+const Int32 aFractDelayPhaseFactorSubQmf[SUBQMF_GROUPS] =
+{
+    0x7E80EC79,  0x72BAC73D, 0x5C45A749, 0x3D398F97, 0x72BA38C3,
+    0x7E801387,  0xBA919478, 0x05068019, 0x895DCFF2, 0x834E1CE7,
+};
+
+
+
+
+
+/*
+ *  Fractional delay length matrix
+ *
+ *  Q_fract(k,m) = exp(-j*pi*q(m)*f_center(k))
+ *
+ *  q(m) = { 0.43, 0.75, 0.347 }
+ *  f_center(k) frequency vector
+ *
+ *
+ *  f_center(k) = { 0.5/4,  1.5/4,  2.5/4,  3.5/4,
+ *                 -1.5/4, -0.5/4,
+ *                  3.5/2,  2.5/2,  4.5/2,  5.5/2};
+ */
+
+const Int32 aaFractDelayPhaseFactorSerSubQmf[SUBQMF_GROUPS][3] =
+{
+
+    { 0x7E2EEA7D,  0x7A7DDAD8, 0x7ED0EE9D },
+    { 0x6FEDC1E5,  0x51349D0E, 0x7574CD1E },
+    { 0x5506A052,  0x0C8C809E, 0x636CAF62 },
+    { 0x3085898D,  0xC3A98F1D, 0x4A0D9799 },
+    { 0x6FED3E1B,  0x513462F2, 0x757432E2 },
+    { 0x7E2E1583,  0x7A7D2528, 0x7ED01163 },
+    { 0xA4C8A634,  0xB8E36A6E, 0xD5AF8732 },
+    { 0xF0F580E3,  0x8276E707, 0x1A7382C3 },
+    { 0x80ABF2F4,  0x471D6A6E, 0x9D2FAEA4 },
+    { 0x9478456F,  0x7D8AE707, 0x8152EDAB }
+};
+
+
+/*----------------------------------------------------------------------------
+; EXTERNAL GLOBAL STORE/BUFFER/POINTER REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; FUNCTION CODE
+----------------------------------------------------------------------------*/
+
+#endif
+
+
+#endif
+
diff --git a/media/libstagefright/codecs/aacdec/ps_all_pass_filter_coeff.h b/media/libstagefright/codecs/aacdec/ps_all_pass_filter_coeff.h
new file mode 100644
index 0000000..0358acb
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/ps_all_pass_filter_coeff.h
@@ -0,0 +1,105 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Pathname: ps_all_pass_filter_coeff.h
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+ Who:                   Date:
+ Description:
+
+------------------------------------------------------------------------------
+ INCLUDE DESCRIPTION
+
+ Header file for all pass filter coefficients
+
+------------------------------------------------------------------------------
+*/
+
+/*----------------------------------------------------------------------------
+; CONTINUE ONLY IF NOT ALREADY DEFINED
+----------------------------------------------------------------------------*/
+#ifndef PS_ALL_PASS_FILTER_COEFF_H
+#define PS_ALL_PASS_FILTER_COEFF_H
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+#include "pv_audio_type_defs.h"
+#include "s_ps_dec.h"
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here.
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL VARIABLES REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+
+extern const Char groupBorders[NO_IID_GROUPS + 1];
+extern const Int16 aRevLinkDecaySerCoeff[NO_ALLPASS_CHANNELS][NO_SERIAL_ALLPASS_LINKS];
+extern const Int32  aRevLinkDelaySer[];
+extern const Int16 aFractDelayPhaseFactorReQmf[NO_QMF_ALLPASS_CHANNELS];
+extern const Int16 aFractDelayPhaseFactorImQmf[NO_QMF_ALLPASS_CHANNELS];
+/* the old center frequencies (found in "else") were too small (factor 1/2) */
+extern const Int16 aFractDelayPhaseFactorReSubQmf[SUBQMF_GROUPS];
+extern const Int16 aFractDelayPhaseFactorImSubQmf[SUBQMF_GROUPS];
+extern const Int32 aFractDelayPhaseFactorSubQmf[SUBQMF_GROUPS];
+extern const Int32 aFractDelayPhaseFactor[NO_QMF_ALLPASS_CHANNELS];
+extern const Int32 aaFractDelayPhaseFactorSerQmf[NO_QMF_ALLPASS_CHANNELS][3];
+extern const Int32 aaFractDelayPhaseFactorSerSubQmf[SUBQMF_GROUPS][3];
+extern const Char bins2groupMap[NO_IID_GROUPS];
+extern const Int32 aaFractDelayPhaseFactorSerReQmf[NO_QMF_ALLPASS_CHANNELS][3];
+extern const Int32 aaFractDelayPhaseFactorSerImQmf[NO_QMF_ALLPASS_CHANNELS][3];
+extern const Int32 aaFractDelayPhaseFactorSerReSubQmf[SUBQMF_GROUPS][3];
+extern const Int32 aaFractDelayPhaseFactorSerImSubQmf[SUBQMF_GROUPS][3];
+
+
+/*----------------------------------------------------------------------------
+; SIMPLE TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; ENUMERATED TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; STRUCTURES TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; GLOBAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+
+
+
+/*----------------------------------------------------------------------------
+; END
+----------------------------------------------------------------------------*/
+#endif  /* PS_ALL_PASS_FILTER_COEFF_H */
diff --git a/media/libstagefright/codecs/aacdec/ps_all_pass_fract_delay_filter.cpp b/media/libstagefright/codecs/aacdec/ps_all_pass_fract_delay_filter.cpp
new file mode 100644
index 0000000..81761a6
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/ps_all_pass_fract_delay_filter.cpp
@@ -0,0 +1,391 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Filename: ps_all_pass_fract_delay_filter.c
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+
+ Who:                                   Date: MM/DD/YYYY
+ Description:
+
+------------------------------------------------------------------------------
+ INPUT AND OUTPUT DEFINITIONS
+
+
+
+------------------------------------------------------------------------------
+ FUNCTION DESCRIPTION
+
+  Decorrelation
+  Decorrelation is achieved by means of all-pass filtering and delaying
+  Sub-band samples s_k(n) are converted into de-correlated sub-bands samples
+  d_k(n). k index for frequency, n time index
+
+
+     _______                                              ________
+    |       |                                  _______   |        |
+  ->|Hybrid | LF ----                         |       |->| Hybrid |-->
+    | Anal. |        |                        |       |  | Synth  |   QMF -> L
+     -------         o----------------------->|       |   --------    Synth
+QMF                  |                s_k(n)  |Stereo |-------------->
+Anal.              -------------------------->|       |
+     _______       | |                        |       |   ________
+    |       | HF --o |   -----------          |Process|  |        |
+  ->| Delay |      |  ->|           |-------->|       |->| Hybrid |-->
+     -------       |    |decorrelate| d_k(n)  |       |  | Synth  |   QMF -> R
+                   ---->|           |-------->|       |   --------    Synth
+                         -----------          |_______|-------------->
+
+
+  Delay is introduced to compensate QMF bands not passed through Hybrid
+  Analysis
+
+------------------------------------------------------------------------------
+ REQUIREMENTS
+
+
+------------------------------------------------------------------------------
+ REFERENCES
+
+SC 29 Software Copyright Licencing Disclaimer:
+
+This software module was originally developed by
+  Coding Technologies
+
+and edited by
+  -
+
+in the course of development of the ISO/IEC 13818-7 and ISO/IEC 14496-3
+standards for reference purposes and its performance may not have been
+optimized. This software module is an implementation of one or more tools as
+specified by the ISO/IEC 13818-7 and ISO/IEC 14496-3 standards.
+ISO/IEC gives users free license to this software module or modifications
+thereof for use in products claiming conformance to audiovisual and
+image-coding related ITU Recommendations and/or ISO/IEC International
+Standards. ISO/IEC gives users the same free license to this software module or
+modifications thereof for research purposes and further ISO/IEC standardisation.
+Those intending to use this software module in products are advised that its
+use may infringe existing patents. ISO/IEC have no liability for use of this
+software module or modifications thereof. Copyright is not released for
+products that do not conform to audiovisual and image-coding related ITU
+Recommendations and/or ISO/IEC International Standards.
+The original developer retains full right to modify and use the code for its
+own purpose, assign or donate the code to a third party and to inhibit third
+parties from using the code for products that do not conform to audiovisual and
+image-coding related ITU Recommendations and/or ISO/IEC International Standards.
+This copyright notice must be included in all copies or derivative works.
+Copyright (c) ISO/IEC 2003.
+
+------------------------------------------------------------------------------
+ PSEUDO-CODE
+
+------------------------------------------------------------------------------
+*/
+
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+
+#ifdef AAC_PLUS
+
+#ifdef PARAMETRICSTEREO
+
+#include    "pv_audio_type_defs.h"
+#include    "ps_decorrelate.h"
+#include    "aac_mem_funcs.h"
+#include    "ps_all_pass_filter_coeff.h"
+#include    "ps_pwr_transient_detection.h"
+#include    "ps_all_pass_fract_delay_filter.h"
+#include    "fxp_mul32.h"
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here. Include conditional
+; compile variables also.
+----------------------------------------------------------------------------*/
+
+
+/*----------------------------------------------------------------------------
+; LOCAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; LOCAL STORE/BUFFER/POINTER DEFINITIONS
+; Variable declaration - defined here and used outside this module
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL FUNCTION REFERENCES
+; Declare functions defined elsewhere and referenced in this module
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL GLOBAL STORE/BUFFER/POINTER REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+
+/*----------------------------------------------------------------------------
+; FUNCTION CODE
+----------------------------------------------------------------------------*/
+
+/*
+ *  For lower subbands
+ *  Apply all-pass filtering
+ *
+ */
+
+
+void ps_all_pass_fract_delay_filter_type_I(UInt32 *delayBufIndex,
+        Int32 sb_delay,
+        const Int32 *ppFractDelayPhaseFactorSer,
+        Int32 ***pppRealDelayRBufferSer,
+        Int32 ***pppImagDelayRBufferSer,
+        Int32 *rIn,
+        Int32 *iIn)
+{
+
+    Int32 cmplx;
+    Int16 rTmp0;
+    Int32 rTmp;
+    Int32 iTmp;
+    Int32 *pt_rTmp;
+    Int32 *pt_iTmp;
+
+
+
+    /*
+     *  All pass filters
+     *                         2
+     *                        ___  Q_fract(k,m)*z^(-d(m))  -  a(m)*g_decay_slope(k)
+     *   z^(-2)*phi_fract(k)* | |  ------------------------------------------------
+     *                        m=0  1  - a(m)*g_decay_slope(k)*Q_fract(k,m)*z^(-d(m))
+     *
+     *
+     *    Fractional delay matrix:
+     *
+     *    Q_fract(k,m) = exp(-j*pi*q(m)*f_center(k))       0<= k <= SUBQMF_GROUPS
+     *
+     *    Vectors: a(m), q(m), d(m) are constants
+     *
+     *    m                              m     0       1       2
+     *                                 -------------------------------
+     *    delay length                 d(m) == 3       4       5      (Fs > 32 KHz)
+     *    fractional delay length      q(m) == 0.43    0.75    0.347
+     *    filter coefficient           a(m) == 0.65144 0.56472 0.48954
+     *
+     *             g_decay_slope(k) is given
+     */
+
+
+    Int32 tmp_r;
+    Int32 tmp_i;
+
+    pt_rTmp = &pppRealDelayRBufferSer[0][*(delayBufIndex)][sb_delay];
+    pt_iTmp = &pppImagDelayRBufferSer[0][*(delayBufIndex++)][sb_delay];
+
+    cmplx  = *(ppFractDelayPhaseFactorSer++);        /* Q_fract(k,m)  */
+    tmp_r = *pt_rTmp << 1;
+    tmp_i = *pt_iTmp << 1;
+
+    rTmp = cmplx_mul32_by_16(tmp_r, -tmp_i,  cmplx);
+    rTmp0  = Qfmt15(0.65143905753106f);
+    iTmp = cmplx_mul32_by_16(tmp_i,  tmp_r,  cmplx);
+
+
+    iTmp     =  fxp_mac32_by_16(-*iIn << 1, rTmp0, iTmp);  /* Q_fract(k,m)*y(n-1) - a(m)*g_decay_slope(k)*x(n) */
+    *pt_iTmp =  fxp_mac32_by_16(iTmp << 1, rTmp0, *iIn);   /* y(n) = x(n) + a(m)*g_decay_slope(k)*( Q_fract(k,m)*y(n-1) - a(m)*g_decay_slope(k)*x(n)) */
+    *iIn = iTmp;
+
+    rTmp     =  fxp_mac32_by_16(-*rIn << 1, rTmp0, rTmp);
+    *pt_rTmp =  fxp_mac32_by_16(rTmp << 1, rTmp0, *rIn);
+
+    *rIn = rTmp;
+
+    pt_rTmp = &pppRealDelayRBufferSer[1][*(delayBufIndex)][sb_delay];
+    pt_iTmp = &pppImagDelayRBufferSer[1][*(delayBufIndex++)][sb_delay];
+
+
+
+    cmplx  = *(ppFractDelayPhaseFactorSer++);        /* Q_fract(k,m)  */
+    tmp_r = *pt_rTmp << 1;
+    tmp_i = *pt_iTmp << 1;
+
+    rTmp = cmplx_mul32_by_16(tmp_r, -tmp_i,  cmplx);
+    rTmp0  = Qfmt15(0.56471812200776f);
+    iTmp = cmplx_mul32_by_16(tmp_i,  tmp_r,  cmplx);
+
+
+    iTmp     =  fxp_mac32_by_16(-*iIn << 1, rTmp0, iTmp);  /* Q_fract(k,m)*y(n-1) - a(m)*g_decay_slope(k)*x(n) */
+    *pt_iTmp =  fxp_mac32_by_16(iTmp << 1, rTmp0, *iIn);   /* y(n) = x(n) + a(m)*g_decay_slope(k)*( Q_fract(k,m)*y(n-1) - a(m)*g_decay_slope(k)*x(n)) */
+    *iIn = iTmp;
+
+    rTmp     =  fxp_mac32_by_16(-*rIn << 1, rTmp0, rTmp);
+    *pt_rTmp =  fxp_mac32_by_16(rTmp << 1, rTmp0, *rIn);
+    *rIn = rTmp;
+
+    pt_rTmp = &pppRealDelayRBufferSer[2][*(delayBufIndex)][sb_delay];
+    pt_iTmp = &pppImagDelayRBufferSer[2][*(delayBufIndex)][sb_delay];
+
+
+    cmplx  = *(ppFractDelayPhaseFactorSer);        /* Q_fract(k,m)  */
+    tmp_r = *pt_rTmp << 1;
+    tmp_i = *pt_iTmp << 1;
+
+    rTmp = cmplx_mul32_by_16(tmp_r, -tmp_i,  cmplx);
+    rTmp0  = Qfmt15(0.97908331911390f);
+    iTmp = cmplx_mul32_by_16(tmp_i,  tmp_r,  cmplx);
+
+
+    iTmp     =  fxp_mac32_by_16(-*iIn, rTmp0, iTmp);    /* Q_fract(k,m)*y(n-1) - a(m)*g_decay_slope(k)*x(n) */
+    *pt_iTmp =  fxp_mac32_by_16(iTmp, rTmp0, *iIn);     /* y(n) = x(n) + a(m)*g_decay_slope(k)*( Q_fract(k,m)*y(n-1) - a(m)*g_decay_slope(k)*x(n)) */
+    *iIn = iTmp << 2;
+
+    rTmp     =  fxp_mac32_by_16(-*rIn, rTmp0, rTmp);
+    *pt_rTmp =  fxp_mac32_by_16(rTmp, rTmp0, *rIn);
+    *rIn = rTmp << 2;
+}
+
+
+void ps_all_pass_fract_delay_filter_type_II(UInt32 *delayBufIndex,
+        Int32 sb_delay,
+        const Int32 *ppFractDelayPhaseFactorSer,
+        Int32 ***pppRealDelayRBufferSer,
+        Int32 ***pppImagDelayRBufferSer,
+        Int32 *rIn,
+        Int32 *iIn,
+        Int32 decayScaleFactor)
+{
+
+    Int32 cmplx;
+    Int16 rTmp0;
+    Int32 rTmp;
+    Int32 iTmp;
+    Int32 *pt_rTmp;
+    Int32 *pt_iTmp;
+    const Int16 *pt_delay;
+
+
+
+    /*
+     *  All pass filters
+     *                         2
+     *                        ___  Q_fract(k,m)*z^(-d(m))  -  a(m)*g_decay_slope(k)
+     *   z^(-2)*phi_fract(k)* | |  ------------------------------------------------
+     *                        m=0  1  - a(m)*g_decay_slope(k)*Q_fract(k,m)*z^(-d(m))
+     *
+     *
+     *    Fractional delay matrix:
+     *
+     *    Q_fract(k,m) = exp(-j*pi*q(m)*f_center(k))       0<= k <= SUBQMF_GROUPS
+     *
+     *    Vectors: a(m), q(m), d(m) are constants
+     *
+     *    m                              m     0       1       2
+     *                                 -------------------------------
+     *    delay length                 d(m) == 3       4       5      (Fs > 32 KHz)
+     *    fractional delay length      q(m) == 0.43    0.75    0.347
+     *    filter coefficient           a(m) == 0.65144 0.56472 0.48954
+     *
+     *             g_decay_slope(k) is given
+     */
+
+
+    Int32 tmp_r;
+    Int32 tmp_i;
+
+    pt_rTmp = &pppRealDelayRBufferSer[0][*(delayBufIndex)][sb_delay];
+    pt_iTmp = &pppImagDelayRBufferSer[0][*(delayBufIndex++)][sb_delay];
+
+    cmplx  = *(ppFractDelayPhaseFactorSer++);        /* Q_fract(k,m)  */
+    pt_delay = aRevLinkDecaySerCoeff[decayScaleFactor];
+    tmp_r = *pt_rTmp << 1;
+    tmp_i = *pt_iTmp << 1;
+
+    rTmp = cmplx_mul32_by_16(tmp_r, -tmp_i,  cmplx);
+    rTmp0  = *(pt_delay++);
+    iTmp = cmplx_mul32_by_16(tmp_i,  tmp_r,  cmplx);
+
+
+    iTmp     =  fxp_mac32_by_16(-*iIn << 1, rTmp0, iTmp);  /* Q_fract(k,m)*y(n-1) - a(m)*g_decay_slope(k)*x(n) */
+    *pt_iTmp =  fxp_mac32_by_16(iTmp << 1, rTmp0, *iIn);   /* y(n) = x(n) + a(m)*g_decay_slope(k)*( Q_fract(k,m)*y(n-1) - a(m)*g_decay_slope(k)*x(n)) */
+    *iIn = iTmp;
+
+    rTmp     =  fxp_mac32_by_16(-*rIn << 1, rTmp0, rTmp);
+    *pt_rTmp =  fxp_mac32_by_16(rTmp << 1, rTmp0, *rIn);
+    *rIn = rTmp;
+
+    pt_rTmp = &pppRealDelayRBufferSer[1][*(delayBufIndex)][sb_delay];
+    pt_iTmp = &pppImagDelayRBufferSer[1][*(delayBufIndex++)][sb_delay];
+
+
+    cmplx  = *(ppFractDelayPhaseFactorSer++);        /* Q_fract(k,m)  */
+    tmp_r = *pt_rTmp << 1;
+    tmp_i = *pt_iTmp << 1;
+
+    rTmp = cmplx_mul32_by_16(tmp_r, -tmp_i,  cmplx);
+    rTmp0  = *(pt_delay++);
+    iTmp = cmplx_mul32_by_16(tmp_i,  tmp_r,  cmplx);
+    iTmp     =  fxp_mac32_by_16(-*iIn << 1, rTmp0, iTmp);  /* Q_fract(k,m)*y(n-1) - a(m)*g_decay_slope(k)*x(n) */
+    *pt_iTmp =  fxp_mac32_by_16(iTmp << 1, rTmp0, *iIn);   /* y(n) = x(n) + a(m)*g_decay_slope(k)*( Q_fract(k,m)*y(n-1) - a(m)*g_decay_slope(k)*x(n)) */
+    *iIn = iTmp;
+
+    rTmp     =  fxp_mac32_by_16(-*rIn << 1, rTmp0, rTmp);
+    *pt_rTmp =  fxp_mac32_by_16(rTmp << 1, rTmp0, *rIn);
+    *rIn = rTmp;
+
+    pt_rTmp = &pppRealDelayRBufferSer[2][*(delayBufIndex)][sb_delay];
+    pt_iTmp = &pppImagDelayRBufferSer[2][*(delayBufIndex)][sb_delay];
+
+
+    cmplx  = *(ppFractDelayPhaseFactorSer);        /* Q_fract(k,m)  */
+    tmp_r = *pt_rTmp << 1;
+    tmp_i = *pt_iTmp << 1;
+
+    rTmp = cmplx_mul32_by_16(tmp_r, -tmp_i,  cmplx);
+    rTmp0  = *(pt_delay);
+    iTmp = cmplx_mul32_by_16(tmp_i,  tmp_r,  cmplx);
+
+
+    iTmp     =  fxp_mac32_by_16(-*iIn, rTmp0, iTmp);    /* Q_fract(k,m)*y(n-1) - a(m)*g_decay_slope(k)*x(n) */
+    *pt_iTmp =  fxp_mac32_by_16(iTmp, rTmp0, *iIn);     /* y(n) = x(n) + a(m)*g_decay_slope(k)*( Q_fract(k,m)*y(n-1) - a(m)*g_decay_slope(k)*x(n)) */
+    *iIn = iTmp << 2;
+
+    rTmp     =  fxp_mac32_by_16(-*rIn, rTmp0, rTmp);
+    *pt_rTmp =  fxp_mac32_by_16(rTmp, rTmp0, *rIn);
+    *rIn = rTmp << 2;
+
+}
+
+
+
+#endif
+
+
+#endif
+
diff --git a/media/libstagefright/codecs/aacdec/ps_all_pass_fract_delay_filter.h b/media/libstagefright/codecs/aacdec/ps_all_pass_fract_delay_filter.h
new file mode 100644
index 0000000..b4e9876
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/ps_all_pass_fract_delay_filter.h
@@ -0,0 +1,117 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Pathname: ps_all_pass_fract_delay_filter.h
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+ Who:                   Date:
+ Description:
+
+------------------------------------------------------------------------------
+ INCLUDE DESCRIPTION
+
+ Header file for function ps_all_pass_fract_delay_filter()
+
+------------------------------------------------------------------------------
+*/
+
+/*----------------------------------------------------------------------------
+; CONTINUE ONLY IF NOT ALREADY DEFINED
+----------------------------------------------------------------------------*/
+#ifndef PS_ALL_PASS_FRACT_DELAY_FILTER_H
+#define PS_ALL_PASS_FRACT_DELAY_FILTER_H
+
+
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+#include "pv_audio_type_defs.h"
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here.
+----------------------------------------------------------------------------*/
+#define R_SHIFT     29
+#define Q29_fmt(x)   (Int32)(x*((Int32)1<<R_SHIFT) + (x>=0?0.5F:-0.5F))
+
+#define Qfmt15(x)   (Int16)(x*((Int32)1<<15) + (x>=0?0.5F:-0.5F))
+
+
+/*----------------------------------------------------------------------------
+; EXTERNAL VARIABLES REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; SIMPLE TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; ENUMERATED TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; STRUCTURES TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; GLOBAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+
+    void ps_all_pass_fract_delay_filter_type_I(UInt32 *delayBufIndex,
+    Int32 sb_delay,
+    const Int32 *ppFractDelayPhaseFactorSer,
+    Int32 ***pppRealDelayRBufferSer,
+    Int32 ***pppImagDelayRBufferSer,
+    Int32 *rIn,
+    Int32 *iIn);
+
+
+    void ps_all_pass_fract_delay_filter_type_II(UInt32 *delayBufIndex,
+            Int32 sb_delay,
+            const Int32 *ppFractDelayPhaseFactorSer,
+            Int32 ***pppRealDelayRBufferSer,
+            Int32 ***pppImagDelayRBufferSer,
+            Int32 *rIn,
+            Int32 *iIn,
+            Int32 decayScaleFactor);
+
+#ifdef __cplusplus
+}
+#endif
+
+
+/*----------------------------------------------------------------------------
+; END
+----------------------------------------------------------------------------*/
+#endif  /* PS_ALL_PASS_FRACT_DELAY_FILTER_H */
diff --git a/media/libstagefright/codecs/aacdec/ps_allocate_decoder.cpp b/media/libstagefright/codecs/aacdec/ps_allocate_decoder.cpp
new file mode 100644
index 0000000..ab15651
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/ps_allocate_decoder.cpp
@@ -0,0 +1,341 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Filename: ps_allocate_decoder.c
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+
+ Who:                                   Date: MM/DD/YYYY
+ Description:
+
+------------------------------------------------------------------------------
+ INPUT AND OUTPUT DEFINITIONS
+
+
+
+------------------------------------------------------------------------------
+ FUNCTION DESCRIPTION
+
+    Reuses AAC+ HQ right channel, which is not used when PS is enabled
+
+------------------------------------------------------------------------------
+ REQUIREMENTS
+
+
+------------------------------------------------------------------------------
+ REFERENCES
+
+SC 29 Software Copyright Licencing Disclaimer:
+
+This software module was originally developed by
+  Coding Technologies
+
+and edited by
+  -
+
+in the course of development of the ISO/IEC 13818-7 and ISO/IEC 14496-3
+standards for reference purposes and its performance may not have been
+optimized. This software module is an implementation of one or more tools as
+specified by the ISO/IEC 13818-7 and ISO/IEC 14496-3 standards.
+ISO/IEC gives users free license to this software module or modifications
+thereof for use in products claiming conformance to audiovisual and
+image-coding related ITU Recommendations and/or ISO/IEC International
+Standards. ISO/IEC gives users the same free license to this software module or
+modifications thereof for research purposes and further ISO/IEC standardisation.
+Those intending to use this software module in products are advised that its
+use may infringe existing patents. ISO/IEC have no liability for use of this
+software module or modifications thereof. Copyright is not released for
+products that do not conform to audiovisual and image-coding related ITU
+Recommendations and/or ISO/IEC International Standards.
+The original developer retains full right to modify and use the code for its
+own purpose, assign or donate the code to a third party and to inhibit third
+parties from using the code for products that do not conform to audiovisual and
+image-coding related ITU Recommendations and/or ISO/IEC International Standards.
+This copyright notice must be included in all copies or derivative works.
+Copyright (c) ISO/IEC 2003.
+
+------------------------------------------------------------------------------
+ PSEUDO-CODE
+
+------------------------------------------------------------------------------
+*/
+
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+
+#ifdef AAC_PLUS
+
+#ifdef HQ_SBR
+
+#ifdef PARAMETRICSTEREO
+
+#include    "s_sbr_channel.h"
+#include    "aac_mem_funcs.h"
+#include    "ps_hybrid_filter_bank_allocation.h"
+#include    "s_ps_dec.h"
+#include    "ps_all_pass_filter_coeff.h"
+#include    "ps_allocate_decoder.h"
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here. Include conditional
+; compile variables also.
+----------------------------------------------------------------------------*/
+
+#define R_SHIFT     30
+#define Q30_fmt(x)   (Int32)(x*((Int32)1<<R_SHIFT) + (x>=0?0.5F:-0.5F))
+
+/*----------------------------------------------------------------------------
+; LOCAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; LOCAL STORE/BUFFER/POINTER DEFINITIONS
+; Variable declaration - defined here and used outside this module
+----------------------------------------------------------------------------*/
+const Int32  aRevLinkDelaySer[] = {3,  4,  5};
+
+/*----------------------------------------------------------------------------
+; EXTERNAL FUNCTION REFERENCES
+; Declare functions defined elsewhere and referenced in this module
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL GLOBAL STORE/BUFFER/POINTER REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; FUNCTION CODE
+----------------------------------------------------------------------------*/
+
+Int32 ps_allocate_decoder(SBRDECODER_DATA *self,
+                          UInt32  noSubSamples)
+{
+    Int32 i, j;
+    Int32 status;
+
+    Int32 *ptr1;
+    Int32 *ptr2;
+    Int32 *ptr3;
+    Int32 *ptr4;
+    Int32 *ptr5;
+    Int32 *ptr6;
+    Int32 *ptr7;
+
+    const Int32 pHybridResolution[] = { HYBRID_8_CPLX,
+                                        HYBRID_2_REAL,
+                                        HYBRID_2_REAL
+                                      };
+
+    STRUCT_PS_DEC *h_ps_dec = self->hParametricStereoDec;
+
+    /* initialisation */
+    h_ps_dec->noSubSamples = noSubSamples;
+
+    h_ps_dec->invNoSubSamples = Q30_fmt(1.0f) / noSubSamples;
+
+    /*
+     *  Reuse AAC+ HQ right channel, which is not used when PS is enabled
+     */
+    ptr1 = (Int32 *)(self->SbrChannel[1].frameData.codecQmfBufferReal[0]);   /*  reuse un-used right channel QMF_FILTER Synthesis buffer */
+
+    ptr2 = (&ptr1[658]);  /*  reuse un-used right channel QMF_FILTER Synthesis buffer */
+    /* 1162 - 658 = 504
+     *            = NO_QMF_ALLPASS_CHANNELS*2 (Re&Im)*( 3 + 4 + 5) + ( 3 + 4 + 5)*2 (Re&Im)
+     */
+
+    ptr3 = (&ptr1[1162]);  /*  reuse un-used right channel QMF_FILTER Synthesis buffer */
+    /* 1426 - 1162 = 264
+     *            = SUBQMF_GROUPS*2 (Re&Im)*( 3 + 4 + 5) + ( 3 + 4 + 5)*2 (Re&Im)
+     */
+
+    ptr4 = (&ptr1[1426]);  /*  high freq generation buffers */
+
+    ptr5 = (&ptr1[1490]);  /*  high freq generation buffers */
+
+    ptr6 = (&ptr1[1618]);  /*  high freq generation buffers */
+
+    ptr7 = (&ptr1[1810]);  /*  high freq generation buffers */
+
+    /*  whole allocation requires 1871 words, sbrQmfBufferImag has 1920 words */
+
+
+    h_ps_dec->aPeakDecayFast =  ptr1;
+    ptr1 += NO_BINS;
+
+    h_ps_dec->aPrevNrg =  ptr1;
+    ptr1 += NO_BINS;
+
+    h_ps_dec->aPrevPeakDiff = ptr1;
+    ptr1 += NO_BINS;
+
+
+
+    status = ps_hybrid_filter_bank_allocation(&h_ps_dec->hHybrid,
+             NO_QMF_CHANNELS_IN_HYBRID,
+             pHybridResolution,
+             &ptr1);
+    h_ps_dec->mHybridRealLeft = ptr1;
+    ptr1 += SUBQMF_GROUPS;
+
+    h_ps_dec->mHybridImagLeft = ptr1;
+    ptr1 += SUBQMF_GROUPS;
+
+    h_ps_dec->mHybridRealRight = ptr1;
+    ptr1 += SUBQMF_GROUPS;
+
+    h_ps_dec->mHybridImagRight = ptr1;
+    ptr1 += SUBQMF_GROUPS;
+
+
+    h_ps_dec->delayBufIndex   = 0;
+
+
+
+    for (i = 0 ; i < NO_DELAY_CHANNELS ; i++)   /* 41  */
+    {
+        if (i < SHORT_DELAY_START)              /* 12  */
+        {
+            h_ps_dec->aNoSampleDelay[i] = LONG_DELAY;
+        }
+        else
+        {
+            h_ps_dec->aNoSampleDelay[i] = SHORT_DELAY;
+        }
+    }
+
+
+    h_ps_dec->aaRealDelayBufferQmf = (Int32 **)ptr6;
+    ptr6 += NO_QMF_ICC_CHANNELS * sizeof(Int32 *) / sizeof(Int32);
+
+    h_ps_dec->aaImagDelayBufferQmf = (Int32 **)ptr7;
+    ptr7 += NO_QMF_ICC_CHANNELS * sizeof(Int32 *) / sizeof(Int32);
+
+    h_ps_dec->aaRealDelayBufferSubQmf = (Int32 **)ptr1;
+    ptr1 += SUBQMF_GROUPS * sizeof(Int32 *) / sizeof(Int32);
+
+    h_ps_dec->aaImagDelayBufferSubQmf = (Int32 **)ptr1;
+    ptr1 += SUBQMF_GROUPS * sizeof(Int32 *) / sizeof(Int32);
+
+    for (i = 0; i < NO_QMF_ICC_CHANNELS; i++)   /* 61 */
+    {
+        int delay;
+
+        if (i < NO_QMF_ALLPASS_CHANNELS)    /* 20 */
+        {
+            delay = 2;
+            h_ps_dec->aaRealDelayBufferQmf[i] = (Int32 *)ptr4;
+            ptr4 += delay;
+
+            h_ps_dec->aaImagDelayBufferQmf[i] = (Int32 *)ptr5;
+            ptr5 += delay;
+        }
+        else
+        {
+
+            if (i >= (NO_QMF_ALLPASS_CHANNELS + SHORT_DELAY_START))
+            {
+                delay = SHORT_DELAY;
+            }
+            else
+            {
+                delay = LONG_DELAY;
+            }
+
+            h_ps_dec->aaRealDelayBufferQmf[i] = (Int32 *)ptr1;
+            ptr1 += delay;
+
+            h_ps_dec->aaImagDelayBufferQmf[i] = (Int32 *)ptr1;
+            ptr1 += delay;
+        }
+    }
+
+    for (i = 0; i < SUBQMF_GROUPS; i++)
+    {
+        h_ps_dec->aaRealDelayBufferSubQmf[i] = (Int32 *)ptr1;
+        ptr1 += DELAY_ALLPASS;
+
+        h_ps_dec->aaImagDelayBufferSubQmf[i] = (Int32 *)ptr1;
+        ptr1 += DELAY_ALLPASS;
+
+    }
+
+    for (i = 0 ; i < NO_SERIAL_ALLPASS_LINKS ; i++) /*  NO_SERIAL_ALLPASS_LINKS == 3 */
+    {
+
+        h_ps_dec->aDelayRBufIndexSer[i] = 0;
+
+        h_ps_dec->aaaRealDelayRBufferSerQmf[i] = (Int32 **)ptr2;
+        ptr2 += aRevLinkDelaySer[i];
+
+        h_ps_dec->aaaImagDelayRBufferSerQmf[i] = (Int32 **)ptr2;
+        ptr2 += aRevLinkDelaySer[i];
+
+        h_ps_dec->aaaRealDelayRBufferSerSubQmf[i] = (Int32 **)ptr3;
+        ptr3 += aRevLinkDelaySer[i];
+
+        h_ps_dec->aaaImagDelayRBufferSerSubQmf[i] = (Int32 **)ptr3;
+        ptr3 += aRevLinkDelaySer[i];
+
+        for (j = 0; j < aRevLinkDelaySer[i]; j++)
+        {
+            h_ps_dec->aaaRealDelayRBufferSerQmf[i][j] = ptr2;
+            ptr2 += NO_QMF_ALLPASS_CHANNELS;    /* NO_QMF_ALLPASS_CHANNELS == 20 */
+
+            h_ps_dec->aaaImagDelayRBufferSerQmf[i][j] = ptr2;
+            ptr2 += NO_QMF_ALLPASS_CHANNELS;
+
+            h_ps_dec->aaaRealDelayRBufferSerSubQmf[i][j] = ptr3;
+            ptr3 += SUBQMF_GROUPS;
+
+            h_ps_dec->aaaImagDelayRBufferSerSubQmf[i][j] = ptr3;
+            ptr3 += SUBQMF_GROUPS;
+
+        }
+    }
+
+
+    for (i = 0; i < NO_IID_GROUPS; i++)         /*  NO_IID_GROUPS == 22   */
+    {
+        h_ps_dec->h11Prev[i] = Q30_fmt(1.0f);
+        h_ps_dec->h12Prev[i] = Q30_fmt(1.0f);
+    }
+
+
+
+    return status;
+} /*END CreatePsDec*/
+#endif
+
+#endif
+
+
+#endif
+
diff --git a/media/libstagefright/codecs/aacdec/ps_allocate_decoder.h b/media/libstagefright/codecs/aacdec/ps_allocate_decoder.h
new file mode 100644
index 0000000..d5f152f
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/ps_allocate_decoder.h
@@ -0,0 +1,94 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Pathname: ps_allocate_decoder.h
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+ Who:                   Date:
+ Description:
+
+------------------------------------------------------------------------------
+ INCLUDE DESCRIPTION
+
+ Header file for function ps_allocate_decoder()
+
+------------------------------------------------------------------------------
+*/
+
+/*----------------------------------------------------------------------------
+; CONTINUE ONLY IF NOT ALREADY DEFINED
+----------------------------------------------------------------------------*/
+#ifndef PS_ALLOCATE_DECODER_H
+#define PS_ALLOCATE_DECODER_H
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+#include "pv_audio_type_defs.h"
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here.
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL VARIABLES REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; SIMPLE TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; ENUMERATED TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; STRUCTURES TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; GLOBAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+    Int32 ps_allocate_decoder(SBRDECODER_DATA *self,
+    UInt32  noSubSamples);
+
+#ifdef __cplusplus
+}
+#endif
+
+/*----------------------------------------------------------------------------
+; END
+----------------------------------------------------------------------------*/
+#endif  /* PS_ALLOCATE_DECODER_H */
diff --git a/media/libstagefright/codecs/aacdec/ps_applied.cpp b/media/libstagefright/codecs/aacdec/ps_applied.cpp
new file mode 100644
index 0000000..77fd8a7
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/ps_applied.cpp
@@ -0,0 +1,216 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Filename: ps_applied.c
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+
+ Who:                                   Date: MM/DD/YYYY
+ Description:
+
+------------------------------------------------------------------------------
+ INPUT AND OUTPUT DEFINITIONS
+
+
+
+------------------------------------------------------------------------------
+ FUNCTION DESCRIPTION
+
+        Applies Parametric Stereo Tool to a QMF-analized mono signal
+        providing a stereo image as output
+
+
+     _______                                              ________
+    |       |                                  _______   |        |
+  ->|Hybrid | LF ----                         |       |->| Hybrid |-->
+    | Anal. |        |                        |       |  | Synth  |   QMF -> L
+     -------         o----------------------->|       |   --------    Synth
+QMF                  |                s_k(n)  |Stereo |-------------->
+Anal.              -------------------------->|       |
+     _______       | |                        |       |   ________
+    |       | HF --o |   -----------          |Process|  |        |
+  ->| Delay |      |  ->|           |-------->|       |->| Hybrid |-->
+     -------       |    |decorrelate| d_k(n)  |       |  | Synth  |   QMF -> R
+                   ---->|           |-------->|       |   --------    Synth
+                         -----------          |_______|-------------->
+
+
+------------------------------------------------------------------------------
+ REQUIREMENTS
+
+
+------------------------------------------------------------------------------
+ REFERENCES
+
+SC 29 Software Copyright Licencing Disclaimer:
+
+This software module was originally developed by
+  Coding Technologies
+
+and edited by
+  -
+
+in the course of development of the ISO/IEC 13818-7 and ISO/IEC 14496-3
+standards for reference purposes and its performance may not have been
+optimized. This software module is an implementation of one or more tools as
+specified by the ISO/IEC 13818-7 and ISO/IEC 14496-3 standards.
+ISO/IEC gives users free license to this software module or modifications
+thereof for use in products claiming conformance to audiovisual and
+image-coding related ITU Recommendations and/or ISO/IEC International
+Standards. ISO/IEC gives users the same free license to this software module or
+modifications thereof for research purposes and further ISO/IEC standardisation.
+Those intending to use this software module in products are advised that its
+use may infringe existing patents. ISO/IEC have no liability for use of this
+software module or modifications thereof. Copyright is not released for
+products that do not conform to audiovisual and image-coding related ITU
+Recommendations and/or ISO/IEC International Standards.
+The original developer retains full right to modify and use the code for its
+own purpose, assign or donate the code to a third party and to inhibit third
+parties from using the code for products that do not conform to audiovisual and
+image-coding related ITU Recommendations and/or ISO/IEC International Standards.
+This copyright notice must be included in all copies or derivative works.
+Copyright (c) ISO/IEC 2003.
+
+------------------------------------------------------------------------------
+ PSEUDO-CODE
+
+------------------------------------------------------------------------------
+*/
+
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+
+#ifdef AAC_PLUS
+
+#ifdef PARAMETRICSTEREO
+#include    "aac_mem_funcs.h"
+#include    "ps_stereo_processing.h"
+#include    "ps_decorrelate.h"
+#include    "ps_hybrid_synthesis.h"
+#include    "ps_hybrid_analysis.h"
+#include    "ps_applied.h"
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here. Include conditional
+; compile variables also.
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; LOCAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; LOCAL STORE/BUFFER/POINTER DEFINITIONS
+; Variable declaration - defined here and used outside this module
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL FUNCTION REFERENCES
+; Declare functions defined elsewhere and referenced in this module
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL GLOBAL STORE/BUFFER/POINTER REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+
+/*----------------------------------------------------------------------------
+; FUNCTION CODE
+----------------------------------------------------------------------------*/
+
+void ps_applied(STRUCT_PS_DEC *h_ps_dec,
+                Int32 rIntBufferLeft[][64],
+                Int32 iIntBufferLeft[][64],
+                Int32 *rIntBufferRight,
+                Int32 *iIntBufferRight,
+                Int32 scratch_mem[],
+                Int32 band)
+
+{
+
+    /*
+     *  Get higher frequency resolution in the lower QMF subbands
+     *  creating sub-subbands
+     */
+    ps_hybrid_analysis(rIntBufferLeft,
+                       iIntBufferLeft,
+                       h_ps_dec->mHybridRealLeft,
+                       h_ps_dec->mHybridImagLeft,
+                       h_ps_dec->hHybrid,
+                       scratch_mem,
+                       band);
+
+    /*
+     *  By means of delaying and all-pass filtering, sub-subbands of
+     *  left ch. are decorrelate to creates right ch. sub-subbands
+     */
+
+    ps_decorrelate(h_ps_dec,
+                   *rIntBufferLeft,
+                   *iIntBufferLeft,
+                   rIntBufferRight,
+                   iIntBufferRight,
+                   scratch_mem);
+
+    /*
+     *  sub-subbands of left and right ch. are processed according to
+     *  stereo clues.
+     */
+
+    ps_stereo_processing(h_ps_dec,
+                         *rIntBufferLeft,
+                         *iIntBufferLeft,
+                         rIntBufferRight,
+                         iIntBufferRight);
+
+    /*
+     *  Reconstruct stereo signals
+     */
+
+    ps_hybrid_synthesis((const Int32*)h_ps_dec->mHybridRealLeft,
+                        (const Int32*)h_ps_dec->mHybridImagLeft,
+                        *rIntBufferLeft,
+                        *iIntBufferLeft,
+                        h_ps_dec->hHybrid);
+
+    ps_hybrid_synthesis((const Int32*)h_ps_dec->mHybridRealRight,
+                        (const Int32*)h_ps_dec->mHybridImagRight,
+                        rIntBufferRight,
+                        iIntBufferRight,
+                        h_ps_dec->hHybrid);
+
+}/* END ps_applied */
+#endif
+
+
+#endif
+
diff --git a/media/libstagefright/codecs/aacdec/ps_applied.h b/media/libstagefright/codecs/aacdec/ps_applied.h
new file mode 100644
index 0000000..231d9c3
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/ps_applied.h
@@ -0,0 +1,101 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Pathname: ps_applied.h
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+ Who:                   Date:
+ Description:
+
+------------------------------------------------------------------------------
+ INCLUDE DESCRIPTION
+
+ Header file for functions ps_applied()
+
+
+------------------------------------------------------------------------------
+*/
+
+/*----------------------------------------------------------------------------
+; CONTINUE ONLY IF NOT ALREADY DEFINED
+----------------------------------------------------------------------------*/
+#ifndef PS_APPLIED_H
+#define PS_APPLIED_H
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+#include "pv_audio_type_defs.h"
+#include "s_ps_dec.h"
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here.
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL VARIABLES REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; SIMPLE TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; ENUMERATED TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; STRUCTURES TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; GLOBAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+    void ps_applied(STRUCT_PS_DEC *h_ps_dec,
+    Int32 rIntBufferLeft[][64],
+    Int32 iIntBufferLeft[][64],
+    Int32 *rIntBufferRight,
+    Int32 *iIntBufferRight,
+    Int32 scratch_mem[],
+    Int32 band);
+
+#ifdef __cplusplus
+}
+#endif
+
+/*----------------------------------------------------------------------------
+; END
+----------------------------------------------------------------------------*/
+#endif  /* PS_APPLIED_H */
diff --git a/media/libstagefright/codecs/aacdec/ps_bstr_decoding.cpp b/media/libstagefright/codecs/aacdec/ps_bstr_decoding.cpp
new file mode 100644
index 0000000..c7ed60b
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/ps_bstr_decoding.cpp
@@ -0,0 +1,304 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Filename: ps_bstr_decoding.c
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+
+ Who:                                   Date: MM/DD/YYYY
+ Description:
+
+------------------------------------------------------------------------------
+ INPUT AND OUTPUT DEFINITIONS
+
+
+
+------------------------------------------------------------------------------
+ FUNCTION DESCRIPTION
+
+        Decodes parametric stereo
+
+------------------------------------------------------------------------------
+ REQUIREMENTS
+
+
+------------------------------------------------------------------------------
+ REFERENCES
+
+SC 29 Software Copyright Licencing Disclaimer:
+
+This software module was originally developed by
+  Coding Technologies
+
+and edited by
+  -
+
+in the course of development of the ISO/IEC 13818-7 and ISO/IEC 14496-3
+standards for reference purposes and its performance may not have been
+optimized. This software module is an implementation of one or more tools as
+specified by the ISO/IEC 13818-7 and ISO/IEC 14496-3 standards.
+ISO/IEC gives users free license to this software module or modifications
+thereof for use in products claiming conformance to audiovisual and
+image-coding related ITU Recommendations and/or ISO/IEC International
+Standards. ISO/IEC gives users the same free license to this software module or
+modifications thereof for research purposes and further ISO/IEC standardisation.
+Those intending to use this software module in products are advised that its
+use may infringe existing patents. ISO/IEC have no liability for use of this
+software module or modifications thereof. Copyright is not released for
+products that do not conform to audiovisual and image-coding related ITU
+Recommendations and/or ISO/IEC International Standards.
+The original developer retains full right to modify and use the code for its
+own purpose, assign or donate the code to a third party and to inhibit third
+parties from using the code for products that do not conform to audiovisual and
+image-coding related ITU Recommendations and/or ISO/IEC International Standards.
+This copyright notice must be included in all copies or derivative works.
+Copyright (c) ISO/IEC 2003.
+
+------------------------------------------------------------------------------
+ PSEUDO-CODE
+
+------------------------------------------------------------------------------
+*/
+
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+
+#ifdef AAC_PLUS
+
+#ifdef PARAMETRICSTEREO
+
+#include "pv_audio_type_defs.h"
+#include "aac_mem_funcs.h"
+#include "ps_bstr_decoding.h"
+#include "ps_decode_bs_utils.h"
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here. Include conditional
+; compile variables also.
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; LOCAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; LOCAL STORE/BUFFER/POINTER DEFINITIONS
+; Variable declaration - defined here and used outside this module
+----------------------------------------------------------------------------*/
+
+const Int32 aNoIidBins[3] = {NO_LOW_RES_IID_BINS, NO_IID_BINS, NO_HI_RES_BINS};
+const Int32 aNoIccBins[3] = {NO_LOW_RES_ICC_BINS, NO_ICC_BINS, NO_HI_RES_BINS};
+const Int32 aFixNoEnvDecode[4] = {0, 1, 2, 4};
+
+/*----------------------------------------------------------------------------
+; EXTERNAL FUNCTION REFERENCES
+; Declare functions defined elsewhere and referenced in this module
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL GLOBAL STORE/BUFFER/POINTER REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; FUNCTION CODE
+----------------------------------------------------------------------------*/
+
+void ps_bstr_decoding(STRUCT_PS_DEC *ps_dec)
+{
+    UInt32 env;
+    Int32 noIidSteps;
+
+    if (!ps_dec->bPsDataAvail)
+    {
+        ps_dec->noEnv = 0;
+    }
+
+    noIidSteps = ps_dec->bFineIidQ ? NO_IID_STEPS_FINE : NO_IID_STEPS;
+
+    for (env = 0; env < ps_dec->noEnv; env++)
+    {
+        Int32 *aPrevIidIndex;
+        Int32 *aPrevIccIndex;
+        if (env == 0)
+        {
+            aPrevIidIndex = ps_dec->aIidPrevFrameIndex;
+            aPrevIccIndex = ps_dec->aIccPrevFrameIndex;
+        }
+        else
+        {
+            aPrevIidIndex = ps_dec->aaIidIndex[env-1];
+            aPrevIccIndex = ps_dec->aaIccIndex[env-1];
+        }
+
+        /*
+         * Differential Decoding of IID parameters over time/frequency
+         */
+        differential_Decoding(ps_dec->bEnableIid,
+                              ps_dec->aaIidIndex[env],
+                              aPrevIidIndex,
+                              ps_dec->abIidDtFlag[env],
+                              aNoIidBins[ps_dec->freqResIid],
+                              (ps_dec->freqResIid) ? 1 : 2,
+                              -noIidSteps,
+                              noIidSteps);
+
+        /*
+         * Differential Decoding of ICC parameters over time/frequency
+         */
+        differential_Decoding(ps_dec->bEnableIcc,
+                              ps_dec->aaIccIndex[env],
+                              aPrevIccIndex,
+                              ps_dec->abIccDtFlag[env],
+                              aNoIccBins[ps_dec->freqResIcc],
+                              (ps_dec->freqResIcc) ? 1 : 2,
+                              0,
+                              NO_ICC_STEPS - 1);
+
+
+    }   /* for (env=0; env<ps_dec->noEnv; env++) */
+
+    if (ps_dec->noEnv == 0)
+    {
+        ps_dec->noEnv = 1;
+
+        if (ps_dec->bEnableIid)
+        {   /*  NO_HI_RES_BINS == 34 */
+            pv_memmove(ps_dec->aaIidIndex[ps_dec->noEnv-1],
+                       ps_dec->aIidPrevFrameIndex,
+                       NO_HI_RES_BINS*sizeof(*ps_dec->aIidPrevFrameIndex));
+
+        }
+        else
+        {
+            pv_memset((void *)ps_dec->aaIidIndex[ps_dec->noEnv-1],
+                      0,
+                      NO_HI_RES_BINS*sizeof(**ps_dec->aaIidIndex));
+        }
+        if (ps_dec->bEnableIcc)
+        {
+            pv_memmove(ps_dec->aaIccIndex[ps_dec->noEnv-1],
+                       ps_dec->aIccPrevFrameIndex,
+                       NO_HI_RES_BINS*sizeof(*ps_dec->aIccPrevFrameIndex));
+        }
+        else
+        {
+            pv_memset((void *)ps_dec->aaIccIndex[ps_dec->noEnv-1],
+                      0,
+                      NO_HI_RES_BINS*sizeof(**ps_dec->aaIccIndex));
+        }
+    }
+
+    pv_memmove(ps_dec->aIidPrevFrameIndex,
+               ps_dec->aaIidIndex[ps_dec->noEnv-1],
+               NO_HI_RES_BINS*sizeof(*ps_dec->aIidPrevFrameIndex));
+
+    pv_memmove(ps_dec->aIccPrevFrameIndex,
+               ps_dec->aaIccIndex[ps_dec->noEnv-1],
+               NO_HI_RES_BINS*sizeof(*ps_dec->aIccPrevFrameIndex));
+
+    ps_dec->bPsDataAvail = 0;
+
+    if (ps_dec->bFrameClass == 0)
+    {
+        Int32 shift;
+
+        shift = ps_dec->noEnv >> 1;
+
+        ps_dec->aEnvStartStop[0] = 0;
+
+        for (env = 1; env < ps_dec->noEnv; env++)
+        {
+            ps_dec->aEnvStartStop[env] =
+                (env * ps_dec->noSubSamples) >> shift;
+        }
+
+        ps_dec->aEnvStartStop[ps_dec->noEnv] = ps_dec->noSubSamples;
+    }
+    else
+    {   /* if (ps_dec->bFrameClass != 0) */
+        ps_dec->aEnvStartStop[0] = 0;
+
+        if (ps_dec->aEnvStartStop[ps_dec->noEnv] < ps_dec->noSubSamples)
+        {
+            ps_dec->noEnv++;
+            ps_dec->aEnvStartStop[ps_dec->noEnv] = ps_dec->noSubSamples;
+
+            pv_memmove(ps_dec->aaIidIndex[ps_dec->noEnv],
+                       ps_dec->aaIidIndex[ps_dec->noEnv-1],
+                       NO_HI_RES_BINS*sizeof(**ps_dec->aaIidIndex));
+
+            pv_memmove(ps_dec->aaIccIndex[ps_dec->noEnv],
+                       ps_dec->aaIccIndex[ps_dec->noEnv-1],
+                       NO_HI_RES_BINS*sizeof(**ps_dec->aaIccIndex));
+        }
+
+        for (env = 1; env < ps_dec->noEnv; env++)
+        {
+            UInt32 thr;
+            thr = ps_dec->noSubSamples - ps_dec->noEnv + env;
+
+            if (ps_dec->aEnvStartStop[env] > thr)
+            {
+                ps_dec->aEnvStartStop[env] = thr;
+            }
+            else
+            {
+                thr = ps_dec->aEnvStartStop[env-1] + 1;
+
+                if (ps_dec->aEnvStartStop[env] < thr)
+                {
+                    ps_dec->aEnvStartStop[env] = thr;
+                }
+            }
+        }
+    }   /* if (ps_dec->bFrameClass == 0) ... else */
+
+    for (env = 0; env < ps_dec->noEnv; env++)
+    {
+        if (ps_dec->freqResIid == 2)
+        {
+            map34IndexTo20(ps_dec->aaIidIndex[env]);
+        }
+        if (ps_dec->freqResIcc == 2)
+        {
+            map34IndexTo20(ps_dec->aaIccIndex[env]);
+        }
+    }
+
+
+}
+
+#endif
+
+
+#endif
+
diff --git a/media/libstagefright/codecs/aacdec/ps_bstr_decoding.h b/media/libstagefright/codecs/aacdec/ps_bstr_decoding.h
new file mode 100644
index 0000000..5212bf8
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/ps_bstr_decoding.h
@@ -0,0 +1,98 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Pathname: ps_bstr_decoding.h
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+ Who:                   Date:
+ Description:
+
+------------------------------------------------------------------------------
+ INCLUDE DESCRIPTION
+
+ Header file for functions ps_bstr_decoding()
+
+
+------------------------------------------------------------------------------
+*/
+
+/*----------------------------------------------------------------------------
+; CONTINUE ONLY IF NOT ALREADY DEFINED
+----------------------------------------------------------------------------*/
+#ifndef PS_BSTR_DECODING_H
+#define PS_BSTR_DECODING_H
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+#include "pv_audio_type_defs.h"
+#include "s_ps_dec.h"
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here.
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL VARIABLES REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+extern const Int32 aNoIidBins[3];
+extern const Int32 aNoIccBins[3];
+
+extern const Int32 aFixNoEnvDecode[4];
+
+/*----------------------------------------------------------------------------
+; SIMPLE TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; ENUMERATED TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; STRUCTURES TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; GLOBAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+    void ps_bstr_decoding(STRUCT_PS_DEC *h_ps_dec);
+
+#ifdef __cplusplus
+}
+#endif
+
+/*----------------------------------------------------------------------------
+; END
+----------------------------------------------------------------------------*/
+#endif  /* PS_BSTR_DECODING_H */
diff --git a/media/libstagefright/codecs/aacdec/ps_channel_filtering.cpp b/media/libstagefright/codecs/aacdec/ps_channel_filtering.cpp
new file mode 100644
index 0000000..03a53df
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/ps_channel_filtering.cpp
@@ -0,0 +1,281 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Filename: ps_hybrid_analysis.c
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+
+ Who:                                   Date: MM/DD/YYYY
+ Description:
+
+------------------------------------------------------------------------------
+ INPUT AND OUTPUT DEFINITIONS
+
+
+
+------------------------------------------------------------------------------
+ FUNCTION DESCRIPTION
+
+        Does Hybrid analysis
+
+------------------------------------------------------------------------------
+ REQUIREMENTS
+
+
+------------------------------------------------------------------------------
+ REFERENCES
+
+SC 29 Software Copyright Licencing Disclaimer:
+
+This software module was originally developed by
+  Coding Technologies
+
+and edited by
+  -
+
+in the course of development of the ISO/IEC 13818-7 and ISO/IEC 14496-3
+standards for reference purposes and its performance may not have been
+optimized. This software module is an implementation of one or more tools as
+specified by the ISO/IEC 13818-7 and ISO/IEC 14496-3 standards.
+ISO/IEC gives users free license to this software module or modifications
+thereof for use in products claiming conformance to audiovisual and
+image-coding related ITU Recommendations and/or ISO/IEC International
+Standards. ISO/IEC gives users the same free license to this software module or
+modifications thereof for research purposes and further ISO/IEC standardisation.
+Those intending to use this software module in products are advised that its
+use may infringe existing patents. ISO/IEC have no liability for use of this
+software module or modifications thereof. Copyright is not released for
+products that do not conform to audiovisual and image-coding related ITU
+Recommendations and/or ISO/IEC International Standards.
+The original developer retains full right to modify and use the code for its
+own purpose, assign or donate the code to a third party and to inhibit third
+parties from using the code for products that do not conform to audiovisual and
+image-coding related ITU Recommendations and/or ISO/IEC International Standards.
+This copyright notice must be included in all copies or derivative works.
+Copyright (c) ISO/IEC 2003.
+
+------------------------------------------------------------------------------
+ PSEUDO-CODE
+
+------------------------------------------------------------------------------
+*/
+
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+
+#ifdef AAC_PLUS
+
+#ifdef PARAMETRICSTEREO
+
+#include    "s_hybrid.h"
+#include    "aac_mem_funcs.h"
+#include    "ps_fft_rx8.h"
+#include    "ps_channel_filtering.h"
+#include    "pv_audio_type_defs.h"
+#include    "fxp_mul32.h"
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here. Include conditional
+; compile variables also.
+----------------------------------------------------------------------------*/
+#define R_SHIFT     29
+#define Q29_fmt(x)   (Int32)(x*((Int32)1<<R_SHIFT) + (x>=0?0.5F:-0.5F))
+
+#define Qfmt31(a)   (Int32)(-a*((Int32)1<<31)  + (a>=0?0.5F:-0.5F))
+
+/*----------------------------------------------------------------------------
+; LOCAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; LOCAL STORE/BUFFER/POINTER DEFINITIONS
+; Variable declaration - defined here and used outside this module
+----------------------------------------------------------------------------*/
+
+
+/*----------------------------------------------------------------------------
+; EXTERNAL FUNCTION REFERENCES
+; Declare functions defined elsewhere and referenced in this module
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL GLOBAL STORE/BUFFER/POINTER REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+
+/*----------------------------------------------------------------------------
+; FUNCTION CODE
+----------------------------------------------------------------------------*/
+
+
+void two_ch_filtering(const Int32 *pQmf_r,
+                      const Int32 *pQmf_i,
+                      Int32 *mHybrid_r,
+                      Int32 *mHybrid_i)
+{
+
+    Int32 cum0;
+    Int32 cum1;
+    Int32 cum2;
+    Int32 tmp1;
+    Int32 tmp2;
+
+    tmp1 = pQmf_r[ 1] + pQmf_r[11];
+    tmp2 = pQmf_i[ 1] + pQmf_i[11];
+    cum1 =   fxp_mul32_Q31(Qfmt31(0.03798975052098f), tmp1);
+    cum2 =   fxp_mul32_Q31(Qfmt31(0.03798975052098f), tmp2);
+    tmp1 = pQmf_r[ 3] + pQmf_r[ 9];
+    tmp2 = pQmf_i[ 3] + pQmf_i[ 9];
+    cum1 =   fxp_msu32_Q31(cum1, Qfmt31(0.14586278335076f), tmp1);
+    cum2 =   fxp_msu32_Q31(cum2, Qfmt31(0.14586278335076f), tmp2);
+    tmp1 = pQmf_r[ 5] + pQmf_r[ 7];
+    tmp2 = pQmf_i[ 5] + pQmf_i[ 7];
+    cum1 =   fxp_mac32_Q31(cum1, Qfmt31(0.61193261090336f), tmp1);
+    cum2 =   fxp_mac32_Q31(cum2, Qfmt31(0.61193261090336f), tmp2);
+
+    cum0 = pQmf_r[HYBRID_FILTER_DELAY] >> 1;  /* HYBRID_FILTER_DELAY == 6 */
+
+    mHybrid_r[0] = (cum0 + cum1);
+    mHybrid_r[1] = (cum0 - cum1);
+
+    cum0 = pQmf_i[HYBRID_FILTER_DELAY] >> 1;  /* HYBRID_FILTER_DELAY == 6 */
+
+    mHybrid_i[0] = (cum0 + cum2);
+    mHybrid_i[1] = (cum0 - cum2);
+
+}
+
+
+
+
+
+/*----------------------------------------------------------------------------
+; FUNCTION CODE
+----------------------------------------------------------------------------*/
+
+
+void eight_ch_filtering(const Int32 *pQmfReal,
+                        const Int32 *pQmfImag,
+                        Int32 *mHybridReal,
+                        Int32 *mHybridImag,
+                        Int32 scratch_mem[])
+
+{
+
+    Int32 real;
+    Int32 imag;
+    Int32 tmp1;
+    Int32 tmp2;
+
+    real  = fxp_mul32_Q29(Q29_fmt(-0.06989827306334f), pQmfReal[ 4]);
+
+    real  = fxp_mac32_Q31(real, Qfmt31(0.01055120626280f), pQmfReal[12]);
+    imag  = fxp_mul32_Q29(Q29_fmt(-0.06989827306334f), pQmfImag[ 4]);
+
+    imag  = fxp_mac32_Q31(imag, Qfmt31(0.01055120626280f), pQmfImag[12]);
+
+    mHybridReal[2] = (imag - real);
+    mHybridImag[2] = -(imag + real);
+
+    real  = fxp_mul32_Q29(Q29_fmt(-0.07266113929591f), pQmfReal[ 3]);
+
+    real  = fxp_mac32_Q31(real, Qfmt31(0.04540841899650f), pQmfReal[11]);
+    imag  = fxp_mul32_Q29(Q29_fmt(-0.07266113929591f), pQmfImag[ 3]);
+
+    imag  = fxp_mac32_Q31(imag, Qfmt31(0.04540841899650f), pQmfImag[11]);
+
+    tmp1           =  fxp_mul32_Q29(Q29_fmt(-0.38268343236509f), real);
+    mHybridReal[3] =  fxp_mac32_Q29(Q29_fmt(0.92387953251129f), imag, tmp1);
+    tmp2           =  fxp_mul32_Q29(Q29_fmt(-0.92387953251129f), real);
+    mHybridImag[3] =  fxp_mac32_Q29(Q29_fmt(-0.38268343236509f), imag, tmp2);
+
+
+    mHybridImag[4] = fxp_mul32_Q31(Qfmt31(0.09093731860946f), (pQmfReal[ 2] - pQmfReal[10]));
+    mHybridReal[4] = fxp_mul32_Q31(Qfmt31(0.09093731860946f), (pQmfImag[10] - pQmfImag[ 2]));
+
+
+    real  = fxp_mul32_Q29(Q29_fmt(-0.02270420949825f), pQmfReal[ 1]);
+
+    real  = fxp_mac32_Q31(real, Qfmt31(0.14532227859182f), pQmfReal[ 9]);
+    imag  = fxp_mul32_Q29(Q29_fmt(-0.02270420949825f), pQmfImag[ 1]);
+
+    imag  = fxp_mac32_Q31(imag, Qfmt31(0.14532227859182f), pQmfImag[ 9]);
+
+    tmp1           =  fxp_mul32_Q29(Q29_fmt(0.92387953251129f), imag);
+
+    mHybridReal[5] =  fxp_mac32_Q31(tmp1, Qfmt31(0.76536686473018f), real);
+    tmp2           =  fxp_mul32_Q29(Q29_fmt(-0.92387953251129f), real);
+
+    mHybridImag[5] =  fxp_mac32_Q31(tmp2, Qfmt31(0.76536686473018f), imag);
+
+    real  = fxp_mul32_Q29(Q29_fmt(-0.00527560313140f), pQmfReal[ 0]);
+
+    real  = fxp_mac32_Q31(real, Qfmt31(0.13979654612668f), pQmfReal[ 8]);
+    imag  = fxp_mul32_Q29(Q29_fmt(-0.00527560313140f), pQmfImag[ 0]);
+
+    imag  = fxp_mac32_Q31(imag, Qfmt31(0.13979654612668f), pQmfImag[ 8]);
+
+    mHybridReal[6] = (imag + real);
+    mHybridImag[6] = (imag - real);
+
+
+    tmp1            =  fxp_mul32_Q31(Qfmt31(0.21791935610828f), pQmfReal[ 7]);
+    mHybridReal[7]  =  fxp_mac32_Q31(tmp1, Qfmt31(0.09026515280366f), pQmfImag[ 7]);
+
+    tmp2            =  fxp_mul32_Q29(Q29_fmt(-0.04513257640183f), pQmfReal[ 7]);
+
+    mHybridImag[7]  =  fxp_mac32_Q31(tmp2, Qfmt31(0.21791935610828f), pQmfImag[ 7]);
+
+    mHybridReal[0] = pQmfReal[HYBRID_FILTER_DELAY] >> 3;
+    mHybridImag[0] = pQmfImag[HYBRID_FILTER_DELAY] >> 3;
+
+    tmp1           =  fxp_mul32_Q29(Q29_fmt(-0.04513257640183f), pQmfImag[ 5]);
+
+    mHybridReal[1] =  fxp_mac32_Q31(tmp1, Qfmt31(0.21791935610828f), pQmfReal[ 5]);
+
+
+    tmp2            =  fxp_mul32_Q31(Qfmt31(0.21791935610828f), pQmfImag[ 5]);
+    mHybridImag[1]  =  fxp_mac32_Q31(tmp2, Qfmt31(0.09026515280366f), pQmfReal[ 5]);
+
+    /*
+     *  8*ifft
+     */
+
+    ps_fft_rx8(mHybridReal, mHybridImag, scratch_mem);
+
+}
+
+
+#endif
+
+
+#endif
+
diff --git a/media/libstagefright/codecs/aacdec/ps_channel_filtering.h b/media/libstagefright/codecs/aacdec/ps_channel_filtering.h
new file mode 100644
index 0000000..19cda79
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/ps_channel_filtering.h
@@ -0,0 +1,104 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Pathname: ps_channel_filtering.h
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+ Who:                   Date:
+ Description:
+
+------------------------------------------------------------------------------
+ INCLUDE DESCRIPTION
+
+ Header file for functions two_ch_filtering()
+ and  eight_ch_filtering()
+
+------------------------------------------------------------------------------
+*/
+
+/*----------------------------------------------------------------------------
+; CONTINUE ONLY IF NOT ALREADY DEFINED
+----------------------------------------------------------------------------*/
+#ifndef PS_CHANNEL_FILTERING_H
+#define PS_CHANNEL_FILTERING_H
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+#include "pv_audio_type_defs.h"
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here.
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL VARIABLES REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; SIMPLE TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; ENUMERATED TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; STRUCTURES TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; GLOBAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+    void two_ch_filtering(const Int32 *pQmf_r,
+    const Int32 *pQmf_i,
+    Int32 *mHybrid_r,
+    Int32 *mHybrid_i);
+
+
+    void eight_ch_filtering(const Int32 *pQmfReal,
+                            const Int32 *pQmfImag,
+                            Int32 *mHybridReal,
+                            Int32 *mHybridImag,
+                            Int32 scratch_mem[]);
+
+#ifdef __cplusplus
+}
+#endif
+
+/*----------------------------------------------------------------------------
+; END
+----------------------------------------------------------------------------*/
+#endif  /* PS_CHANNEL_FILTERING_H */
diff --git a/media/libstagefright/codecs/aacdec/ps_constants.h b/media/libstagefright/codecs/aacdec/ps_constants.h
new file mode 100644
index 0000000..d5b2ad4
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/ps_constants.h
@@ -0,0 +1,89 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/****************************************************************************
+SC 29 Software Copyright Licencing Disclaimer:
+
+This software module was originally developed by
+  Coding Technologies
+
+and edited by
+  -
+
+in the course of development of the ISO/IEC 13818-7 and ISO/IEC 14496-3
+standards for reference purposes and its performance may not have been
+optimized. This software module is an implementation of one or more tools as
+specified by the ISO/IEC 13818-7 and ISO/IEC 14496-3 standards.
+ISO/IEC gives users free license to this software module or modifications
+thereof for use in products claiming conformance to audiovisual and
+image-coding related ITU Recommendations and/or ISO/IEC International
+Standards. ISO/IEC gives users the same free license to this software module or
+modifications thereof for research purposes and further ISO/IEC standardisation.
+Those intending to use this software module in products are advised that its
+use may infringe existing patents. ISO/IEC have no liability for use of this
+software module or modifications thereof. Copyright is not released for
+products that do not conform to audiovisual and image-coding related ITU
+Recommendations and/or ISO/IEC International Standards.
+The original developer retains full right to modify and use the code for its
+own purpose, assign or donate the code to a third party and to inhibit third
+parties from using the code for products that do not conform to audiovisual and
+image-coding related ITU Recommendations and/or ISO/IEC International Standards.
+This copyright notice must be included in all copies or derivative works.
+Copyright (c) ISO/IEC 2003.
+*******************************************************************************/
+/*
+*/
+#ifndef PS_CONSTANTS_H
+#define PS_CONSTANTS_H
+
+
+#define NO_SUB_QMF_CHANNELS         12
+#define NO_QMF_CHANNELS_IN_HYBRID   3
+#define NO_QMF_CHANNELS             64
+#define NO_ALLPASS_CHANNELS         23
+#define NO_DELAY_CHANNELS           (NO_QMF_CHANNELS-NO_ALLPASS_CHANNELS)
+#define DELAY_ALLPASS               2
+#define SHORT_DELAY_START           12
+#define SHORT_DELAY                 1
+#define LONG_DELAY                  14
+#define NO_QMF_ALLPASS_CHANNELS    (NO_ALLPASS_CHANNELS-NO_QMF_CHANNELS_IN_HYBRID)
+#define NO_QMF_ICC_CHANNELS        (NO_QMF_ALLPASS_CHANNELS+NO_DELAY_CHANNELS)
+#define HYBRIDGROUPS                8
+#define DECAY_CUTOFF                3
+#define NO_SERIAL_ALLPASS_LINKS     3
+#define MAX_NO_PS_ENV               5
+#define NEGATE_IPD_MASK                 ( 0x00001000 )
+#define NO_BINS                         ( 20 )
+#define NO_HI_RES_BINS                  ( 34 )
+#define NO_LOW_RES_BINS                 ( NO_IID_BINS / 2 )
+#define NO_IID_BINS                     ( NO_BINS )
+#define NO_ICC_BINS                     ( NO_BINS )
+#define NO_LOW_RES_IID_BINS             ( NO_LOW_RES_BINS )
+#define NO_LOW_RES_ICC_BINS             ( NO_LOW_RES_BINS )
+#define SUBQMF_GROUPS                   ( 10 )
+#define QMF_GROUPS                      ( 12 )
+#define NO_IID_GROUPS                   ( SUBQMF_GROUPS + QMF_GROUPS )
+#define NO_IID_STEPS                    ( 7 )
+#define NO_IID_STEPS_FINE               ( 15 )
+#define NO_ICC_STEPS                    ( 8 )
+#define NO_IID_LEVELS                   ( 2 * NO_IID_STEPS + 1 )
+#define NO_IID_LEVELS_FINE              ( 2 * NO_IID_STEPS_FINE + 1 )
+#define NO_ICC_LEVELS                   ( NO_ICC_STEPS )
+
+
+
+#endif      /*  PS_CONSTANTS_H */
diff --git a/media/libstagefright/codecs/aacdec/ps_decode_bs_utils.cpp b/media/libstagefright/codecs/aacdec/ps_decode_bs_utils.cpp
new file mode 100644
index 0000000..241da34
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/ps_decode_bs_utils.cpp
@@ -0,0 +1,274 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Filename: ps_decode_bs_utils.c
+
+  Functions:
+        GetNrBitsAvailable
+        differential_Decoding
+        map34IndexTo20
+        limitMinMax
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+
+ Who:                                   Date: MM/DD/YYYY
+ Description:
+
+------------------------------------------------------------------------------
+ INPUT AND OUTPUT DEFINITIONS
+
+
+
+------------------------------------------------------------------------------
+ FUNCTION DESCRIPTION
+
+        Decode bitstream parametric stereo's utilities
+
+------------------------------------------------------------------------------
+ REQUIREMENTS
+
+
+------------------------------------------------------------------------------
+ REFERENCES
+
+SC 29 Software Copyright Licencing Disclaimer:
+
+This software module was originally developed by
+  Coding Technologies
+
+and edited by
+  -
+
+in the course of development of the ISO/IEC 13818-7 and ISO/IEC 14496-3
+standards for reference purposes and its performance may not have been
+optimized. This software module is an implementation of one or more tools as
+specified by the ISO/IEC 13818-7 and ISO/IEC 14496-3 standards.
+ISO/IEC gives users free license to this software module or modifications
+thereof for use in products claiming conformance to audiovisual and
+image-coding related ITU Recommendations and/or ISO/IEC International
+Standards. ISO/IEC gives users the same free license to this software module or
+modifications thereof for research purposes and further ISO/IEC standardisation.
+Those intending to use this software module in products are advised that its
+use may infringe existing patents. ISO/IEC have no liability for use of this
+software module or modifications thereof. Copyright is not released for
+products that do not conform to audiovisual and image-coding related ITU
+Recommendations and/or ISO/IEC International Standards.
+The original developer retains full right to modify and use the code for its
+own purpose, assign or donate the code to a third party and to inhibit third
+parties from using the code for products that do not conform to audiovisual and
+image-coding related ITU Recommendations and/or ISO/IEC International Standards.
+This copyright notice must be included in all copies or derivative works.
+Copyright (c) ISO/IEC 2003.
+
+------------------------------------------------------------------------------
+ PSEUDO-CODE
+
+------------------------------------------------------------------------------
+*/
+
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+
+#ifdef AAC_PLUS
+
+#ifdef PARAMETRICSTEREO
+
+#include "aac_mem_funcs.h"
+#include "s_ps_dec.h"
+#include "ps_decode_bs_utils.h"
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here. Include conditional
+; compile variables also.
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; LOCAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+
+
+/*----------------------------------------------------------------------------
+; LOCAL STORE/BUFFER/POINTER DEFINITIONS
+; Variable declaration - defined here and used outside this module
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL FUNCTION REFERENCES
+; Declare functions defined elsewhere and referenced in this module
+----------------------------------------------------------------------------*/
+
+
+/*----------------------------------------------------------------------------
+; EXTERNAL GLOBAL STORE/BUFFER/POINTER REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; FUNCTION CODE
+----------------------------------------------------------------------------*/
+
+Int32 GetNrBitsAvailable(HANDLE_BIT_BUFFER hBitBuf)
+{
+
+    return (hBitBuf->bufferLen - hBitBuf->nrBitsRead);
+}
+
+/*----------------------------------------------------------------------------
+; FUNCTION CODE
+;
+;   Differential Decoding of parameters over time/frequency
+----------------------------------------------------------------------------*/
+
+void differential_Decoding(Int32 enable,
+                           Int32 *aIndex,
+                           Int32 *aPrevFrameIndex,
+                           Int32 DtDf,
+                           Int32 nrElements,
+                           Int32 stride,
+                           Int32 minIdx,
+                           Int32 maxIdx)
+{
+    Int32 i;
+    Int32 *ptr_aIndex;
+
+    if (enable == 1)
+    {
+        ptr_aIndex = aIndex;
+
+        if (DtDf == 0)
+        {
+            *(ptr_aIndex) = limitMinMax(*ptr_aIndex, minIdx, maxIdx);
+            ptr_aIndex++;
+
+            for (i = 1; i < nrElements; i++)
+            {
+                *(ptr_aIndex) = limitMinMax(aIndex[i-1] + *ptr_aIndex, minIdx, maxIdx);
+                ptr_aIndex++;
+            }
+        }
+        else
+        {
+            if (stride == 1)
+            {
+                for (i = 0; i < nrElements; i++)
+                {
+                    *(ptr_aIndex) = limitMinMax(aPrevFrameIndex[i] + *ptr_aIndex, minIdx, maxIdx);
+                    ptr_aIndex++;
+                }
+            }
+            else
+            {
+                for (i = 0; i < nrElements; i++)
+                {
+                    *(ptr_aIndex) = limitMinMax(aPrevFrameIndex[(i<<1)] + *ptr_aIndex, minIdx, maxIdx);
+                    ptr_aIndex++;
+                }
+            }
+        }
+    }
+    else
+    {
+        pv_memset((void *)aIndex, 0, nrElements*sizeof(*aIndex));
+    }
+    if (stride == 2)
+    {
+        for (i = (nrElements << 1) - 1; i > 0; i--)
+        {
+            aIndex[i] = aIndex[(i>>1)];
+        }
+    }
+}
+
+
+/*----------------------------------------------------------------------------
+; FUNCTION CODE
+        map34IndexTo20
+----------------------------------------------------------------------------*/
+
+void map34IndexTo20(Int32 *aIndex)
+{
+
+    aIndex[ 0] = ((aIndex[0] << 1) +  aIndex[1]) / 3;
+    aIndex[ 1] = (aIndex[1] + (aIndex[2] << 1)) / 3;
+    aIndex[ 2] = ((aIndex[3] << 1) +  aIndex[4]) / 3;
+    aIndex[ 3] = (aIndex[4] + (aIndex[5] << 1)) / 3;
+    aIndex[ 4] = (aIndex[ 6] +  aIndex[7]) >> 1;
+    aIndex[ 5] = (aIndex[ 8] +  aIndex[9]) >> 1;
+    aIndex[ 6] =   aIndex[10];
+    aIndex[ 7] =   aIndex[11];
+    aIndex[ 8] = (aIndex[12] +  aIndex[13]) >> 1;
+    aIndex[ 9] = (aIndex[14] +  aIndex[15]) >> 1;
+    aIndex[10] =   aIndex[16];
+    aIndex[11] =   aIndex[17];
+    aIndex[12] =   aIndex[18];
+    aIndex[13] =   aIndex[19];
+    aIndex[14] = (aIndex[20] +  aIndex[21]) >> 1;
+    aIndex[15] = (aIndex[22] +  aIndex[23]) >> 1;
+    aIndex[16] = (aIndex[24] +  aIndex[25]) >> 1;
+    aIndex[17] = (aIndex[26] +  aIndex[27]) >> 1;
+    aIndex[18] = (aIndex[28] +  aIndex[29] + aIndex[30] + aIndex[31]) >> 2;
+    aIndex[19] = (aIndex[32] +  aIndex[33]) >> 1;
+}
+
+
+/*----------------------------------------------------------------------------
+; FUNCTION CODE
+        limitMinMax
+----------------------------------------------------------------------------*/
+
+
+Int32 limitMinMax(Int32 i,
+                  Int32 min,
+                  Int32 max)
+{
+    if (i < max)
+    {
+        if (i > min)
+        {
+            return i;
+        }
+        else
+        {
+            return min;
+        }
+    }
+    else
+    {
+        return max;
+    }
+}
+
+
+#endif
+
+
+#endif
+
diff --git a/media/libstagefright/codecs/aacdec/ps_decode_bs_utils.h b/media/libstagefright/codecs/aacdec/ps_decode_bs_utils.h
new file mode 100644
index 0000000..a672d94
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/ps_decode_bs_utils.h
@@ -0,0 +1,112 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Pathname: ps_decode_bs_utils.h
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+ Who:                   Date:
+ Description:
+
+------------------------------------------------------------------------------
+ INCLUDE DESCRIPTION
+
+ Header file for functions differential_Decoding(), limitMinMax(),
+                           GetNrBitsAvailable(), map34IndexTo20()
+
+
+------------------------------------------------------------------------------
+*/
+
+/*----------------------------------------------------------------------------
+; CONTINUE ONLY IF NOT ALREADY DEFINED
+----------------------------------------------------------------------------*/
+#ifndef PS_DECODE_BS_UTILS_H
+#define PS_DECODE_BS_UTILS_H
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+#include "pv_audio_type_defs.h"
+#include "s_ps_dec.h"
+#include "s_bit_buffer.h"
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here.
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL VARIABLES REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; SIMPLE TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; ENUMERATED TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; STRUCTURES TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; GLOBAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+    void differential_Decoding(Int32 enable,
+    Int32 *aIndex,
+    Int32 *aPrevFrameIndex,
+    Int32 DtDf,
+    Int32 nrElements,
+    Int32 stride,
+    Int32 minIdx,
+    Int32 maxIdx);
+
+    Int32 limitMinMax(Int32 i,
+                      Int32 min,
+                      Int32 max);
+
+    Int32 GetNrBitsAvailable(HANDLE_BIT_BUFFER hBitBuf);
+
+    void map34IndexTo20(Int32 *aIndex);
+
+#ifdef __cplusplus
+}
+#endif
+
+/*----------------------------------------------------------------------------
+; END
+----------------------------------------------------------------------------*/
+#endif  /* PS_DECODE_BS_UTILS_H */
diff --git a/media/libstagefright/codecs/aacdec/ps_decorrelate.cpp b/media/libstagefright/codecs/aacdec/ps_decorrelate.cpp
new file mode 100644
index 0000000..6776d6e
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/ps_decorrelate.cpp
@@ -0,0 +1,499 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Filename: ps_decorrelate.c
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+
+ Who:                                   Date: MM/DD/YYYY
+ Description:
+
+------------------------------------------------------------------------------
+ INPUT AND OUTPUT DEFINITIONS
+
+
+
+------------------------------------------------------------------------------
+ FUNCTION DESCRIPTION
+
+  Decorrelation
+  Decorrelation is achieved by means of all-pass filtering and delaying
+  Sub-band samples s_k(n) are converted into de-correlated sub-bands samples
+  d_k(n). k index for frequency, n time index
+
+
+     _______                                              ________
+    |       |                                  _______   |        |
+  ->|Hybrid | LF ----                         |       |->| Hybrid |-->
+    | Anal. |        |                        |       |  | Synth  |   QMF -> L
+     -------         o----------------------->|       |   --------    Synth
+QMF                  |                s_k(n)  |Stereo |-------------->
+Anal.              -------------------------->|       |
+     _______       | |                        |       |   ________
+    |       | HF --o |   -----------          |Process|  |        |
+  ->| Delay |      |  ->|           |-------->|       |->| Hybrid |-->
+     -------       |    |decorrelate| d_k(n)  |       |  | Synth  |   QMF -> R
+                   ---->|           |-------->|       |   --------    Synth
+                         -----------          |_______|-------------->
+
+
+  Delay is introduced to compensate QMF bands not passed through Hybrid
+  Analysis
+
+------------------------------------------------------------------------------
+ REQUIREMENTS
+
+
+------------------------------------------------------------------------------
+ REFERENCES
+
+SC 29 Software Copyright Licencing Disclaimer:
+
+This software module was originally developed by
+  Coding Technologies
+
+and edited by
+  -
+
+in the course of development of the ISO/IEC 13818-7 and ISO/IEC 14496-3
+standards for reference purposes and its performance may not have been
+optimized. This software module is an implementation of one or more tools as
+specified by the ISO/IEC 13818-7 and ISO/IEC 14496-3 standards.
+ISO/IEC gives users free license to this software module or modifications
+thereof for use in products claiming conformance to audiovisual and
+image-coding related ITU Recommendations and/or ISO/IEC International
+Standards. ISO/IEC gives users the same free license to this software module or
+modifications thereof for research purposes and further ISO/IEC standardisation.
+Those intending to use this software module in products are advised that its
+use may infringe existing patents. ISO/IEC have no liability for use of this
+software module or modifications thereof. Copyright is not released for
+products that do not conform to audiovisual and image-coding related ITU
+Recommendations and/or ISO/IEC International Standards.
+The original developer retains full right to modify and use the code for its
+own purpose, assign or donate the code to a third party and to inhibit third
+parties from using the code for products that do not conform to audiovisual and
+image-coding related ITU Recommendations and/or ISO/IEC International Standards.
+This copyright notice must be included in all copies or derivative works.
+Copyright (c) ISO/IEC 2003.
+
+------------------------------------------------------------------------------
+ PSEUDO-CODE
+
+------------------------------------------------------------------------------
+*/
+
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+
+#ifdef AAC_PLUS
+
+#ifdef PARAMETRICSTEREO
+#include    "pv_audio_type_defs.h"
+#include    "ps_decorrelate.h"
+#include    "aac_mem_funcs.h"
+#include    "ps_all_pass_filter_coeff.h"
+#include    "ps_pwr_transient_detection.h"
+#include    "ps_all_pass_fract_delay_filter.h"
+#include    "fxp_mul32.h"
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+#ifndef min
+#define min(a, b) ((a) < (b) ? (a) : (b))
+#endif
+
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here. Include conditional
+; compile variables also.
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; LOCAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+
+
+/*----------------------------------------------------------------------------
+; LOCAL STORE/BUFFER/POINTER DEFINITIONS
+; Variable declaration - defined here and used outside this module
+----------------------------------------------------------------------------*/
+
+
+/*----------------------------------------------------------------------------
+; EXTERNAL FUNCTION REFERENCES
+; Declare functions defined elsewhere and referenced in this module
+----------------------------------------------------------------------------*/
+
+
+
+
+/*----------------------------------------------------------------------------
+; EXTERNAL GLOBAL STORE/BUFFER/POINTER REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+
+/*----------------------------------------------------------------------------
+; FUNCTION CODE
+----------------------------------------------------------------------------*/
+void ps_decorrelate(STRUCT_PS_DEC *h_ps_dec,
+                    Int32 *rIntBufferLeft,
+                    Int32 *iIntBufferLeft,
+                    Int32 *rIntBufferRight,
+                    Int32 *iIntBufferRight,
+                    Int32 scratch_mem[])
+{
+    Int32 sb;
+    Int32 maxsb;
+    Int32 gr;
+    Int32 sb_delay;
+    Int32 bin;
+
+
+
+
+    Int32 *aLeftReal;
+    Int32 *aLeftImag;
+    Int32 *aRightReal;
+    Int32 *aRightImag;
+
+    Int32 *aTransRatio = scratch_mem;   /* use  NO_BINS == 20 */
+
+
+    Int32 ***pppRealDelayRBufferSer;
+    Int32 ***pppImagDelayRBufferSer;
+
+    Int32 **ppRealDelayBuffer;
+    Int32 **ppImagDelayBuffer;
+
+    const Int32(*ppFractDelayPhaseFactorSer)[3];
+    /*
+     *  Power transient estimation and detection
+     */
+
+
+    ps_pwr_transient_detection(h_ps_dec,
+                               rIntBufferLeft,
+                               iIntBufferLeft,
+                               aTransRatio);
+
+
+    aLeftReal = h_ps_dec->mHybridRealLeft;
+    aLeftImag = h_ps_dec->mHybridImagLeft;
+    aRightReal = h_ps_dec->mHybridRealRight;
+    aRightImag = h_ps_dec->mHybridImagRight;
+
+    pppRealDelayRBufferSer = h_ps_dec->aaaRealDelayRBufferSerSubQmf;
+    pppImagDelayRBufferSer = h_ps_dec->aaaImagDelayRBufferSerSubQmf;
+
+    ppRealDelayBuffer = h_ps_dec->aaRealDelayBufferSubQmf;
+    ppImagDelayBuffer = h_ps_dec->aaImagDelayBufferSubQmf;
+
+
+
+    ppFractDelayPhaseFactorSer = aaFractDelayPhaseFactorSerSubQmf;
+
+
+    /*
+     *   NO_IID_GROUPS (SUBQMF_GROUPS (12) + QMF_GROUPS (10)) == 22
+     */
+
+    for (gr = 0; gr < SUBQMF_GROUPS; gr++)      /*  0 to 9 */
+    {
+        Int32 rIn;
+        Int32 iIn;
+        Int32 *pt_rTmp;
+        Int32 *pt_iTmp;
+        Int32 rTmp;
+        Int32 cmplx;
+        Int32 tmp1, tmp2;
+
+        /* sb = subQMF/QMF subband */
+
+        sb = groupBorders[gr];
+
+        /*
+         *  For lower subbands
+         *  Apply all-pass filtering
+         *
+         */
+        pt_rTmp = &ppRealDelayBuffer[sb][h_ps_dec->delayBufIndex];
+        pt_iTmp = &ppImagDelayBuffer[sb][h_ps_dec->delayBufIndex];
+
+        tmp1 = aLeftReal[sb];
+        tmp2 = aLeftImag[sb];
+        rIn = *pt_rTmp >> 1;
+        iIn = *pt_iTmp >> 1;
+
+
+        *pt_rTmp = tmp1;
+        *pt_iTmp = tmp2;
+
+        /*
+         *  Fractional delay vector
+         *
+         *  phi_fract(k) = exp(-j*pi*q_phi*f_center(k))       0<= k <= SUBQMF_GROUPS
+         *
+         *  q_phi = 0.39
+         *  f_center(k) frequency vector
+         */
+
+        cmplx =  aFractDelayPhaseFactorSubQmf[sb];
+
+        aRightReal[sb]  = cmplx_mul32_by_16(rIn, -iIn, cmplx);
+        aRightImag[sb]  = cmplx_mul32_by_16(iIn,  rIn, cmplx);
+
+        ps_all_pass_fract_delay_filter_type_I(h_ps_dec->aDelayRBufIndexSer,
+                                              sb,
+                                              ppFractDelayPhaseFactorSer[sb],
+                                              pppRealDelayRBufferSer,
+                                              pppImagDelayRBufferSer,
+                                              &aRightReal[sb],
+                                              &aRightImag[sb]);
+
+        bin = bins2groupMap[gr];
+        rTmp = aTransRatio[bin];
+
+        if (rTmp != 0x7FFFFFFF)
+        {
+            aRightReal[sb] = fxp_mul32_Q31(rTmp, aRightReal[sb]) << 1;
+            aRightImag[sb] = fxp_mul32_Q31(rTmp, aRightImag[sb]) << 1;
+        }
+
+
+    } /* gr */
+
+    aLeftReal = rIntBufferLeft;
+    aLeftImag = iIntBufferLeft;
+    aRightReal = rIntBufferRight;
+    aRightImag = iIntBufferRight;
+
+    pppRealDelayRBufferSer = h_ps_dec->aaaRealDelayRBufferSerQmf;
+    pppImagDelayRBufferSer = h_ps_dec->aaaImagDelayRBufferSerQmf;
+
+    ppRealDelayBuffer = h_ps_dec->aaRealDelayBufferQmf;
+    ppImagDelayBuffer = h_ps_dec->aaImagDelayBufferQmf;
+
+
+
+    ppFractDelayPhaseFactorSer = aaFractDelayPhaseFactorSerQmf;
+
+
+    for (gr = SUBQMF_GROUPS; gr < NO_BINS; gr++)     /* 10 to 20 */
+    {
+
+        maxsb = min(h_ps_dec->usb, groupBorders[gr+1]);
+
+        /* sb = subQMF/QMF subband */
+
+        for (sb = groupBorders[gr]; sb < maxsb; sb++)
+        {
+
+            Int32 rIn, iIn;
+            Int32 *pt_rTmp, *pt_iTmp;
+            Int32 cmplx;
+            Int32 tmp1, tmp2;
+            Int32 rTmp;
+
+
+            sb_delay = sb - NO_QMF_CHANNELS_IN_HYBRID;  /* NO_QMF_CHANNELS_IN_HYBRID == 3 */
+
+            /*
+             *  For lower subbands
+             *  Apply all-pass filtering
+             *
+             */
+            pt_rTmp = &ppRealDelayBuffer[sb_delay][h_ps_dec->delayBufIndex];
+            pt_iTmp = &ppImagDelayBuffer[sb_delay][h_ps_dec->delayBufIndex];
+
+            rIn = *pt_rTmp >> 1;
+            iIn = *pt_iTmp >> 1;
+
+            tmp1 = aLeftReal[sb];
+            tmp2 = aLeftImag[sb];
+            *pt_rTmp = tmp1;
+            *pt_iTmp = tmp2;
+
+            /*
+             *  Fractional delay vector
+             *
+             *  phi_fract(k) = exp(-j*pi*q_phi*f_center(k))       0<= k <= SUBQMF_GROUPS
+             *
+             *  q_phi = 0.39
+             *  f_center(k) frequency vector
+             */
+
+            cmplx =  aFractDelayPhaseFactor[sb_delay];
+            aRightReal[sb] = cmplx_mul32_by_16(rIn, -iIn, cmplx);
+            aRightImag[sb] = cmplx_mul32_by_16(iIn,  rIn, cmplx);
+
+            ps_all_pass_fract_delay_filter_type_II(h_ps_dec->aDelayRBufIndexSer,
+                                                   sb_delay,
+                                                   ppFractDelayPhaseFactorSer[sb_delay],
+                                                   pppRealDelayRBufferSer,
+                                                   pppImagDelayRBufferSer,
+                                                   &aRightReal[sb],
+                                                   &aRightImag[sb],
+                                                   sb);
+
+            rTmp = aTransRatio[gr-2];
+            if (rTmp != 0x7FFFFFFF)
+            {
+                aRightReal[sb] = fxp_mul32_Q31(rTmp, aRightReal[sb]) << 1;
+                aRightImag[sb] = fxp_mul32_Q31(rTmp, aRightImag[sb]) << 1;
+            }
+
+
+        } /* sb */
+
+    }
+
+
+    maxsb = min(h_ps_dec->usb, 35);  /*  35 == groupBorders[NO_BINS + 1] */
+
+    /* sb = subQMF/QMF subband */
+    {
+        Int32 factor = aTransRatio[NO_BINS-2];
+
+        for (sb = 23; sb < maxsb; sb++)    /*  23 == groupBorders[NO_BINS] */
+        {
+
+            Int32  tmp, tmp2;
+            Int32 *pt_rTmp, *pt_iTmp;
+
+            sb_delay = sb - NO_QMF_CHANNELS_IN_HYBRID;  /*  == 3 */
+
+            /*
+             *  For the Upper Bands apply delay only
+             *                          -D(k)
+             *  Apply Delay   H_k(z) = z         , D(k) == 1 or 14
+             *
+             */
+            Int32 k = sb - NO_ALLPASS_CHANNELS;  /* == 23 */
+
+
+            pt_rTmp = &ppRealDelayBuffer[sb_delay][h_ps_dec->aDelayBufIndex[ k]];
+            pt_iTmp = &ppImagDelayBuffer[sb_delay][h_ps_dec->aDelayBufIndex[ k]];
+
+            if (++h_ps_dec->aDelayBufIndex[ k] >= LONG_DELAY)     /* == 14 */
+            {
+                h_ps_dec->aDelayBufIndex[ k] = 0;
+            }
+
+
+            tmp  = *pt_rTmp;
+            tmp2 = *pt_iTmp;
+
+            if (aTransRatio[NO_BINS-2] < 0x7FFFFFFF)
+            {
+                aRightReal[sb] = fxp_mul32_Q31(factor, tmp) << 1;
+                aRightImag[sb] = fxp_mul32_Q31(factor, tmp2) << 1;
+            }
+            else
+            {
+                aRightReal[sb] = tmp;
+                aRightImag[sb] = tmp2;
+            }
+
+
+            tmp  = aLeftReal[sb];
+            tmp2 = aLeftImag[sb];
+            *pt_rTmp = tmp;
+            *pt_iTmp = tmp2;
+
+
+        } /* sb */
+    }
+
+
+    maxsb = min(h_ps_dec->usb, 64);     /*  64 == groupBorders[NO_BINS+2] */
+
+    /* sb = subQMF/QMF subband */
+
+    {
+
+        for (sb = 35; sb < maxsb; sb++)    /*  35 == groupBorders[NO_BINS+1] */
+        {
+
+            Int32 *pt_rTmp, *pt_iTmp;
+
+            sb_delay = sb - NO_QMF_CHANNELS_IN_HYBRID;  /*  == 3 */
+
+            /*
+             *  For the Upper Bands apply delay only
+             *                          -D(k)
+             *  Apply Delay   H_k(z) = z         , D(k) == 1 or 14
+             *
+             */
+
+            pt_rTmp = &ppRealDelayBuffer[sb_delay][0];
+            pt_iTmp = &ppImagDelayBuffer[sb_delay][0];
+
+            aRightReal[sb] = *pt_rTmp;
+            aRightImag[sb] = *pt_iTmp;
+
+
+            if (aTransRatio[NO_BINS-1] < 0x7FFFFFFF)
+            {
+                aRightReal[sb] = fxp_mul32_Q31(aTransRatio[NO_BINS-1], aRightReal[sb]) << 1;
+                aRightImag[sb] = fxp_mul32_Q31(aTransRatio[NO_BINS-1], aRightImag[sb]) << 1;
+            }
+
+            *pt_rTmp = aLeftReal[sb];
+            *pt_iTmp = aLeftImag[sb];
+
+
+        } /* sb */
+    }
+
+
+    if (++h_ps_dec->delayBufIndex >= DELAY_ALLPASS)
+    {
+        h_ps_dec->delayBufIndex = 0;
+    }
+
+    if (++h_ps_dec->aDelayRBufIndexSer[0] >= 3)
+    {
+        h_ps_dec->aDelayRBufIndexSer[0] = 0;
+    }
+    if (++h_ps_dec->aDelayRBufIndexSer[1] >= 4)
+    {
+        h_ps_dec->aDelayRBufIndexSer[1] = 0;
+    }
+    if (++h_ps_dec->aDelayRBufIndexSer[2] >= 5)
+    {
+        h_ps_dec->aDelayRBufIndexSer[2] = 0;
+    }
+
+
+} /* END deCorrelate */
+#endif
+
+
+#endif
+
diff --git a/media/libstagefright/codecs/aacdec/ps_decorrelate.h b/media/libstagefright/codecs/aacdec/ps_decorrelate.h
new file mode 100644
index 0000000..c2a025a
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/ps_decorrelate.h
@@ -0,0 +1,99 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Pathname: ps_decorrelate.h
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+ Who:                   Date:
+ Description:
+
+------------------------------------------------------------------------------
+ INCLUDE DESCRIPTION
+
+ Header file for function ps_decorrelate()
+
+------------------------------------------------------------------------------
+*/
+
+/*----------------------------------------------------------------------------
+; CONTINUE ONLY IF NOT ALREADY DEFINED
+----------------------------------------------------------------------------*/
+#ifndef PS_DECORRELATE_H
+#define PS_DECORRELATE_H
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+#include "pv_audio_type_defs.h"
+#include "s_ps_dec.h"
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here.
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL VARIABLES REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; SIMPLE TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; ENUMERATED TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; STRUCTURES TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; GLOBAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+    void ps_decorrelate(STRUCT_PS_DEC *h_ps_dec,
+    Int32 *rIntBufferLeft,
+    Int32 *iIntBufferLeft,
+    Int32 *rIntBufferRight,
+    Int32 *iIntBufferRight,
+    Int32 scratch_mem[]);
+
+#ifdef __cplusplus
+}
+#endif
+
+/*----------------------------------------------------------------------------
+; END
+----------------------------------------------------------------------------*/
+#endif  /* PS_DECORRELATE_H */
diff --git a/media/libstagefright/codecs/aacdec/ps_fft_rx8.cpp b/media/libstagefright/codecs/aacdec/ps_fft_rx8.cpp
new file mode 100644
index 0000000..7669be3
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/ps_fft_rx8.cpp
@@ -0,0 +1,318 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Pathname: fft_rx8.c
+ Funtions: ps_fft_rx8
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+
+
+ Who:                       Date:
+ Description:
+
+------------------------------------------------------------------------------
+ INPUT AND OUTPUT DEFINITIONS
+
+ Inputs:
+    Real     Vector of Real components size 8
+
+    Imag     Vector of Imag components size 8
+             type Int32
+
+
+ Local Stores/Buffers/Pointers Needed:
+    None
+
+ Global Stores/Buffers/Pointers Needed:
+     scratch_mem size 32
+
+ Outputs:
+    In-place calculation of a 8-point FFT (radix-8)
+
+ Pointers and Buffers Modified:
+    calculation are done in-place and returned in Data
+
+ Local Stores Modified:
+    None
+
+ Global Stores Modified:
+    None
+
+------------------------------------------------------------------------------
+ FUNCTION DESCRIPTION
+
+    8-point DFT, radix 8 with Decimation in Frequency
+
+------------------------------------------------------------------------------
+ REQUIREMENTS
+
+    This function should provide a fixed point FFT for any input array
+    of size power of 8.
+
+------------------------------------------------------------------------------
+ REFERENCES
+
+    [1] Advance Digital Signal Processing, J. Proakis, C. Rader, F. Ling,
+        C. Nikias, Macmillan Pub. Co.
+
+------------------------------------------------------------------------------
+ PSEUDO-CODE
+
+
+   MODIFY( x[] )
+   RETURN( exponent )
+
+------------------------------------------------------------------------------
+ RESOURCES USED
+   When the code is written for a specific target processor the
+     the resources used should be documented below.
+
+ STACK USAGE: [stack count for this module] + [variable to represent
+          stack usage for each subroutine called]
+
+     where: [stack usage variable] = stack usage for [subroutine
+         name] (see [filename].ext)
+
+ DATA MEMORY USED: x words
+
+ PROGRAM MEMORY USED: x words
+
+ CLOCK CYCLES: [cycle count equation for this module] + [variable
+           used to represent cycle count for each subroutine
+           called]
+
+     where: [cycle count variable] = cycle count for [subroutine
+        name] (see [filename].ext)
+
+------------------------------------------------------------------------------
+*/
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+
+#ifdef AAC_PLUS
+
+
+#ifdef PARAMETRICSTEREO
+
+
+#include "pv_audio_type_defs.h"
+#include "ps_fft_rx8.h"
+
+#include    "fxp_mul32.h"
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here. Include conditional
+; compile variables also.
+----------------------------------------------------------------------------*/
+#define R_SHIFT     29
+#define Q29_fmt(x)   (Int32)(x*((Int32)1<<R_SHIFT) + (x>=0?0.5F:-0.5F))
+
+/*----------------------------------------------------------------------------
+; LOCAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; LOCAL VARIABLE DEFINITIONS
+; Variable declaration - defined here and used outside this module
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL FUNCTION REFERENCES
+; Declare functions defined elsewhere and referenced in this module
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL VARIABLES REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL GLOBAL STORE/BUFFER/POINTER REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; FUNCTION CODE
+----------------------------------------------------------------------------*/
+
+void ps_fft_rx8(Int32 Re[], Int32 Im[], Int32 scratch_mem[])
+
+/* scratch_mem size 32 */
+{
+
+    Int     i;
+    Int32   *Q = &scratch_mem[0];
+    Int32   *Z = &scratch_mem[16];
+    Int32   temp1;
+    Int32   temp2;
+    Int32   temp3;
+    Int32   temp4;
+    Int32   aux_r[2];
+    Int32   aux_i[2];
+    Int32   *pt_r1 = &Re[0];
+    Int32   *pt_r2 = &Re[4];
+    Int32   *pt_i1 = &Im[0];
+    Int32   *pt_i2 = &Im[4];
+
+    Int32   *pt_Q = Q;
+    Int32   *pt_Z = Z;
+
+
+    temp1 = *(pt_r1++); /*  Real */
+    temp2 = *(pt_r2++); /*  Real */
+    temp3 = *(pt_i1++); /*  Imag */
+    temp4 = *(pt_i2++); /*  Imag */
+    /*
+     *  Vector Q stores data as Real, Imag, Real, Imag,....
+     */
+
+    *(pt_Q++) = temp1 + temp2;  /* Q(0) =  v(0) + v(4) */
+    *(pt_Q++) = temp3 + temp4;
+    *(pt_Q++) = temp1 - temp2;  /* Q(1) =  v(0) - v(4) */
+    *(pt_Q++) = temp3 - temp4;
+
+    temp1 = *(pt_r1++);
+    temp2 = *(pt_r2++);
+    temp3 = *(pt_i1++);
+    temp4 = *(pt_i2++);
+
+    *(pt_Q++) = temp1 + temp2;  /*    Q(2) =  v(1) + v(5) */
+    *(pt_Q++) = temp3 + temp4;
+    aux_r[0]  = temp1 - temp2;  /* aux[0]  =  v(1) - v(5) */
+    aux_i[0]  = temp3 - temp4;
+
+    temp1 = *(pt_r1++);
+    temp2 = *(pt_r2++);
+    temp3 = *(pt_i1++);
+    temp4 = *(pt_i2++);
+
+    *(pt_Q++) = temp1 + temp2;  /*  Q(3) =  v(2) + v(6) */
+    *(pt_Q++) = temp3 + temp4;
+    *(pt_Q++) = temp4 - temp3;  /*  Q(4) = (v(2) - v(6))*j */
+    *(pt_Q++) = temp1 - temp2;
+
+    temp1 = *(pt_r1++);
+    temp2 = *(pt_r2++);
+    temp3 = *(pt_i1++);
+    temp4 = *(pt_i2++);
+
+
+    *(pt_Q++) = temp1 + temp2;  /*  Q(5)   = v(3) + v(7) */
+    *(pt_Q++) = temp3 + temp4;
+    aux_r[1]  = temp1 - temp2;  /*  aux[1] = v(3) - v(7) */
+    aux_i[1]  = temp3 - temp4;
+    /*  Q(6) =  (aux[0] - aux[1])/sqrt(2); */
+    *(pt_Q++) = fxp_mul32_Q29((aux_r[0] - aux_r[1]), Q29_fmt(0.70710678118655f));
+    *(pt_Q++) = fxp_mul32_Q29((aux_i[0] - aux_i[1]), Q29_fmt(0.70710678118655f));
+
+    /*  Q(7) =  (aux[0] + aux[1])*j/sqrt(2); */
+    *(pt_Q++) =  fxp_mul32_Q29((aux_i[0] + aux_i[1]), Q29_fmt(-0.70710678118655f));
+    *(pt_Q) =  fxp_mul32_Q29((aux_r[0] + aux_r[1]), Q29_fmt(0.70710678118655f));
+
+    pt_r1 = &Q[0];        /* reset pointer */
+    pt_r2 = &Q[6];        /* reset pointer */
+
+    temp1 = *(pt_r1++);
+    temp2 = *(pt_r2++);
+    temp3 = *(pt_r1++);
+    temp4 = *(pt_r2++);
+
+    /*
+     *  Vector Z stores data as Real, Imag, Real, Imag,....
+     */
+
+    *(pt_Z++) = temp1 + temp2;  /* Q(0) + Q(3) */
+    *(pt_Z++) = temp3 + temp4;
+    aux_r[0]  = temp1 - temp2;
+    aux_i[0]  = temp3 - temp4;
+
+    temp1 = *(pt_r1++);
+    temp2 = *(pt_r2++);
+    temp3 = *(pt_r1++);
+    temp4 = *(pt_r2++);
+
+    *(pt_Z++) = temp1 + temp2;  /* Q(1) + Q(4) */
+    *(pt_Z++) = temp3 + temp4;
+    *(pt_Z++) = aux_r[0];       /* Q(0) - Q(3) */
+    *(pt_Z++) = aux_i[0];
+    *(pt_Z++) = temp1 - temp2;  /* Q(1) - Q(4) */
+    *(pt_Z++) = temp3 - temp4;
+
+    temp1 = *(pt_r1++);
+    temp2 = *(pt_r2++);
+    temp3 = *(pt_r1);
+    temp4 = *(pt_r2++);
+
+    *(pt_Z++) = temp1 + temp2;  /* Q(2) + Q(5) */
+    *(pt_Z++) = temp3 + temp4;
+    aux_r[0]  = temp1 - temp2;
+    aux_i[0]  = temp3 - temp4;
+
+    temp1 = *(pt_r2++);
+    temp3 = *(pt_r2++);
+    temp2 = *(pt_r2++);
+    temp4 = *(pt_r2);
+
+    *(pt_Z++) = temp1 + temp2;  /* Q(6) + Q(7) */
+    *(pt_Z++) = temp3 + temp4;
+
+    *(pt_Z++) = -aux_i[0];      /* (Q(2) - Q(5))*j */
+    *(pt_Z++) =  aux_r[0];
+
+    *(pt_Z++) =  temp2 - temp1;  /* -Q(6) + Q(7) */
+    *(pt_Z) =  temp4 - temp3;
+
+    pt_Z = &Z[0];        /* reset pointer */
+    pt_Q = &Z[8];        /* reset pointer */
+
+    pt_r1 = &Re[0];
+    pt_r2 = &Re[4];
+    pt_i1 = &Im[0];
+    pt_i2 = &Im[4];
+
+
+    for (i = 4; i != 0; i--)
+    {
+        temp1 = *(pt_Z++);
+        temp2 = *(pt_Q++);
+        temp3 = *(pt_Z++);
+        temp4 = *(pt_Q++);
+
+        *(pt_r1++) = temp1 + temp2;  /* Z(n) + Z(n+4) */
+        *(pt_i1++) = temp3 + temp4;
+        *(pt_r2++) = temp1 - temp2;  /* Z(n) - Z(n+4) */
+        *(pt_i2++) = temp3 - temp4;
+    }
+
+}
+
+#endif  /* PARAMETRICSTEREO */
+
+
+#endif  /* AAC_PLUS */
diff --git a/media/libstagefright/codecs/aacdec/ps_fft_rx8.h b/media/libstagefright/codecs/aacdec/ps_fft_rx8.h
new file mode 100644
index 0000000..6c3482e
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/ps_fft_rx8.h
@@ -0,0 +1,94 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Pathname: ps_fft_rx8.h
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+ Who:                   Date:
+ Description:
+
+------------------------------------------------------------------------------
+ INCLUDE DESCRIPTION
+
+ Header file for functions ps_fft_rx8()
+
+
+------------------------------------------------------------------------------
+*/
+
+/*----------------------------------------------------------------------------
+; CONTINUE ONLY IF NOT ALREADY DEFINED
+----------------------------------------------------------------------------*/
+#ifndef PS_FFT_RX8_H
+#define PS_FFT_RX8_H
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+#include "pv_audio_type_defs.h"
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here.
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL VARIABLES REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; SIMPLE TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; ENUMERATED TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; STRUCTURES TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; GLOBAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+    void ps_fft_rx8(Int32 Re[], Int32 Im[], Int32 scratch_mem[]);
+
+#ifdef __cplusplus
+}
+#endif
+
+/*----------------------------------------------------------------------------
+; END
+----------------------------------------------------------------------------*/
+#endif  /* PS_FFT_RX4_H */
diff --git a/media/libstagefright/codecs/aacdec/ps_hybrid_analysis.cpp b/media/libstagefright/codecs/aacdec/ps_hybrid_analysis.cpp
new file mode 100644
index 0000000..933b07e
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/ps_hybrid_analysis.cpp
@@ -0,0 +1,285 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Filename: ps_hybrid_analysis.c
+
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+
+ Who:                                   Date: MM/DD/YYYY
+ Description:
+
+------------------------------------------------------------------------------
+ INPUT AND OUTPUT DEFINITIONS
+
+
+
+------------------------------------------------------------------------------
+ FUNCTION DESCRIPTION
+
+    Does Hybrid analysis:
+
+        Get higher frequency resolution in the lower QMF subbands
+        creating sub-subbands. This is done by low frequency filtering.
+        Lower QMF subbands are further split in order to obtain a higher
+        frequency resolution, enabling a proper stereo analysis and synthesis
+        for the lower frequencies.
+        Two hybrid are defined. Both filters have length 13 and a delay of 6.
+        In this implementation, the symmetry of the filters helps to simplify
+        the design.
+
+
+   Increase Freq. Resolution
+     _______                                              ________
+    |       |                                  _______   |        |
+  ->|Hybrid | LF ----                         |       |->| Hybrid |-->
+    | Anal. |        |                        |       |  | Synth  |   QMF -> L
+     -------         o----------------------->|       |   --------    Synth
+QMF                  |                s_k(n)  |Stereo |-------------->
+Anal.              -------------------------->|       |
+     _______       | |                        |       |   ________
+    |       | HF --o |   -----------          |Process|  |        |
+  ->| Delay |      |  ->|           |-------->|       |->| Hybrid |-->
+     -------       |    |decorrelate| d_k(n)  |       |  | Synth  |   QMF -> R
+                   ---->|           |-------->|       |   --------    Synth
+                         -----------          |_______|-------------->
+
+
+
+          subband k             QMF channel
+             0   .................  0      -----------
+             1   .................  0
+             2   .................  0
+             3   .................  0
+             4   .................  0
+             5   .................  0        Sub-QMF  ( Increase Freq. Resolution)
+             6   .................  1
+             7   .................  1
+             8   .................  2
+             9   .................  2
+            10   .................  3      -----------
+            11   .................  4
+            12   .................  5
+            13   .................  6
+            14   .................  7
+            15   .................  8         QMF
+           16-17 .................  9-10
+           18-20 ................. 11-13
+           21-24 ................. 14-17
+           25-29 ................. 18-22
+           30-41 ................. 23-34
+           42-70 ................. 35-63   -----------
+
+------------------------------------------------------------------------------
+ REQUIREMENTS
+
+
+------------------------------------------------------------------------------
+ REFERENCES
+
+SC 29 Software Copyright Licencing Disclaimer:
+
+This software module was originally developed by
+  Coding Technologies
+
+and edited by
+  -
+
+in the course of development of the ISO/IEC 13818-7 and ISO/IEC 14496-3
+standards for reference purposes and its performance may not have been
+optimized. This software module is an implementation of one or more tools as
+specified by the ISO/IEC 13818-7 and ISO/IEC 14496-3 standards.
+ISO/IEC gives users free license to this software module or modifications
+thereof for use in products claiming conformance to audiovisual and
+image-coding related ITU Recommendations and/or ISO/IEC International
+Standards. ISO/IEC gives users the same free license to this software module or
+modifications thereof for research purposes and further ISO/IEC standardisation.
+Those intending to use this software module in products are advised that its
+use may infringe existing patents. ISO/IEC have no liability for use of this
+software module or modifications thereof. Copyright is not released for
+products that do not conform to audiovisual and image-coding related ITU
+Recommendations and/or ISO/IEC International Standards.
+The original developer retains full right to modify and use the code for its
+own purpose, assign or donate the code to a third party and to inhibit third
+parties from using the code for products that do not conform to audiovisual and
+image-coding related ITU Recommendations and/or ISO/IEC International Standards.
+This copyright notice must be included in all copies or derivative works.
+Copyright (c) ISO/IEC 2003.
+
+------------------------------------------------------------------------------
+ PSEUDO-CODE
+
+------------------------------------------------------------------------------
+*/
+
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+
+#ifdef AAC_PLUS
+
+#ifdef PARAMETRICSTEREO
+
+#include    "s_hybrid.h"
+#include    "aac_mem_funcs.h"
+#include    "ps_channel_filtering.h"
+#include    "ps_hybrid_analysis.h"
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here. Include conditional
+; compile variables also.
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; LOCAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; LOCAL STORE/BUFFER/POINTER DEFINITIONS
+; Variable declaration - defined here and used outside this module
+----------------------------------------------------------------------------*/
+
+
+/*----------------------------------------------------------------------------
+; EXTERNAL FUNCTION REFERENCES
+; Declare functions defined elsewhere and referenced in this module
+----------------------------------------------------------------------------*/
+
+
+
+/*----------------------------------------------------------------------------
+; EXTERNAL GLOBAL STORE/BUFFER/POINTER REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+
+/*----------------------------------------------------------------------------
+; FUNCTION CODE
+----------------------------------------------------------------------------*/
+
+void ps_hybrid_analysis(const Int32 mQmfReal[][64],
+                        const Int32 mQmfImag[][64],
+                        Int32 *mHybridReal,
+                        Int32 *mHybridImag,
+                        HYBRID *pHybrid,
+                        Int32 scratch_mem[],
+                        Int32 i)
+
+{
+
+    Int32 band;
+    HYBRID_RES hybridRes;
+    Int32  chOffset = 0;
+
+    Int32 *ptr_mHybrid_Re;
+    Int32 *ptr_mHybrid_Im;
+
+    Int32 *pt_mQmfBufferReal;
+    Int32 *pt_mQmfBufferImag;
+
+    pt_mQmfBufferReal = &scratch_mem[32 + i];
+
+    for (band = 0; band < pHybrid->nQmfBands; band++)
+    {
+        pt_mQmfBufferImag = pt_mQmfBufferReal + 44;
+
+
+        pt_mQmfBufferReal[HYBRID_FILTER_LENGTH_m_1] = mQmfReal[HYBRID_FILTER_DELAY][band];
+        pt_mQmfBufferImag[HYBRID_FILTER_LENGTH_m_1] = mQmfImag[HYBRID_FILTER_DELAY][band];
+
+
+        ptr_mHybrid_Re = &mHybridReal[ chOffset];
+        ptr_mHybrid_Im = &mHybridImag[ chOffset];
+
+        hybridRes = (HYBRID_RES)pHybrid->pResolution[band];
+        switch (hybridRes)
+        {
+                /*
+                 *  For QMF band = 1  and  2
+                 */
+
+            case HYBRID_2_REAL:
+
+                two_ch_filtering(pt_mQmfBufferReal,
+                                 pt_mQmfBufferImag,
+                                 ptr_mHybrid_Re,
+                                 ptr_mHybrid_Im);
+                chOffset += 2;
+
+                break;
+
+                /*
+                 *  For QMF band = 0
+                 */
+
+            case HYBRID_8_CPLX:
+
+                eight_ch_filtering(pt_mQmfBufferReal,
+                                   pt_mQmfBufferImag,
+                                   pHybrid->mTempReal,
+                                   pHybrid->mTempImag,
+                                   scratch_mem);
+
+                pv_memmove(ptr_mHybrid_Re, pHybrid->mTempReal, 4*sizeof(*pHybrid->mTempReal));
+
+                ptr_mHybrid_Re += 2;
+
+                *(ptr_mHybrid_Re++) +=  pHybrid->mTempReal[5];
+                *(ptr_mHybrid_Re++) +=  pHybrid->mTempReal[4];
+                *(ptr_mHybrid_Re++)  =  pHybrid->mTempReal[6];
+                *(ptr_mHybrid_Re)  =  pHybrid->mTempReal[7];
+
+                pv_memmove(ptr_mHybrid_Im, pHybrid->mTempImag, 4*sizeof(*pHybrid->mTempImag));
+                ptr_mHybrid_Im += 2;
+
+                *(ptr_mHybrid_Im++) +=  pHybrid->mTempImag[5];
+                *(ptr_mHybrid_Im++) +=  pHybrid->mTempImag[4];
+                *(ptr_mHybrid_Im++)  =  pHybrid->mTempImag[6];
+                *(ptr_mHybrid_Im)  =  pHybrid->mTempImag[7];
+
+                chOffset += 6;
+
+                break;
+
+            default:
+                ;
+        }
+
+        pt_mQmfBufferReal = pt_mQmfBufferImag + 44;
+
+    }
+
+
+}
+#endif
+
+
+#endif
+
diff --git a/media/libstagefright/codecs/aacdec/ps_hybrid_analysis.h b/media/libstagefright/codecs/aacdec/ps_hybrid_analysis.h
new file mode 100644
index 0000000..0140a1f
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/ps_hybrid_analysis.h
@@ -0,0 +1,98 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Pathname: ps_hybrid_analysis.h
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+ Who:                   Date:
+ Description:
+
+------------------------------------------------------------------------------
+ INCLUDE DESCRIPTION
+
+ Header file for function ps_hybrid_analysis()
+
+------------------------------------------------------------------------------
+*/
+
+/*----------------------------------------------------------------------------
+; CONTINUE ONLY IF NOT ALREADY DEFINED
+----------------------------------------------------------------------------*/
+#ifndef PS_HYBRID_ANALYSIS_H
+#define PS_HYBRID_ANALYSIS_H
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+#include "pv_audio_type_defs.h"
+#include "s_hybrid.h"
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here.
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL VARIABLES REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; SIMPLE TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; ENUMERATED TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; STRUCTURES TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; GLOBAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+    void ps_hybrid_analysis(const Int32 mQmfReal[][64],
+    const Int32 mQmfImag[][64],
+    Int32 *mHybridReal,
+    Int32 *mHybridImag,
+    HYBRID *pHybrid,
+    Int32 scratch_mem[],
+    Int32 band);
+#ifdef __cplusplus
+}
+#endif
+
+/*----------------------------------------------------------------------------
+; END
+----------------------------------------------------------------------------*/
+#endif  /* PS_HYBRID_ANALYSIS_H */
diff --git a/media/libstagefright/codecs/aacdec/ps_hybrid_filter_bank_allocation.cpp b/media/libstagefright/codecs/aacdec/ps_hybrid_filter_bank_allocation.cpp
new file mode 100644
index 0000000..4ff2385
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/ps_hybrid_filter_bank_allocation.cpp
@@ -0,0 +1,213 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Filename: ps_hybrid_filter_bank_allocation.c
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+
+ Who:                                   Date: MM/DD/YYYY
+ Description:
+
+------------------------------------------------------------------------------
+ INPUT AND OUTPUT DEFINITIONS
+
+
+
+------------------------------------------------------------------------------
+ FUNCTION DESCRIPTION
+
+        Does Hybrid filter bank memory allocation
+
+------------------------------------------------------------------------------
+ REQUIREMENTS
+
+
+------------------------------------------------------------------------------
+ REFERENCES
+
+SC 29 Software Copyright Licencing Disclaimer:
+
+This software module was originally developed by
+  Coding Technologies
+
+and edited by
+  -
+
+in the course of development of the ISO/IEC 13818-7 and ISO/IEC 14496-3
+standards for reference purposes and its performance may not have been
+optimized. This software module is an implementation of one or more tools as
+specified by the ISO/IEC 13818-7 and ISO/IEC 14496-3 standards.
+ISO/IEC gives users free license to this software module or modifications
+thereof for use in products claiming conformance to audiovisual and
+image-coding related ITU Recommendations and/or ISO/IEC International
+Standards. ISO/IEC gives users the same free license to this software module or
+modifications thereof for research purposes and further ISO/IEC standardisation.
+Those intending to use this software module in products are advised that its
+use may infringe existing patents. ISO/IEC have no liability for use of this
+software module or modifications thereof. Copyright is not released for
+products that do not conform to audiovisual and image-coding related ITU
+Recommendations and/or ISO/IEC International Standards.
+The original developer retains full right to modify and use the code for its
+own purpose, assign or donate the code to a third party and to inhibit third
+parties from using the code for products that do not conform to audiovisual and
+image-coding related ITU Recommendations and/or ISO/IEC International Standards.
+This copyright notice must be included in all copies or derivative works.
+Copyright (c) ISO/IEC 2003.
+
+------------------------------------------------------------------------------
+ PSEUDO-CODE
+
+------------------------------------------------------------------------------
+*/
+
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+
+#ifdef AAC_PLUS
+
+#ifdef PARAMETRICSTEREO
+#include    "aac_mem_funcs.h"
+#include    "ps_hybrid_filter_bank_allocation.h"
+#include    "ps_all_pass_filter_coeff.h"
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here. Include conditional
+; compile variables also.
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; LOCAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; LOCAL STORE/BUFFER/POINTER DEFINITIONS
+; Variable declaration - defined here and used outside this module
+----------------------------------------------------------------------------*/
+
+
+/*----------------------------------------------------------------------------
+; EXTERNAL FUNCTION REFERENCES
+; Declare functions defined elsewhere and referenced in this module
+----------------------------------------------------------------------------*/
+
+
+
+/*----------------------------------------------------------------------------
+; EXTERNAL GLOBAL STORE/BUFFER/POINTER REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+
+/*----------------------------------------------------------------------------
+; FUNCTION CODE
+----------------------------------------------------------------------------*/
+
+Int32 ps_hybrid_filter_bank_allocation(HYBRID **phHybrid,
+                                       Int32 noBands,
+                                       const Int32 *pResolution,
+                                       Int32 **pPtr)
+{
+    Int32 i;
+    Int32 tmp;
+    Int32 maxNoChannels = 0;
+    HYBRID *hs;
+    Int32 *ptr = *pPtr;
+
+
+    *phHybrid = (HYBRID *)NULL;
+
+    hs = (HYBRID *)ptr;
+
+    ptr += sizeof(HYBRID) / sizeof(*ptr);
+
+    hs->pResolution = (Int32*)ptr;
+
+    ptr += noBands * sizeof(Int32) / sizeof(*ptr);
+
+    for (i = 0; i < noBands; i++)
+    {
+
+        hs->pResolution[i] = pResolution[i];
+
+        if (pResolution[i] != HYBRID_8_CPLX &&
+                pResolution[i] != HYBRID_2_REAL &&
+                pResolution[i] != HYBRID_4_CPLX)
+        {
+            return 1;
+        }
+
+        if (pResolution[i] > maxNoChannels)
+        {
+            maxNoChannels = pResolution[i];
+        }
+    }
+
+    hs->nQmfBands     = noBands;
+    hs->qmfBufferMove = HYBRID_FILTER_LENGTH - 1;
+
+    hs->mQmfBufferReal = (Int32 **)ptr;
+    ptr += noBands * sizeof(ptr) / sizeof(*ptr);
+
+    hs->mQmfBufferImag = (Int32 **)ptr;
+    ptr += noBands * sizeof(ptr) / sizeof(*ptr);
+
+    tmp = hs->qmfBufferMove;        /*  HYBRID_FILTER_LENGTH == 13 */
+
+    for (i = 0; i < noBands; i++)
+    {
+        hs->mQmfBufferReal[i] = ptr;
+        ptr += tmp;
+
+        hs->mQmfBufferImag[i] = ptr;
+        ptr += tmp;
+
+    }
+
+    hs->mTempReal = ptr;
+    ptr += maxNoChannels;
+
+
+    hs->mTempImag = ptr;
+    ptr += maxNoChannels;
+
+
+    *phHybrid = hs;
+    *pPtr = ptr;
+
+    return 0;
+}
+
+
+#endif
+
+
+#endif
+
diff --git a/media/libstagefright/codecs/aacdec/ps_hybrid_filter_bank_allocation.h b/media/libstagefright/codecs/aacdec/ps_hybrid_filter_bank_allocation.h
new file mode 100644
index 0000000..fbc0d80
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/ps_hybrid_filter_bank_allocation.h
@@ -0,0 +1,97 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Pathname: ps_hybrid_filter_bank_allocation.h
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+ Who:                   Date:
+ Description:
+
+------------------------------------------------------------------------------
+ INCLUDE DESCRIPTION
+
+ Header file for ps_hybrid_filter_bank_allocation
+
+------------------------------------------------------------------------------
+*/
+
+/*----------------------------------------------------------------------------
+; CONTINUE ONLY IF NOT ALREADY DEFINED
+----------------------------------------------------------------------------*/
+#ifndef PS_HYBRID_FILTER_BANK_ALLOCATION_H
+#define PS_HYBRID_FILTER_BANK_ALLOCATION_H
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+#include    "pv_audio_type_defs.h"
+#include    "s_hybrid.h"
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here.
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL VARIABLES REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; SIMPLE TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; ENUMERATED TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; STRUCTURES TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; GLOBAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+    Int32 ps_hybrid_filter_bank_allocation(HYBRID **phHybrid,
+    Int32 noBands,
+    const Int32 *pResolution,
+    Int32 **pPtr);
+
+#ifdef __cplusplus
+}
+#endif
+
+/*----------------------------------------------------------------------------
+; END
+----------------------------------------------------------------------------*/
+#endif  /* PS_HYBRID_FILTER_BANK_ALLOCATION_H */
diff --git a/media/libstagefright/codecs/aacdec/ps_hybrid_synthesis.cpp b/media/libstagefright/codecs/aacdec/ps_hybrid_synthesis.cpp
new file mode 100644
index 0000000..4fbd016
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/ps_hybrid_synthesis.cpp
@@ -0,0 +1,192 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Filename: ps_hybrid_synthesis.c
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+
+ Who:                                   Date: MM/DD/YYYY
+ Description:
+
+------------------------------------------------------------------------------
+ INPUT AND OUTPUT DEFINITIONS
+
+
+
+------------------------------------------------------------------------------
+ FUNCTION DESCRIPTION
+
+        Hybrid synthesis
+
+     _______                                              ________
+    |       |                                  _______   |        |
+  ->|Hybrid | LF ----                         |       |->| Hybrid |-->
+    | Anal. |        |                        |       |  | Synth  |   QMF -> L
+     -------         o----------------------->|       |   --------    Synth
+QMF                  |                s_k(n)  |Stereo |-------------->
+Anal.              -------------------------->|       |
+     _______       | |                        |       |   ________
+    |       | HF --o |   -----------          |Process|  |        |
+  ->| Delay |      |  ->|           |-------->|       |->| Hybrid |-->
+     -------       |    |decorrelate| d_k(n)  |       |  | Synth  |   QMF -> R
+                   ---->|           |-------->|       |   --------    Synth
+                         -----------          |_______|-------------->
+
+
+------------------------------------------------------------------------------
+ REQUIREMENTS
+
+
+------------------------------------------------------------------------------
+ REFERENCES
+
+SC 29 Software Copyright Licencing Disclaimer:
+
+This software module was originally developed by
+  Coding Technologies
+
+and edited by
+  -
+
+in the course of development of the ISO/IEC 13818-7 and ISO/IEC 14496-3
+standards for reference purposes and its performance may not have been
+optimized. This software module is an implementation of one or more tools as
+specified by the ISO/IEC 13818-7 and ISO/IEC 14496-3 standards.
+ISO/IEC gives users free license to this software module or modifications
+thereof for use in products claiming conformance to audiovisual and
+image-coding related ITU Recommendations and/or ISO/IEC International
+Standards. ISO/IEC gives users the same free license to this software module or
+modifications thereof for research purposes and further ISO/IEC standardisation.
+Those intending to use this software module in products are advised that its
+use may infringe existing patents. ISO/IEC have no liability for use of this
+software module or modifications thereof. Copyright is not released for
+products that do not conform to audiovisual and image-coding related ITU
+Recommendations and/or ISO/IEC International Standards.
+The original developer retains full right to modify and use the code for its
+own purpose, assign or donate the code to a third party and to inhibit third
+parties from using the code for products that do not conform to audiovisual and
+image-coding related ITU Recommendations and/or ISO/IEC International Standards.
+This copyright notice must be included in all copies or derivative works.
+Copyright (c) ISO/IEC 2003.
+
+------------------------------------------------------------------------------
+ PSEUDO-CODE
+
+------------------------------------------------------------------------------
+*/
+
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+
+#ifdef AAC_PLUS
+
+#ifdef PARAMETRICSTEREO
+
+#include "s_hybrid.h"
+#include "ps_hybrid_synthesis.h"
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here. Include conditional
+; compile variables also.
+----------------------------------------------------------------------------*/
+#ifndef min
+#define min(a, b) ((a) < (b) ? (a) : (b))
+#endif
+
+/*----------------------------------------------------------------------------
+; LOCAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; LOCAL STORE/BUFFER/POINTER DEFINITIONS
+; Variable declaration - defined here and used outside this module
+----------------------------------------------------------------------------*/
+
+
+/*----------------------------------------------------------------------------
+; EXTERNAL FUNCTION REFERENCES
+; Declare functions defined elsewhere and referenced in this module
+----------------------------------------------------------------------------*/
+
+
+/*----------------------------------------------------------------------------
+; EXTERNAL GLOBAL STORE/BUFFER/POINTER REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+
+/*----------------------------------------------------------------------------
+; FUNCTION CODE
+----------------------------------------------------------------------------*/
+void ps_hybrid_synthesis(const Int32 *mHybridReal,
+                         const Int32 *mHybridImag,
+                         Int32 *mQmfReal,
+                         Int32 *mQmfImag,
+                         HYBRID *hHybrid)
+{
+    Int32  k;
+    Int32  band;
+    HYBRID_RES hybridRes;
+
+    Int32 real;
+    Int32 imag;
+    Int32 *ptr_mQmfReal = mQmfReal;
+    Int32 *ptr_mQmfImag = mQmfImag;
+    const Int32 *ptr_mHybrid_Re = mHybridReal;
+    const Int32 *ptr_mHybrid_Im = mHybridImag;
+
+    for (band = 0; band < hHybrid->nQmfBands; band++)
+    {
+        hybridRes = (HYBRID_RES)(min(hHybrid->pResolution[band], 6) - 2);
+
+        real  = *(ptr_mHybrid_Re++);
+        real += *(ptr_mHybrid_Re++);
+        imag  = *(ptr_mHybrid_Im++);
+        imag += *(ptr_mHybrid_Im++);
+
+        for (k = (hybridRes >> 1); k != 0; k--)    /*  hybridRes = { 2,4,6 }  */
+        {
+            real += *(ptr_mHybrid_Re++);
+            real += *(ptr_mHybrid_Re++);
+            imag += *(ptr_mHybrid_Im++);
+            imag += *(ptr_mHybrid_Im++);
+        }
+
+        *(ptr_mQmfReal++) = real;
+        *(ptr_mQmfImag++) = imag;
+    }
+}
+
+#endif
+
+
+#endif
+
diff --git a/media/libstagefright/codecs/aacdec/ps_hybrid_synthesis.h b/media/libstagefright/codecs/aacdec/ps_hybrid_synthesis.h
new file mode 100644
index 0000000..d7242dd
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/ps_hybrid_synthesis.h
@@ -0,0 +1,97 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Pathname: ps_hybrid_synthesis.h
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+ Who:                   Date:
+ Description:
+
+------------------------------------------------------------------------------
+ INCLUDE DESCRIPTION
+
+ Header file for function ps_hybrid_synthesis()
+
+------------------------------------------------------------------------------
+*/
+
+/*----------------------------------------------------------------------------
+; CONTINUE ONLY IF NOT ALREADY DEFINED
+----------------------------------------------------------------------------*/
+#ifndef PS_HYBRID_SYNTHESIS_H
+#define PS_HYBRID_SYNTHESIS_H
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+#include "pv_audio_type_defs.h"
+#include "s_hybrid.h"
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here.
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL VARIABLES REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; SIMPLE TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; ENUMERATED TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; STRUCTURES TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; GLOBAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+    void ps_hybrid_synthesis(const Int32 *mHybridReal,
+    const Int32 *mHybridImag,
+    Int32 *mQmfReal,
+    Int32 *mQmfImag,
+    HYBRID *hHybrid);
+
+#ifdef __cplusplus
+}
+#endif
+
+/*----------------------------------------------------------------------------
+; END
+----------------------------------------------------------------------------*/
+#endif  /* PS_HYBRID_SYNTHESIS_H */
diff --git a/media/libstagefright/codecs/aacdec/ps_init_stereo_mixing.cpp b/media/libstagefright/codecs/aacdec/ps_init_stereo_mixing.cpp
new file mode 100644
index 0000000..7027b5c
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/ps_init_stereo_mixing.cpp
@@ -0,0 +1,496 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Filename: ps_init_stereo_mixing.c
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+
+ Who:                                   Date: MM/DD/YYYY
+ Description:
+
+------------------------------------------------------------------------------
+ INPUT AND OUTPUT DEFINITIONS
+
+
+
+------------------------------------------------------------------------------
+ FUNCTION DESCRIPTION
+
+      initialize mixing procedure  type Ra, type Rb is not supported
+
+------------------------------------------------------------------------------
+ REQUIREMENTS
+
+
+------------------------------------------------------------------------------
+ REFERENCES
+
+SC 29 Software Copyright Licencing Disclaimer:
+
+This software module was originally developed by
+  Coding Technologies
+
+and edited by
+  -
+
+in the course of development of the ISO/IEC 13818-7 and ISO/IEC 14496-3
+standards for reference purposes and its performance may not have been
+optimized. This software module is an implementation of one or more tools as
+specified by the ISO/IEC 13818-7 and ISO/IEC 14496-3 standards.
+ISO/IEC gives users free license to this software module or modifications
+thereof for use in products claiming conformance to audiovisual and
+image-coding related ITU Recommendations and/or ISO/IEC International
+Standards. ISO/IEC gives users the same free license to this software module or
+modifications thereof for research purposes and further ISO/IEC standardisation.
+Those intending to use this software module in products are advised that its
+use may infringe existing patents. ISO/IEC have no liability for use of this
+software module or modifications thereof. Copyright is not released for
+products that do not conform to audiovisual and image-coding related ITU
+Recommendations and/or ISO/IEC International Standards.
+The original developer retains full right to modify and use the code for its
+own purpose, assign or donate the code to a third party and to inhibit third
+parties from using the code for products that do not conform to audiovisual and
+image-coding related ITU Recommendations and/or ISO/IEC International Standards.
+This copyright notice must be included in all copies or derivative works.
+Copyright (c) ISO/IEC 2003.
+
+------------------------------------------------------------------------------
+ PSEUDO-CODE
+
+------------------------------------------------------------------------------
+*/
+
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+
+#ifdef AAC_PLUS
+
+#ifdef PARAMETRICSTEREO
+
+#include    "pv_audio_type_defs.h"
+#include    "fxp_mul32.h"
+
+#include    "aac_mem_funcs.h"
+#include    "pv_sine.h"
+#include    "s_ps_dec.h"
+#include    "ps_all_pass_filter_coeff.h"
+#include    "ps_init_stereo_mixing.h"
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here. Include conditional
+; compile variables also.
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; LOCAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; LOCAL STORE/BUFFER/POINTER DEFINITIONS
+; Variable declaration - defined here and used outside this module
+----------------------------------------------------------------------------*/
+
+/*
+;
+;  c(b) = 10^(iid(b)/20)
+;
+;  Intensity differences
+;
+;                  sqrt(2)
+;   c_1(b) = ----------------
+;            sqrt( 1 + c^2(b))
+;
+;               sqrt(2)*c(b)
+;   c_2(b) = ----------------
+;            sqrt( 1 + c^2(b))
+;
+*/
+
+
+
+#define R_SHIFT     30
+#define Q30_fmt(x)   (Int32)(x*((Int32)1<<R_SHIFT) + (x>=0?0.5F:-0.5F))
+
+const Int32 scaleFactors[NO_IID_LEVELS] =
+{
+    Q30_fmt(1.411983f),  Q30_fmt(1.403138f),  Q30_fmt(1.386877f),
+    Q30_fmt(1.348400f),  Q30_fmt(1.291249f),  Q30_fmt(1.196037f),
+    Q30_fmt(1.107372f),  Q30_fmt(1.000000f),  Q30_fmt(0.879617f),
+    Q30_fmt(0.754649f),  Q30_fmt(0.576780f),  Q30_fmt(0.426401f),
+    Q30_fmt(0.276718f),  Q30_fmt(0.176645f),  Q30_fmt(0.079402f)
+};
+
+const Int32 scaleFactorsFine[NO_IID_LEVELS_FINE] =
+{
+    Q30_fmt(1.414207f),  Q30_fmt(1.414191f),  Q30_fmt(1.414143f),
+    Q30_fmt(1.413990f),  Q30_fmt(1.413507f),  Q30_fmt(1.411983f),
+    Q30_fmt(1.409773f),  Q30_fmt(1.405395f),  Q30_fmt(1.396780f),
+    Q30_fmt(1.380053f),  Q30_fmt(1.348400f),  Q30_fmt(1.313920f),
+    Q30_fmt(1.264310f),  Q30_fmt(1.196037f),  Q30_fmt(1.107372f),
+    Q30_fmt(1.000000f),  Q30_fmt(0.879617f),  Q30_fmt(0.754649f),
+    Q30_fmt(0.633656f),  Q30_fmt(0.523081f),  Q30_fmt(0.426401f),
+    Q30_fmt(0.308955f),  Q30_fmt(0.221375f),  Q30_fmt(0.157688f),
+    Q30_fmt(0.111982f),  Q30_fmt(0.079402f),  Q30_fmt(0.044699f),
+    Q30_fmt(0.025145f),  Q30_fmt(0.014141f),  Q30_fmt(0.007953f),
+    Q30_fmt(0.004472f)
+};
+
+
+/*
+ *  alphas ranged between 0 and pi/2
+ *  alpha(b) = (1/2)*arccos( gamma(b))
+ *
+ *    b   0    1      2        3        4      5        6     7
+ *  gamma 1 0.937  0.84118  0.60092  0.36764   0    -0.589   -1
+ *
+ */
+
+
+
+const Int32 scaled_alphas[NO_ICC_LEVELS] =
+{
+    Q30_fmt(0.00000000000000f),  Q30_fmt(0.12616764875355f),
+    Q30_fmt(0.20199707286122f),  Q30_fmt(0.32744135137762f),
+    Q30_fmt(0.42225800677370f),  Q30_fmt(0.55536025173035f),
+    Q30_fmt(0.77803595530059f),  Q30_fmt(1.11072050346071f)
+};
+
+const Int32 cos_alphas[NO_ICC_LEVELS] =
+{
+    Q30_fmt(1.00000000000000f),  Q30_fmt(0.98412391153249f),
+    Q30_fmt(0.95947390717984f),  Q30_fmt(0.89468446298319f),
+    Q30_fmt(0.82693418207478f),  Q30_fmt(0.70710689672598f),
+    Q30_fmt(0.45332071670080f),  Q30_fmt(0.00000032679490f)
+};
+
+const Int32 sin_alphas[NO_ICC_LEVELS] =
+{
+    Q30_fmt(0.00000000000000f),  Q30_fmt(0.17748275057029f),
+    Q30_fmt(0.28179748302823f),  Q30_fmt(0.44669868110000f),
+    Q30_fmt(0.56229872711603f),  Q30_fmt(0.70710666564709f),
+    Q30_fmt(0.89134747871404f),  Q30_fmt(1.00000000000000f)
+};
+
+
+
+/*----------------------------------------------------------------------------
+; EXTERNAL FUNCTION REFERENCES
+; Declare functions defined elsewhere and referenced in this module
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL GLOBAL STORE/BUFFER/POINTER REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; FUNCTION CODE
+----------------------------------------------------------------------------*/
+
+Int32 ps_init_stereo_mixing(STRUCT_PS_DEC *pms,
+                            Int32 env,
+                            Int32 usb)
+{
+    Int32   group;
+    Int32   bin;
+    Int32   noIidSteps;
+    Int32   tmp;
+
+    Int32   invEnvLength;
+    const Int32  *pScaleFactors;
+    Int32   scaleR;
+    Int32   scaleL;
+    Int32   cos_alpha;
+    Int32   sin_alpha;
+    Int32   beta;
+    Int32   cos_beta;
+    Int32   sin_beta;
+    Int32   temp1;
+    Int32   temp2;
+    Int32   *ptr_tmp;
+    Int32   h11;
+    Int32   h12;
+    Int32   h21;
+    Int32   h22;
+
+    if (pms->bFineIidQ)
+    {
+        noIidSteps = NO_IID_STEPS_FINE;     /*  NO_IID_STEPS_FINE == 15  */
+        pScaleFactors = scaleFactorsFine;
+    }
+    else
+    {
+        noIidSteps = NO_IID_STEPS;          /*  NO_IID_STEPS == 7   */
+        pScaleFactors = scaleFactors;
+    }
+
+    if (env == 0)
+    {
+        pms->lastUsb = pms->usb;
+        pms->usb = usb;
+        if (usb != pms->lastUsb && pms->lastUsb != 0)
+        {
+            return(-1);
+
+        }
+    }
+
+    invEnvLength =  pms->aEnvStartStop[env + 1] - pms->aEnvStartStop[env];
+
+    if (invEnvLength == (Int32) pms->noSubSamples)
+    {
+        invEnvLength = pms->invNoSubSamples;
+    }
+    else
+    {
+        invEnvLength = Q30_fmt(1.0f) / invEnvLength;
+    }
+
+    if (invEnvLength == 32)     /*  more likely value  */
+    {
+        for (group = 0; group < NO_IID_GROUPS; group++)      /* == 22 */
+        {
+            bin = bins2groupMap[group];
+
+            /*
+             *  c(b) = 10^(iid(b)/20)
+             */
+
+            tmp = pms->aaIidIndex[env][bin];
+
+            /*
+             *  Intensity differences
+             *
+             *                  sqrt(2)
+             *   c_1(b) = ----------------
+             *            sqrt( 1 + c^2(b))
+             *
+             */
+            scaleR = pScaleFactors[noIidSteps + tmp];
+
+            /*
+             *               sqrt(2)*c(b)
+             *   c_2(b) = ----------------
+             *            sqrt( 1 + c^2(b))
+             *
+             */
+
+            scaleL = pScaleFactors[noIidSteps - tmp];
+
+
+            /*
+             *  alpha(b) = (1/2)*arccos( gamma(b))
+             */
+            tmp = pms->aaIccIndex[env][bin];
+
+            cos_alpha = cos_alphas[ tmp];
+            sin_alpha = sin_alphas[ tmp];
+
+            /*
+             *   beta(b) = alpha(b)/sqrt(2)*( c_1(b) - c_2(b))
+             */
+
+            beta   = fxp_mul32_Q30(scaled_alphas[ tmp], (scaleR - scaleL));
+
+            cos_beta = pv_cosine(beta);
+            sin_beta = pv_sine(beta);
+
+            temp1 = fxp_mul32_Q30(cos_beta, cos_alpha);
+            temp2 = fxp_mul32_Q30(sin_beta, sin_alpha);
+
+
+            /*
+             *  h11(b) = cos( alpha(b) +  beta(b))* c_2(b)
+             *  h12(b) = cos(  beta(b) - alpha(b))* c_1(b)
+             */
+
+            h11 = fxp_mul32_Q30(scaleL, (temp1 - temp2));
+            h12 = fxp_mul32_Q30(scaleR, (temp1 + temp2));
+
+            temp1 = fxp_mul32_Q30(sin_beta, cos_alpha);
+            temp2 = fxp_mul32_Q30(cos_beta, sin_alpha);
+
+            /*
+             *  h21(b) = sin( alpha(b) +  beta(b))* c_2(b)
+             *  h22(b) = sin(  beta(b) - alpha(b))* c_1(b)
+             */
+
+            h21 = fxp_mul32_Q30(scaleL, (temp1 + temp2));
+            h22 = fxp_mul32_Q30(scaleR, (temp1 - temp2));
+
+
+            /*
+             *   Linear interpolation
+             *
+             *                                       Hij(k, n_e+1) - Hij(k, n_e)
+             *    Hij(k,n) = Hij(k, n_e) + (n - n_e)*---------------------------
+             *                                              n_e+1 - n_e
+             */
+
+            ptr_tmp = &pms->h11Prev[group];
+            pms->H11[group]       = *ptr_tmp;
+            pms->deltaH11[group]  = (h11 - *ptr_tmp) >> 5;
+            *ptr_tmp              = h11;
+
+            ptr_tmp = &pms->h12Prev[group];
+            pms->H12[group]       = *ptr_tmp;
+            pms->deltaH12[group]  = (h12 - *ptr_tmp) >> 5;
+            *ptr_tmp              = h12;
+
+            ptr_tmp = &pms->h21Prev[group];
+            pms->H21[group]       = *ptr_tmp;
+            pms->deltaH21[group]  = (h21 - *ptr_tmp) >> 5;
+            *ptr_tmp              = h21;
+
+            ptr_tmp = &pms->h22Prev[group];
+            pms->H22[group]       = *ptr_tmp;
+            pms->deltaH22[group]  = (h22 - *ptr_tmp) >> 5;
+            *ptr_tmp              = h22;
+
+
+        } /* groups loop */
+    }
+    else
+    {
+
+        for (group = 0; group < NO_IID_GROUPS; group++)      /* == 22 */
+        {
+            bin = bins2groupMap[group];
+
+            /*
+             *  c(b) = 10^(iid(b)/20)
+             */
+
+            tmp = pms->aaIidIndex[env][bin];
+
+            /*
+             *  Intensity differences
+             *
+             *                  sqrt(2)
+             *   c_1(b) = ----------------
+             *            sqrt( 1 + c^2(b))
+             *
+             */
+            scaleR = pScaleFactors[noIidSteps + tmp];
+
+            /*
+             *               sqrt(2)*c(b)
+             *   c_2(b) = ----------------
+             *            sqrt( 1 + c^2(b))
+             *
+             */
+
+            scaleL = pScaleFactors[noIidSteps - tmp];
+
+
+            /*
+             *  alpha(b) = (1/2)*arccos( gamma(b))
+             */
+            tmp = pms->aaIccIndex[env][bin];
+
+            cos_alpha = cos_alphas[ tmp];
+            sin_alpha = sin_alphas[ tmp];
+
+            /*
+             *   beta(b) = alpha(b)/sqrt(2)*( c_1(b) - c_2(b))
+             */
+
+            beta   = fxp_mul32_Q30(scaled_alphas[ tmp], (scaleR - scaleL));
+
+            cos_beta = pv_cosine(beta);
+            sin_beta = pv_sine(beta);
+
+            temp1 = fxp_mul32_Q30(cos_beta, cos_alpha);
+            temp2 = fxp_mul32_Q30(sin_beta, sin_alpha);
+
+
+            /*
+             *  h11(b) = cos( alpha(b) +  beta(b))* c_2(b)
+             *  h12(b) = cos(  beta(b) - alpha(b))* c_1(b)
+             */
+
+            h11 = fxp_mul32_Q30(scaleL, (temp1 - temp2));
+            h12 = fxp_mul32_Q30(scaleR, (temp1 + temp2));
+
+            temp1 = fxp_mul32_Q30(sin_beta, cos_alpha);
+            temp2 = fxp_mul32_Q30(cos_beta, sin_alpha);
+
+            /*
+             *  h21(b) = sin( alpha(b) +  beta(b))* c_2(b)
+             *  h22(b) = sin(  beta(b) - alpha(b))* c_1(b)
+             */
+
+            h21 = fxp_mul32_Q30(scaleL, (temp1 + temp2));
+            h22 = fxp_mul32_Q30(scaleR, (temp1 - temp2));
+
+
+            /*
+             *   Linear interpolation
+             *
+             *                                       Hij(k, n_e+1) - Hij(k, n_e)
+             *    Hij(k,n) = Hij(k, n_e) + (n - n_e)*---------------------------
+             *                                              n_e+1 - n_e
+             */
+
+            ptr_tmp = &pms->h11Prev[group];
+            pms->deltaH11[group]  = fxp_mul32_Q30((h11 - *ptr_tmp), invEnvLength);
+            pms->H11[group]       = *ptr_tmp;
+            *ptr_tmp              = h11;
+
+            ptr_tmp = &pms->h12Prev[group];
+            pms->deltaH12[group]  = fxp_mul32_Q30((h12 - *ptr_tmp), invEnvLength);
+            pms->H12[group]       = *ptr_tmp;
+            *ptr_tmp              = h12;
+
+            ptr_tmp = &pms->h21Prev[group];
+            pms->deltaH21[group]  = fxp_mul32_Q30((h21 - *ptr_tmp), invEnvLength);
+            pms->H21[group]       = *ptr_tmp;
+            *ptr_tmp              = h21;
+
+            ptr_tmp = &pms->h22Prev[group];
+            pms->deltaH22[group]  = fxp_mul32_Q30((h22 - *ptr_tmp), invEnvLength);
+            pms->H22[group]       = *ptr_tmp;
+            *ptr_tmp              = h22;
+
+
+        } /* groups loop */
+    }
+
+
+    return (0);
+
+} /* END ps_init_stereo_mixing */
+
+#endif
+
+
+#endif
+
diff --git a/media/libstagefright/codecs/aacdec/ps_init_stereo_mixing.h b/media/libstagefright/codecs/aacdec/ps_init_stereo_mixing.h
new file mode 100644
index 0000000..6c30781
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/ps_init_stereo_mixing.h
@@ -0,0 +1,97 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Pathname: ps_init_stereo_mixing.h
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+ Who:                   Date:
+ Description:
+
+------------------------------------------------------------------------------
+ INCLUDE DESCRIPTION
+
+ Header file for functions ps_init_stereo_mixing()
+
+
+------------------------------------------------------------------------------
+*/
+
+/*----------------------------------------------------------------------------
+; CONTINUE ONLY IF NOT ALREADY DEFINED
+----------------------------------------------------------------------------*/
+#ifndef PS_INIT_STEREO_MIXING_H
+#define PS_INIT_STEREO_MIXING_H
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+#include "pv_audio_type_defs.h"
+#include "s_ps_dec.h"
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here.
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL VARIABLES REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; SIMPLE TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; ENUMERATED TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; STRUCTURES TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; GLOBAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+    Int32 ps_init_stereo_mixing(STRUCT_PS_DEC *pms,
+    Int32 env,
+    Int32 usb);
+
+#ifdef __cplusplus
+}
+#endif
+
+/*----------------------------------------------------------------------------
+; END
+----------------------------------------------------------------------------*/
+#endif  /* PS_INIT_STEREO_MIXING_H */
diff --git a/media/libstagefright/codecs/aacdec/ps_pwr_transient_detection.cpp b/media/libstagefright/codecs/aacdec/ps_pwr_transient_detection.cpp
new file mode 100644
index 0000000..a0e8c38
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/ps_pwr_transient_detection.cpp
@@ -0,0 +1,340 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Filename: ps_pwr_transient_detection.c
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+
+ Who:                                   Date: MM/DD/YYYY
+ Description:
+
+------------------------------------------------------------------------------
+ INPUT AND OUTPUT DEFINITIONS
+
+
+
+------------------------------------------------------------------------------
+ FUNCTION DESCRIPTION
+
+  Decorrelation
+  Decorrelation is achieved by means of all-pass filtering and delaying
+  Sub-band samples s_k(n) are converted into de-correlated sub-bands samples
+  d_k(n). k index for frequency, n time index
+
+
+     _______                                              ________
+    |       |                                  _______   |        |
+  ->|Hybrid | LF ----                         |       |->| Hybrid |-->
+    | Anal. |        |                        |       |  | Synth  |   QMF -> L
+     -------         o----------------------->|       |   --------    Synth
+QMF                  |                s_k(n)  |Stereo |-------------->
+Anal.              -------------------------->|       |
+     _______       | |                        |       |   ________
+    |       | HF --o |   -----------          |Process|  |        |
+  ->| Delay |      |  ->|           |-------->|       |->| Hybrid |-->
+     -------       |    |decorrelate| d_k(n)  |       |  | Synth  |   QMF -> R
+                   ---->|           |-------->|       |   --------    Synth
+                         -----------          |_______|-------------->
+
+
+  To handle transients and other fast time-envelopes, the output of the all
+  pass filters has to be attenuated at those signals.
+
+
+------------------------------------------------------------------------------
+ REQUIREMENTS
+
+
+------------------------------------------------------------------------------
+ REFERENCES
+
+SC 29 Software Copyright Licencing Disclaimer:
+
+This software module was originally developed by
+  Coding Technologies
+
+and edited by
+  -
+
+in the course of development of the ISO/IEC 13818-7 and ISO/IEC 14496-3
+standards for reference purposes and its performance may not have been
+optimized. This software module is an implementation of one or more tools as
+specified by the ISO/IEC 13818-7 and ISO/IEC 14496-3 standards.
+ISO/IEC gives users free license to this software module or modifications
+thereof for use in products claiming conformance to audiovisual and
+image-coding related ITU Recommendations and/or ISO/IEC International
+Standards. ISO/IEC gives users the same free license to this software module or
+modifications thereof for research purposes and further ISO/IEC standardisation.
+Those intending to use this software module in products are advised that its
+use may infringe existing patents. ISO/IEC have no liability for use of this
+software module or modifications thereof. Copyright is not released for
+products that do not conform to audiovisual and image-coding related ITU
+Recommendations and/or ISO/IEC International Standards.
+The original developer retains full right to modify and use the code for its
+own purpose, assign or donate the code to a third party and to inhibit third
+parties from using the code for products that do not conform to audiovisual and
+image-coding related ITU Recommendations and/or ISO/IEC International Standards.
+This copyright notice must be included in all copies or derivative works.
+Copyright (c) ISO/IEC 2003.
+
+------------------------------------------------------------------------------
+ PSEUDO-CODE
+
+------------------------------------------------------------------------------
+*/
+
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+
+#ifdef AAC_PLUS
+
+#ifdef PARAMETRICSTEREO
+
+#include    "pv_audio_type_defs.h"
+#include    "s_ps_dec.h"
+#include    "aac_mem_funcs.h"
+#include    "ps_all_pass_filter_coeff.h"
+#include    "ps_pwr_transient_detection.h"
+
+#include    "fxp_mul32.h"
+#include    "pv_div.h"
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+#ifndef min
+#define min(a, b) ((a) < (b) ? (a) : (b))
+#endif
+
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here. Include conditional
+; compile variables also.
+----------------------------------------------------------------------------*/
+
+#define R_SHIFT     29
+#define Q29_fmt(x)   (Int32)(x*((Int32)1<<R_SHIFT) + (x>=0?0.5F:-0.5F))
+
+#define Qfmt31(a)   (Int32)(-a*((Int32)1<<31) - 1 + (a>=0?0.5F:-0.5F))
+
+/*----------------------------------------------------------------------------
+; LOCAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+
+
+/*----------------------------------------------------------------------------
+; LOCAL STORE/BUFFER/POINTER DEFINITIONS
+; Variable declaration - defined here and used outside this module
+----------------------------------------------------------------------------*/
+
+
+/*----------------------------------------------------------------------------
+; EXTERNAL FUNCTION REFERENCES
+; Declare functions defined elsewhere and referenced in this module
+----------------------------------------------------------------------------*/
+
+
+
+
+/*----------------------------------------------------------------------------
+; EXTERNAL GLOBAL STORE/BUFFER/POINTER REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+
+/*----------------------------------------------------------------------------
+; FUNCTION CODE
+----------------------------------------------------------------------------*/
+
+
+void ps_pwr_transient_detection(STRUCT_PS_DEC *h_ps_dec,
+                                Int32 *rIntBufferLeft,
+                                Int32 *iIntBufferLeft,
+                                Int32 aTransRatio[])
+{
+
+    Int32 sb;
+    Int32 maxsb;
+    Int32 gr;
+    Int32 bin;
+
+
+
+    Int32 *aLeftReal;
+    Int32 *aLeftImag;
+    Int32   temp_r;
+    Int32   temp_i;
+    Int32   accu;
+    Int32 *aPower = aTransRatio;
+    Quotient result;
+
+    Int32 nrg;
+    Int32 *ptr_aPrevNrg;
+    Int32 peakDiff;
+    Int32 *ptr_PrevPeakDiff;
+
+
+    aLeftReal = rIntBufferLeft;
+    aLeftImag = iIntBufferLeft;
+
+    /*
+     *  Input Power Matrix
+     *                            2
+     *  Power(i,n) = SUM | s_k(n)|
+     *                i
+     */
+
+    for (gr = SUBQMF_GROUPS; gr < NO_IID_GROUPS; gr++) /* 10 to 22  */
+    {
+        maxsb = min(h_ps_dec->usb, groupBorders[ gr+1]);
+
+        accu = 0;
+
+        for (sb = groupBorders[gr]; sb < maxsb; sb++)
+        {
+
+            temp_r = aLeftReal[sb];
+            temp_i = aLeftImag[sb];
+            accu =  fxp_mac32_Q31(accu, temp_r, temp_r);
+            accu =  fxp_mac32_Q31(accu, temp_i, temp_i);
+
+        } /* sb */
+        aPower[gr - 2] = accu >> 1;
+    } /* gr */
+
+    aLeftReal = h_ps_dec->mHybridRealLeft;
+    aLeftImag = h_ps_dec->mHybridImagLeft;
+
+
+    temp_r = aLeftReal[0];
+    temp_i = aLeftImag[0];
+    accu   = fxp_mul32_Q31(temp_r, temp_r);
+    accu  = fxp_mac32_Q31(accu, temp_i, temp_i);
+    temp_r = aLeftReal[5];
+    temp_i = aLeftImag[5];
+    accu   = fxp_mac32_Q31(accu, temp_r, temp_r);
+    aPower[0]  = fxp_mac32_Q31(accu, temp_i, temp_i) >> 1;
+
+    temp_r = aLeftReal[1];
+    temp_i = aLeftImag[1];
+    accu   = fxp_mul32_Q31(temp_r, temp_r);
+    accu  = fxp_mac32_Q31(accu, temp_i, temp_i);
+    temp_r = aLeftReal[4];
+    temp_i = aLeftImag[4];
+    accu   = fxp_mac32_Q31(accu, temp_r, temp_r);
+    aPower[1]  = fxp_mac32_Q31(accu, temp_i, temp_i) >> 1;
+
+    temp_r = aLeftReal[2];
+    temp_i = aLeftImag[2];
+    accu   = fxp_mul32_Q31(temp_r, temp_r);
+    aPower[2]  = fxp_mac32_Q31(accu, temp_i, temp_i) >> 1;
+
+    temp_r = aLeftReal[3];
+    temp_i = aLeftImag[3];
+    accu   = fxp_mul32_Q31(temp_r, temp_r);
+    aPower[3]  = fxp_mac32_Q31(accu, temp_i, temp_i) >> 1;
+
+
+
+    temp_r = aLeftReal[6];
+    temp_i = aLeftImag[6];
+    accu   = fxp_mul32_Q31(temp_r, temp_r);
+    aPower[5]  = fxp_mac32_Q31(accu, temp_i, temp_i) >> 1;
+
+    temp_r = aLeftReal[7];
+    temp_i = aLeftImag[7];
+    accu   = fxp_mul32_Q31(temp_r, temp_r);
+    aPower[4]  = fxp_mac32_Q31(accu, temp_i, temp_i) >> 1;
+
+    temp_r = aLeftReal[8];
+    temp_i = aLeftImag[8];
+    accu   = fxp_mul32_Q31(temp_r, temp_r);
+    aPower[6]  = fxp_mac32_Q31(accu, temp_i, temp_i) >> 1;
+
+    temp_r = aLeftReal[9];
+    temp_i = aLeftImag[9];
+    accu   = fxp_mul32_Q31(temp_r, temp_r);
+    aPower[7]  = fxp_mac32_Q31(accu, temp_i, temp_i) >> 1;
+
+
+    /*
+     *  Power transient detection
+     */
+
+    ptr_aPrevNrg = h_ps_dec->aPrevNrg;
+
+    ptr_PrevPeakDiff = h_ps_dec->aPrevPeakDiff;
+
+    for (bin = 0; bin < NO_BINS; bin++) /* NO_BINS = 20  */
+    {
+
+        peakDiff  = *ptr_PrevPeakDiff;
+
+
+        /* PEAK_DECAY_FACTOR  0.765928338364649f @ 48 KHz  for Fs > 32 Khz */
+        accu = h_ps_dec->aPeakDecayFast[bin];
+        peakDiff -= peakDiff >> 2;
+
+        accu  = fxp_mul32_Q31(accu, Qfmt31(0.765928338364649f)) << 1;
+
+        if (accu < *aPower)
+        {
+            accu = *aPower;
+        }
+        else
+        {
+            peakDiff += ((accu - *aPower) >> 2);
+        }
+
+        h_ps_dec->aPeakDecayFast[bin] = accu;
+
+        *(ptr_PrevPeakDiff++) = peakDiff;
+
+        nrg =   *ptr_aPrevNrg + ((*aPower - *ptr_aPrevNrg) >> 2);
+
+        *(ptr_aPrevNrg++) = nrg;
+
+        peakDiff += peakDiff >> 1;         /* transient impact factor == 1.5 */
+
+        if (peakDiff <= nrg)
+        {
+            *(aPower++) = 0x7FFFFFFF;    /* in Q31  */
+        }
+        else
+        {
+            pv_div(nrg, peakDiff, &result);
+            *(aPower++) = (result.quotient >> (result.shift_factor)) << 1;    /* in Q31  */
+        }
+
+    } /* bin */
+
+}
+
+
+#endif
+
+#endif
diff --git a/media/libstagefright/codecs/aacdec/ps_pwr_transient_detection.h b/media/libstagefright/codecs/aacdec/ps_pwr_transient_detection.h
new file mode 100644
index 0000000..80a73a8
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/ps_pwr_transient_detection.h
@@ -0,0 +1,96 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Pathname: ps_pwr_transient_detection.h
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+ Who:                   Date:
+ Description:
+
+------------------------------------------------------------------------------
+ INCLUDE DESCRIPTION
+
+ Header file for function ps_pwr_transient_detection()
+
+------------------------------------------------------------------------------
+*/
+
+/*----------------------------------------------------------------------------
+; CONTINUE ONLY IF NOT ALREADY DEFINED
+----------------------------------------------------------------------------*/
+#ifndef PS_PWR_TRANSIENT_DETECTION_H
+#define PS_PWR_TRANSIENT_DETECTION_H
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+#include "pv_audio_type_defs.h"
+#include "s_ps_dec.h"
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here.
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL VARIABLES REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; SIMPLE TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; ENUMERATED TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; STRUCTURES TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; GLOBAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+    void ps_pwr_transient_detection(STRUCT_PS_DEC *h_ps_dec,
+    Int32 *rIntBufferLeft,
+    Int32 *iIntBufferLeft,
+    Int32 aTransRatio[]);
+
+#ifdef __cplusplus
+}
+#endif
+
+/*----------------------------------------------------------------------------
+; END
+----------------------------------------------------------------------------*/
+#endif  /* PS_PWR_TRANSIENT_DETECTION_H */
diff --git a/media/libstagefright/codecs/aacdec/ps_read_data.cpp b/media/libstagefright/codecs/aacdec/ps_read_data.cpp
new file mode 100644
index 0000000..c49eb3d
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/ps_read_data.cpp
@@ -0,0 +1,388 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Filename: ps_read_data.c
+
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+
+ Who:                                   Date: MM/DD/YYYY
+ Description:
+
+------------------------------------------------------------------------------
+ INPUT AND OUTPUT DEFINITIONS
+
+
+
+------------------------------------------------------------------------------
+ FUNCTION DESCRIPTION
+
+        Decodes parametric stereo
+
+------------------------------------------------------------------------------
+ REQUIREMENTS
+
+
+------------------------------------------------------------------------------
+ REFERENCES
+
+SC 29 Software Copyright Licencing Disclaimer:
+
+This software module was originally developed by
+  Coding Technologies
+
+and edited by
+  -
+
+in the course of development of the ISO/IEC 13818-7 and ISO/IEC 14496-3
+standards for reference purposes and its performance may not have been
+optimized. This software module is an implementation of one or more tools as
+specified by the ISO/IEC 13818-7 and ISO/IEC 14496-3 standards.
+ISO/IEC gives users free license to this software module or modifications
+thereof for use in products claiming conformance to audiovisual and
+image-coding related ITU Recommendations and/or ISO/IEC International
+Standards. ISO/IEC gives users the same free license to this software module or
+modifications thereof for research purposes and further ISO/IEC standardisation.
+Those intending to use this software module in products are advised that its
+use may infringe existing patents. ISO/IEC have no liability for use of this
+software module or modifications thereof. Copyright is not released for
+products that do not conform to audiovisual and image-coding related ITU
+Recommendations and/or ISO/IEC International Standards.
+The original developer retains full right to modify and use the code for its
+own purpose, assign or donate the code to a third party and to inhibit third
+parties from using the code for products that do not conform to audiovisual and
+image-coding related ITU Recommendations and/or ISO/IEC International Standards.
+This copyright notice must be included in all copies or derivative works.
+Copyright (c) ISO/IEC 2003.
+
+------------------------------------------------------------------------------
+ PSEUDO-CODE
+
+------------------------------------------------------------------------------
+*/
+
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+
+#ifdef AAC_PLUS
+
+#ifdef PARAMETRICSTEREO
+
+#include    "pv_audio_type_defs.h"
+#include    "buf_getbits.h"
+#include    "s_bit_buffer.h"
+#include    "s_huffman.h"
+#include    "aac_mem_funcs.h"
+#include    "s_ps_dec.h"
+#include    "sbr_decode_huff_cw.h"
+#include    "ps_decode_bs_utils.h"
+#include    "ps_bstr_decoding.h"
+#include    "ps_read_data.h"
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here. Include conditional
+; compile variables also.
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; LOCAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; LOCAL STORE/BUFFER/POINTER DEFINITIONS
+; Variable declaration - defined here and used outside this module
+----------------------------------------------------------------------------*/
+
+
+/*----------------------------------------------------------------------------
+; EXTERNAL FUNCTION REFERENCES
+; Declare functions defined elsewhere and referenced in this module
+----------------------------------------------------------------------------*/
+
+
+/*----------------------------------------------------------------------------
+; EXTERNAL GLOBAL STORE/BUFFER/POINTER REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+/* IID & ICC Huffman codebooks */
+const Char aBookPsIidTimeDecode[28][2] =
+{
+    { -64,   1 },    { -65,   2 },    { -63,   3 },    { -66,   4 },
+    { -62,   5 },    { -67,   6 },    { -61,   7 },    { -68,   8 },
+    { -60,   9 },    { -69,  10 },    { -59,  11 },    { -70,  12 },
+    { -58,  13 },    { -57,  14 },    { -71,  15 },    {  16,  17 },
+    { -56, -72 },    {  18,  21 },    {  19,  20 },    { -55, -78 },
+    { -77, -76 },    {  22,  25 },    {  23,  24 },    { -75, -74 },
+    { -73, -54 },    {  26,  27 },    { -53, -52 },    { -51, -50 }
+};
+
+const Char aBookPsIidFreqDecode[28][2] =
+{
+    { -64,   1 },    {   2,   3 },    { -63, -65 },    {   4,   5 },
+    { -62, -66 },    {   6,   7 },    { -61, -67 },    {   8,   9 },
+    { -68, -60 },    { -59,  10 },    { -69,  11 },    { -58,  12 },
+    { -70,  13 },    { -71,  14 },    { -57,  15 },    {  16,  17 },
+    { -56, -72 },    {  18,  19 },    { -55, -54 },    {  20,  21 },
+    { -73, -53 },    {  22,  24 },    { -74,  23 },    { -75, -78 },
+    {  25,  26 },    { -77, -76 },    { -52,  27 },    { -51, -50 }
+};
+
+const Char aBookPsIccTimeDecode[14][2] =
+{
+    { -64,   1 },    { -63,   2 },    { -65,   3 },    { -62,   4 },
+    { -66,   5 },    { -61,   6 },    { -67,   7 },    { -60,   8 },
+    { -68,   9 },    { -59,  10 },    { -69,  11 },    { -58,  12 },
+    { -70,  13 },    { -71, -57 }
+};
+
+const Char aBookPsIccFreqDecode[14][2] =
+{
+    { -64,   1 },    { -63,   2 },    { -65,   3 },    { -62,   4 },
+    { -66,   5 },    { -61,   6 },    { -67,   7 },    { -60,   8 },
+    { -59,   9 },    { -68,  10 },    { -58,  11 },    { -69,  12 },
+    { -57,  13 },    { -70, -71 }
+};
+
+const Char aBookPsIidFineTimeDecode[60][2] =
+{
+    {   1, -64 },    { -63,   2 },    {   3, -65 },    {   4,  59 },
+    {   5,   7 },    {   6, -67 },    { -68, -60 },    { -61,   8 },
+    {   9,  11 },    { -59,  10 },    { -70, -58 },    {  12,  41 },
+    {  13,  20 },    {  14, -71 },    { -55,  15 },    { -53,  16 },
+    {  17, -77 },    {  18,  19 },    { -85, -84 },    { -46, -45 },
+    { -57,  21 },    {  22,  40 },    {  23,  29 },    { -51,  24 },
+    {  25,  26 },    { -83, -82 },    {  27,  28 },    { -90, -38 },
+    { -92, -91 },    {  30,  37 },    {  31,  34 },    {  32,  33 },
+    { -35, -34 },    { -37, -36 },    {  35,  36 },    { -94, -93 },
+    { -89, -39 },    {  38, -79 },    {  39, -81 },    { -88, -40 },
+    { -74, -54 },    {  42, -69 },    {  43,  44 },    { -72, -56 },
+    {  45,  52 },    {  46,  50 },    {  47, -76 },    { -49,  48 },
+    { -47,  49 },    { -87, -41 },    { -52,  51 },    { -78, -50 },
+    {  53, -73 },    {  54, -75 },    {  55,  57 },    {  56, -80 },
+    { -86, -42 },    { -48,  58 },    { -44, -43 },    { -66, -62 }
+};
+
+const Char aBookPsIidFineFreqDecode[60][2] =
+{
+    {   1, -64 },    {   2,   4 },    {   3, -65 },    { -66, -62 },
+    { -63,   5 },    {   6,   7 },    { -67, -61 },    {   8,   9 },
+    { -68, -60 },    {  10,  11 },    { -69, -59 },    {  12,  13 },
+    { -70, -58 },    {  14,  18 },    { -57,  15 },    {  16, -72 },
+    { -54,  17 },    { -75, -53 },    {  19,  37 },    { -56,  20 },
+    {  21, -73 },    {  22,  29 },    {  23, -76 },    {  24, -78 },
+    {  25,  28 },    {  26,  27 },    { -85, -43 },    { -83, -45 },
+    { -81, -47 },    { -52,  30 },    { -50,  31 },    {  32, -79 },
+    {  33,  34 },    { -82, -46 },    {  35,  36 },    { -90, -89 },
+    { -92, -91 },    {  38, -71 },    { -55,  39 },    {  40, -74 },
+    {  41,  50 },    {  42, -77 },    { -49,  43 },    {  44,  47 },
+    {  45,  46 },    { -86, -42 },    { -88, -87 },    {  48,  49 },
+    { -39, -38 },    { -41, -40 },    { -51,  51 },    {  52,  59 },
+    {  53,  56 },    {  54,  55 },    { -35, -34 },    { -37, -36 },
+    {  57,  58 },    { -94, -93 },    { -84, -44 },    { -80, -48 }
+};
+
+
+
+
+
+
+/*----------------------------------------------------------------------------
+; FUNCTION CODE
+----------------------------------------------------------------------------*/
+
+Int32 ps_read_data(STRUCT_PS_DEC *ps_dec,
+                   BIT_BUFFER * hBitBuf,
+                   Int32 nBitsLeft)
+
+{
+    Int     gr;
+    UInt32     env;
+    UInt32     dtFlag;
+    Int32     startbits;
+    SbrHuffman CurrentTable;
+
+    if (!ps_dec)
+    {
+        return 0;
+    }
+
+    startbits = GetNrBitsAvailable(hBitBuf);
+
+    if (buf_get_1bit(hBitBuf))  /*  Enable Header */
+    {
+        ps_dec->bEnableIid = buf_get_1bit(hBitBuf);
+
+        if (ps_dec->bEnableIid)
+        {
+            ps_dec->freqResIid = buf_getbits(hBitBuf, 3);
+
+            if (ps_dec->freqResIid > 2)
+            {
+                ps_dec->bFineIidQ = 1;
+                ps_dec->freqResIid -= 3;
+            }
+            else
+            {
+                ps_dec->bFineIidQ = 0;
+            }
+        }
+
+        ps_dec->bEnableIcc = buf_get_1bit(hBitBuf);
+        if (ps_dec->bEnableIcc)
+        {
+            ps_dec->freqResIcc = buf_getbits(hBitBuf, 3);
+
+            if (ps_dec->freqResIcc > 2)
+            {
+                ps_dec->freqResIcc -= 3;
+            }
+        }
+        ps_dec->bEnableExt = buf_get_1bit(hBitBuf);
+    }
+
+    ps_dec->bFrameClass = buf_get_1bit(hBitBuf);
+    if (ps_dec->bFrameClass == 0)
+    {
+        ps_dec->noEnv = aFixNoEnvDecode[ buf_getbits(hBitBuf, 2)];
+    }
+    else
+    {
+        ps_dec->noEnv = 1 + buf_getbits(hBitBuf, 2);
+        for (env = 1; env < ps_dec->noEnv + 1; env++)
+        {
+            ps_dec->aEnvStartStop[env] = (buf_getbits(hBitBuf, 5)) + 1;
+        }
+    }
+
+    if ((ps_dec->freqResIid > 2) || (ps_dec->freqResIcc > 2))
+    {
+
+        ps_dec->bPsDataAvail = 0;
+
+        nBitsLeft -= startbits - GetNrBitsAvailable(hBitBuf);
+        while (nBitsLeft)
+        {
+            int i = nBitsLeft;
+            if (i > 8)
+            {
+                i = 8;
+            }
+            buf_getbits(hBitBuf, i);
+            nBitsLeft -= i;
+        }
+        return (startbits - GetNrBitsAvailable(hBitBuf));
+    }
+
+    if (ps_dec->bEnableIid)
+    {
+        for (env = 0; env < ps_dec->noEnv; env++)
+        {
+            dtFlag = buf_get_1bit(hBitBuf);
+
+            if (!dtFlag)
+            {
+                if (ps_dec->bFineIidQ)
+                {
+                    CurrentTable = aBookPsIidFineFreqDecode;
+                }
+                else
+                {
+                    CurrentTable = aBookPsIidFreqDecode;
+                }
+            }
+            else
+            {
+                if (ps_dec->bFineIidQ)
+                {
+                    CurrentTable = aBookPsIidFineTimeDecode;
+                }
+                else
+                {
+                    CurrentTable = aBookPsIidTimeDecode;
+                }
+            }
+
+            for (gr = 0; gr < aNoIidBins[ps_dec->freqResIid]; gr++)
+            {
+                ps_dec->aaIidIndex[env][gr] = sbr_decode_huff_cw(CurrentTable, hBitBuf);
+            }
+
+            ps_dec->abIidDtFlag[env] = dtFlag;
+        }
+    }
+
+    if (ps_dec->bEnableIcc)
+    {
+        for (env = 0; env < ps_dec->noEnv; env++)
+        {
+            dtFlag = buf_get_1bit(hBitBuf);
+            if (!dtFlag)
+            {
+                CurrentTable = aBookPsIccFreqDecode;
+            }
+            else
+            {
+                CurrentTable = aBookPsIccTimeDecode;
+            }
+            for (gr = 0; gr < aNoIccBins[ps_dec->freqResIcc]; gr++)
+            {
+                ps_dec->aaIccIndex[env][gr] = sbr_decode_huff_cw(CurrentTable, hBitBuf);
+            }
+
+            ps_dec->abIccDtFlag[env] = dtFlag;
+        }
+    }
+
+    if (ps_dec->bEnableExt)
+    {
+
+        int cnt;
+
+        cnt = (int)buf_getbits(hBitBuf, 4);
+
+        if (cnt == 15)
+        {
+            cnt += (int)buf_getbits(hBitBuf, 8);
+        }
+
+        hBitBuf->nrBitsRead += (cnt << 3);
+    }
+
+    ps_dec->bPsDataAvail = 1;
+
+    return (startbits - GetNrBitsAvailable(hBitBuf));
+}
+
+#endif
+
+
+#endif
+
diff --git a/media/libstagefright/codecs/aacdec/ps_read_data.h b/media/libstagefright/codecs/aacdec/ps_read_data.h
new file mode 100644
index 0000000..e2fec53
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/ps_read_data.h
@@ -0,0 +1,100 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Pathname: ps_read_data.h
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+ Who:                   Date:
+ Description:
+
+------------------------------------------------------------------------------
+ INCLUDE DESCRIPTION
+
+ Header file for functions ps_read_data()
+
+
+------------------------------------------------------------------------------
+*/
+
+/*----------------------------------------------------------------------------
+; CONTINUE ONLY IF NOT ALREADY DEFINED
+----------------------------------------------------------------------------*/
+#ifndef PS_READ_DATA_H
+#define PS_READ_DATA_H
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+#include "pv_audio_type_defs.h"
+#include "s_ps_dec.h"
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here.
+----------------------------------------------------------------------------*/
+
+#define EXTENSION_ID_PS_CODING   2
+
+
+/*----------------------------------------------------------------------------
+; EXTERNAL VARIABLES REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; SIMPLE TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; ENUMERATED TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; STRUCTURES TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; GLOBAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+    Int32 ps_read_data(STRUCT_PS_DEC *ps_dec,
+    BIT_BUFFER * hBitBuf,
+    Int32 nBitsLeft);
+
+#ifdef __cplusplus
+}
+#endif
+
+/*----------------------------------------------------------------------------
+; END
+----------------------------------------------------------------------------*/
+#endif  /* PS_READ_DATA_H */
diff --git a/media/libstagefright/codecs/aacdec/ps_stereo_processing.cpp b/media/libstagefright/codecs/aacdec/ps_stereo_processing.cpp
new file mode 100644
index 0000000..813b55d
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/ps_stereo_processing.cpp
@@ -0,0 +1,372 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Filename: ps_stereo_processing.c
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+
+ Who:                                   Date: MM/DD/YYYY
+ Description:
+
+------------------------------------------------------------------------------
+ INPUT AND OUTPUT DEFINITIONS
+
+
+
+------------------------------------------------------------------------------
+ FUNCTION DESCRIPTION
+
+        Stereo Process or reconstruction
+
+           l_k(n) = H11(k,n)*s_k(n) + H21(k,n)*d_k(n)
+
+           r_k(n) = H12(k,n)*s_k(n) + H22(k,n)*d_k(n)
+
+     _______                                              ________
+    |       |                                  _______   |        |
+  ->|Hybrid | LF ----                         |       |->| Hybrid |-->
+    | Anal. |        |                        |       |  | Synth  |   QMF -> L
+     -------         o----------------------->|       |   --------    Synth
+QMF                  |                s_k(n)  |Stereo |-------------->
+Anal.              -------------------------->|       |
+     _______       | |                        |       |   ________
+    |       | HF --o |   -----------          |Process|  |        |
+  ->| Delay |      |  ->|           |-------->|       |->| Hybrid |-->
+     -------       |    |decorrelate| d_k(n)  |       |  | Synth  |   QMF -> R
+                   ---->|           |-------->|       |   --------    Synth
+                         -----------          |_______|-------------->
+
+
+------------------------------------------------------------------------------
+ REQUIREMENTS
+
+
+------------------------------------------------------------------------------
+ REFERENCES
+
+SC 29 Software Copyright Licencing Disclaimer:
+
+This software module was originally developed by
+  Coding Technologies
+
+and edited by
+  -
+
+in the course of development of the ISO/IEC 13818-7 and ISO/IEC 14496-3
+standards for reference purposes and its performance may not have been
+optimized. This software module is an implementation of one or more tools as
+specified by the ISO/IEC 13818-7 and ISO/IEC 14496-3 standards.
+ISO/IEC gives users free license to this software module or modifications
+thereof for use in products claiming conformance to audiovisual and
+image-coding related ITU Recommendations and/or ISO/IEC International
+Standards. ISO/IEC gives users the same free license to this software module or
+modifications thereof for research purposes and further ISO/IEC standardisation.
+Those intending to use this software module in products are advised that its
+use may infringe existing patents. ISO/IEC have no liability for use of this
+software module or modifications thereof. Copyright is not released for
+products that do not conform to audiovisual and image-coding related ITU
+Recommendations and/or ISO/IEC International Standards.
+The original developer retains full right to modify and use the code for its
+own purpose, assign or donate the code to a third party and to inhibit third
+parties from using the code for products that do not conform to audiovisual and
+image-coding related ITU Recommendations and/or ISO/IEC International Standards.
+This copyright notice must be included in all copies or derivative works.
+Copyright (c) ISO/IEC 2003.
+
+------------------------------------------------------------------------------
+ PSEUDO-CODE
+
+------------------------------------------------------------------------------
+*/
+
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+
+#ifdef AAC_PLUS
+
+#ifdef PARAMETRICSTEREO
+#include    "pv_audio_type_defs.h"
+#include    "ps_stereo_processing.h"
+#include    "fxp_mul32.h"
+#include    "ps_all_pass_filter_coeff.h"
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+#ifndef min
+#define min(a, b) ((a) < (b) ? (a) : (b))
+#endif
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here. Include conditional
+; compile variables also.
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; LOCAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; LOCAL STORE/BUFFER/POINTER DEFINITIONS
+; Variable declaration - defined here and used outside this module
+----------------------------------------------------------------------------*/
+
+
+/*----------------------------------------------------------------------------
+; EXTERNAL FUNCTION REFERENCES
+; Declare functions defined elsewhere and referenced in this module
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL GLOBAL STORE/BUFFER/POINTER REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+
+/*----------------------------------------------------------------------------
+; FUNCTION CODE
+----------------------------------------------------------------------------*/
+
+void ps_stereo_processing(STRUCT_PS_DEC  *pms,
+                          Int32          *qmfLeftReal,
+                          Int32          *qmfLeftImag,
+                          Int32          *qmfRightReal,
+                          Int32          *qmfRightImag)
+{
+    Int32     group;
+    Int32     subband;
+    Int32     maxSubband;
+    Int32     usb;
+    Char     index;
+
+
+    Int32  *hybrLeftReal;
+    Int32  *hybrLeftImag;
+    Int32  *hybrRightReal;
+    Int32  *hybrRightImag;
+    Int32  *ptr_hybrLeftReal;
+    Int32  *ptr_hybrLeftImag;
+    Int32  *ptr_hybrRightReal;
+    Int32  *ptr_hybrRightImag;
+
+
+    Int16   h11;
+    Int16   h12;
+    Int16   h21;
+    Int16   h22;
+
+    Int32   temp1;
+    Int32   temp2;
+    Int32   temp3;
+
+    usb = pms->usb;
+
+    /*
+     *   Complete Linear interpolation
+     */
+
+    hybrLeftReal  = pms->mHybridRealLeft;
+    hybrLeftImag  = pms->mHybridImagLeft;
+    hybrRightReal = pms->mHybridRealRight;
+    hybrRightImag = pms->mHybridImagRight;
+
+    for (group = 0; group < SUBQMF_GROUPS; group++)     /* SUBQMF_GROUPS == 10 */
+    {
+
+        temp1 = pms->deltaH11[group];
+        temp2 = pms->deltaH12[group];
+
+        pms->H11[group]  += temp1;
+        h11  = (Int16)(pms->H11[group] >> 16);
+        pms->H12[group]  += temp2;
+        h12  = (Int16)(pms->H12[group] >> 16);
+
+        temp1 = pms->deltaH21[group];
+        temp2 = pms->deltaH22[group];
+
+        pms->H21[group]  += temp1;
+        h21  = (Int16)(pms->H21[group] >> 16);
+        pms->H22[group]  += temp2;
+        h22  = (Int16)(pms->H22[group] >> 16);
+
+        index = groupBorders[group];
+
+        /*
+         *  Reconstruction of Stereo sub-band signal
+         *
+         *  l_k(n) = H11(k,n)*s_k(n) + H21(k,n)*d_k(n)
+         *
+         *  r_k(n) = H12(k,n)*s_k(n) + H22(k,n)*d_k(n)
+         */
+        ptr_hybrLeftReal  = &hybrLeftReal[  index];
+        ptr_hybrRightReal = &hybrRightReal[ index];
+
+        temp1 = *(ptr_hybrLeftReal) << 1;
+        temp2 = *(ptr_hybrRightReal) << 1;
+
+        temp3 = fxp_mul32_by_16(temp1, h11);
+        *(ptr_hybrLeftReal)  = fxp_mac32_by_16(temp2, h21, temp3) << 1;
+
+        temp3 = fxp_mul32_by_16(temp1, h12);
+        *(ptr_hybrRightReal) = fxp_mac32_by_16(temp2, h22, temp3) << 1;
+
+
+        ptr_hybrLeftImag  = &hybrLeftImag[  index];
+        ptr_hybrRightImag = &hybrRightImag[ index];
+
+        temp1 = *(ptr_hybrLeftImag) << 1;
+        temp2 = *(ptr_hybrRightImag) << 1;
+
+        temp3 = fxp_mul32_by_16(temp1, h11);
+        *(ptr_hybrLeftImag)  = fxp_mac32_by_16(temp2, h21, temp3) << 1;
+
+        temp3 = fxp_mul32_by_16(temp1, h12);
+        *(ptr_hybrRightImag) = fxp_mac32_by_16(temp2, h22, temp3) << 1;
+
+
+    } /* groups loop */
+
+    temp1 = pms->deltaH11[SUBQMF_GROUPS];
+    temp2 = pms->deltaH12[SUBQMF_GROUPS];
+
+    pms->H11[SUBQMF_GROUPS]  += temp1;
+    h11  = (Int16)(pms->H11[SUBQMF_GROUPS] >> 16);
+    pms->H12[SUBQMF_GROUPS]  += temp2;
+    h12  = (Int16)(pms->H12[SUBQMF_GROUPS] >> 16);
+
+    temp1 = pms->deltaH21[SUBQMF_GROUPS];
+    temp2 = pms->deltaH22[SUBQMF_GROUPS];
+
+    pms->H21[SUBQMF_GROUPS]  += temp1;
+    h21  = (Int16)(pms->H21[SUBQMF_GROUPS] >> 16);
+    pms->H22[SUBQMF_GROUPS]  += temp2;
+    h22  = (Int16)(pms->H22[SUBQMF_GROUPS] >> 16);
+
+
+    ptr_hybrLeftReal  = &qmfLeftReal[  3];
+    ptr_hybrRightReal = &qmfRightReal[ 3];
+
+    /*
+     *  Reconstruction of Stereo sub-band signal
+     *
+     *  l_k(n) = H11(k,n)*s_k(n) + H21(k,n)*d_k(n)
+     *
+     *  r_k(n) = H12(k,n)*s_k(n) + H22(k,n)*d_k(n)
+     */
+    temp1 = *(ptr_hybrLeftReal) << 1;
+    temp2 = *(ptr_hybrRightReal) << 1;
+
+
+    temp3 = fxp_mul32_by_16(temp1, h11);
+    *(ptr_hybrLeftReal)  = fxp_mac32_by_16(temp2, h21, temp3) << 1;
+
+    temp3 = fxp_mul32_by_16(temp1, h12);
+    *(ptr_hybrRightReal)  = fxp_mac32_by_16(temp2, h22, temp3) << 1;
+
+    ptr_hybrLeftImag  = &qmfLeftImag[  3];
+    ptr_hybrRightImag = &qmfRightImag[ 3];
+
+
+    temp1 = *(ptr_hybrLeftImag) << 1;
+    temp2 = *(ptr_hybrRightImag) << 1;
+
+    temp3 = fxp_mul32_by_16(temp1, h11);
+    *(ptr_hybrLeftImag)  = fxp_mac32_by_16(temp2, h21, temp3) << 1;
+
+    temp3 = fxp_mul32_by_16(temp1, h12);
+    *(ptr_hybrRightImag)  = fxp_mac32_by_16(temp2, h22, temp3) << 1;
+
+
+    for (group = SUBQMF_GROUPS + 1; group < NO_IID_GROUPS; group++)   /* 11 to NO_IID_GROUPS == 22 */
+    {
+        temp1 = pms->deltaH11[group];
+        temp2 = pms->deltaH12[group];
+
+        pms->H11[group]  += temp1;
+        h11  = (Int16)(pms->H11[group] >> 16);
+        pms->H12[group]  += temp2;
+        h12  = (Int16)(pms->H12[group] >> 16);
+
+        temp1 = pms->deltaH21[group];
+        temp2 = pms->deltaH22[group];
+
+        pms->H21[group]  += temp1;
+        h21  = (Int16)(pms->H21[group] >> 16);
+        pms->H22[group]  += temp2;
+        h22  = (Int16)(pms->H22[group] >> 16);
+
+        index = groupBorders[group];
+        maxSubband = groupBorders[group + 1];
+        maxSubband = min(usb, maxSubband);
+
+        /*
+         *  Reconstruction of Stereo sub-band signal
+         *
+         *  l_k(n) = H11(k,n)*s_k(n) + H21(k,n)*d_k(n)
+         *
+         *  r_k(n) = H12(k,n)*s_k(n) + H22(k,n)*d_k(n)
+         */
+
+        ptr_hybrLeftReal  = &qmfLeftReal[  index];
+        ptr_hybrRightReal = &qmfRightReal[ index];
+
+        for (subband = index; subband < maxSubband; subband++)
+        {
+            temp1 = *(ptr_hybrLeftReal) << 1;
+            temp2 = *(ptr_hybrRightReal) << 1;
+            temp3 = fxp_mul32_by_16(temp1, h11);
+            *(ptr_hybrLeftReal++)   = fxp_mac32_by_16(temp2, h21, temp3) << 1;
+
+            temp3 = fxp_mul32_by_16(temp1, h12);
+            *(ptr_hybrRightReal++)  = fxp_mac32_by_16(temp2, h22, temp3) << 1;
+        }
+
+        ptr_hybrLeftImag  = &qmfLeftImag[  index];
+        ptr_hybrRightImag = &qmfRightImag[ index];
+
+        for (subband = index; subband < maxSubband; subband++)
+        {
+            temp1 = *(ptr_hybrLeftImag) << 1;
+            temp2 = *(ptr_hybrRightImag) << 1;
+            temp3 = fxp_mul32_by_16(temp1, h11);
+            *(ptr_hybrLeftImag++)   = fxp_mac32_by_16(temp2, h21, temp3) << 1;
+
+            temp3 = fxp_mul32_by_16(temp1, h12);
+            *(ptr_hybrRightImag++)  = fxp_mac32_by_16(temp2, h22, temp3) << 1;
+
+        } /* subband loop */
+
+    } /* groups loop */
+
+} /* END ps_stereo_processing */
+
+
+#endif
+
+
+#endif
+
diff --git a/media/libstagefright/codecs/aacdec/ps_stereo_processing.h b/media/libstagefright/codecs/aacdec/ps_stereo_processing.h
new file mode 100644
index 0000000..58b025a
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/ps_stereo_processing.h
@@ -0,0 +1,98 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Pathname: ps_stereo_processing.h
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+ Who:                   Date:
+ Description:
+
+------------------------------------------------------------------------------
+ INCLUDE DESCRIPTION
+
+ Header file for function ps_stereo_processing()
+
+------------------------------------------------------------------------------
+*/
+
+/*----------------------------------------------------------------------------
+; CONTINUE ONLY IF NOT ALREADY DEFINED
+----------------------------------------------------------------------------*/
+#ifndef PS_STEREO_PROCESSING_H
+#define PS_STEREO_PROCESSING_H
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+#include "pv_audio_type_defs.h"
+#include "s_ps_dec.h"
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here.
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL VARIABLES REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; SIMPLE TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; ENUMERATED TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; STRUCTURES TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; GLOBAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+    void ps_stereo_processing(STRUCT_PS_DEC  *pms,
+    Int32          *qmfLeftReal,
+    Int32          *qmfLeftImag,
+    Int32          *qmfRightReal,
+    Int32          *qmfRightImag);
+
+#ifdef __cplusplus
+}
+#endif
+
+/*----------------------------------------------------------------------------
+; END
+----------------------------------------------------------------------------*/
+#endif  /* PS_STEREO_PROCESSING_H */
diff --git a/media/libstagefright/codecs/aacdec/pulse_nc.cpp b/media/libstagefright/codecs/aacdec/pulse_nc.cpp
new file mode 100644
index 0000000..87b264d
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/pulse_nc.cpp
@@ -0,0 +1,298 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Pathname: pulse_nc.c
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+ Description:  Modified from original shareware code
+
+ Description:  Modified to pass variables by reference to eliminate use
+               of global variables.
+
+ Description:  Modified to bring code in-line with PV standards.
+
+ Description: Pass in max as input argument.
+
+ Description: Went back to the if-statement to check for max.
+
+ Who:                       Date:
+ Description:
+
+------------------------------------------------------------------------------
+ INPUT AND OUTPUT DEFINITIONS
+
+ Inputs:
+    coef[]         =  Array of quantized spectral coefficents.
+                      (Int [])
+
+    pPulseInfo     =  Pointer to structure which contains noiseless
+                      encoding info, includes information about the pulse data,
+                      pulse amplitude, etc.
+                      (const PulseInfo *)
+
+    pLongFrameInfo =  Pointer to structure that holds information about
+                      each group. (long block flag, number of windows,
+                      scalefactor bands per group, etc.)
+
+                      Variable is named (pLongFrameInfo) because this function
+                      is only used for LONG windows.
+                      (FrameInfo *)
+    max             = Pointer to the maximum value of coef[]
+
+ Local Stores/Buffers/Pointers Needed:
+    None
+
+ Global Stores/Buffers/Pointers Needed:
+    None
+
+ Outputs:
+    None
+
+ Pointers and Buffers Modified:
+    coef[]  =  coefficient contents are modified by the encoded pulse
+
+ Local Stores Modified:
+
+ Global Stores Modified:
+
+------------------------------------------------------------------------------
+ FUNCTION DESCRIPTION
+
+ This function adds pulses to defined ranges of coefficients in the window,
+ for the case of LONG windows.  The pulses are unsigned, so
+ negative coefficients subtract the pulse, and positive coefficients add it.
+ (The ampltiude of the coefficient is always increased by the pulse)
+
+ A maximum of 4 coefficients may be modified by a pulse, and these
+ coefficients must all occur in the same scalefactor band.
+
+ The number of pulse-encoded coefficients to be processed by this function
+ is communicated to this function via pPulseInfo->number_pulse
+
+ This value is equal to the actual number of pulses - 1.
+ (e.g if pPulseInfo->number_pulse == 0, one pulse is assumed)
+ This function must not be called if no pulse encoded data exists.
+ The function assumes that at least one pulse exists.
+------------------------------------------------------------------------------
+ REQUIREMENTS
+
+ This module shall correctly add transmitted pulse(s) to the correct
+ coefficients in a LONG window.
+
+------------------------------------------------------------------------------
+ REFERENCES
+ (1) ISO/IEC 14496-3:1999(E)
+     Part 3
+        Subpart 4.6.3.3 Decoding Process
+
+ (2) MPEG-2 NBC Audio Decoder
+   "This software module was originally developed by AT&T, Dolby
+   Laboratories, Fraunhofer Gesellschaft IIS in the course of development
+   of the MPEG-2 NBC/MPEG-4 Audio standard ISO/IEC 13818-7, 14496-1,2 and
+   3. This software module is an implementation of a part of one or more
+   MPEG-2 NBC/MPEG-4 Audio tools as specified by the MPEG-2 NBC/MPEG-4
+   Audio standard. ISO/IEC  gives users of the MPEG-2 NBC/MPEG-4 Audio
+   standards free license to this software module or modifications thereof
+   for use in hardware or software products claiming conformance to the
+   MPEG-2 NBC/MPEG-4 Audio  standards. Those intending to use this software
+   module in hardware or software products are advised that this use may
+   infringe existing patents. The original developer of this software
+   module and his/her company, the subsequent editors and their companies,
+   and ISO/IEC have no liability for use of this software module or
+   modifications thereof in an implementation. Copyright is not released
+   for non MPEG-2 NBC/MPEG-4 Audio conforming products.The original
+   developer retains full right to use the code for his/her  own purpose,
+   assign or donate the code to a third party and to inhibit third party
+   from using the code for non MPEG-2 NBC/MPEG-4 Audio conforming products.
+   This copyright notice must be included in all copies or derivative
+   works."
+   Copyright(c)1996.
+
+------------------------------------------------------------------------------
+ PSEUDO-CODE
+
+    index = pLongFrameInfo->win_sfb_top[0][pPulseInfo->pulse_start_sfb];
+
+    pPulseOffset = &(pPulseInfo->pulse_offset[0]);
+
+    pPulseAmp    = &(pPulseInfo->pulse_amp[0]);
+
+    pCoef        = &(Coef[index]);
+
+    FOR (index = pPulseInfo->number_pulse; index >= 0; index--)
+
+        pCoef   = pCoef + *(pPulseOffset);
+        pPulseOffset = pPulseOffset + 1;
+
+        IF (*pCoef > 0)
+            *(pCoef) = *(pCoef) + *(pPulseAmp);
+            pPulseAmp     = pPulseAmp + 1;
+        ELSE
+            *(pCoef) = *(pCoef) - *(pPulseAmp);
+            pPulseAmp     = pPulseAmp + 1;
+        ENDIF
+
+    ENDFOR
+
+------------------------------------------------------------------------------
+ RESOURCES USED
+   When the code is written for a specific target processor the
+     the resources used should be documented below.
+
+ STACK USAGE: [stack count for this module] + [variable to represent
+          stack usage for each subroutine called]
+
+     where: [stack usage variable] = stack usage for [subroutine
+         name] (see [filename].ext)
+
+ DATA MEMORY USED: x words
+
+ PROGRAM MEMORY USED: x words
+
+ CLOCK CYCLES: [cycle count equation for this module] + [variable
+           used to represent cycle count for each subroutine
+           called]
+
+     where: [cycle count variable] = cycle count for [subroutine
+        name] (see [filename].ext)
+
+------------------------------------------------------------------------------
+*/
+
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+#include "pv_audio_type_defs.h"
+#include "s_frameinfo.h"
+#include "s_pulseinfo.h"
+#include "pulse_nc.h"
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+/*---------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here. Include conditional
+; compile variables also.
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; LOCAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; LOCAL STORE/BUFFER/POINTER DEFINITIONS
+; Variable declaration - defined here and used outside this module
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL FUNCTION REFERENCES
+; Declare functions defined elsewhere and referenced in this module
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL GLOBAL STORE/BUFFER/POINTER REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; FUNCTION CODE
+----------------------------------------------------------------------------*/
+
+void pulse_nc(
+    Int16      coef[],
+    const PulseInfo  *pPulseInfo,
+    const FrameInfo  *pLongFrameInfo,
+    Int      *max)
+{
+    Int index;
+
+    Int16 *pCoef;
+    Int temp;
+
+    const Int *pPulseOffset;
+    const Int *pPulseAmp;
+
+    /*--- Find the scalefactor band where pulse-encoded data starts ---*/
+
+    if (pPulseInfo->pulse_start_sfb > 0)
+    {
+        index = pLongFrameInfo->win_sfb_top[0][pPulseInfo->pulse_start_sfb - 1];
+    }
+    else
+    {
+        index = 0;
+    }
+
+    /*-------------------------------------------------------------------------
+      Each pulse index is stored as an offset from the previous pulse
+
+      Example - here we have a sfb that is 20 coefficients in length:
+
+      [0][1][2][3][4][5][6][7][8][9][10][11][12][13][14][15][16][17][18][19]
+      [ ][ ][ ][ ][ ][P][P][ ][ ][ ][  ][  ][  ][  ][  ][ P][  ][  ][  ][ P]
+
+      The array pointed to by pPulseOffset == [5][1][9][4]
+
+      pPulseAmp is of the same length as pPulseOffset, and contains
+      an individual pulse amplitude for each coefficient.
+    --------------------------------------------------------------------------*/
+
+    pCoef        = &(coef[index]);
+
+    pPulseOffset = &(pPulseInfo->pulse_offset[0]);
+
+    pPulseAmp    = &(pPulseInfo->pulse_amp[0]);
+
+    for (index = pPulseInfo->number_pulse; index > 0; index--)
+    {
+        pCoef  += *pPulseOffset++;
+
+        temp = *pCoef;
+
+        if (temp > 0)
+        {
+            temp += *(pPulseAmp++);
+            *pCoef = (Int16)temp;
+            if (temp > *max)
+            {
+                *max = temp;
+            }
+        }
+        else
+        {
+            temp -= *(pPulseAmp++);
+            *pCoef = (Int16)temp;
+            if (-temp > *max)
+            {
+                *max = -temp;
+            }
+        }
+
+    } /* for() */
+
+    return;
+
+} /* pulse_nc */
diff --git a/media/libstagefright/codecs/aacdec/pulse_nc.h b/media/libstagefright/codecs/aacdec/pulse_nc.h
new file mode 100644
index 0000000..8181dd0
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/pulse_nc.h
@@ -0,0 +1,104 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Pathname: pulse_nc.h
+
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+ Description: Pass in max as input argument.
+
+ Who:                       Date:
+ Description:
+
+------------------------------------------------------------------------------
+ INCLUDE DESCRIPTION
+
+ This include file contains the global function declaration for pulse_nc
+
+------------------------------------------------------------------------------
+*/
+
+/*----------------------------------------------------------------------------
+; CONTINUE ONLY IF NOT ALREADY DEFINED
+----------------------------------------------------------------------------*/
+#ifndef PULSE_NC_H
+#define PULSE_NC_H
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+#include "pv_audio_type_defs.h"
+#include "s_frameinfo.h"
+#include "s_pulseinfo.h"
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here.
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL VARIABLES REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; SIMPLE TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; ENUMERATED TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; STRUCTURES TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; GLOBAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+    void pulse_nc(
+        Int16        coef[],
+        const PulseInfo  *pPulseInfo,
+        const FrameInfo  *pLongFrameInfo,
+        Int      *max);
+
+#ifdef __cplusplus
+}
+#endif
+
+/*----------------------------------------------------------------------------
+; END
+----------------------------------------------------------------------------*/
+#endif
+
+
diff --git a/media/libstagefright/codecs/aacdec/pv_audio_type_defs.h b/media/libstagefright/codecs/aacdec/pv_audio_type_defs.h
new file mode 100644
index 0000000..dee66bc
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/pv_audio_type_defs.h
@@ -0,0 +1,183 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+------------------------------------------------------------------------------
+ Pathname: ./c/include/pv_audio_type_defs.h
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+ Description:  Removed errant semicolons from #define statements
+
+ Description:
+        1. Modified ifndef STD_TYPE_DEFS_H with
+           #ifndef PV_AUDIO_TYPE_DEFS_H to avoid double definition
+               if file was already included
+        2. Merged cai if-def structures and C++ definition
+            3. Updated copyright notice
+
+ Description:  Added dependency on OSCL libraries
+
+ Description:
+------------------------------------------------------------------------------
+ INCLUDE DESCRIPTION
+
+ This file was derived from a number of standards bodies. The type
+ definitions below were created from some of the best practices observed
+ in the standards bodies.
+
+ This file is dependent on limits.h for defining the bit widths. In an
+ ANSI C environment limits.h is expected to always be present and contain
+ the following definitions:
+
+     SCHAR_MIN
+     SCHAR_MAX
+     UCHAR_MAX
+
+     INT_MAX
+     INT_MIN
+     UINT_MAX
+
+     SHRT_MIN
+     SHRT_MAX
+     USHRT_MAX
+
+     LONG_MIN
+     LONG_MAX
+     ULONG_MAX
+
+------------------------------------------------------------------------------
+*/
+
+#ifndef PV_AUDIO_TYPE_DEFS_H
+#define PV_AUDIO_TYPE_DEFS_H
+
+#include <stdint.h>
+
+typedef int8_t        Char;
+
+typedef uint8_t       UChar;
+
+
+
+/*----------------------------------------------------------------------------
+; Define generic signed and unsigned int
+----------------------------------------------------------------------------*/
+#ifndef Int
+typedef signed int  Int;
+#endif
+
+#ifndef UInt
+typedef unsigned int    UInt;
+#endif
+
+
+/*----------------------------------------------------------------------------
+; Define 16 bit signed and unsigned words
+----------------------------------------------------------------------------*/
+
+
+#ifndef Int16
+typedef int16_t       Int16;
+#endif
+
+#ifndef INT16_MIN
+#define INT16_MIN   (-32768)
+#endif
+
+#ifndef INT16_MAX
+#define INT16_MAX   32767
+#endif
+
+#ifndef UInt16
+typedef uint16_t      UInt16;
+
+#endif
+
+
+/*----------------------------------------------------------------------------
+; Define 32 bit signed and unsigned words
+----------------------------------------------------------------------------*/
+
+
+#ifndef Int32
+typedef int32_t       Int32;
+#endif
+
+#ifndef INT32_MIN
+#define INT32_MIN   (-2147483647 - 1)
+#endif
+#ifndef INT32_MAX
+#define INT32_MAX   2147483647
+#endif
+
+#ifndef UInt32
+typedef uint32_t      UInt32;
+#endif
+
+#ifndef UINT32_MIN
+#define UINT32_MIN  0
+#endif
+#ifndef UINT32_MAX
+#define UINT32_MAX  0xffffffff
+#endif
+
+
+/*----------------------------------------------------------------------------
+; Define 64 bit signed and unsigned words
+----------------------------------------------------------------------------*/
+
+
+/*----------------------------------------------------------------------------
+; Define boolean type
+----------------------------------------------------------------------------*/
+#ifndef Bool
+typedef Int     Bool;
+#endif
+#ifndef FALSE
+#define FALSE       0
+#endif
+
+#ifndef TRUE
+#define TRUE        1
+#endif
+
+#ifndef OFF
+#define OFF     0
+#endif
+#ifndef ON
+#define ON      1
+#endif
+
+#ifndef NO
+#define NO      0
+#endif
+#ifndef YES
+#define YES     1
+#endif
+
+#ifndef SUCCESS
+#define SUCCESS     0
+#endif
+
+#ifndef  NULL
+#define  NULL       0
+#endif
+
+
+#endif  /* PV_AUDIO_TYPE_DEFS_H */
diff --git a/media/libstagefright/codecs/aacdec/pv_div.cpp b/media/libstagefright/codecs/aacdec/pv_div.cpp
new file mode 100644
index 0000000..86d2487
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/pv_div.cpp
@@ -0,0 +1,188 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Filename: pv_div.c
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+
+ Who:                                   Date: MM/DD/YYYY
+ Description:
+
+------------------------------------------------------------------------------
+ INPUT AND OUTPUT DEFINITIONS
+
+    Int32 x             32-bit integer numerator
+    Int32 y             32-bit integer denominator
+    Quotient *result    structure that hold result and shift factor
+
+
+------------------------------------------------------------------------------
+ FUNCTION DESCRIPTION
+
+    Implement division of two Int32 numbers, provides back quotient and a
+    shift factor
+------------------------------------------------------------------------------
+ REQUIREMENTS
+
+
+------------------------------------------------------------------------------
+ REFERENCES
+
+------------------------------------------------------------------------------
+ PSEUDO-CODE
+
+------------------------------------------------------------------------------
+*/
+
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+#ifdef AAC_PLUS
+
+
+#include "pv_audio_type_defs.h"
+#include "fxp_mul32.h"
+#include "pv_div.h"
+#include "pv_normalize.h"
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here. Include conditional
+; compile variables also.
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; LOCAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; LOCAL STORE/BUFFER/POINTER DEFINITIONS
+; Variable declaration - defined here and used outside this module
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL FUNCTION REFERENCES
+; Declare functions defined elsewhere and referenced in this module
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL GLOBAL STORE/BUFFER/POINTER REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; FUNCTION CODE
+----------------------------------------------------------------------------*/
+
+
+void pv_div(Int32 x, Int32 y, Quotient *result)
+{
+    /*----------------------------------------------------------------------------
+    ; Define all local variables
+    ----------------------------------------------------------------------------*/
+    Int32 quotient;
+    Int32 i;
+    Int32 j;
+    Int32 y_ov_y_hi;
+    Int32 flag = 0;     /* carries negative sign, if any  */
+
+
+    result->shift_factor = 0;   /* default  */
+
+    if (y == 0)
+    {
+        x = 0;   /* this will return 0 for any div/0 */
+    }
+    /*
+     *  make sure x and y are both positive
+     */
+
+    if (y < 0)
+    {
+        y = -y;
+        flag ^= 1;
+    }
+
+
+    if (x < 0)
+    {
+        x = -x;
+        flag ^= 1;
+    }
+
+    if (x != 0)
+    {
+        /*----------------------------------------------------------------------------
+        ; Scale the input to get maximum precision for x
+        ----------------------------------------------------------------------------*/
+
+        i = pv_normalize(x);
+
+        x <<= i;
+
+
+        /*----------------------------------------------------------------------------
+        ; Scale the input to get maximum precision for y
+        ----------------------------------------------------------------------------*/
+
+        j = pv_normalize(y);
+
+        y <<= j;
+
+        result->shift_factor = i - j;
+
+        /*----------------------------------------------------------------------------
+        ; Function body here
+        ----------------------------------------------------------------------------*/
+        /*---------------------------------------------------------------
+         ; take the inverse of the 16 MSB of y
+         ---------------------------------------------------------------*/
+
+        quotient = (0x40000000 / (y >> 15));
+
+        y_ov_y_hi = fxp_mul32_Q15(y, quotient);            /*  y*(1/y_hi)     */
+
+        y_ov_y_hi = 0x7FFFFFFF - y_ov_y_hi;                 /*  2 - y*(1/y_hi) */
+        y_ov_y_hi = fxp_mul32_Q14(quotient,  y_ov_y_hi);
+        i  = fxp_mul32_Q31(y_ov_y_hi,  x) << 1;
+
+        result->quotient = flag ? -i : i;
+    }
+    else
+    {
+        result->quotient = 0;
+    }
+
+
+
+}
+
+#endif
+
+
diff --git a/media/libstagefright/codecs/aacdec/pv_div.h b/media/libstagefright/codecs/aacdec/pv_div.h
new file mode 100644
index 0000000..2dfa8a0
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/pv_div.h
@@ -0,0 +1,74 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Pathname: pv_div.h
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+ Who:                                       Date:
+ Description:
+------------------------------------------------------------------------------
+ INCLUDE DESCRIPTION
+
+------------------------------------------------------------------------------
+*/
+
+#ifndef PV_DIV_H
+#define PV_DIV_H
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+    /*----------------------------------------------------------------------------
+    ; INCLUDES
+    ----------------------------------------------------------------------------*/
+
+#include "pv_audio_type_defs.h"
+
+    /*----------------------------------------------------------------------------
+    ; MACROS
+    ; Define module specific macros here
+    ----------------------------------------------------------------------------*/
+
+    /*----------------------------------------------------------------------------
+    ; EXTERNAL VARIABLES REFERENCES
+    ----------------------------------------------------------------------------*/
+
+    /*----------------------------------------------------------------------------
+    ; DEFINES AND SIMPLE TYPEDEF'S
+    ----------------------------------------------------------------------------*/
+
+    struct intg_div
+    {
+        Int32 quotient;
+        Int32 shift_factor;
+    };
+    typedef struct intg_div Quotient;
+
+
+    void pv_div(Int32 x, Int32 y, Quotient *quotient);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif  /* PV_DIV_H */
diff --git a/media/libstagefright/codecs/aacdec/pv_log2.cpp b/media/libstagefright/codecs/aacdec/pv_log2.cpp
new file mode 100644
index 0000000..69cbe91
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/pv_log2.cpp
@@ -0,0 +1,168 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Filename: pv_log2.c
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+
+ Who:                                   Date: MM/DD/YYYY
+ Description:
+
+------------------------------------------------------------------------------
+ INPUT AND OUTPUT DEFINITIONS
+
+    Int32 x             32-bit integer input
+
+
+------------------------------------------------------------------------------
+ FUNCTION DESCRIPTION
+
+    Implement the logarithm base 2 of a number
+------------------------------------------------------------------------------
+ REQUIREMENTS
+
+
+------------------------------------------------------------------------------
+ REFERENCES
+
+------------------------------------------------------------------------------
+ PSEUDO-CODE
+
+------------------------------------------------------------------------------
+*/
+
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+
+#ifdef AAC_PLUS
+
+
+#include "pv_log2.h"
+#include "fxp_mul32.h"
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here. Include conditional
+; compile variables also.
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; LOCAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; LOCAL STORE/BUFFER/POINTER DEFINITIONS
+; Variable declaration - defined here and used outside this module
+----------------------------------------------------------------------------*/
+
+#define R_SHIFT     20
+#define Q_fmt(x)   (Int32)(x*((Int32)1<<R_SHIFT) + (x>=0?0.5F:-0.5F))
+
+const Int32 log_table[9] =
+{
+    Q_fmt(-0.00879832091331F),  Q_fmt(0.12022974263833F),
+    Q_fmt(-0.72883958314294F),  Q_fmt(2.57909824242332F),
+    Q_fmt(-5.90041216630330F),  Q_fmt(9.15023342527264F),
+    Q_fmt(-9.90616619500413F),  Q_fmt(8.11228968755409F),
+    Q_fmt(-3.41763474309898F)
+};
+
+
+/*----------------------------------------------------------------------------
+; EXTERNAL FUNCTION REFERENCES
+; Declare functions defined elsewhere and referenced in this module
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL GLOBAL STORE/BUFFER/POINTER REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; FUNCTION CODE
+----------------------------------------------------------------------------*/
+
+
+
+Int32 pv_log2(Int32 z)
+{
+    const Int32 *pt_table = log_table;
+    Int32 y;
+    Int32 i;
+
+    Int32 int_log2 = 0;
+
+    if (z > Q_fmt(2.0f))
+    {
+        while (z > Q_fmt(2.0f))
+        {
+            z >>= 1;
+            int_log2++;
+        }
+    }
+    else if (z < Q_fmt(1.0f))
+    {
+        {
+            while (z < Q_fmt(1.0f))
+            {
+                z <<= 1;
+                int_log2--;
+            }
+        }
+    }
+
+    /*
+     *  at this point, input limited to 1<x<2
+     */
+
+    if (z != Q_fmt(1.0f))
+    {
+        y  = fxp_mul32_Q20(*(pt_table++), z);
+
+        for (i = 7; i != 0; i--)
+        {
+            y += *(pt_table++);
+            y  = fxp_mul32_Q20(y, z);
+        }
+
+        y += *(pt_table++);
+    }
+    else
+    {
+        y = 0;
+    }
+
+
+    return (y + (int_log2 << 20));         /* Q20 */
+}
+
+
+#endif
+
diff --git a/media/libstagefright/codecs/aacdec/pv_log2.h b/media/libstagefright/codecs/aacdec/pv_log2.h
new file mode 100644
index 0000000..4834e82
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/pv_log2.h
@@ -0,0 +1,69 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Pathname: pv_log2.h
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+ Who:                                       Date:
+ Description:
+------------------------------------------------------------------------------
+ INCLUDE DESCRIPTION
+
+------------------------------------------------------------------------------
+*/
+
+#ifndef PV_LOG2_H
+#define PV_LOG2_H
+
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+
+#include "pv_audio_type_defs.h"
+
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+    /*----------------------------------------------------------------------------
+    ; EXTERNAL VARIABLES REFERENCES
+    ----------------------------------------------------------------------------*/
+
+    /*----------------------------------------------------------------------------
+    ; DEFINES AND SIMPLE TYPEDEF'S
+    ----------------------------------------------------------------------------*/
+
+
+    Int32 pv_log2(Int32 z);
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif  /* PV_LOG2_H */
diff --git a/media/libstagefright/codecs/aacdec/pv_normalize.cpp b/media/libstagefright/codecs/aacdec/pv_normalize.cpp
new file mode 100644
index 0000000..365b5ad
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/pv_normalize.cpp
@@ -0,0 +1,167 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Filename: pv_normalize.c
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+
+ Who:                                   Date: MM/DD/YYYY
+ Description:
+
+------------------------------------------------------------------------------
+ INPUT AND OUTPUT DEFINITIONS
+
+Input
+    Int32 x             32-bit integer non-zero input
+Returns
+    Int32 i             number of leading zeros on x
+
+
+------------------------------------------------------------------------------
+ FUNCTION DESCRIPTION
+
+    Returns number of leading zeros on the non-zero input
+
+------------------------------------------------------------------------------
+ REQUIREMENTS
+
+
+------------------------------------------------------------------------------
+ REFERENCES
+
+------------------------------------------------------------------------------
+ PSEUDO-CODE
+
+------------------------------------------------------------------------------
+*/
+
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+
+#include "pv_audio_type_defs.h"
+#include "pv_normalize.h"
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here. Include conditional
+; compile variables also.
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; LOCAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; LOCAL STORE/BUFFER/POINTER DEFINITIONS
+; Variable declaration - defined here and used outside this module
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL FUNCTION REFERENCES
+; Declare functions defined elsewhere and referenced in this module
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL GLOBAL STORE/BUFFER/POINTER REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; FUNCTION CODE
+----------------------------------------------------------------------------*/
+
+#if defined(_ARM)
+#elif (defined(PV_ARM_GCC_V5)||defined(PV_ARM_GCC_V4))
+/* function is inlined in header file */
+
+
+#else
+
+Int pv_normalize(Int32 x)
+{
+    /*----------------------------------------------------------------------------
+    ; Define all local variables
+    ----------------------------------------------------------------------------*/
+    Int i;
+
+
+    if (x > 0x0FFFFFFF)
+    {
+        i = 0;  /* most likely case */
+    }
+    else if (x > 0x00FFFFFF)
+    {
+        i = 3;  /* second most likely case */
+    }
+    else if (x > 0x0000FFFF)
+    {
+        i  = x > 0x000FFFFF ?  7 :  11;
+    }
+    else
+    {
+        if (x > 0x000000FF)
+        {
+            i  = x > 0x00000FFF ?  15 :  19;
+        }
+        else
+        {
+            i  = x > 0x0000000F ?  23 :  27;
+        }
+    }
+
+
+    x <<= i;
+
+    switch (x & 0x78000000)
+    {
+        case 0x08000000:
+            i += 3;
+            break;
+
+        case 0x18000000:
+        case 0x10000000:
+            i += 2;
+            break;
+        case 0x28000000:
+        case 0x20000000:
+        case 0x38000000:
+        case 0x30000000:
+            i++;
+
+        default:
+            ;
+    }
+
+    return i;
+
+}
+
+#endif
+
diff --git a/media/libstagefright/codecs/aacdec/pv_normalize.h b/media/libstagefright/codecs/aacdec/pv_normalize.h
new file mode 100644
index 0000000..dce080e
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/pv_normalize.h
@@ -0,0 +1,105 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+  Pathname: pv_normalize.h
+
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+ Who:                                       Date:
+ Description:
+------------------------------------------------------------------------------
+ INCLUDE DESCRIPTION
+
+------------------------------------------------------------------------------
+*/
+
+#ifndef PV_NORMALIZE_H
+#define PV_NORMALIZE_H
+
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+
+#include "pv_audio_type_defs.h"
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL VARIABLES REFERENCES
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; DEFINES AND SIMPLE TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+#if defined(_ARM)
+
+__inline Int pv_normalize(Int32 x)
+{
+    Int32 y;
+    __asm
+    {
+        clz y, x;
+        sub y, y, #1
+    }
+    return (y);
+}
+
+
+#elif (defined(PV_ARM_GCC_V5)||defined(PV_ARM_GCC_V4))
+
+__inline Int pv_normalize(Int32 x)
+{
+    register Int32 y;
+    register Int32 ra = x;
+
+
+    asm volatile(
+        "clz %0, %1\n\t"
+        "sub %0, %0, #1"
+    : "=&r*i"(y)
+                : "r"(ra));
+    return (y);
+
+}
+
+#else
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+    Int pv_normalize(Int32 x);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
+
+
+
+#endif  /* PV_NORMALIZE_H */
diff --git a/media/libstagefright/codecs/aacdec/pv_pow2.cpp b/media/libstagefright/codecs/aacdec/pv_pow2.cpp
new file mode 100644
index 0000000..8dfca23
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/pv_pow2.cpp
@@ -0,0 +1,170 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Filename: pv_pow2.c
+
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+
+ Who:                                   Date: MM/DD/YYYY
+ Description:
+
+------------------------------------------------------------------------------
+ INPUT AND OUTPUT DEFINITIONS
+
+Input
+    Int32 x             32-bit integer input  Q27
+
+Output
+    Int32               32-bit integer in Q25
+
+
+------------------------------------------------------------------------------
+ FUNCTION DESCRIPTION
+
+    Implement the power base 2 for positive numbers lesser than 5.999999
+------------------------------------------------------------------------------
+ REQUIREMENTS
+
+
+------------------------------------------------------------------------------
+ REFERENCES
+
+------------------------------------------------------------------------------
+ PSEUDO-CODE
+
+------------------------------------------------------------------------------
+*/
+#ifdef AAC_PLUS
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+#include "pv_pow2.h"
+#include "fxp_mul32.h"
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here. Include conditional
+; compile variables also.
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; LOCAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+#define POW_2_TABLE_LENGTH          6
+#define POW_2_TABLE_LENGTH_m_2      (POW_2_TABLE_LENGTH - 2)
+
+/*----------------------------------------------------------------------------
+; LOCAL STORE/BUFFER/POINTER DEFINITIONS
+; Variable declaration - defined here and used outside this module
+----------------------------------------------------------------------------*/
+
+#define R_SHIFT     29
+#define Q_fmt(x)   (Int32)(x*((Int32)1<<R_SHIFT) + (x>=0?0.5F:-0.5F))
+
+#define Q27fmt(x)   (Int32)(x*((Int32)1<<27) + (x>=0?0.5F:-0.5F))
+
+const Int32 pow2_table[6] =
+{
+    Q_fmt(0.00224510927441F),   Q_fmt(0.00777943379416F),
+    Q_fmt(0.05737929218747F),   Q_fmt(0.23918017179889F),
+    Q_fmt(0.69345251849351F),   Q_fmt(0.99996347120248F)
+};
+
+
+/*----------------------------------------------------------------------------
+; EXTERNAL FUNCTION REFERENCES
+; Declare functions defined elsewhere and referenced in this module
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL GLOBAL STORE/BUFFER/POINTER REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; FUNCTION CODE
+----------------------------------------------------------------------------*/
+
+
+/*
+ *      z in Q27 format
+ */
+
+Int32 pv_pow2(Int32 z)
+{
+    const Int32 *pt_table = pow2_table;
+    Int32 multiplier = 0;
+    Int32 shift_factor;
+    Int32 i;
+    Int32 v_q;
+    Int32 y;
+
+
+    if (z > Q27fmt(1.0f))
+    {
+        v_q = z - (z & 0xF8000000);
+        shift_factor =   z >> 27;
+    }
+    else
+    {
+        v_q = z;
+        shift_factor = 0;
+    }
+
+    if (v_q < Q27fmt(0.5f))
+    {
+        v_q += Q27fmt(0.5f);
+        multiplier = Q_fmt(0.70710678118655F);
+    }
+
+    v_q = v_q << 2;
+
+    y  = fxp_mul32_Q29(*(pt_table++), v_q);
+
+    for (i = POW_2_TABLE_LENGTH_m_2; i != 0; i--)
+    {
+        y += *(pt_table++);
+        y  = fxp_mul32_Q29(y, v_q);
+    }
+    y += *(pt_table++);
+
+    if (multiplier)
+    {
+        y = fxp_mul32_Q29(y, multiplier);
+    }
+
+    /*
+     *  returns number on Q25
+     */
+    return (y >> (4 - shift_factor));
+
+}
+
+#endif
diff --git a/media/libstagefright/codecs/aacdec/pv_pow2.h b/media/libstagefright/codecs/aacdec/pv_pow2.h
new file mode 100644
index 0000000..04bfe93
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/pv_pow2.h
@@ -0,0 +1,68 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Pathname: pv_pow2.h
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+ Who:                                       Date:
+ Description:
+------------------------------------------------------------------------------
+ INCLUDE DESCRIPTION
+
+------------------------------------------------------------------------------
+*/
+
+#ifndef PV_POW2_H
+#define PV_POW2_H
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+
+#include "pv_audio_type_defs.h"
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+
+    /*----------------------------------------------------------------------------
+    ; EXTERNAL VARIABLES REFERENCES
+    ----------------------------------------------------------------------------*/
+
+    /*----------------------------------------------------------------------------
+    ; DEFINES AND SIMPLE TYPEDEF'S
+    ----------------------------------------------------------------------------*/
+
+
+    Int32 pv_pow2(Int32 z);
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif  /* PV_POW2_H */
diff --git a/media/libstagefright/codecs/aacdec/pv_sine.cpp b/media/libstagefright/codecs/aacdec/pv_sine.cpp
new file mode 100644
index 0000000..54319b1
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/pv_sine.cpp
@@ -0,0 +1,182 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Filename: pv_sine.c
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+
+ Who:                                   Date: MM/DD/YYYY
+ Description:
+
+------------------------------------------------------------------------------
+ INPUT AND OUTPUT DEFINITIONS
+
+    Int32 x             32-bit integer angle (in Q30) between 0 and pi/2
+
+
+------------------------------------------------------------------------------
+ FUNCTION DESCRIPTION
+
+    Find the sine of a number between 0 and pi/2
+------------------------------------------------------------------------------
+ REQUIREMENTS
+
+
+------------------------------------------------------------------------------
+ REFERENCES
+
+------------------------------------------------------------------------------
+ PSEUDO-CODE
+
+------------------------------------------------------------------------------
+*/
+
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+
+#ifdef AAC_PLUS
+
+#ifdef PARAMETRICSTEREO
+
+#include "pv_audio_type_defs.h"
+#include "fxp_mul32.h"
+#include "pv_sine.h"
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here. Include conditional
+; compile variables also.
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; LOCAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; LOCAL STORE/BUFFER/POINTER DEFINITIONS
+; Variable declaration - defined here and used outside this module
+----------------------------------------------------------------------------*/
+
+#define R_SHIFT     30
+
+#define Q_fmt(x)   (Int32)(x*((Int32)1<<R_SHIFT) + (x>=0?0.5F:-0.5F))
+
+const Int32 sin_table[9] =
+{
+    Q_fmt(0.00001724684028), Q_fmt(-0.00024606242846),
+    Q_fmt(0.00007297328923), Q_fmt(0.00826706596417),
+    Q_fmt(0.00003585160465), Q_fmt(-0.16667772526248),
+    Q_fmt(0.00000174197440), Q_fmt(0.99999989138797),
+    Q_fmt(0.00000000110513)
+};
+
+
+/*----------------------------------------------------------------------------
+; EXTERNAL FUNCTION REFERENCES
+; Declare functions defined elsewhere and referenced in this module
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL GLOBAL STORE/BUFFER/POINTER REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; FUNCTION CODE
+----------------------------------------------------------------------------*/
+
+
+Int32 pv_sine(Int32 z)
+{
+    Int32 sine;
+    Int32 i;
+    const Int32 *pt_table = sin_table;
+    Int32 sign = 0;
+
+    if (z < 0)
+    {
+        z = -z;
+        sign = 1;
+    }
+
+    if (z > Q_fmt(0.0015))
+    {
+        sine  = fxp_mul32_Q30(*(pt_table++), z);
+
+        for (i = 7; i != 0; i--)
+        {
+            sine += *(pt_table++);
+            sine  = fxp_mul32_Q30(sine, z);
+        }
+
+    }
+    else
+    {
+        sine = z;  /*  better approximation in this range */
+    }
+
+    if (sign)
+    {
+        sine = -sine;
+    }
+
+    return sine;
+}
+
+
+
+Int32 pv_cosine(Int32 z)
+{
+    Int32 cosine;
+
+    if (z < 0)
+    {
+        z = -z;     /* sign does not play a role in cosine */
+    }
+
+    if (z > Q_fmt(0.0015))
+    {
+        z = Q_fmt(1.57079632679490) - z;   /* pi/2 - z */
+
+        cosine  = pv_sine(z);
+    }
+    else
+    {   /*  better approximation in this range  */
+        cosine = Q_fmt(0.99999999906868) - (fxp_mul32_Q30(z, z) >> 1);
+    }
+
+    return cosine;
+}
+
+#endif
+
+#endif
+
+
diff --git a/media/libstagefright/codecs/aacdec/pv_sine.h b/media/libstagefright/codecs/aacdec/pv_sine.h
new file mode 100644
index 0000000..145013a
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/pv_sine.h
@@ -0,0 +1,68 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Pathname: pv_sine.h
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+ Who:                                       Date:
+ Description:
+------------------------------------------------------------------------------
+ INCLUDE DESCRIPTION
+
+------------------------------------------------------------------------------
+*/
+
+#ifndef PV_SINE_H
+#define PV_SINE_H
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+    /*----------------------------------------------------------------------------
+    ; INCLUDES
+    ----------------------------------------------------------------------------*/
+
+#include "pv_audio_type_defs.h"
+
+    /*----------------------------------------------------------------------------
+    ; MACROS
+    ; Define module specific macros here
+    ----------------------------------------------------------------------------*/
+
+    /*----------------------------------------------------------------------------
+    ; EXTERNAL VARIABLES REFERENCES
+    ----------------------------------------------------------------------------*/
+
+    /*----------------------------------------------------------------------------
+    ; DEFINES AND SIMPLE TYPEDEF'S
+    ----------------------------------------------------------------------------*/
+
+
+    Int32 pv_sine(Int32 x);
+    Int32 pv_cosine(Int32 x);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif  /* PV_SINE_H */
diff --git a/media/libstagefright/codecs/aacdec/pv_sqrt.cpp b/media/libstagefright/codecs/aacdec/pv_sqrt.cpp
new file mode 100644
index 0000000..065fa38
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/pv_sqrt.cpp
@@ -0,0 +1,218 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Filename: pv_sqrt.c
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+
+ Who:                                   Date: MM/DD/YYYY
+ Description:
+
+------------------------------------------------------------------------------
+ INPUT AND OUTPUT DEFINITIONS
+
+    Int32 x             32-bit integer
+
+    Int32 y             32-bit integer
+
+
+------------------------------------------------------------------------------
+ FUNCTION DESCRIPTION
+
+    Implement root squared of a number
+
+------------------------------------------------------------------------------
+ REQUIREMENTS
+
+
+------------------------------------------------------------------------------
+ REFERENCES
+
+------------------------------------------------------------------------------
+ PSEUDO-CODE
+
+------------------------------------------------------------------------------
+*/
+
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+
+#ifdef AAC_PLUS
+
+
+#include "pv_audio_type_defs.h"
+
+#include "fxp_mul32.h"
+#include "pv_sqrt.h"
+
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here. Include conditional
+; compile variables also.
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; LOCAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+#define R_SHIFT     28
+#define Q_fmt(x)   (Int32)(x*((Int32)1<<R_SHIFT) + (x>=0?0.5F:-0.5F))
+
+
+const Int32 sqrt_table[9] =
+{
+    Q_fmt(-0.13829740941110F),  Q_fmt(0.95383399963991F),
+    Q_fmt(-2.92784603873353F),  Q_fmt(5.27429191920042F),
+    Q_fmt(-6.20272445821478F),  Q_fmt(5.04717433019620F),
+    Q_fmt(-3.03362807640415F),  Q_fmt(1.86178814410910F),
+    Q_fmt(0.16540758699193F)
+};
+
+/*----------------------------------------------------------------------------
+; LOCAL STORE/BUFFER/POINTER DEFINITIONS
+; Variable declaration - defined here and used outside this module
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL FUNCTION REFERENCES
+; Declare functions defined elsewhere and referenced in this module
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL GLOBAL STORE/BUFFER/POINTER REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; FUNCTION CODE
+----------------------------------------------------------------------------*/
+
+
+void pv_sqrt(Int32 man, Int32 exp, Root_sq *result, Int32 *sqrt_cache)
+{
+
+    Int32   y;
+    Int32   xx;
+    Int32   nn;
+    Int32   i;
+    const Int32 *pt_table = sqrt_table;
+
+
+    if (sqrt_cache[0] == man && sqrt_cache[1] == exp)
+    {
+        result->root         =        sqrt_cache[2];
+        result->shift_factor = (Int16)sqrt_cache[3];
+    }
+    else
+    {
+
+        sqrt_cache[0] = man;
+        sqrt_cache[1] = exp;
+
+
+        if (man > 0)
+        {
+            xx =  man;
+            if (man >= Q_fmt(1.0f))
+            {
+                nn = exp + 1;
+                while ((xx >>= 1) > Q_fmt(1.0f))
+                {
+                    nn++;
+                }
+            }
+            else if (man < Q_fmt(0.5f))
+            {
+                nn = exp - 1;
+                while ((xx <<= 1) < Q_fmt(0.5f))
+                {
+                    nn--;
+                }
+            }
+            else
+            {
+                nn = exp;
+            }
+
+
+            y  = fxp_mul32_Q28(*(pt_table++), xx);
+
+            for (i = 3; i != 0; i--)
+            {
+                y += *(pt_table++);
+                y  = fxp_mul32_Q28(y, xx);
+                y += *(pt_table++);
+                y  = fxp_mul32_Q28(y, xx);
+            }
+            y += *(pt_table++);
+            y  = fxp_mul32_Q28(y, xx) + *(pt_table++);
+
+            if (nn >= 0)
+            {
+                if (nn&1)
+                {
+                    y = fxp_mul32_Q29(y, Q_fmt(1.41421356237310F));
+                    result->shift_factor = (nn >> 1) - 28;
+                }
+                else
+                {
+                    result->shift_factor = (nn >> 1) - 29;
+                }
+            }
+            else
+            {
+                if (nn&1)
+                {
+                    y = fxp_mul32_Q28(y, Q_fmt(0.70710678118655F));
+                }
+
+                result->shift_factor = -((-nn) >> 1) - 29;
+            }
+
+            result->root = y;
+
+        }
+        else
+        {
+            result->root = 0;
+            result->shift_factor = 0;
+        }
+
+    }
+
+    sqrt_cache[2] = result->root;
+    sqrt_cache[3] = result->shift_factor;
+
+}
+
+
+#endif
+
+
diff --git a/media/libstagefright/codecs/aacdec/pv_sqrt.h b/media/libstagefright/codecs/aacdec/pv_sqrt.h
new file mode 100644
index 0000000..45d6f52
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/pv_sqrt.h
@@ -0,0 +1,74 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Pathname: pv_sqrt.h
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+ Who:                                       Date:
+ Description:
+------------------------------------------------------------------------------
+ INCLUDE DESCRIPTION
+
+------------------------------------------------------------------------------
+*/
+
+#ifndef PV_SQRT_H
+#define PV_SQRT_H
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+    /*----------------------------------------------------------------------------
+    ; INCLUDES
+    ----------------------------------------------------------------------------*/
+
+#include "pv_audio_type_defs.h"
+
+    /*----------------------------------------------------------------------------
+    ; MACROS
+    ; Define module specific macros here
+    ----------------------------------------------------------------------------*/
+
+    /*----------------------------------------------------------------------------
+    ; EXTERNAL VARIABLES REFERENCES
+    ----------------------------------------------------------------------------*/
+
+    /*----------------------------------------------------------------------------
+    ; DEFINES AND SIMPLE TYPEDEF'S
+    ----------------------------------------------------------------------------*/
+
+    struct intg_sqrt
+    {
+        Int32 root;
+        Int32 shift_factor;
+    };
+    typedef struct intg_sqrt Root_sq;
+
+    void pv_sqrt(Int32 man, Int32 exp, Root_sq *result, Int32 *sqrt_cache);
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif  /* PV_SQRT_H */
diff --git a/media/libstagefright/codecs/aacdec/pvmp4audiodecoder_api.h b/media/libstagefright/codecs/aacdec/pvmp4audiodecoder_api.h
new file mode 100644
index 0000000..7806f88
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/pvmp4audiodecoder_api.h
@@ -0,0 +1,376 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+  Name: PVMP4AudioDecoder_API.h
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+ Description: Change buffer type to UChar
+
+ Description: Update comments
+
+ Description: Updated a comment that MT did not get around to
+ before the end of his contract.
+
+ Description: add a new API to decode audioSpecificConfig separately, the same
+              change has been made on 32-bits version (element \main\2)
+
+ Description: add a new API to reset history buffer, the same change has been
+              made on a 32-bits version(element \nd.e0352.wjin\1)
+
+ Who:                                       Date:
+ Description:
+
+------------------------------------------------------------------------------
+ INCLUDE DESCRIPTION
+
+ Main header file for the Packet Video MP4/AAC audio decoder library. The
+ constants, structures, and functions defined within this file, along with
+ a basic data types header file, is all that is needed to use and communicate
+ with the library. The internal data structures within the library are
+ purposely hidden.
+
+ ---* Need description of the input buffering. *-------
+
+ ---* Need an example of calling the library here *----
+
+------------------------------------------------------------------------------
+ REFERENCES
+
+  (Normally header files do not have a reference section)
+
+  ISO/EIC 14496-3:(1999) Document titled
+------------------------------------------------------------------------------
+*/
+
+/*----------------------------------------------------------------------------
+; CONTINUE ONLY IF NOT ALREADY DEFINED
+----------------------------------------------------------------------------*/
+#ifndef PVMP4AUDIODECODER_API_H
+#define PVMP4AUDIODECODER_API_H
+
+#include "pv_audio_type_defs.h"  /* Basic data types used within the lib */
+
+#include "e_tmp4audioobjecttype.h"
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+    /*----------------------------------------------------------------------------
+    ; MACROS
+    ; Define module specific macros here
+    ----------------------------------------------------------------------------*/
+
+    /*----------------------------------------------------------------------------
+    ; DEFINES
+    ; Include all pre-processor statements here.
+    ----------------------------------------------------------------------------*/
+
+    /*
+     * This constant is the guaranteed-to-work buffer size, specified in bytes,
+     * for the input buffer for 2 audio channels to decode one frame of data,
+     * as specified by the MPEG-2 or MPEG-4 standard.
+     * The standard, and this constant, do not take into account that lower
+     * bitrates will use less data per frame. Note that the number of bits
+     * used per frame is variable, and only that the average value will be the
+     * bit rate specified during encoding. The standard does not specify
+     * over how many frames the average must be maintained.
+     *
+     * The constant value is 6144 * 2 channels / 8 bits per byte
+     */
+
+
+#define PVMP4AUDIODECODER_INBUFSIZE  1536
+
+    /*----------------------------------------------------------------------------
+    ; EXTERNAL VARIABLES REFERENCES
+    ; Declare variables used in this module but defined elsewhere
+    ----------------------------------------------------------------------------*/
+
+    /*----------------------------------------------------------------------------
+    ; SIMPLE TYPEDEF'S
+    ----------------------------------------------------------------------------*/
+
+    /*----------------------------------------------------------------------------
+    ; ENUMERATED TYPEDEF'S
+    ----------------------------------------------------------------------------*/
+    /*
+     * This enumeration is used for the structure element outputFormat. It
+     * specifies how the output data is to be formatted. Presently only 16-bit
+     * PCM data is supported, and this enum informs how the single output
+     * buffer should be for two-channel stereo data.
+     * Grouped format stores all the left channel values, then right:
+     * "LLLL...LLRRRR...RR"
+     * Interleave format store left, then right audio samples:
+     * "LRLRLRLR...."
+     */
+    typedef enum ePVMP4AudioDecoderOutputFormat
+    {
+        OUTPUTFORMAT_16PCM_GROUPED = 0,
+        OUTPUTFORMAT_16PCM_INTERLEAVED = 1
+
+    } tPVMP4AudioDecoderOutputFormat;
+
+    /*
+     * This enumeration holds the possible return values for the main decoder
+     * function, PVMP4AudioDecodeFrame. The plan was to easily distinguish
+     * whether an error was recoverable (streaming mode) or not. Presently no
+     * errors are recoverable, which is a result of not supporting ADTS in
+     * this release.
+     */
+    typedef enum ePVMP4AudioDecoderErrorCode
+    {
+        MP4AUDEC_SUCCESS           =  0,
+        MP4AUDEC_INVALID_FRAME     = 10,
+        MP4AUDEC_INCOMPLETE_FRAME  = 20,
+        MP4AUDEC_LOST_FRAME_SYNC   = 30     /* Cannot happen since no ADTS */
+    } tPVMP4AudioDecoderErrorCode;
+
+
+    /*
+     * This enumeration holds the possible return values for stream type
+     * being decoded
+     */
+    typedef enum
+    {
+        AAC = 0,
+        AACPLUS,
+        ENH_AACPLUS
+    } STREAMTYPE;
+
+    /*----------------------------------------------------------------------------
+    ; STRUCTURES TYPEDEF'S
+    ----------------------------------------------------------------------------*/
+    /*
+     * This structure is used to communicate information in to and out of the
+     * AAC decoder.
+     */
+
+    typedef struct
+#ifdef __cplusplus
+                tPVMP4AudioDecoderExternal  // To allow forward declaration of this struct in C++
+#endif
+    {
+        /*
+         * INPUT:
+         * Pointer to the input buffer that contains the encoded bistream data.
+         * The data is filled in such that the first bit transmitted is
+         * the most-significant bit (MSB) of the first array element.
+         * The buffer is accessed in a linear fashion for speed, and the number of
+         * bytes consumed varies frame to frame.
+         * The calling environment can change what is pointed to between calls to
+         * the decode function, library, as long as the inputBufferCurrentLength,
+         * and inputBufferUsedLength are updated too. Also, any remaining bits in
+         * the old buffer must be put at the beginning of the new buffer.
+         */
+        UChar  *pInputBuffer;
+
+        /*
+         * INPUT:
+         * Number of valid bytes in the input buffer, set by the calling
+         * function. After decoding the bitstream the library checks to
+         * see if it when past this value; it would be to prohibitive to
+         * check after every read operation. This value is not modified by
+         * the AAC library.
+         */
+        Int     inputBufferCurrentLength;
+
+        /*
+         * INPUT:
+         * The actual size of the buffer.
+         * This variable is not used by the library, but is used by the
+         * console test application. This parameter could be deleted
+         * if this value was passed into these function. The helper functions are
+         * not part of the library and are not used by the Common Audio Decoder
+         * Interface.
+         */
+        Int     inputBufferMaxLength;
+
+        /*
+         * INPUT:
+         * Enumerated value the output is to be interleaved left-right-left-right.
+         * For further information look at the comments for the enumeration.
+         */
+        tPVMP4AudioDecoderOutputFormat  outputFormat;
+
+        /*
+         * INPUT: (but what is pointed to is an output)
+         * Pointer to the output buffer to hold the 16-bit PCM audio samples.
+         * If the output is stereo, both left and right channels will be stored
+         * in this one buffer. Presently it must be of length of 2048 points.
+         * The format of the buffer is set by the parameter outputFormat.
+         */
+        Int16  *pOutputBuffer;
+
+        /*
+         * INPUT: (but what is pointed to is an output)
+         * Pointer to the output buffer to hold the 16-bit PCM AAC-plus audio samples.
+         * If the output is stereo, both left and right channels will be stored
+         * in this one buffer. Presently it must be of length of 2048 points.
+         * The format of the buffer is set by the parameter outputFormat.
+         */
+        Int16  *pOutputBuffer_plus;     /* Used in AAC+ and enhanced AAC+  */
+
+        /*
+         * INPUT:
+         * AAC Plus Upsampling Factor. Normally set to 2 when Spectrum Band
+         * Replication (SBR) is used
+         */
+        Int32  aacPlusUpsamplingFactor; /* Used in AAC+ and enhanced AAC+  */
+
+        /*
+         * INPUT:
+         * AAC Plus enabler. Deafaults to be ON, unless run time conditions
+         * require the SBR and PS tools disabled
+         */
+        bool    aacPlusEnabled;
+        /*
+         * INPUT:
+         * (Currently not being used inside the AAC library.)
+         * This flag is set to TRUE when the playback position has been changed,
+         * for example, rewind or fast forward. This informs the AAC library to
+         * take an appropriate action, which has yet to be determined.
+         */
+        Bool    repositionFlag;
+
+        /*
+         * INPUT:
+         * Number of requested output audio channels. This relieves the calling
+         * environment from having to perform stereo-to-mono or mono-to-stereo
+         * conversions.
+         */
+        Int     desiredChannels;
+
+        /*
+         * INPUT/OUTPUT:
+         * Number of elements used by the library, initially set to zero by
+         * the function PVMP4AudioDecoderInitLibrary, and modified by each
+         * call to PVMP4AudioDecodeFrame.
+         */
+        Int     inputBufferUsedLength;
+
+        /*
+         * INPUT/OUTPUT:
+         * Number of bits left over in the next buffer element,
+         * This value will always be zero, unless support for ADTS is added.
+         */
+        Int32    remainderBits;
+
+        /*
+         * OUTPUT:
+         * The sampling rate decoded from the bitstream, in units of
+         * samples/second. For this release of the library this value does
+         * not change from frame to frame, but future versions will.
+         */
+        Int32   samplingRate;
+
+        /*
+         * OUTPUT:
+         * This value is the bitrate in units of bits/second. IT
+         * is calculated using the number of bits consumed for the current frame,
+         * and then multiplying by the sampling_rate, divided by points in a frame.
+         * This value can changes frame to frame.
+         */
+        Int32   bitRate;
+
+        /*
+         * OUTPUT:
+         * The number of channels decoded from the bitstream. The output data
+         * will have be the amount specified in the variable desiredChannels,
+         * this output is informative only, and can be ignored.
+         */
+        Int     encodedChannels;
+
+        /*
+         * OUTPUT:
+         * This value is the number of output PCM samples per channel.
+         * It is presently hard-coded to 1024, but may change in the future.
+         * It will not change frame to frame, and would take on
+         * one of these four values: 1024, 960, 512, or 480. If an error occurs
+         * do not rely on this value.
+         */
+        Int     frameLength;
+
+        /*
+        * This value is audio object type as defined in struct tMP4AudioObjectType
+        * in file e_tMP4AudioObjectType.h
+        */
+        Int     audioObjectType;
+
+        /*
+        * This value is extended audio object type as defined in struct tMP4AudioObjectType
+        * in file e_tMP4AudioObjectType.h. It carries the output Audio Object Type
+        */
+        Int     extendedAudioObjectType;
+
+
+    } tPVMP4AudioDecoderExternal;
+
+    /*----------------------------------------------------------------------------
+    ; GLOBAL FUNCTION DEFINITIONS
+    ; Function Prototype declaration
+    ----------------------------------------------------------------------------*/
+
+    OSCL_IMPORT_REF UInt32 PVMP4AudioDecoderGetMemRequirements(void);
+
+    OSCL_IMPORT_REF Int PVMP4AudioDecoderInitLibrary(
+        tPVMP4AudioDecoderExternal  *pExt,
+        void                        *pMem);
+
+    OSCL_IMPORT_REF Int PVMP4AudioDecodeFrame(
+        tPVMP4AudioDecoderExternal  *pExt,
+        void                        *pMem);
+
+    OSCL_IMPORT_REF Int PVMP4AudioDecoderConfig(
+        tPVMP4AudioDecoderExternal  *pExt,
+        void                        *pMem);
+
+    OSCL_IMPORT_REF void PVMP4AudioDecoderResetBuffer(
+        void                        *pMem);
+
+    OSCL_IMPORT_REF void PVMP4AudioDecoderDisableAacPlus(
+        tPVMP4AudioDecoderExternal  *pExt,
+        void                        *pMem);
+
+    Int PVMP4SetAudioConfig(
+        tPVMP4AudioDecoderExternal  *pExt,
+        void                        *pMem,
+        Int                         upsamplingFactor,
+        Int                         samp_rate,
+        int                         num_ch,
+        tMP4AudioObjectType         audioObjectType);
+
+    /*----------------------------------------------------------------------------
+    ; END
+    ----------------------------------------------------------------------------*/
+
+#ifdef __cplusplus
+}
+#endif
+
+
+#endif  /* PVMP4AUDIODECODER_API_H */
+
+
diff --git a/media/libstagefright/codecs/aacdec/pvmp4audiodecoderconfig.cpp b/media/libstagefright/codecs/aacdec/pvmp4audiodecoderconfig.cpp
new file mode 100644
index 0000000..9208fa8
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/pvmp4audiodecoderconfig.cpp
@@ -0,0 +1,285 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Pathname: PVMP4AudioDecoderConfig
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+ Description: (1) Modified to decode AudioSpecificConfig for any frame number
+                  pVars->bno
+              (2) Update the input and output descriptions
+
+ Description: Eliminated search for ADIF header
+
+ Description: Added support for AAC+
+
+ Who:                                         Date:
+ Description:
+
+------------------------------------------------------------------------------
+ INPUT AND OUTPUT DEFINITIONS
+
+ Inputs:
+    pExt = pointer to the external interface structure. See the file
+           PVMP4AudioDecoder_API.h for a description of each field.
+           Data type of pointer to a tPVMP4AudioDecoderExternal
+           structure.
+
+           pExt->pInputBuffer: pointer to input buffer containing input
+                               bitstream
+
+           pExt->inputBufferCurrentLength: number of bytes in the input buffer
+
+           pExt->inputBufferUsedLength: number of bytes already consumed in
+                                        input buffer
+
+           pExt->remainderBits: number of bits consumed in addition to
+                                pExt->inputBufferUsedLength
+
+    pMem = void pointer to hide the internal implementation of the library
+           It is cast back to a tDec_Int_File structure. This structure
+           contains information that needs to persist between calls to
+           this function, or is too big to be placed on the stack, even
+           though the data is only needed during execution of this function
+           Data type void pointer, internally pointer to a tDec_Int_File
+           structure.
+
+ Local Stores/Buffers/Pointers Needed: None
+           (The memory set aside in pMem performs this task)
+
+ Global Stores/Buffers/Pointers Needed: None
+
+ Outputs:
+     status = 0                       if no error occurred
+              MP4AUDEC_NONRECOVERABLE if a non-recoverable error occurred
+              MP4AUDEC_RECOVERABLE    if a recoverable error occurred.
+              Presently a recoverable error does not exist, but this
+              was a requirement.
+
+
+ Pointers and Buffers Modified:
+    pMem contents are modified.
+    pExt: (more detail in the file PVMP4AudioDecoder_API.h)
+    inputBufferUsedLength - number of array elements used up by the stream.
+    remainderBits - remaining bits in the next UInt32 buffer
+    samplingRate - sampling rate in samples per sec
+    encodedChannels - channels found on the file (informative)
+    frameLength - length of the frame
+
+ Local Stores Modified: None.
+
+ Global Stores Modified: None.
+
+------------------------------------------------------------------------------
+ FUNCTION DESCRIPTION
+
+
+------------------------------------------------------------------------------
+ REQUIREMENTS
+
+ PacketVideo Document # CCC-AUD-AAC-ERS-0003
+
+------------------------------------------------------------------------------
+ REFERENCES
+
+ (1) ISO/IEC 14496-3: 1999(E)
+      subclause 1.6
+
+------------------------------------------------------------------------------
+ RESOURCES USED
+   When the code is written for a specific target processor the
+     the resources used should be documented below.
+
+ STACK USAGE: [stack count for this module] + [variable to represent
+          stack usage for each subroutine called]
+
+     where: [stack usage variable] = stack usage for [subroutine
+         name] (see [filename].ext)
+
+ DATA MEMORY USED: x words
+
+ PROGRAM MEMORY USED: x words
+
+ CLOCK CYCLES: [cycle count equation for this module] + [variable
+           used to represent cycle count for each subroutine
+           called]
+
+     where: [cycle count variable] = cycle count for [subroutine
+        name] (see [filename].ext)
+
+------------------------------------------------------------------------------
+*/
+
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+#include "pv_audio_type_defs.h"
+#include "s_tdec_int_file.h"
+#include "ibstream.h"           /* where #define INBUF_ARRAY_INDEX_SHIFT */
+#include "sfb.h"                   /* Where samp_rate_info[] is declared */
+
+#include "get_audio_specific_config.h"
+#include "pvmp4audiodecoder_api.h"   /* Where this function is declared */
+
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here. Include conditional
+; compile variables also.
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; LOCAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; LOCAL STORE/BUFFER/POINTER DEFINITIONS
+; Variable declaration - defined here and used outside this module
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL FUNCTION REFERENCES
+; Declare functions defined elsewhere and referenced in this module
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL GLOBAL STORE/BUFFER/POINTER REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; FUNCTION CODE
+----------------------------------------------------------------------------*/
+
+OSCL_EXPORT_REF Int PVMP4AudioDecoderConfig(
+    tPVMP4AudioDecoderExternal  *pExt,
+    void                        *pMem)
+{
+
+    UInt           initialUsedBits;  /* Unsigned for C55x */
+    tDec_Int_File *pVars;           /* Helper pointer */
+
+    Int            status = MP4AUDEC_INCOMPLETE_FRAME;
+
+    /*
+     * Initialize "helper" pointers to existing memory.
+     */
+    pVars = (tDec_Int_File *)pMem;
+    /*
+     * Translate input buffer variables.
+     */
+    pVars->inputStream.pBuffer = pExt->pInputBuffer;
+
+    pVars->inputStream.inputBufferCurrentLength =
+        (UInt)pExt->inputBufferCurrentLength;
+
+    pVars->inputStream.availableBits =
+        (UInt)(pExt->inputBufferCurrentLength << INBUF_ARRAY_INDEX_SHIFT);
+
+    initialUsedBits =
+        (UInt)((pExt->inputBufferUsedLength << INBUF_ARRAY_INDEX_SHIFT) +
+               pExt->remainderBits);
+
+    pVars->inputStream.usedBits = initialUsedBits;
+
+    if (initialUsedBits <= pVars->inputStream.availableBits)
+    {
+
+        /*
+         * Buffer is not overrun, then
+         * decode the AudioSpecificConfig() structure
+         */
+
+        pVars->aacConfigUtilityEnabled = false;  /* set aac dec mode */
+
+        status = get_audio_specific_config(pVars);
+
+    }
+
+    byte_align(&pVars->inputStream);
+
+
+    if (status == SUCCESS)
+    {
+
+        pVars->bno++;
+
+        /*
+         * A possible improvement would be to set these values only
+         * when they change.
+         */
+        pExt->samplingRate =
+            samp_rate_info[pVars->prog_config.sampling_rate_idx].samp_rate;
+
+        /*
+         *  we default to 2 channel, even for mono files, (where channels have same content)
+         *  this is done to ensure support for enhanced aac+ with implicit signalling
+         */
+        pExt->aacPlusEnabled = pVars->aacPlusEnabled;
+
+//        pExt->encodedChannels = pVars->mc_info.nch;
+
+        pExt->encodedChannels = 2;
+
+        pExt->frameLength = pVars->frameLength;
+#ifdef AAC_PLUS
+        pExt->aacPlusUpsamplingFactor = pVars->mc_info.upsamplingFactor;
+#endif
+
+    }
+    else
+    {
+        /*
+         *  Default to nonrecoverable error status unless there is a Buffer overrun
+         */
+        status = MP4AUDEC_INVALID_FRAME;
+
+        if (pVars->inputStream.usedBits > pVars->inputStream.availableBits)
+        {
+            /* all bits were used but were not enough to complete parsing */
+            pVars->inputStream.usedBits = pVars->inputStream.availableBits;
+
+            status = MP4AUDEC_INCOMPLETE_FRAME; /* audio config too small */
+        }
+
+    }
+
+    /*
+     * Translate from units of bits back into units of words.
+     */
+
+    pExt->inputBufferUsedLength =
+        pVars->inputStream.usedBits >> INBUF_ARRAY_INDEX_SHIFT;
+
+    pExt->remainderBits = pVars->inputStream.usedBits & INBUF_BIT_MODULO_MASK;
+
+    pVars->status = status;
+
+    return (status);
+
+} /* PVMP4AudioDecoderDecodeFrame */
+
diff --git a/media/libstagefright/codecs/aacdec/pvmp4audiodecoderframe.cpp b/media/libstagefright/codecs/aacdec/pvmp4audiodecoderframe.cpp
new file mode 100644
index 0000000..7a279dc
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/pvmp4audiodecoderframe.cpp
@@ -0,0 +1,1458 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Pathname: pvmp4audiodecodeframe
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+ Description:  Modified from original shareware code
+
+ Description:  Pulled in loop structure from console.c, so that this function
+               now decodes all frames in the file.
+
+               Original program used several global variables.  These have been
+               eliminated, except for situations in which the global variables
+               could be converted into const types.  Otherwise, they are passed
+               by reference through the functions.
+
+ Description:  Begin mods for file I/O removal
+
+ Description:  Merged trans4m_freq_2_time, trans4m_time_2_freq, etc.
+
+ Description:  Removing commented out sections of code.  This includes the
+               removal of unneeded functions init_lt_pred, reset_mc_info,
+
+ Description: Copied from aac_decode_frame.c and renamed file,
+              Made many changes.
+
+ Description: Prepare for code review
+
+ Description: Update per review comments:
+              1) Add comment about leaveGetLoop
+              2) Remove inverseTNSCoef array
+              3) fix wnd_shape_this_bk to wnd_shape_prev_bk in F to T
+              4) Clean up comments
+              5) Change call to long_term_synthesis
+
+ Description: Remove division for calculation of bitrate.
+
+ Description: Remove update of LTP buffers if not LTP audio object type.
+
+ Description: Add hasmask to call to right_ch_sfb_tools_ms
+
+ Description:
+ Modified to call ltp related routines on the left channel
+ before intensity is called on the right channel.  The previous version
+ was causing a problem when IS was used on the right channel and LTP
+ on the left channel for the same scalefactor band.
+
+ This fix required creating a new function, apply_ms_synt, deleting another
+ function (right_ch_sfb_tools_noms.c), and modifying the calling order of
+ the other functions.
+
+ Description: Made changes per review comments.
+
+ Description: Changed name of right_ch_sfb_tools_ms to pns_intensity_right
+
+ Description: Added cast, since pVars->inputStream.usedBits is UInt, and
+ pExt->remainderBits is Int.
+
+ pExt->remainderBits =
+    (Int)(pVars->inputStream.usedBits & INBUF_BIT_MODULO_MASK);
+
+ Description: Modified to pass a pointer to scratch memory into
+ tns_setup_filter.c
+
+ Description: Removed include of "s_TNSInfo.h"
+
+ Description: Removed call to "tns_setup_filter" which has been eliminated
+ by merging its functionality into "get_tns"
+
+ Description:  Passing in a pointer to a q-format array, rather than
+ the address of a single q-format, for the inverse filter case for
+ apply_tns.
+
+ Description:
+ (1) Added #include of "e_ElementId.h"
+     Previously, this function was relying on another include file
+     to include "e_ElementId.h"
+
+ (2) Updated the copyright header.
+
+ Description:
+ Per review comments, declared two temporary variables
+
+    pChLeftShare  = pChVars[LEFT]->pShareWfxpCoef;
+    pChRightShare = pChVars[RIGHT]->pShareWfxpCoef;
+
+ Description:
+    long_term_synthesis should have been invoked with max_sfb
+    as the 2nd parameter, rather than pFrameInfo->sfb_per_win[0].
+
+    Old
+                long_term_synthesis(
+                    pChVars[ch]->wnd,
+                    pFrameInfo->sfb_per_win[0] ...
+
+    Correction
+                long_term_synthesis(
+                    pChVars[ch]->wnd,
+                    pChVars[ch]->pShareWfxpCoef->max_sfb ...
+
+    This problem caused long_term_synthesis to read memory which
+    was not initialized in get_ics_info.c
+
+ Description:
+ (1) Utilize scratch memory for the scratch Prog_Config.
+
+ Description: (1) Modified to decode ID_END syntactic element after header
+
+ Description:
+ (1) Reconfigured LTP buffer as a circular buffer.  This saves
+     2048 Int16->Int16 copies per frame.
+
+ Description: Updated so ltp buffers are not used as a wasteful
+ intermediate buffer for LC streams.  Data is transferred directly
+ from the filterbank to the output stream.
+
+ Description: Decode ADIF header if frame count is zero.
+              The AudioSpecificConfig is decoded by a separate API.
+
+ Description: Added comments explaining how the ltp_buffer_state
+ variable is updated.
+
+
+ Description: Modified code to take advantage of new trans4m_freq_2_time_fxp,
+ which writes the output directly into a 16-bit output buffer.  This
+ improvement allows faster operation by reducing the amount of memory
+ transfers.  Speed can be further improved on most platforms via use of a
+ DMA transfer in the function write_output.c
+
+ Description: perChan[] is an array of structures in tDec_Int_File. Made
+              corresponding changes.
+
+ Description: Included changes in interface for q_normalize() and
+              trans4m_freq_2_time_fxp.
+
+ Description: Included changes in interface for long_term_prediction.
+
+ Description: Added support for DSE (Data Streaming Channel). Added
+              function get_dse() and included file get_dse.h
+
+ Description: Added support for the ill-case when a raw data block contains
+              only a terminator <ID_END>. This is illegal but is added
+              for convinience
+
+ Description: Added support for empty audio frames, such the one containing
+              only DSE or FILL elements. A trap was added to stop processing
+              when no audio information was sent.
+
+ Description: Added support for adts format files. Added saturation to
+              floating point version of aac+ decoding
+
+ Description:
+
+------------------------------------------------------------------------------
+ INPUT AND OUTPUT DEFINITIONS
+
+ Inputs:
+    pExt = pointer to the external interface structure. See the file
+           PVMP4AudioDecoder_API.h for a description of each field.
+           Data type of pointer to a tPVMP4AudioDecoderExternal
+           structure.
+
+    pMem = void pointer to hide the internal implementation of the library
+           It is cast back to a tDec_Int_File structure. This structure
+           contains information that needs to persist between calls to
+           this function, or is too big to be placed on the stack, even
+           though the data is only needed during execution of this function
+           Data type void pointer, internally pointer to a tDec_Int_File
+           structure.
+
+ Local Stores/Buffers/Pointers Needed: None
+           (The memory set aside in pMem performs this task)
+
+ Global Stores/Buffers/Pointers Needed: None
+
+ Outputs:
+     status = 0                       if no error occurred
+              MP4AUDEC_NONRECOVERABLE if a non-recoverable error occurred
+              MP4AUDEC_RECOVERABLE    if a recoverable error occurred.
+              Presently a recoverable error does not exist, but this
+              was a requirement.
+
+
+ Pointers and Buffers Modified:
+    pMem contents are modified.
+    pExt: (more detail in the file PVMP4AudioDecoder_API.h)
+    inputBufferUsedLength - number of array elements used up by the stream.
+    remainderBits - remaining bits in the next UInt32 buffer
+    samplingRate - sampling rate in samples per sec
+    bitRate - bit rate in bits per second, varies frame to frame.
+    encodedChannels - channels found on the file (informative)
+    frameLength - length of the frame
+
+ Local Stores Modified: None.
+
+ Global Stores Modified: None.
+
+------------------------------------------------------------------------------
+ FUNCTION DESCRIPTION
+
+ Decodes one frame of an MPEG-2/MPEG-4 encoded audio bitstream.
+
+ This function calls the various components of the decoder in the proper order.
+
+
+         Left Channel                                    Right Channel
+             |                                                 |
+             |                                                 |
+             |                                                 |
+            \|/                                               \|/
+ #1 ____________________                           #2 ____________________
+    |                  |                              |                  |
+    | Huffman Decoding |                              | Huffman Decoding |
+    |__________________|                              |__________________|
+             |                                                 |
+             |                                                 |
+             |                                                 |
+            \|/                                                |
+ #3 ____________________                                       |
+    |                  |                                       |
+    |     PNS LEFT     |                                       |
+    |__________________|                                       |
+             |                                                 |
+             |                                                 |
+             |                                                 |
+            \|/                                               \|/
+ #4 ______________________________________________________________________
+    |                                                                    |
+    |                          Apply MS_Synt                             |
+    |____________________________________________________________________|
+             |                                                 |
+             |                                                 |
+            \|/                                                |
+ #5 ____________________                                       |
+    |                  |                                       W
+    |       LTP        |                                       A
+    |__________________|                                       I
+             |                                                 T
+             |                                                 |
+             |                                                 F
+            \|/                                                O
+ #6 ____________________                                       R
+    |                  |                                       |
+    |   Time -> Freq   |                                       L
+    |__________________|                                       E
+             |                                                 F
+             |                                                 T
+             |                                                 |
+            \|/                                                C
+ #7 ____________________                                       H
+    |                  |                                       A
+    |    TNS Inverse   |                                       N
+    |__________________|                                       N
+             |                                                 E
+             |                                                 L
+             |                                                 |
+            \|/                                                |
+ #8 ____________________                                       |
+    |                  |                                       |
+    | Long Term Synth  |                                       |
+    |__________________|                                       |
+             |                                                 |
+             |                                                \|/
+             |                                     #9 ____________________
+             |                                        |                  |
+             |--DATA ON LEFT CHANNEL MAY BE USED----->| PNS/Intensity Rt |
+             |                                        |__________________|
+             |                                                 |
+             |                                                 |
+             |                                                \|/
+             |                                    #10 ____________________
+             W                                        |                  |
+             A                                        |       LTP        |
+             I                                        |__________________|
+             T                                                 |
+             |                                                 |
+             F                                                 |
+             O                                                \|/
+             R                                    #11 ____________________
+             |                                        |                  |
+             R                                        |   Time -> Freq   |
+             I                                        |__________________|
+             G                                                 |
+             H                                                 |
+             T                                                 |
+             |                                                \|/
+             C                                    #12 ____________________
+             H                                        |                  |
+             A                                        |    TNS Inverse   |
+             N                                        |__________________|
+             N                                                 |
+             E                                                 |
+             L                                                 |
+             |                                                \|/
+             |                                    #13 ____________________
+             |                                        |                  |
+             |                                        | Long Term Synth  |
+             |                                        |__________________|
+             |                                                 |
+             |                                                 |
+             |                                                 |
+            \|/                                               \|/
+#14 ____________________                          #18 ____________________
+    |                  |                              |                  |
+    |       TNS        |                              |       TNS        |
+    |__________________|                              |__________________|
+             |                                                 |
+             |                                                 |
+             |                                                 |
+            \|/                                               \|/
+#15 ____________________                          #19 ____________________
+    |                  |                              |                  |
+    |   qFormatNorm    |                              |   qFormatNorm    |
+    |__________________|                              |__________________|
+             |                                                 |
+             |                                                 |
+             |                                                 |
+            \|/                                               \|/
+#16 ____________________                          #20 ____________________
+    |                  |                              |                  |
+    |   Freq / Time    |                              |   Freq / Time    |
+    |__________________|                              |__________________|
+             |                                                 |
+             |                                                 |
+             |                                                 |
+            \|/                                               \|/
+#17 ____________________                          #21 ____________________
+    |                  |                              |                  |
+    |   Limit Buffer   |                              |   Limit Buffer   |
+    |__________________|                              |__________________|
+             |                                                 |
+             |                                                 |
+             |                                                 |
+            \|/                                               \|/
+#22 ______________________________________________________________________
+    |                                                                    |
+    |                           Write Output                             |
+    |____________________________________________________________________|
+
+
+------------------------------------------------------------------------------
+ REQUIREMENTS
+
+ PacketVideo Document # CCC-AUD-AAC-ERS-0003
+
+------------------------------------------------------------------------------
+ REFERENCES
+
+ (1) MPEG-2 NBC Audio Decoder
+   "This software module was originally developed by AT&T, Dolby
+   Laboratories, Fraunhofer Gesellschaft IIS in the course of development
+   of the MPEG-2 NBC/MPEG-4 Audio standard ISO/IEC 13818-7, 14496-1,2 and
+   3. This software module is an implementation of a part of one or more
+   MPEG-2 NBC/MPEG-4 Audio tools as specified by the MPEG-2 NBC/MPEG-4
+   Audio standard. ISO/IEC gives users of the MPEG-2 NBC/MPEG-4 Audio
+   standards free license to this software module or modifications thereof
+   for use in hardware or software products claiming conformance to the
+   MPEG-2 NBC/MPEG-4 Audio  standards. Those intending to use this software
+   module in hardware or software products are advised that this use may
+   infringe existing patents. The original developer of this software
+   module and his/her company, the subsequent editors and their companies,
+   and ISO/IEC have no liability for use of this software module or
+   modifications thereof in an implementation. Copyright is not released
+   for non MPEG-2 NBC/MPEG-4 Audio conforming products.The original
+   developer retains full right to use the code for his/her own purpose,
+   assign or donate the code to a third party and to inhibit third party
+   from using the code for non MPEG-2 NBC/MPEG-4 Audio conforming products.
+   This copyright notice must be included in all copies or derivative
+   works."
+   Copyright(c)1996.
+
+------------------------------------------------------------------------------
+ RESOURCES USED
+   When the code is written for a specific target processor the
+     the resources used should be documented below.
+
+ STACK USAGE: [stack count for this module] + [variable to represent
+          stack usage for each subroutine called]
+
+     where: [stack usage variable] = stack usage for [subroutine
+         name] (see [filename].ext)
+
+ DATA MEMORY USED: x words
+
+ PROGRAM MEMORY USED: x words
+
+ CLOCK CYCLES: [cycle count equation for this module] + [variable
+           used to represent cycle count for each subroutine
+           called]
+
+     where: [cycle count variable] = cycle count for [subroutine
+        name] (see [filename].ext)
+
+------------------------------------------------------------------------------
+*/
+
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+#include "pv_audio_type_defs.h"
+
+#include "s_tdec_int_chan.h"
+#include "s_tdec_int_file.h"
+#include "aac_mem_funcs.h"
+#include "sfb.h"                   /* Where samp_rate_info[] is declared */
+#include "e_tmp4audioobjecttype.h"
+#include "e_elementid.h"
+
+
+#include "get_adif_header.h"
+#include "get_adts_header.h"
+#include "get_audio_specific_config.h"
+#include "ibstream.h"           /* where getbits is declared */
+
+#include "huffman.h"            /* where huffdecode is declared */
+#include "get_prog_config.h"
+#include "getfill.h"
+#include "pns_left.h"
+
+#include "apply_ms_synt.h"
+#include "pns_intensity_right.h"
+#include "q_normalize.h"
+#include "long_term_prediction.h"
+#include "long_term_synthesis.h"
+#include "ltp_common_internal.h"
+#include "apply_tns.h"
+
+#include "window_block_fxp.h"
+
+#include "write_output.h"
+
+#include "pvmp4audiodecoder_api.h"   /* Where this function is declared */
+#include "get_dse.h"
+
+#include "sbr_applied.h"
+#include "sbr_open.h"
+#include "get_sbr_bitstream.h"
+#include "e_sbr_element_id.h"
+
+
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here. Include conditional
+; compile variables also.
+----------------------------------------------------------------------------*/
+
+#define LEFT (0)
+#define RIGHT (1)
+
+
+/*----------------------------------------------------------------------------
+; LOCAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; LOCAL STORE/BUFFER/POINTER DEFINITIONS
+; Variable declaration - defined here and used outside this module
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL FUNCTION REFERENCES
+; Declare functions defined elsewhere and referenced in this module
+----------------------------------------------------------------------------*/
+
+void InitSbrSynFilterbank(bool bDownSampleSBR);
+
+
+
+/*----------------------------------------------------------------------------
+; EXTERNAL GLOBAL STORE/BUFFER/POINTER REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; FUNCTION CODE
+----------------------------------------------------------------------------*/
+
+
+OSCL_EXPORT_REF Int PVMP4AudioDecodeFrame(
+    tPVMP4AudioDecoderExternal  *pExt,
+    void                        *pMem)
+{
+    Int            frameLength;      /* Helper variable */
+    Int            ch;
+    Int            id_syn_ele;
+    UInt           initialUsedBits;  /* Unsigned for C55x */
+    Int            qFormatNorm;
+    Int            qPredictedSamples;
+    Bool           leaveGetLoop;
+    MC_Info       *pMC_Info;        /* Helper pointer */
+    FrameInfo     *pFrameInfo;      /* Helper pointer */
+    tDec_Int_File *pVars;           /* Helper pointer */
+    tDec_Int_Chan *pChVars[Chans];  /* Helper pointer */
+
+    per_chan_share_w_fxpCoef *pChLeftShare;  /* Helper pointer */
+    per_chan_share_w_fxpCoef *pChRightShare; /* Helper pointer */
+
+    Int            status = MP4AUDEC_SUCCESS;
+
+
+    Bool empty_frame;
+
+#ifdef AAC_PLUS
+
+    SBRDECODER_DATA *sbrDecoderData;
+    SBR_DEC         *sbrDec;
+    SBRBITSTREAM    *sbrBitStream;
+
+#endif
+    /*
+     * Initialize "helper" pointers to existing memory.
+     */
+    pVars = (tDec_Int_File *)pMem;
+
+    pMC_Info = &pVars->mc_info;
+
+    pChVars[LEFT]  = &pVars->perChan[LEFT];
+    pChVars[RIGHT] = &pVars->perChan[RIGHT];
+
+    pChLeftShare = pChVars[LEFT]->pShareWfxpCoef;
+    pChRightShare = pChVars[RIGHT]->pShareWfxpCoef;
+
+
+#ifdef AAC_PLUS
+
+    sbrDecoderData = (SBRDECODER_DATA *) & pVars->sbrDecoderData;
+    sbrDec         = (SBR_DEC *) & pVars->sbrDec;
+    sbrBitStream   = (SBRBITSTREAM *) & pVars->sbrBitStr;
+
+#ifdef PARAMETRICSTEREO
+    sbrDecoderData->hParametricStereoDec = (HANDLE_PS_DEC) & pVars->sbrDecoderData.ParametricStereoDec;
+#endif
+
+#endif
+    /*
+     * Translate input buffer variables.
+     */
+    pVars->inputStream.pBuffer = pExt->pInputBuffer;
+
+    pVars->inputStream.inputBufferCurrentLength = (UInt)pExt->inputBufferCurrentLength;
+
+    pVars->inputStream.availableBits =
+        (UInt)(pExt->inputBufferCurrentLength << INBUF_ARRAY_INDEX_SHIFT);
+
+    initialUsedBits =
+        (UInt)((pExt->inputBufferUsedLength << INBUF_ARRAY_INDEX_SHIFT) +
+               pExt->remainderBits);
+
+    pVars->inputStream.usedBits = initialUsedBits;
+
+    if (initialUsedBits > pVars->inputStream.availableBits)
+    {
+        status = MP4AUDEC_INVALID_FRAME;
+    }
+    else if (pVars->bno == 0)
+    {
+        /*
+         * Attempt to read in ADIF format first because it is easily identified.
+         * If its not an ADIF bitstream, get_adif_header rewinds the "pointer"
+         * (actually usedBits).
+         */
+        status =
+            get_adif_header(
+                pVars,
+                &(pVars->scratch.scratch_prog_config));
+
+        byte_align(&pVars->inputStream);
+
+        if (status == SUCCESS)
+        {
+            pVars->prog_config.file_is_adts = FALSE;
+        }
+        else  /* we've tried simple audio config, adif, then it should be adts */
+        {
+            pVars->prog_config.file_is_adts = TRUE;
+        }
+    }
+    else if ((pVars->bno == 1) && (pVars->prog_config.file_is_adts == FALSE))
+    {
+
+        /*
+         * There might be an ID_END element following immediately after the
+         * AudioSpecificConfig header. This syntactic element should be read
+         * and byte_aligned before proceeds to decode "real" AAC raw data.
+         */
+        id_syn_ele = (Int)getbits(LEN_SE_ID, &pVars->inputStream) ;
+
+        if (id_syn_ele == ID_END)
+        {
+
+            byte_align(&pVars->inputStream);
+
+            pExt->inputBufferUsedLength =
+                pVars->inputStream.usedBits >> INBUF_ARRAY_INDEX_SHIFT;
+
+            pExt->remainderBits = pVars->inputStream.usedBits & INBUF_BIT_MODULO_MASK;
+
+            pVars->bno++;
+
+            return(status);
+        }
+        else
+        {
+            /*
+             * Rewind bitstream pointer so that the syntactic element can be
+             * read when decoding raw bitstream
+             */
+            pVars->inputStream.usedBits -= LEN_SE_ID;
+        }
+
+    }
+
+    if (pVars->prog_config.file_is_adts == TRUE)
+    {
+        /*
+         *  If file is adts format, let the decoder handle only on data raw
+         *  block at the time, once the last (or only) data block has been
+         *  processed, then synch on the next header
+         */
+        if (pVars->prog_config.headerless_frames)
+        {
+            pVars->prog_config.headerless_frames--;  /* raw data block counter  */
+        }
+        else
+        {
+            status =  get_adts_header(pVars,
+                                      &(pVars->syncword),
+                                      &(pVars->invoke),
+                                      3);     /*   CorrectlyReadFramesCount  */
+
+            if (status != SUCCESS)
+            {
+                status = MP4AUDEC_LOST_FRAME_SYNC;    /*  we lost track of header */
+            }
+        }
+    }
+    else
+    {
+        byte_align(&pVars->inputStream);
+    }
+
+#ifdef AAC_PLUS
+    sbrBitStream->NrElements = 0;
+    sbrBitStream->NrElementsCore = 0;
+
+#endif
+
+    /*
+     * The variable leaveGetLoop is used to signal that the following
+     * loop can be left, which retrieves audio syntatic elements until
+     * an ID_END is found, or an error occurs.
+     */
+    leaveGetLoop = FALSE;
+    empty_frame  = TRUE;
+
+    while ((leaveGetLoop == FALSE) && (status == SUCCESS))
+    {
+        /* get audio syntactic element */
+        id_syn_ele = (Int)get9_n_lessbits(LEN_SE_ID, &pVars->inputStream);
+
+        /*
+         *  As fractional frames are a possible input, check that parsing does not
+         *  go beyond the available bits before parsing the syntax.
+         */
+        if (pVars->inputStream.usedBits > pVars->inputStream.availableBits)
+        {
+            status = MP4AUDEC_INCOMPLETE_FRAME; /* possible EOF or fractional frame */
+            id_syn_ele = ID_END;           /* quit while-loop */
+        }
+
+        switch (id_syn_ele)
+        {
+            case ID_END:        /* terminator field */
+                leaveGetLoop = TRUE;
+                break;
+
+            case ID_SCE:        /* single channel */
+            case ID_CPE:        /* channel pair */
+                empty_frame = FALSE;
+                status =
+                    huffdecode(
+                        id_syn_ele,
+                        &(pVars->inputStream),
+                        pVars,
+                        pChVars);
+
+#ifdef AAC_PLUS
+                if (id_syn_ele == ID_SCE)
+                {
+                    sbrBitStream->sbrElement[sbrBitStream->NrElements].ElementID = SBR_ID_SCE;
+                }
+                else if (id_syn_ele == ID_CPE)
+                {
+                    sbrBitStream->sbrElement[sbrBitStream->NrElements].ElementID = SBR_ID_CPE;
+                }
+                sbrBitStream->NrElementsCore++;
+
+
+#endif
+
+                break;
+
+            case ID_PCE:        /* program config element */
+                /*
+                 * PCE are not accepted in the middle of a
+                 * raw_data_block. If found, a possible error may happen
+                 * If a PCE is encountered during the first 2 frames,
+                 * it will be read and accepted
+                 * if its tag matches the first, with no error checking
+                 * (inside of get_prog_config)
+                 */
+
+                if (pVars->bno <= 1)
+                {
+                    status = get_prog_config(pVars,
+                                             &(pVars->scratch.scratch_prog_config));
+                }
+                else
+                {
+                    status = MP4AUDEC_INVALID_FRAME;
+                }
+                break;
+
+            case ID_FIL:        /* fill element */
+#ifdef AAC_PLUS
+                get_sbr_bitstream(sbrBitStream, &pVars->inputStream);
+
+#else
+                getfill(&pVars->inputStream);
+#endif
+
+                break;
+
+            case ID_DSE:       /* Data Streaming element */
+                get_dse(pVars->share.data_stream_bytes,
+                        &pVars->inputStream);
+                break;
+
+            default: /* Unsupported element, including ID_LFE */
+                status = -1;  /* ERROR CODE needs to be updated */
+                break;
+
+        } /* end switch() */
+
+    } /* end while() */
+
+    byte_align(&pVars->inputStream);
+
+    /*
+     *   After parsing the first frame ( bno=0 (adif), bno=1 (raw))
+     *   verify if implicit signalling is forcing to upsample AAC with
+     *   no AAC+/eAAC+ content. If so, disable upsampling
+     */
+
+#ifdef AAC_PLUS
+    if (pVars->bno <= 1)
+    {
+        if ((pVars->mc_info.ExtendedAudioObjectType == MP4AUDIO_AAC_LC) &&
+                (!sbrBitStream->NrElements))
+        {
+            PVMP4AudioDecoderDisableAacPlus(pExt, pMem);
+        }
+    }
+#endif
+
+    /*
+     *   There might be an empty raw data block with only a
+     *   ID_END element or non audio ID_DSE, ID_FIL
+     *   This is an "illegal" condition but this trap
+     *   avoids any further processing
+     */
+
+    if (empty_frame == TRUE)
+    {
+        pExt->inputBufferUsedLength =
+            pVars->inputStream.usedBits >> INBUF_ARRAY_INDEX_SHIFT;
+
+        pExt->remainderBits = pVars->inputStream.usedBits & INBUF_BIT_MODULO_MASK;
+
+        pVars->bno++;
+
+        return(status);
+
+    }
+
+#ifdef AAC_PLUS
+
+    if (sbrBitStream->NrElements)
+    {
+        /* for every core SCE or CPE there must be an SBR element, otherwise sths. wrong */
+        if (sbrBitStream->NrElements != sbrBitStream->NrElementsCore)
+        {
+            status = MP4AUDEC_INVALID_FRAME;
+        }
+
+        if (pExt->aacPlusEnabled == false)
+        {
+            sbrBitStream->NrElements = 0;   /* disable aac processing  */
+        }
+    }
+    else
+    {
+        /*
+         *  This is AAC, but if aac+/eaac+ was declared in the stream, and there is not sbr content
+         *  something is wrong
+         */
+        if (pMC_Info->sbrPresentFlag || pMC_Info->psPresentFlag)
+        {
+            status = MP4AUDEC_INVALID_FRAME;
+        }
+    }
+#endif
+
+
+
+
+    /*
+     * Signal processing section.
+     */
+    frameLength = pVars->frameLength;
+
+    if (status == SUCCESS)
+    {
+        /*
+         *   PNS and INTENSITY STEREO and MS
+         */
+
+        pFrameInfo = pVars->winmap[pChVars[LEFT]->wnd];
+
+        pns_left(
+            pFrameInfo,
+            pChLeftShare->group,
+            pChLeftShare->cb_map,
+            pChLeftShare->factors,
+            pChLeftShare->lt_status.sfb_prediction_used,
+            pChLeftShare->lt_status.ltp_data_present,
+            pChVars[LEFT]->fxpCoef,
+            pChLeftShare->qFormat,
+            &(pVars->pns_cur_noise_state));
+
+        /*
+         * apply_ms_synt can only be ran for common windows.
+         * (where both the left and right channel share the
+         * same grouping, window length, etc.
+         *
+         * pVars->hasmask will be > 0 only if
+         * common windows are enabled for this frame.
+         */
+
+        if (pVars->hasmask > 0)
+        {
+            apply_ms_synt(
+                pFrameInfo,
+                pChLeftShare->group,
+                pVars->mask,
+                pChLeftShare->cb_map,
+                pChVars[LEFT]->fxpCoef,
+                pChVars[RIGHT]->fxpCoef,
+                pChLeftShare->qFormat,
+                pChRightShare->qFormat);
+        }
+
+        for (ch = 0; (ch < pMC_Info->nch); ch++)
+        {
+            pFrameInfo = pVars->winmap[pChVars[ch]->wnd];
+
+            /*
+             * Note: This MP4 library assumes that if there are two channels,
+             * then the second channel is right AND it was a coupled channel,
+             * therefore there is no need to check the "is_cpe" flag.
+             */
+
+            if (ch > 0)
+            {
+                pns_intensity_right(
+                    pVars->hasmask,
+                    pFrameInfo,
+                    pChRightShare->group,
+                    pVars->mask,
+                    pChRightShare->cb_map,
+                    pChLeftShare->factors,
+                    pChRightShare->factors,
+                    pChRightShare->lt_status.sfb_prediction_used,
+                    pChRightShare->lt_status.ltp_data_present,
+                    pChVars[LEFT]->fxpCoef,
+                    pChVars[RIGHT]->fxpCoef,
+                    pChLeftShare->qFormat,
+                    pChRightShare->qFormat,
+                    &(pVars->pns_cur_noise_state));
+            }
+
+            if (pChVars[ch]->pShareWfxpCoef->lt_status.ltp_data_present != FALSE)
+            {
+                /*
+                 * LTP - Long Term Prediction
+                 */
+
+                qPredictedSamples = long_term_prediction(
+                                        pChVars[ch]->wnd,
+                                        pChVars[ch]->pShareWfxpCoef->lt_status.
+                                        weight_index,
+                                        pChVars[ch]->pShareWfxpCoef->lt_status.
+                                        delay,
+                                        pChVars[ch]->ltp_buffer,
+                                        pVars->ltp_buffer_state,
+                                        pChVars[ch]->time_quant,
+                                        pVars->share.predictedSamples,      /* Scratch */
+                                        frameLength);
+
+                trans4m_time_2_freq_fxp(
+                    pVars->share.predictedSamples,
+                    pChVars[ch]->wnd,
+                    pChVars[ch]->wnd_shape_prev_bk,
+                    pChVars[ch]->wnd_shape_this_bk,
+                    &qPredictedSamples,
+                    pVars->scratch.fft);   /* scratch memory for FFT */
+
+
+                /*
+                 * To solve a potential problem where a pointer tied to
+                 * the qFormat was being incremented, a pointer to
+                 * pChVars[ch]->qFormat is passed in here rather than
+                 * the address of qPredictedSamples.
+                 *
+                 * Neither values are actually needed in the case of
+                 * inverse filtering, but the pointer was being
+                 * passed (and incremented) regardless.
+                 *
+                 * So, the solution is to pass a space of memory
+                 * that a pointer can happily point to.
+                 */
+
+                /* This is the inverse filter */
+                apply_tns(
+                    pVars->share.predictedSamples,  /* scratch re-used for each ch */
+                    pChVars[ch]->pShareWfxpCoef->qFormat,     /* Not used by the inv_filter */
+                    pFrameInfo,
+                    &(pChVars[ch]->pShareWfxpCoef->tns),
+                    TRUE,                       /* TRUE is FIR */
+                    pVars->scratch.tns_inv_filter);
+
+                /*
+                 * For the next function long_term_synthesis,
+                 * the third param win_sfb_top[], and
+                 * the tenth param coef_per_win,
+                 * are used differently that in the rest of the project. This
+                 * is because originally the ISO code was going to have
+                 * these parameters change as the "short window" changed.
+                 * These are all now the same value for each of the eight
+                 * windows.  This is why there is a [0] at the
+                 * end of each of theses parameters.
+                 * Note in particular that win_sfb_top was originally an
+                 * array of pointers to arrays, but inside long_term_synthesis
+                 * it is now a simple array.
+                 * When the rest of the project functions are changed, the
+                 * structure FrameInfo changes, and the [0]'s are removed,
+                 * this comment could go away.
+                 */
+                long_term_synthesis(
+                    pChVars[ch]->wnd,
+                    pChVars[ch]->pShareWfxpCoef->max_sfb,
+                    pFrameInfo->win_sfb_top[0], /* Look above */
+                    pChVars[ch]->pShareWfxpCoef->lt_status.win_prediction_used,
+                    pChVars[ch]->pShareWfxpCoef->lt_status.sfb_prediction_used,
+                    pChVars[ch]->fxpCoef,   /* input and output */
+                    pChVars[ch]->pShareWfxpCoef->qFormat,   /* input and output */
+                    pVars->share.predictedSamples,
+                    qPredictedSamples,       /* q format for previous aray */
+                    pFrameInfo->coef_per_win[0], /* Look above */
+                    NUM_SHORT_WINDOWS,
+                    NUM_RECONSTRUCTED_SFB);
+
+            } /* end if (pChVars[ch]->lt_status.ltp_data_present != FALSE) */
+
+        } /* for(ch) */
+
+        for (ch = 0; (ch < pMC_Info->nch); ch++)
+        {
+
+            pFrameInfo = pVars->winmap[pChVars[ch]->wnd];
+
+            /*
+             * TNS - Temporal Noise Shaping
+             */
+
+            /* This is the forward filter
+             *
+             * A special note:  Scratch memory is not used by
+             * the forward filter, but is passed in to maintain
+             * common interface for inverse and forward filter
+             */
+            apply_tns(
+                pChVars[ch]->fxpCoef,
+                pChVars[ch]->pShareWfxpCoef->qFormat,
+                pFrameInfo,
+                &(pChVars[ch]->pShareWfxpCoef->tns),
+                FALSE,                   /* FALSE is IIR */
+                pVars->scratch.tns_inv_filter);
+
+            /*
+             * Normalize the q format across all scale factor bands
+             * to one value.
+             */
+            qFormatNorm =
+                q_normalize(
+                    pChVars[ch]->pShareWfxpCoef->qFormat,
+                    pFrameInfo,
+                    pChVars[ch]->abs_max_per_window,
+                    pChVars[ch]->fxpCoef);
+
+            /*
+             *  filterbank - converts frequency coeficients to time domain.
+             */
+
+#ifdef AAC_PLUS
+            if (sbrBitStream->NrElements == 0 && pMC_Info->upsamplingFactor == 1)
+            {
+                trans4m_freq_2_time_fxp_2(
+                    pChVars[ch]->fxpCoef,
+                    pChVars[ch]->time_quant,
+                    pChVars[ch]->wnd,   /* window sequence */
+                    pChVars[ch]->wnd_shape_prev_bk,
+                    pChVars[ch]->wnd_shape_this_bk,
+                    qFormatNorm,
+                    pChVars[ch]->abs_max_per_window,
+                    pVars->scratch.fft,
+                    &pExt->pOutputBuffer[ch]);
+                /*
+                 *  Update LTP buffers if needed
+                 */
+
+                if (pVars->mc_info.audioObjectType == MP4AUDIO_LTP)
+                {
+                    Int16 * pt = &pExt->pOutputBuffer[ch];
+                    Int16 * ptr = &(pChVars[ch]->ltp_buffer[pVars->ltp_buffer_state]);
+                    Int16  x, y;
+                    for (Int32 i = HALF_LONG_WINDOW; i != 0; i--)
+                    {
+                        x = *pt;
+                        pt += 2;
+                        y = *pt;
+                        pt += 2;
+                        *(ptr++) =  x;
+                        *(ptr++) =  y;
+                    }
+                }
+            }
+            else
+            {
+                trans4m_freq_2_time_fxp_1(
+                    pChVars[ch]->fxpCoef,
+                    pChVars[ch]->time_quant,
+                    &(pChVars[ch]->ltp_buffer[pVars->ltp_buffer_state + 288]),
+                    pChVars[ch]->wnd,   /* window sequence */
+                    pChVars[ch]->wnd_shape_prev_bk,
+                    pChVars[ch]->wnd_shape_this_bk,
+                    qFormatNorm,
+                    pChVars[ch]->abs_max_per_window,
+                    pVars->scratch.fft);
+
+            }
+#else
+
+            trans4m_freq_2_time_fxp_2(
+                pChVars[ch]->fxpCoef,
+                pChVars[ch]->time_quant,
+                pChVars[ch]->wnd,   /* window sequence */
+                pChVars[ch]->wnd_shape_prev_bk,
+                pChVars[ch]->wnd_shape_this_bk,
+                qFormatNorm,
+                pChVars[ch]->abs_max_per_window,
+                pVars->scratch.fft,
+                &pExt->pOutputBuffer[ch]);
+            /*
+             *  Update LTP buffers only if needed
+             */
+
+            if (pVars->mc_info.audioObjectType == MP4AUDIO_LTP)
+            {
+                Int16 * pt = &pExt->pOutputBuffer[ch];
+                Int16 * ptr = &(pChVars[ch]->ltp_buffer[pVars->ltp_buffer_state]);
+                Int16  x, y;
+                for (Int32 i = HALF_LONG_WINDOW; i != 0; i--)
+                {
+                    x = *pt;
+                    pt += 2;
+                    y = *pt;
+                    pt += 2;
+                    *(ptr++) =  x;
+                    *(ptr++) =  y;
+                }
+
+            }
+
+
+#endif
+
+
+            /* Update the window shape */
+            pChVars[ch]->wnd_shape_prev_bk = pChVars[ch]->wnd_shape_this_bk;
+
+        } /* end for() */
+
+
+        /*
+         * Copy to the final output buffer, taking into account the desired
+         * channels from the calling environment, the actual channels, and
+         * whether the data should be interleaved or not.
+         *
+         * If the stream had only one channel, write_output will not use
+         * the right channel data.
+         *
+         */
+
+
+        /* CONSIDER USE OF DMA OPTIMIZATIONS WITHIN THE write_output FUNCTION.
+         *
+         * It is presumed that the ltp_buffer will reside in internal (fast)
+         * memory, while the pExt->pOutputBuffer will reside in external
+         * (slow) memory.
+         *
+         */
+
+
+#ifdef AAC_PLUS
+
+        if (sbrBitStream->NrElements || pMC_Info->upsamplingFactor == 2)
+        {
+
+            if (pVars->bno <= 1)   /* allows console to operate with ADIF and audio config */
+            {
+                if (sbrDec->outSampleRate == 0) /* do it only once (disregarding of signaling type) */
+                {
+                    sbr_open(samp_rate_info[pVars->mc_info.sampling_rate_idx].samp_rate,
+                             sbrDec,
+                             sbrDecoderData,
+                             pVars->mc_info.bDownSampledSbr);
+                }
+
+            }
+            pMC_Info->upsamplingFactor =
+                sbrDecoderData->SbrChannel[0].frameData.sbr_header.sampleRateMode;
+
+
+            /* reuse right aac spectrum channel  */
+            {
+                Int16 *pt_left  =  &(pChVars[LEFT ]->ltp_buffer[pVars->ltp_buffer_state]);
+                Int16 *pt_right =  &(pChVars[RIGHT]->ltp_buffer[pVars->ltp_buffer_state]);
+
+                if (sbr_applied(sbrDecoderData,
+                                sbrBitStream,
+                                pt_left,
+                                pt_right,
+                                pExt->pOutputBuffer,
+                                sbrDec,
+                                pVars,
+                                pMC_Info->nch) != SBRDEC_OK)
+                {
+                    status = MP4AUDEC_INVALID_FRAME;
+                }
+            }
+
+
+        }  /*  if( pExt->aacPlusEnabled == FALSE) */
+#endif
+
+        /*
+         * Copied mono data in both channels or just leave it as mono,
+         * according with desiredChannels (default is 2)
+         */
+
+        if (pExt->desiredChannels == 2)
+        {
+
+#if defined(AAC_PLUS)
+#if defined(PARAMETRICSTEREO)&&defined(HQ_SBR)
+            if (pMC_Info->nch != 2 && pMC_Info->psPresentFlag != 1)
+#else
+            if (pMC_Info->nch != 2)
+#endif
+#else
+            if (pMC_Info->nch != 2)
+#endif
+            {
+                /* mono */
+
+
+                Int16 * pt  = &pExt->pOutputBuffer[0];
+                Int16 * pt2 = &pExt->pOutputBuffer[1];
+                Int i;
+                if (pMC_Info->upsamplingFactor == 2)
+                {
+                    for (i = 0; i < 1024; i++)
+                    {
+                        *pt2 = *pt;
+                        pt += 2;
+                        pt2 += 2;
+                    }
+                    pt  = &pExt->pOutputBuffer_plus[0];
+                    pt2 = &pExt->pOutputBuffer_plus[1];
+
+                    for (i = 0; i < 1024; i++)
+                    {
+                        *pt2 = *pt;
+                        pt += 2;
+                        pt2 += 2;
+                    }
+                }
+                else
+                {
+                    for (i = 0; i < 1024; i++)
+                    {
+                        *pt2 = *pt;
+                        pt += 2;
+                        pt2 += 2;
+                    }
+                }
+
+            }
+
+#if defined(AAC_PLUS)
+#if defined(PARAMETRICSTEREO)&&defined(HQ_SBR)
+
+            else if (pMC_Info->psPresentFlag == 1)
+            {
+                Int32 frameSize = 0;
+                if (pExt->aacPlusEnabled == false)
+                {
+                    /*
+                     *  Decoding eaac+ when only aac is enabled, copy L into R
+                     */
+                    frameSize = 1024;
+                }
+                else if (sbrDecoderData->SbrChannel[0].syncState != SBR_ACTIVE)
+                {
+                    /*
+                     *  Decoding eaac+ when no PS data was found, copy upsampled L into R
+                     */
+                    frameSize = 2048;
+                }
+
+                Int16 * pt  = &pExt->pOutputBuffer[0];
+                Int16 * pt2 = &pExt->pOutputBuffer[1];
+                Int i;
+                for (i = 0; i < frameSize; i++)
+                {
+                    *pt2 = *pt;
+                    pt += 2;
+                    pt2 += 2;
+                }
+            }
+#endif
+#endif
+
+        }
+        else
+        {
+
+#if defined(AAC_PLUS)
+#if defined(PARAMETRICSTEREO)&&defined(HQ_SBR)
+            if (pMC_Info->nch != 2 && pMC_Info->psPresentFlag != 1)
+#else
+            if (pMC_Info->nch != 2)
+#endif
+#else
+            if (pMC_Info->nch != 2)
+#endif
+            {
+                /* mono */
+                Int16 * pt  = &pExt->pOutputBuffer[0];
+                Int16 * pt2 = &pExt->pOutputBuffer[0];
+                Int i;
+
+                if (pMC_Info->upsamplingFactor == 2)
+                {
+                    for (i = 0; i < 1024; i++)
+                    {
+                        *pt2++ = *pt;
+                        pt += 2;
+                    }
+
+                    pt  = &pExt->pOutputBuffer_plus[0];
+                    pt2 = &pExt->pOutputBuffer_plus[0];
+
+                    for (i = 0; i < 1024; i++)
+                    {
+                        *pt2++ = *pt;
+                        pt += 2;
+                    }
+                }
+                else
+                {
+                    for (i = 0; i < 1024; i++)
+                    {
+                        *pt2++ = *pt;
+                        pt += 2;
+                    }
+                }
+
+            }
+
+        }
+
+
+
+
+        /* pVars->ltp_buffer_state cycles between 0 and 1024.  The value
+         * indicates the location of the data corresponding to t == -2.
+         *
+         * | t == -2 | t == -1 |  pVars->ltp_buffer_state == 0
+         *
+         * | t == -1 | t == -2 |  pVars->ltp_buffer_state == 1024
+         *
+         */
+
+#ifdef AAC_PLUS
+        if (sbrBitStream->NrElements == 0 && pMC_Info->upsamplingFactor == 1)
+        {
+            pVars->ltp_buffer_state ^= frameLength;
+        }
+        else
+        {
+            pVars->ltp_buffer_state ^= (frameLength + 288);
+        }
+#else
+        pVars->ltp_buffer_state ^= frameLength;
+#endif
+
+
+        if (pVars->bno <= 1)
+        {
+            /*
+             * to set these values only during the second call
+             * when they change.
+             */
+            pExt->samplingRate =
+                samp_rate_info[pVars->mc_info.sampling_rate_idx].samp_rate;
+
+            pVars->mc_info.implicit_channeling = 0; /* disable flag, as this is allowed
+                                                      * only the first time
+                                                      */
+
+
+#ifdef AAC_PLUS
+
+            if (pMC_Info->upsamplingFactor == 2)
+            {
+                pExt->samplingRate *= pMC_Info->upsamplingFactor;
+                pExt->aacPlusUpsamplingFactor = pMC_Info->upsamplingFactor;
+            }
+
+#endif
+
+            pExt->extendedAudioObjectType = pMC_Info->ExtendedAudioObjectType;
+            pExt->audioObjectType = pMC_Info->audioObjectType;
+
+            pExt->encodedChannels = pMC_Info->nch;
+            pExt->frameLength = pVars->frameLength;
+        }
+
+        pVars->bno++;
+
+
+        /*
+         * Using unit analysis, the bitrate is a function of the sampling rate, bits,
+         * points in a frame
+         *
+         *     bits        samples                frame
+         *     ----  =    --------- *  bits  *   -------
+         *     sec           sec                  sample
+         *
+         * To save a divide, a shift is used. Presently only the value of
+         * 1024 is used by this library, so make it the most accurate for that
+         * value. This may need to be updated later.
+         */
+
+        pExt->bitRate = (pExt->samplingRate *
+                         (pVars->inputStream.usedBits - initialUsedBits)) >> 10;  /*  LONG_WINDOW  1024 */
+
+        pExt->bitRate >>= (pMC_Info->upsamplingFactor - 1);
+
+
+    } /* end if (status == SUCCESS) */
+
+
+    if (status != MP4AUDEC_SUCCESS)
+    {
+        /*
+         *  A non-SUCCESS decoding could be due to an error on the bitstream or
+         *  an incomplete frame. As access to the bitstream beyond frame boundaries
+         *  are not allowed, in those cases the bitstream reading routine return a 0
+         *  Zero values guarantees that the data structures are filled in with values
+         *  that eventually will signal an error (like invalid parameters) or that allow
+         *  completion of the parsing routine. Either way, the partial frame condition
+         *  is verified at this time.
+         */
+        if (pVars->prog_config.file_is_adts == TRUE)
+        {
+            status = MP4AUDEC_LOST_FRAME_SYNC;
+            pVars->prog_config.headerless_frames = 0; /* synchronization forced */
+        }
+        else
+        {
+            /*
+             *  Check if the decoding error was due to buffer overrun, if it was,
+             *  update status
+             */
+            if (pVars->inputStream.usedBits > pVars->inputStream.availableBits)
+            {
+                /* all bits were used but were not enough to complete decoding */
+                pVars->inputStream.usedBits = pVars->inputStream.availableBits;
+
+                status = MP4AUDEC_INCOMPLETE_FRAME; /* possible EOF or fractional frame */
+            }
+        }
+    }
+
+    /*
+     * Translate from units of bits back into units of words.
+     */
+
+    pExt->inputBufferUsedLength =
+        pVars->inputStream.usedBits >> INBUF_ARRAY_INDEX_SHIFT;
+
+    pExt->remainderBits = (Int)(pVars->inputStream.usedBits & INBUF_BIT_MODULO_MASK);
+
+
+
+    return (status);
+
+} /* PVMP4AudioDecoderDecodeFrame */
+
diff --git a/media/libstagefright/codecs/aacdec/pvmp4audiodecodergetmemrequirements.cpp b/media/libstagefright/codecs/aacdec/pvmp4audiodecodergetmemrequirements.cpp
new file mode 100644
index 0000000..7cdecd0
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/pvmp4audiodecodergetmemrequirements.cpp
@@ -0,0 +1,157 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Pathname: PVMP4AudioDecoderGetMemRequirements.c
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+ Description:  Copied from aac_decode_frame
+
+ Description: Cleaned up.
+
+ Description: (1) use UInt32 to replace size_t type
+              (2) memory of tDec_Int_File is splitted into 3 pieces,
+                  sizeof(tDec_Int_File) is only part of the total memory
+                  required. The additional memory required to decode per
+                  channel information is allocated by a DPI call outside this
+                  API
+
+ Who:                                   Date: MM/DD/YYYY
+ Description:
+
+------------------------------------------------------------------------------
+ INPUT AND OUTPUT DEFINITIONS
+
+ Inputs: None
+
+ Local Stores/Buffers/Pointers Needed: None
+
+ Global Stores/Buffers/Pointers Needed: None
+
+ Outputs:
+    size = amount of memory needed to be allocated by the calling
+        environment.
+
+ Pointers and Buffers Modified: None
+
+ Local Stores Modified: None
+
+ Global Stores Modified: None
+
+------------------------------------------------------------------------------
+ FUNCTION DESCRIPTION
+
+ This function returns the amount of internal memory needed by the library.
+ Presently this is a constant value, but could later be more sophisticated
+ by taking into account mono or stereo, and whether LTP is to be used.
+
+------------------------------------------------------------------------------
+ REQUIREMENTS
+
+
+------------------------------------------------------------------------------
+ REFERENCES
+
+
+------------------------------------------------------------------------------
+ PSEUDO-CODE
+
+    size = sizeof(tDec_Int_File);
+
+ RETURN (size)
+
+------------------------------------------------------------------------------
+ RESOURCES USED
+   When the code is written for a specific target processor the
+     the resources used should be documented below.
+
+ STACK USAGE: [stack count for this module] + [variable to represent
+          stack usage for each subroutine called]
+
+     where: [stack usage variable] = stack usage for [subroutine
+         name] (see [filename].ext)
+
+ DATA MEMORY USED: x words
+
+ PROGRAM MEMORY USED: x words
+
+ CLOCK CYCLES: [cycle count equation for this module] + [variable
+           used to represent cycle count for each subroutine
+           called]
+
+     where: [cycle count variable] = cycle count for [subroutine
+        name] (see [filename].ext)
+
+------------------------------------------------------------------------------
+*/
+
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+
+#include "pv_audio_type_defs.h"
+#include "s_tdec_int_file.h"
+#include "pvmp4audiodecoder_api.h" /* Where this function is declared */
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here. Include conditional
+; compile variables also.
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; LOCAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; LOCAL VARIABLE DEFINITIONS
+; Variable declaration - defined here and used outside this module
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL FUNCTION REFERENCES
+; Declare functions defined elsewhere and referenced in this module
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL VARIABLES REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; FUNCTION CODE
+----------------------------------------------------------------------------*/
+OSCL_EXPORT_REF UInt32 PVMP4AudioDecoderGetMemRequirements(void)
+{
+    UInt32 size;
+
+    size = (UInt32) sizeof(tDec_Int_File);
+
+    return (size);
+
+} /* PVMP4AudioDecoderGetMemRequirements() */
+
diff --git a/media/libstagefright/codecs/aacdec/pvmp4audiodecoderinitlibrary.cpp b/media/libstagefright/codecs/aacdec/pvmp4audiodecoderinitlibrary.cpp
new file mode 100644
index 0000000..146ba0f
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/pvmp4audiodecoderinitlibrary.cpp
@@ -0,0 +1,418 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Pathname: PVMP4AudioDecoderInitLibrary.c
+
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+ Description:  Copied from aac_decode_frame
+
+ Description:  Clean up.
+
+ Description:  Update per review comments
+
+ Description:  Add frame_length, fix mistake in pseudo-code.
+               Change frame_length to frameLength, to matcht the API,
+               look more professional, etc.
+
+ Description:
+ (1) Added #include of "e_ProgConfigConst.h"
+     Previously, this function was relying on another include file
+     to include "e_ProgConfigConst.h"
+
+ (2) Updated the copyright header.
+
+ Description:
+ (1) Modified to initialize pointers for shared memory techniques.
+
+ Description: Since memory will be allocated continuously, it is initialized
+              in one spot
+
+ Description: Added field aacPlusUpsamplingFactor (default == 1) to have a
+              common interface for all AAC variations
+
+ Description: Added PVMP4AudioDecoderDisableAacPlus to disable sbr decoding
+
+ Who:                                   Date: MM/DD/YYYY
+ Description:
+
+------------------------------------------------------------------------------
+ INPUT AND OUTPUT DEFINITIONS
+
+ Inputs:
+    pExt = pointer to the external application-program interface (API)
+           structure that a client program uses to communicate information
+           with this library. Among the items in this structure is a pointer
+           to the input and output buffers, data for handling the input buffer
+           and output information. Look in PVMP4AudioDecoder_API.h for all the
+           fields to this structure. Data type pointer to a
+           tPVMP4AudioDecoderExternal structure.
+
+   pMem =  pointer to allocated memory, of the size returned by the function
+           PVMP4AudioDecoderGetMemRequirements. This is a void pointer for
+           two reasons:
+           1) So the external program does not need all of the header files
+              for all of the fields in the structure tDec_Int_File
+           2) To hide data and the implementation of the program. Even knowing
+              how data is stored can help in reverse engineering software.
+
+ Local Stores/Buffers/Pointers Needed: None
+
+ Global Stores/Buffers/Pointers Needed: None
+
+ Outputs:
+    status = 0 (SUCCESS). Presently there is no error checking in this
+    function.
+
+ Pointers and Buffers Modified: None
+
+ Local Stores Modified: None
+
+ Global Stores Modified: None
+
+------------------------------------------------------------------------------
+ FUNCTION DESCRIPTION
+
+ Initializes the internal memory for the MP4 Audio Decoder library.
+ Also sets relevant values for the external interface structure, clears
+ the bit rate, channel count, sampling rate, and number of used buffer
+ elements.
+
+------------------------------------------------------------------------------
+ REQUIREMENTS
+
+
+------------------------------------------------------------------------------
+ REFERENCES
+
+ (1) MPEG-2 NBC Audio Decoder
+   "This software module was originally developed by AT&T, Dolby
+   Laboratories, Fraunhofer Gesellschaft IIS in the course of development
+   of the MPEG-2 NBC/MPEG-4 Audio standard ISO/IEC 13818-7, 14496-1,2 and
+   3. This software module is an implementation of a part of one or more
+   MPEG-2 NBC/MPEG-4 Audio tools as specified by the MPEG-2 NBC/MPEG-4
+   Audio standard. ISO/IEC gives users of the MPEG-2 NBC/MPEG-4 Audio
+   standards free license to this software module or modifications thereof
+   for use in hardware or software products claiming conformance to the
+   MPEG-2 NBC/MPEG-4 Audio  standards. Those intending to use this software
+   module in hardware or software products are advised that this use may
+   infringe existing patents. The original developer of this software
+   module and his/her company, the subsequent editors and their companies,
+   and ISO/IEC have no liability for use of this software module or
+   modifications thereof in an implementation. Copyright is not released
+   for non MPEG-2 NBC/MPEG-4 Audio conforming products.The original
+   developer retains full right to use the code for his/her own purpose,
+   assign or donate the code to a third party and to inhibit third party
+   from using the code for non MPEG-2 NBC/MPEG-4 Audio conforming products.
+   This copyright notice must be included in all copies or derivative
+   works."
+   Copyright(c)1996.
+------------------------------------------------------------------------------
+ PSEUDO-CODE
+
+    pVars = pMem;
+
+    CALL pv_memset(
+           to = pVars,
+           c  = 0,
+           n  = sizeof(tDec_Int_File))
+    MODIFYING(*pVars = 0)
+    RETURNING(nothing)
+
+    pVars->current_program = -1
+    pVars->mc_info.sampling_rate_idx = Fs_44
+    pVars->frameLength = LONG_WINDOW
+
+
+    pVars->winmap[ONLY_LONG_SEQUENCE]   = &pVars->longFrameInfo;
+    pVars->winmap[LONG_START_SEQUENCE]  = &pVars->longFrameInfo;
+    pVars->winmap[EIGHT_SHORT_SEQUENCE] = &pVars->shortFrameInfo;
+    pVars->winmap[LONG_STOP_SEQUENCE]   = &pVars->longFrameInfo;
+
+    CALL infoinit(
+        samp_rate_indx = pVars->mc_info.sampling_rate_idx,
+        ppWin_seq_info = pVars->winmap,
+        pSfbwidth128   = pVars->SFBWidth128)
+    MODIFYING(ppWinSeq_info)
+    MODIFYING(pSfbwidth128)
+    RETURNING(nothing)
+
+    pExt->bitRate = 0;
+    pExt->encodedChannels = 0;
+    pExt->samplingRate = 0;
+    pExt->inputBufferUsedLength = 0;
+
+    MODIFY(pExt)
+    MODIFY(pMem)
+    RETURN(SUCCESS)
+
+------------------------------------------------------------------------------
+ RESOURCES USED
+   When the code is written for a specific target processor the
+     the resources used should be documented below.
+
+ STACK USAGE: [stack count for this module] + [variable to represent
+          stack usage for each subroutine called]
+
+     where: [stack usage variable] = stack usage for [subroutine
+         name] (see [filename].ext)
+
+ DATA MEMORY USED: x words
+
+ PROGRAM MEMORY USED: x words
+
+ CLOCK CYCLES: [cycle count equation for this module] + [variable
+           used to represent cycle count for each subroutine
+           called]
+
+     where: [cycle count variable] = cycle count for [subroutine
+        name] (see [filename].ext)
+
+------------------------------------------------------------------------------
+*/
+
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+
+#include "pv_audio_type_defs.h"
+#include "s_tdec_int_file.h"
+#include "e_progconfigconst.h"
+
+#include "huffman.h"               /* For the definition of infoinit        */
+#include "aac_mem_funcs.h"         /* For pv_memset                         */
+#include "pvmp4audiodecoder_api.h" /* Where this function is declared       */
+#include "s_tdec_int_chan.h"
+#include "sfb.h"                   /* samp_rate_info[] is declared here     */
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here. Include conditional
+; compile variables also.
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; LOCAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; LOCAL VARIABLE DEFINITIONS
+; Variable declaration - defined here and used outside this module
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL FUNCTION REFERENCES
+; Declare functions defined elsewhere and referenced in this module
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL VARIABLES REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; FUNCTION CODE
+----------------------------------------------------------------------------*/
+OSCL_EXPORT_REF Int PVMP4AudioDecoderInitLibrary(
+    tPVMP4AudioDecoderExternal  *pExt,
+    void                        *pMem)
+{
+    tDec_Int_File *pVars;
+
+    pVars = (tDec_Int_File *)pMem;
+
+    /*
+     * Initialize all memory. The pointers to channel memory will be
+     * set to zero also.
+     */
+    pv_memset(
+        pVars,
+        0,
+        sizeof(tDec_Int_File));
+
+    /*
+     * Pick default values for the library.
+     */
+    pVars->perChan[0].fxpCoef = pVars->fxpCoef[0];
+    pVars->perChan[1].fxpCoef = pVars->fxpCoef[1];
+
+    /* Here, the "shared memory" pointer is set to point
+     * at the 1024th element of fxpCoef, because those spaces
+     * in memory are not used until the filterbank is called.
+     *
+     * Therefore, any variables that are only used before
+     * the filterbank can occupy this same space in memory.
+     */
+
+    pVars->perChan[0].pShareWfxpCoef = (per_chan_share_w_fxpCoef *)
+                                       & (pVars->perChan[0].fxpCoef[1024]);
+
+    pVars->perChan[1].pShareWfxpCoef = (per_chan_share_w_fxpCoef *)
+                                       & (pVars->perChan[1].fxpCoef[1024]);
+
+    /*
+     * This next line informs the function get_prog_config that no
+     * configuration has been found thus far, so it is a default
+     * configuration.
+     */
+
+    pVars->current_program = -1;
+    pVars->mc_info.sampling_rate_idx = Fs_44; /* Fs_44 = 4, 44.1kHz */
+
+    /*
+     * In the future, the frame length will change with MP4 file format.
+     * Presently this variable is used to simply the unit test for
+     * the function PVMP4AudioDecodeFrame() .. otherwise the test would
+     * have to pass around 1024 length arrays.
+     */
+    pVars->frameLength = LONG_WINDOW; /* 1024*/
+
+    /*
+     * The window types ONLY_LONG_SEQUENCE, LONG_START_SEQUENCE, and
+     * LONG_STOP_SEQUENCE share the same information. The only difference
+     * between the windows is accounted for in the "filterbank", in
+     * the function trans4m_freq_2_time_fxp()
+     */
+
+    pVars->winmap[ONLY_LONG_SEQUENCE]   /* 0 */ = &pVars->longFrameInfo;
+    pVars->winmap[LONG_START_SEQUENCE]  /* 1 */ = &pVars->longFrameInfo;
+    pVars->winmap[EIGHT_SHORT_SEQUENCE] /* 2 */ = &pVars->shortFrameInfo;
+    pVars->winmap[LONG_STOP_SEQUENCE]   /* 3 */ = &pVars->longFrameInfo;
+
+    infoinit(
+        pVars->mc_info.sampling_rate_idx,
+        (FrameInfo   **)pVars->winmap,
+        pVars->SFBWidth128);
+
+
+    /*
+     * Clear out external output values. These values are set later at the end
+     * of PVMP4AudioDecodeFrames()
+     */
+    pExt->bitRate = 0;
+    pExt->encodedChannels = 0;
+    pExt->samplingRate = 0;
+    pExt->aacPlusUpsamplingFactor = 1;  /*  Default for regular AAC */
+    pVars->aacPlusEnabled = pExt->aacPlusEnabled;
+
+
+#if defined(AAC_PLUS)
+    pVars->sbrDecoderData.setStreamType = 1;        /* Enable Lock for AAC stream type setting  */
+#endif
+
+    /*
+     * Initialize input buffer variable.
+     */
+
+    pExt->inputBufferUsedLength = 0;
+
+    return (MP4AUDEC_SUCCESS);
+
+}  /* PVMP4AudioDecoderInitLibrary */
+
+
+/*
+------------------------------------------------------------------------------
+ INPUT AND OUTPUT DEFINITIONS
+
+ Inputs:
+    pExt = pointer to the external application-program interface (API)
+           structure that a client program uses to communicate information
+           with this library. Among the items in this structure is a pointer
+           to the input and output buffers, data for handling the input buffer
+           and output information. Look in PVMP4AudioDecoder_API.h for all the
+           fields to this structure. Data type pointer to a
+           tPVMP4AudioDecoderExternal structure.
+
+   pMem =  pointer to allocated memory, of the size returned by the function
+           PVMP4AudioDecoderGetMemRequirements. This is a void pointer for
+           two reasons:
+           1) So the external program does not need all of the header files
+              for all of the fields in the structure tDec_Int_File
+           2) To hide data and the implementation of the program. Even knowing
+              how data is stored can help in reverse engineering software.
+
+ Local Stores/Buffers/Pointers Needed: None
+
+ Global Stores/Buffers/Pointers Needed: None
+
+ Outputs:
+    status = 0 (SUCCESS). Presently there is no error checking in this
+    function.
+
+ Pointers and Buffers Modified: None
+
+ Local Stores Modified: None
+
+ Global Stores Modified: None
+
+------------------------------------------------------------------------------
+ FUNCTION DESCRIPTION
+
+ Disable SBR decoding functionality and set parameters accordingly
+
+------------------------------------------------------------------------------
+ REQUIREMENTS
+
+
+----------------------------------------------------------------------------
+; FUNCTION CODE
+----------------------------------------------------------------------------*/
+
+
+OSCL_EXPORT_REF void PVMP4AudioDecoderDisableAacPlus(
+    tPVMP4AudioDecoderExternal  *pExt,
+    void                        *pMem)
+{
+    tDec_Int_File *pVars;
+
+    pVars = (tDec_Int_File *)pMem;
+
+    if ((pVars->aacPlusEnabled == true) && (pExt->aacPlusEnabled == true))
+    {
+        // disable only when makes sense
+        pVars->aacPlusEnabled = false;
+        pExt->aacPlusEnabled = false;
+
+#if defined(AAC_PLUS)
+        pVars->mc_info.upsamplingFactor = 1;
+        pVars->mc_info.psPresentFlag  = 0;
+        pVars->mc_info.sbrPresentFlag = 0;
+        pVars->prog_config.sampling_rate_idx += 3;
+        pVars->sbrDecoderData.SbrChannel[0].syncState = SBR_NOT_INITIALIZED;
+        pVars->sbrDecoderData.SbrChannel[1].syncState = SBR_NOT_INITIALIZED;
+
+
+        pExt->samplingRate = samp_rate_info[pVars->prog_config.sampling_rate_idx].samp_rate;
+        pExt->aacPlusUpsamplingFactor = 1;
+#endif
+    }
+}  /* PVMP4AudioDecoderDisableAacPlus */
+
+
+
diff --git a/media/libstagefright/codecs/aacdec/pvmp4audiodecoderresetbuffer.cpp b/media/libstagefright/codecs/aacdec/pvmp4audiodecoderresetbuffer.cpp
new file mode 100644
index 0000000..c10423b
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/pvmp4audiodecoderresetbuffer.cpp
@@ -0,0 +1,354 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Pathname: PVMP4AudioDecoderResetBuffer.c
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+ Description: (1) add more comments (2) set pVars->bno = 1
+
+ Description: perChan[] is an array of structures in tDec_Int_File. Made
+              corresponding changes.
+
+ Who:                                         Date:
+ Description:
+
+------------------------------------------------------------------------------
+ INPUT AND OUTPUT DEFINITIONS
+
+ Inputs:
+
+    pMem = void pointer to hide the internal implementation of the library
+           It is cast back to a tDec_Int_File structure. This structure
+           contains information that needs to persist between calls to
+           PVMP4AudioDecodeFrame
+           Data type void pointer, internally pointer to a tDec_Int_File
+           structure.
+
+ Local Stores/Buffers/Pointers Needed: None
+           (The memory set aside in pMem performs this task)
+
+ Global Stores/Buffers/Pointers Needed: None
+
+ Outputs: None
+
+ Pointers and Buffers Modified:
+    pMem contents are modified.
+    pMem->perChan[0].time_quant[0-1023]: contents are set to zero
+    pMem->perChan[1].time_quant[0-1023]: contents are set to zero
+    pMem->bno = 1
+
+ Local Stores Modified: None.
+
+ Global Stores Modified: None.
+
+------------------------------------------------------------------------------
+ FUNCTION DESCRIPTION
+
+  This function is called when the same audio clip will be played again from
+  the begining. This situation happens when the "stop" button is pressed or
+  the "loop-mode" is selected on PVPlayer. Since it is the same audio clip to
+  be played again, the decoder does not need to reset the audioSpecificInfo.
+  However, the overlap-and-add buffer of the filterbank output needs to be
+  cleared, so that the decoder can re-start properly from the begining of
+  the audio. The frame number counter, pVars->bno, is set to 1 because the
+  audioSpecificInfo is decoded on pVars->bno==0
+
+------------------------------------------------------------------------------
+ REQUIREMENTS
+
+ PacketVideo Document # CCC-AUD-AAC-ERS-0003
+
+------------------------------------------------------------------------------
+ REFERENCES
+
+ (1) ISO/IEC 14496-3: 1999(E)
+      subclause 1.6
+
+------------------------------------------------------------------------------
+ RESOURCES USED
+   When the code is written for a specific target processor the
+     the resources used should be documented below.
+
+ STACK USAGE: [stack count for this module] + [variable to represent
+          stack usage for each subroutine called]
+
+     where: [stack usage variable] = stack usage for [subroutine
+         name] (see [filename].ext)
+
+ DATA MEMORY USED: x words
+
+ PROGRAM MEMORY USED: x words
+
+ CLOCK CYCLES: [cycle count equation for this module] + [variable
+           used to represent cycle count for each subroutine
+           called]
+
+     where: [cycle count variable] = cycle count for [subroutine
+        name] (see [filename].ext)
+
+------------------------------------------------------------------------------
+*/
+
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+#include "pv_audio_type_defs.h"
+#include "s_tdec_int_file.h"
+#include "pvmp4audiodecoder_api.h"   /* Where this function is declared */
+#include "aac_mem_funcs.h"
+
+#ifdef AAC_PLUS
+#include    "s_sbr_frame_data.h"
+#endif
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here. Include conditional
+; compile variables also.
+----------------------------------------------------------------------------*/
+#define LEFT  (0)
+#define RIGHT (1)
+
+/*----------------------------------------------------------------------------
+; LOCAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; LOCAL STORE/BUFFER/POINTER DEFINITIONS
+; Variable declaration - defined here and used outside this module
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL FUNCTION REFERENCES
+; Declare functions defined elsewhere and referenced in this module
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL GLOBAL STORE/BUFFER/POINTER REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; FUNCTION CODE
+----------------------------------------------------------------------------*/
+
+OSCL_EXPORT_REF void PVMP4AudioDecoderResetBuffer(void  *pMem)
+{
+
+    tDec_Int_File *pVars;           /* Helper pointer */
+
+#ifdef AAC_PLUS
+    SBR_FRAME_DATA * hFrameData_1;
+    SBR_FRAME_DATA * hFrameData_2;
+#ifdef HQ_SBR
+#ifdef PARAMETRICSTEREO
+    SBRDECODER_DATA *sbrDecoderData;
+#endif
+#endif
+
+#endif
+    /*
+     * Initialize "helper" pointers to existing memory.
+     */
+    pVars = (tDec_Int_File *)pMem;
+
+    /*
+     * Clear the overlap-and-add buffer of filterbank output. The audio
+     * clip will be played again from the beginning.
+     */
+    pv_memset(pVars->perChan[LEFT].time_quant,
+              0,
+              LONG_WINDOW*sizeof(pVars->perChan[LEFT].time_quant[0]));
+
+    pv_memset(pVars->perChan[RIGHT].time_quant,
+              0,
+              LONG_WINDOW*sizeof(pVars->perChan[RIGHT].time_quant[0]));
+
+
+#ifdef AAC_PLUS
+
+    if (!pVars->sbrDecoderData.setStreamType)  /* reset only when stream type is defined */
+    {
+        if (pVars->aacPlusEnabled == true)  /* clear buffer only if they were used */
+        {
+
+            hFrameData_1   = (SBR_FRAME_DATA *) & pVars->sbrDecoderData.SbrChannel[LEFT].frameData;
+            hFrameData_2   = (SBR_FRAME_DATA *) & pVars->sbrDecoderData.SbrChannel[RIGHT].frameData;
+#ifdef HQ_SBR
+#ifdef PARAMETRICSTEREO
+            sbrDecoderData = (SBRDECODER_DATA *) & pVars->sbrDecoderData;
+            sbrDecoderData->hParametricStereoDec = (HANDLE_PS_DEC) & pVars->sbrDecoderData.ParametricStereoDec;
+#endif
+#endif
+
+
+            pv_memset(&pVars->perChan[LEFT].ltp_buffer[0],
+                      0,
+                      288*sizeof(pVars->perChan[LEFT].ltp_buffer[0]));
+            pv_memset(&pVars->perChan[LEFT].ltp_buffer[1024 + 288],
+                      0,
+                      288*sizeof(pVars->perChan[LEFT].ltp_buffer[0]));
+            pv_memset(hFrameData_1->V,
+                      0,
+                      1152*sizeof(hFrameData_1->V[0]));
+            pv_memset(hFrameData_1->prevNoiseLevel_man,
+                      0,
+                      MAX_NUM_NOISE_VALUES*sizeof(hFrameData_1->prevNoiseLevel_man[0]));
+
+
+            pv_memset(&pVars->perChan[RIGHT].ltp_buffer[0],
+                      0,
+                      288*sizeof(pVars->perChan[RIGHT].ltp_buffer[0]));
+            pv_memset(&pVars->perChan[RIGHT].ltp_buffer[1024 + 288],
+                      0,
+                      288*sizeof(pVars->perChan[RIGHT].ltp_buffer[0]));
+            pv_memset(hFrameData_2->V,
+                      0,
+                      1152*sizeof(hFrameData_2->V[0]));
+
+            pv_memset(hFrameData_2->prevNoiseLevel_man,
+                      0,
+                      MAX_NUM_NOISE_VALUES*sizeof(hFrameData_2->prevNoiseLevel_man[0]));
+
+
+            int i;
+            for (i = 0; i < 8; i++)
+            {
+                pv_memset((void *)&hFrameData_1->codecQmfBufferReal[i],
+                          0,
+                          sizeof(**hFrameData_1->codecQmfBufferReal) << 5);
+            }
+
+
+            /* ---- */
+            pv_memset((void *)hFrameData_1->BwVectorOld,
+                      0,
+                      sizeof(*hFrameData_1->BwVectorOld)*MAX_NUM_PATCHES);
+
+#ifdef HQ_SBR
+
+            for (i = 0; i < 5; i++)
+            {
+                pv_memset((void *)&hFrameData_1->fBuffer_man[i],
+                          0,
+                          sizeof(**hFrameData_1->fBuffer_man)*64);
+                pv_memset((void *)&hFrameData_1->fBufferN_man[i],
+                          0,
+                          sizeof(**hFrameData_1->fBufferN_man)*64);
+            }
+#endif
+
+
+            /* ---- */
+
+
+
+            pv_memset((void *)hFrameData_1->HistsbrQmfBufferReal,
+                      0,
+                      sizeof(*hFrameData_1->HistsbrQmfBufferReal)*6*SBR_NUM_BANDS);
+
+#ifdef HQ_SBR
+            pv_memset((void *)hFrameData_1->HistsbrQmfBufferImag,
+                      0,
+                      sizeof(*hFrameData_1->HistsbrQmfBufferImag)*6*SBR_NUM_BANDS);
+#endif
+
+            if (pVars->sbrDec.LC_aacP_DecoderFlag == 1)  /* clear buffer only for LC decoding */
+            {
+
+                for (i = 0; i < 8; i++)
+                {
+                    pv_memset((void *)&hFrameData_2->codecQmfBufferReal[i],
+                              0,
+                              sizeof(**hFrameData_1->codecQmfBufferReal) << 5);
+                }
+
+                pv_memset((void *)hFrameData_2->HistsbrQmfBufferReal,
+                          0,
+                          sizeof(*hFrameData_2->HistsbrQmfBufferReal)*6*SBR_NUM_BANDS);
+
+
+                pv_memset((void *)hFrameData_2->BwVectorOld,
+                          0,
+                          sizeof(*hFrameData_2->BwVectorOld)*MAX_NUM_PATCHES);
+
+#ifdef HQ_SBR
+
+                for (i = 0; i < 5; i++)
+                {
+                    pv_memset((void *)&hFrameData_2->fBuffer_man[i],
+                              0,
+                              sizeof(**hFrameData_2->fBuffer_man)*64);
+                    pv_memset((void *)&hFrameData_2->fBufferN_man[i],
+                              0,
+                              sizeof(**hFrameData_2->fBufferN_man)*64);
+                }
+#endif
+
+            }
+
+#ifdef HQ_SBR
+#ifdef PARAMETRICSTEREO
+            else if (pVars->mc_info.psPresentFlag == 1)
+            {
+                for (i = 0; i < 3; i++)
+                {
+                    pv_memset(sbrDecoderData->hParametricStereoDec->hHybrid->mQmfBufferReal[i],
+                              0,
+                              HYBRID_FILTER_LENGTH_m_1*sizeof(*sbrDecoderData->hParametricStereoDec->hHybrid->mQmfBufferReal));
+                    pv_memset(sbrDecoderData->hParametricStereoDec->hHybrid->mQmfBufferImag[i],
+                              0,
+                              HYBRID_FILTER_LENGTH_m_1*sizeof(*sbrDecoderData->hParametricStereoDec->hHybrid->mQmfBufferImag));
+                }
+            }
+#endif
+#endif
+
+            /*
+             *  default to UPSAMPLING, as if the file is SBR_ACTIVE, this will be fine and will be
+             *  fixed onced the new sbr header is found
+             *  SBR headers contain SBT freq. range as well as control signals that do not require
+             *  frequent changes.
+             *  For streaming, the SBR header is sent twice per second. Also, an SBR header can be
+             *  inserted at any time, if a change of parameters is needed.
+             */
+
+            pVars->sbrDecoderData.SbrChannel[LEFT].syncState = UPSAMPLING;
+            pVars->sbrDecoderData.SbrChannel[RIGHT].syncState = UPSAMPLING;
+
+        }
+    }
+#endif      /*  #ifdef AAC_PLUS */
+
+    /* reset frame count to 1 */
+    pVars->bno = 1;
+
+    return ;
+
+} /* PVMP4AudioDecoderDecodeFrame */
+
diff --git a/media/libstagefright/codecs/aacdec/pvmp4setaudioconfig.cpp b/media/libstagefright/codecs/aacdec/pvmp4setaudioconfig.cpp
new file mode 100644
index 0000000..d183d84
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/pvmp4setaudioconfig.cpp
@@ -0,0 +1,368 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Pathname: pvmp4setaudioconfigg
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+ Who:                                         Date:
+ Description:
+
+------------------------------------------------------------------------------
+ INPUT AND OUTPUT DEFINITIONS
+
+ Inputs:
+    pExt = pointer to the external interface structure. See the file
+           PVMP4AudioDecoder_API.h for a description of each field.
+           Data type of pointer to a tPVMP4AudioDecoderExternal
+           structure.
+
+           pExt->pInputBuffer: pointer to input buffer containing input
+                               bitstream
+
+           pExt->inputBufferCurrentLength: number of bytes in the input buffer
+
+           pExt->inputBufferUsedLength: number of bytes already consumed in
+                                        input buffer
+
+           pExt->remainderBits: number of bits consumed in addition to
+                                pExt->inputBufferUsedLength
+
+    pMem = void pointer to hide the internal implementation of the library
+           It is cast back to a tDec_Int_File structure. This structure
+           contains information that needs to persist between calls to
+           this function, or is too big to be placed on the stack, even
+           though the data is only needed during execution of this function
+           Data type void pointer, internally pointer to a tDec_Int_File
+           structure.
+
+ Local Stores/Buffers/Pointers Needed: None
+           (The memory set aside in pMem performs this task)
+
+ Global Stores/Buffers/Pointers Needed: None
+
+ Outputs:
+     status = 0                       if no error occurred
+              MP4AUDEC_NONRECOVERABLE if a non-recoverable error occurred
+              MP4AUDEC_RECOVERABLE    if a recoverable error occurred.
+              Presently a recoverable error does not exist, but this
+              was a requirement.
+
+
+ Pointers and Buffers Modified:
+    pMem contents are modified.
+    pExt: (more detail in the file PVMP4AudioDecoder_API.h)
+    inputBufferUsedLength - number of array elements used up by the stream.
+    remainderBits - remaining bits in the next UInt32 buffer
+    samplingRate - sampling rate in samples per sec
+    encodedChannels - channels found on the file (informative)
+    frameLength - length of the frame
+
+ Local Stores Modified: None.
+
+ Global Stores Modified: None.
+
+------------------------------------------------------------------------------
+ FUNCTION DESCRIPTION
+
+
+------------------------------------------------------------------------------
+ REQUIREMENTS
+
+ PacketVideo Document # CCC-AUD-AAC-ERS-0003
+
+------------------------------------------------------------------------------
+ REFERENCES
+
+
+------------------------------------------------------------------------------
+ RESOURCES USED
+   When the code is written for a specific target processor the
+     the resources used should be documented below.
+
+ STACK USAGE: [stack count for this module] + [variable to represent
+          stack usage for each subroutine called]
+
+     where: [stack usage variable] = stack usage for [subroutine
+         name] (see [filename].ext)
+
+ DATA MEMORY USED: x words
+
+ PROGRAM MEMORY USED: x words
+
+ CLOCK CYCLES: [cycle count equation for this module] + [variable
+           used to represent cycle count for each subroutine
+           called]
+
+     where: [cycle count variable] = cycle count for [subroutine
+        name] (see [filename].ext)
+
+------------------------------------------------------------------------------
+*/
+
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+
+#include "pv_audio_type_defs.h"
+#include "s_tdec_int_file.h"
+#include "ibstream.h"           /* where #define INBUF_ARRAY_INDEX_SHIFT */
+#include "sfb.h"                   /* Where samp_rate_info[] is declared */
+
+#include "get_audio_specific_config.h"
+#include "pvmp4audiodecoder_api.h"   /* Where this function is declared */
+#include "set_mc_info.h"
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here. Include conditional
+; compile variables also.
+----------------------------------------------------------------------------*/
+
+
+/*----------------------------------------------------------------------------
+; LOCAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; LOCAL STORE/BUFFER/POINTER DEFINITIONS
+; Variable declaration - defined here and used outside this module
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL FUNCTION REFERENCES
+; Declare functions defined elsewhere and referenced in this module
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL GLOBAL STORE/BUFFER/POINTER REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; FUNCTION CODE
+----------------------------------------------------------------------------*/
+
+Int PVMP4SetAudioConfig(
+    tPVMP4AudioDecoderExternal  *pExt,
+    void                        *pMem,
+    Int                         upsamplingFactor,
+    Int                         samp_rate,
+    Int                         num_ch,
+    tMP4AudioObjectType         audioObjectType)
+
+{
+
+    tDec_Int_File *pVars;           /* Helper pointer */
+
+    Int            status = MP4AUDEC_INCOMPLETE_FRAME;
+
+    /*
+     * Initialize "helper" pointers to existing memory.
+     */
+    pVars = (tDec_Int_File *)pMem;
+    /*
+     * Translate input buffer variables.
+     */
+    pVars->inputStream.pBuffer = pExt->pInputBuffer;
+
+    pVars->inputStream.availableBits = 0;
+
+    pVars->inputStream.usedBits = 0;
+
+
+
+    /*
+     *  get sampling rate index
+     */
+
+    switch (samp_rate)
+    {
+        case 96000:
+            pVars->prog_config.sampling_rate_idx = 0;
+            break;
+        case 88200:
+            pVars->prog_config.sampling_rate_idx = 1;
+            break;
+        case 64000:
+            pVars->prog_config.sampling_rate_idx = 2;
+            break;
+        case 48000:
+            pVars->prog_config.sampling_rate_idx = 3;
+            break;
+        case 44100:
+            pVars->prog_config.sampling_rate_idx = 4;
+            break;
+        case 32000:
+            pVars->prog_config.sampling_rate_idx = 5;
+            break;
+        case 24000:
+            pVars->prog_config.sampling_rate_idx = 6;
+            break;
+        case 22050:
+            pVars->prog_config.sampling_rate_idx = 7;
+            break;
+        case 16000:
+            pVars->prog_config.sampling_rate_idx = 8;
+            break;
+        case 12000:
+            pVars->prog_config.sampling_rate_idx = 9;
+            break;
+        case 11025:
+            pVars->prog_config.sampling_rate_idx = 10;
+            break;
+        case 8000:
+            pVars->prog_config.sampling_rate_idx = 11;
+            break;
+        case 7350:
+            pVars->prog_config.sampling_rate_idx = 12;
+            break;
+        default:
+            status = -1;
+
+            break;
+    }
+
+    pVars->mc_info.sbrPresentFlag = 0;
+    pVars->mc_info.psPresentFlag = 0;
+#ifdef AAC_PLUS
+    pVars->mc_info.bDownSampledSbr = 0;
+#endif
+    pVars->mc_info.implicit_channeling = 0;
+    pVars->mc_info.nch = num_ch;
+    pVars->mc_info.upsamplingFactor = upsamplingFactor;
+
+
+    /*
+     *  Set number of channels
+     */
+
+    if (num_ch == 2)
+    {
+        pVars->prog_config.front.ele_is_cpe[0] = 1;
+    }
+    else if (num_ch == 1)
+    {
+        pVars->prog_config.front.ele_is_cpe[0] = 0;
+    }
+    else
+    {
+        status = -1; /* do not support more than two channels */
+        pVars->status = status;
+        return (status);
+    }
+
+
+    /*
+     *  Set AAC bitstream
+     */
+
+    if ((audioObjectType == MP4AUDIO_AAC_LC)        ||
+            (audioObjectType == MP4AUDIO_LTP))
+    {
+        pVars->aacPlusEnabled = false;
+
+        status = set_mc_info(&(pVars->mc_info),
+                             audioObjectType, /* previously profile */
+                             pVars->prog_config.sampling_rate_idx,
+                             pVars->prog_config.front.ele_tag[0],
+                             pVars->prog_config.front.ele_is_cpe[0],
+                             pVars->winmap, /*pVars->pWinSeqInfo,*/
+                             pVars->SFBWidth128);
+    }
+    else if ((audioObjectType == MP4AUDIO_SBR)        ||
+             (audioObjectType == MP4AUDIO_PS))
+    {
+        pVars->aacPlusEnabled = true;
+
+
+        status = set_mc_info(&(pVars->mc_info),
+                             MP4AUDIO_AAC_LC,
+                             pVars->prog_config.sampling_rate_idx,
+                             pVars->prog_config.front.ele_tag[0],
+                             pVars->prog_config.front.ele_is_cpe[0],
+                             pVars->winmap, /*pVars->pWinSeqInfo,*/
+                             pVars->SFBWidth128);
+
+        pVars->mc_info.sbrPresentFlag = 1;
+        if (audioObjectType == MP4AUDIO_PS)
+        {
+            pVars->mc_info.psPresentFlag = 1;
+        }
+
+        if (upsamplingFactor == 1)
+        {
+#ifdef AAC_PLUS
+            pVars->mc_info.bDownSampledSbr = 1;
+#endif
+
+            /*
+             *  Disable SBR decoding for any sbr-downsampled file whose SF is >= 24 KHz
+             */
+            if (pVars->prog_config.sampling_rate_idx < 6)
+            {
+                pVars->aacPlusEnabled = false;
+            }
+        }
+
+    }
+    else
+    {
+        status = -1;
+    }
+
+
+    /*
+     * Translate from units of bits back into units of words.
+     */
+    pExt->inputBufferUsedLength = 0;
+
+    pExt->remainderBits = 0;
+
+    pVars->bno++;
+
+    pExt->samplingRate = samp_rate * upsamplingFactor;
+
+    pExt->aacPlusEnabled = pVars->aacPlusEnabled;
+
+    /*
+     *  we default to 2 channel, even for mono files, (where channels have same content)
+     *  this is done to ensure support for enhanced aac+ with implicit signalling
+     */
+
+    pExt->encodedChannels = 2;
+
+    pExt->frameLength = 1024;
+#ifdef AAC_PLUS
+    pExt->aacPlusUpsamplingFactor = upsamplingFactor;
+#endif
+
+    pVars->status = status;
+
+    return (status);
+
+} /* PVMP4AudioDecoderDecodeFrame */
diff --git a/media/libstagefright/codecs/aacdec/q_normalize.cpp b/media/libstagefright/codecs/aacdec/q_normalize.cpp
new file mode 100644
index 0000000..5266966
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/q_normalize.cpp
@@ -0,0 +1,388 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Pathname: q_normalize.c
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+ Description:
+ (1) Modify to include search over the scalefactor bands to insure
+     that the data is using all 31 data-bits.
+
+ Description:
+ (1) Modify to remove search over the scalefactor bands to insure
+     that the data is using all 31 data-bits.
+     (Pushed out into separate function)
+ (2) Change variable "k" to more descriptive "shift_amt"
+ (3) Update pseudocode to reflect removed code.
+ (4) Add PV Copyright notice.
+
+ Description:
+ (1) Modified to protect q-normalize from shifting by amounts >= 32.
+
+ Description:
+ (1) Delete local variable idx_count.
+
+ Description:
+ (1) Included search for max in each frame, modified interface.
+
+ Description:
+ (1) unrolled loop based on the fact that the size of each scale band
+     is always an even number.
+
+ Description:Check shift, if zero, do not shift.
+
+ Description: Eliminated warning: non use variable "i" and memset function
+    definition
+
+ Who:                       Date:
+ Description:
+------------------------------------------------------------------------------
+ INPUT AND OUTPUT DEFINITIONS
+
+ Inputs:
+    qFormat[] = Array of qFormats, one per scalefactor band. [ Int ]
+
+    pFrameInfo = Pointer to structure that holds information about each group.
+                 (long block flag, number of windows, scalefactor bands, etc.)
+                 [const FrameInfo]
+
+    coef[]    = Array of the spectral coefficients for one channel. [ Int32 ]
+
+ Local Stores/Buffers/Pointers Needed:
+    None
+
+ Global Stores/Buffers/Pointers Needed:
+    None
+
+ Outputs:
+    min_q = The common q-format for the entire frame. [Int]
+
+ Pointers and Buffers Modified:
+    coef[]    = Array of spectral data, now normalized to one q-format.
+
+ Local Stores Modified:
+    None
+
+ Global Stores Modified:
+    None
+
+------------------------------------------------------------------------------
+ FUNCTION DESCRIPTION
+
+ This module first scans every scalefactor band for the frame, insuring that
+ at least one element in that scalefactor band is using all available bits.
+ If not, the elements in the scalefactor band are shifted up to use all 31
+ data bits.  The q-format is adjusted accordingly.
+
+ This module then scans the q-formats for each scalefactor band.
+ Upon finding the minimum q-format in the frame, the coefficients in each
+ scalefactor band are normalized to the minimum q-format.
+ The minimum q-format is then returned to the calling function, which is now
+ the q-format for the entire frame.
+
+------------------------------------------------------------------------------
+ REQUIREMENTS
+
+------------------------------------------------------------------------------
+ REFERENCES
+
+------------------------------------------------------------------------------
+ PSEUDO-CODE
+
+    nwin = pFrameInfo->num_win;
+
+    pQformat   = &(qFormat[0]);
+    pSfbPerWin = &(pFrameInfo->sfb_per_win[0]);
+    pCoef      = &(coef[0]);
+
+    FOR (win = nwin; win > 0; win--)
+
+        nsfb = *(pSfbPerWin++);
+
+        FOR (sfb = nsfb; sfb > 0; sfb--)
+
+            IF ( *(pQformat) < min_q)
+                min_q = *(pQformat);
+            ENDIF
+
+            pQformat++;
+
+        ENDFOR
+
+    ENDFOR
+
+    pQformat   = &(qFormat[0]);
+    pSfbPerWin = &(pFrameInfo->sfb_per_win[0]);
+    pCoef      = &(coef[0]);
+
+    FOR (win = 0; win < nwin; win++)
+
+        stop_idx = 0;
+
+        nsfb   = *(pSfbPerWin++);
+
+        pWinSfbTop = &(pFrameInfo->win_sfb_top[win][0]);
+
+        FOR (sfb = nsfb; sfb > 0; sfb--)
+
+            sfbWidth  = *(pWinSfbTop++) - stop_idx;
+
+            stop_idx += sfbWidth;
+
+            k = *(pQformat++) - min_q;
+
+            IF (k < 32)
+            THEN
+                FOR (; sfbWidth > 0; sfbWidth--)
+                    *(pCoef++) >>= k;
+                ENDFOR
+            ELSE
+                FOR (; sfbWidth > 0; sfbWidth--)
+                    *(pCoef++) = 0;
+                ENDFOR
+            ENDIF
+
+        ENDFOR
+
+    ENDFOR
+
+    return min_q;
+
+------------------------------------------------------------------------------
+ RESOURCES USED
+   When the code is written for a specific target processor the
+     the resources used should be documented below.
+
+ STACK USAGE: [stack count for this module] + [variable to represent
+          stack usage for each subroutine called]
+
+     where: [stack usage variable] = stack usage for [subroutine
+         name] (see [filename].ext)
+
+ DATA MEMORY USED: x words
+
+ PROGRAM MEMORY USED: x words
+
+ CLOCK CYCLES: [cycle count equation for this module] + [variable
+           used to represent cycle count for each subroutine
+           called]
+
+     where: [cycle count variable] = cycle count for [subroutine
+        name] (see [filename].ext)
+
+------------------------------------------------------------------------------
+*/
+
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+#include "pv_audio_type_defs.h"
+#include "s_frameinfo.h"
+#include "q_normalize.h"
+#include "aac_mem_funcs.h"         /* For pv_memset                         */
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here. Include conditional
+; compile variables also.
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; LOCAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; LOCAL STORE/BUFFER/POINTER DEFINITIONS
+; Variable declaration - defined here and used outside this module
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL FUNCTION REFERENCES
+; Declare functions defined elsewhere and referenced in this module
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL GLOBAL STORE/BUFFER/POINTER REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; FUNCTION CODE
+----------------------------------------------------------------------------*/
+Int q_normalize(
+    Int        qFormat[],
+    const FrameInfo *pFrameInfo,
+    Int32      abs_max_per_window[],
+    Int32      coef[])
+{
+    Int    sfb;
+    Int    nsfb;
+    Int    win;
+    Int    nwin;
+    Int    sfbWidth;
+
+    Int    shift_amt;
+
+    /* Initialize min_q to a very large value */
+    Int    min_q = 1000;
+
+    Int stop_idx  = 0;
+
+    const Int   *pSfbPerWin;
+    const Int16 *pWinSfbTop;
+
+    Int   *pQformat;
+    Int32 *pCoef;
+
+    nwin = pFrameInfo->num_win;
+
+    /* Find the minimum q format */
+    pQformat   = &(qFormat[0]);
+    pSfbPerWin = &(pFrameInfo->sfb_per_win[0]);
+
+    for (win = nwin; win != 0; win--)
+    {
+
+        nsfb = *(pSfbPerWin++);
+
+        if (nsfb < 0 || nsfb > MAXBANDS)
+        {
+            break;  /* avoid any processing on error condition */
+        }
+
+        for (sfb = nsfb; sfb != 0; sfb--)
+        {
+            Int qformat = *(pQformat++);
+            if (qformat < min_q)
+            {
+                min_q = qformat;
+            }
+        }
+
+    } /* for(win) */
+
+    /* Normalize the coefs in each scalefactor band to one q-format */
+    pQformat   = &(qFormat[0]);
+    pSfbPerWin = &(pFrameInfo->sfb_per_win[0]);
+    pCoef      = &(coef[0]);
+
+    for (win = 0; win < nwin; win++)
+    {
+
+        Int32 max = 0;
+        stop_idx = 0;
+
+        nsfb   = *(pSfbPerWin++);
+
+        if (nsfb < 0 || nsfb > MAXBANDS)
+        {
+            break;  /* avoid any processing on error condition */
+        }
+
+        pWinSfbTop = &(pFrameInfo->win_sfb_top[win][0]);
+
+        for (sfb = nsfb; sfb != 0; sfb--)
+        {
+            Int tmp1, tmp2;
+            tmp1 = *(pWinSfbTop++);
+            tmp2 = *(pQformat++);
+            sfbWidth  = tmp1 - stop_idx;
+
+            if (sfbWidth < 2)
+            {
+                break;  /* will lead to error condition */
+            }
+
+            stop_idx += sfbWidth;
+
+            shift_amt = tmp2 - min_q;
+
+            if (shift_amt == 0)
+            {
+                Int32 tmp1, tmp2;
+                tmp1 = *(pCoef++);
+                tmp2 = *(pCoef++);
+                /*
+                 *  sfbWidth is always an even number
+                 *  (check tables in pg.66 IS0 14496-3)
+                 */
+                for (Int i = (sfbWidth >> 1) - 1; i != 0; i--)
+                {
+                    max  |= (tmp1 >> 31) ^ tmp1;
+                    max  |= (tmp2 >> 31) ^ tmp2;
+                    tmp1 = *(pCoef++);
+                    tmp2 = *(pCoef++);
+                }
+                max  |= (tmp1 >> 31) ^ tmp1;
+                max  |= (tmp2 >> 31) ^ tmp2;
+
+            }
+            else
+            {
+                if (shift_amt < 31)
+                {
+                    Int32 tmp1, tmp2;
+                    tmp1 = *(pCoef++) >> shift_amt;
+                    tmp2 = *(pCoef--) >> shift_amt;
+                    /*
+                     *  sfbWidth is always an even number
+                     *  (check tables in pg.66 IS0 14496-3)
+                     */
+                    for (Int i = (sfbWidth >> 1) - 1; i != 0; i--)
+                    {
+                        *(pCoef++)   = tmp1;
+                        *(pCoef++)   = tmp2;
+
+                        max  |= (tmp1 >> 31) ^ tmp1;
+                        max  |= (tmp2 >> 31) ^ tmp2;
+                        tmp1 = *(pCoef++) >> shift_amt;
+                        tmp2 = *(pCoef--) >> shift_amt;
+
+                    }
+                    *(pCoef++)   = tmp1;
+                    *(pCoef++)   = tmp2;
+                    max  |= (tmp1 >> 31) ^ tmp1;
+                    max  |= (tmp2 >> 31) ^ tmp2;
+
+                }
+                else
+                {
+                    pv_memset(pCoef, 0, sizeof(Int32)*sfbWidth);
+                    pCoef += sfbWidth;
+                }
+            }
+
+            abs_max_per_window[win] = max;
+
+        }
+
+    } /* for (win) */
+
+    return min_q;
+
+} /* normalize() */
diff --git a/media/libstagefright/codecs/aacdec/q_normalize.h b/media/libstagefright/codecs/aacdec/q_normalize.h
new file mode 100644
index 0000000..63a9d53
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/q_normalize.h
@@ -0,0 +1,103 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Pathname: q_normalize.h
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+ Description:
+ (1) Added PV Copyright notice.
+ (2) Removed embedded TABS
+
+ Who:                       Date:
+ Description:
+
+------------------------------------------------------------------------------
+ INCLUDE DESCRIPTION
+
+  This file includes the function definition for q_normalize.h
+------------------------------------------------------------------------------
+*/
+
+/*----------------------------------------------------------------------------
+; CONTINUE ONLY IF NOT ALREADY DEFINED
+----------------------------------------------------------------------------*/
+#ifndef Q_NORMALIZE_H
+#define Q_NORMALIZE_H
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+#include "pv_audio_type_defs.h"
+#include "s_frameinfo.h"
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here.
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL VARIABLES REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; SIMPLE TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; ENUMERATED TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; STRUCTURES TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; GLOBAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+    Int q_normalize(
+        Int        qFormat[],
+        const FrameInfo *pFrameInfo,
+        Int32     abs_max_per_window[],
+        Int32      coef[]);
+
+#ifdef __cplusplus
+}
+#endif
+
+
+
+/*----------------------------------------------------------------------------
+; END
+----------------------------------------------------------------------------*/
+#endif
diff --git a/media/libstagefright/codecs/aacdec/qmf_filterbank_coeff.cpp b/media/libstagefright/codecs/aacdec/qmf_filterbank_coeff.cpp
new file mode 100644
index 0000000..1164129
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/qmf_filterbank_coeff.cpp
@@ -0,0 +1,319 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Pathname: qmf_filterbank_coeff.c
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+ Who:                              Date:
+ Description:
+
+------------------------------------------------------------------------------
+ INPUT AND OUTPUT DEFINITIONS
+
+ Inputs:
+
+ Local Stores/Buffers/Pointers Needed:
+
+ Global Stores/Buffers/Pointers Needed:
+
+ Outputs:
+
+ Pointers and Buffers Modified:
+
+
+ Local Stores Modified:
+
+ Global Stores Modified:
+
+------------------------------------------------------------------------------
+ FUNCTION DESCRIPTION
+
+ This function defines the scalefactor bands for all sampling rates
+
+------------------------------------------------------------------------------
+ REQUIREMENTS
+
+
+------------------------------------------------------------------------------
+ REFERENCES
+
+SC 29 Software Copyright Licencing Disclaimer:
+
+This software module was originally developed by
+  Coding Technologies
+
+and edited by
+  -
+
+in the course of development of the ISO/IEC 13818-7 and ISO/IEC 14496-3
+standards for reference purposes and its performance may not have been
+optimized. This software module is an implementation of one or more tools as
+specified by the ISO/IEC 13818-7 and ISO/IEC 14496-3 standards.
+ISO/IEC gives users free license to this software module or modifications
+thereof for use in products claiming conformance to audiovisual and
+image-coding related ITU Recommendations and/or ISO/IEC International
+Standards. ISO/IEC gives users the same free license to this software module or
+modifications thereof for research purposes and further ISO/IEC standardisation.
+Those intending to use this software module in products are advised that its
+use may infringe existing patents. ISO/IEC have no liability for use of this
+software module or modifications thereof. Copyright is not released for
+products that do not conform to audiovisual and image-coding related ITU
+Recommendations and/or ISO/IEC International Standards.
+The original developer retains full right to modify and use the code for its
+own purpose, assign or donate the code to a third party and to inhibit third
+parties from using the code for products that do not conform to audiovisual and
+image-coding related ITU Recommendations and/or ISO/IEC International Standards.
+This copyright notice must be included in all copies or derivative works.
+Copyright (c) ISO/IEC 2002.
+
+------------------------------------------------------------------------------
+ PSEUDO-CODE
+
+------------------------------------------------------------------------------
+ RESOURCES USED
+   When the code is written for a specific target processor the
+     the resources used should be documented below.
+
+ STACK USAGE: [stack count for this module] + [variable to represent
+          stack usage for each subroutine called]
+
+     where: [stack usage variable] = stack usage for [subroutine
+         name] (see [filename].ext)
+
+ DATA MEMORY USED: x words
+
+ PROGRAM MEMORY USED: x words
+
+ CLOCK CYCLES: [cycle count equation for this module] + [variable
+           used to represent cycle count for each subroutine
+           called]
+
+     where: [cycle count variable] = cycle count for [subroutine
+        name] (see [filename].ext)
+
+------------------------------------------------------------------------------
+*/
+
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+
+#ifdef AAC_PLUS
+
+
+#include    "qmf_filterbank_coeff.h"
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here. Include conditional
+; compile variables also.
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; LOCAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; LOCAL STORE/BUFFER/POINTER DEFINITIONS
+; Variable declaration - defined here and used outside this module
+----------------------------------------------------------------------------*/
+
+
+
+const Int32 sbrDecoderFilterbankCoefficients[155] =
+{
+    /*  10/9*table */
+
+    0xFFEA0066,  0x020C09CF,  0x34F67965,  0xCE380A2F,  0xFE43005A,
+    0xFFEA006C,  0x02360998,  0x36907954,  0xCFCD0A57,  0xFE690054,
+    0xFFEC0072,  0x0262095B,  0x382B7937,  0xD1600A7A,  0xFE8E004F,
+    0xFFED0078,  0x028E0919,  0x39C6790F,  0xD2F00A98,  0xFEB20049,
+    0xFFED007E,  0x02BB08D0,  0x3B6378DB,  0xD47D0AB1,  0xFED50043,
+    0xFFEC0084,  0x02E90882,  0x3D00789B,  0xD6080AC6,  0xFEF6003E,
+    0xFFEB0089,  0x0318082F,  0x3E9D7851,  0xD78F0AD6,  0xFF160039,
+    0xFFEB008F,  0x034807D5,  0x403A77FB,  0xD9130AE2,  0xFF350033,
+    0xFFEA0095,  0x03790775,  0x41D7779A,  0xDA930AEA,  0xFF53002E,
+    0xFFE9009A,  0x03AB070E,  0x4373772D,  0xDC100AED,  0xFF6F0029,
+    0xFFE800A0,  0x03DE06A2,  0x450D76B6,  0xDD890AED,  0xFF8A0024,
+    0xFFE800A5,  0x0412062F,  0x46A77633,  0xDEFD0AE9,  0xFFA40020,
+    0xFFE700AA,  0x044705B6,  0x483F75A6,  0xE06D0AE2,  0xFFBD001C,
+    0xFFE600AF,  0x047B0537,  0x49D5750E,  0xE1D90AD7,  0xFFD40017,
+    0xFFE500B3,  0x04B104B0,  0x4B69746B,  0xE3400AC8,  0xFFEB0013,
+    0xFFE400B8,  0x04E70423,  0x4CFA73BE,  0xE4A20AB7,  0x0002000F,
+    0xFFE400BC,  0x051E0390,  0x4E897306,  0xE5FF0AA2,  0x0016000B,
+    0xFFE300BF,  0x055502F6,  0x50157244,  0xE7560A8A,  0x00280008,
+    0xFFE300C3,  0x058D0254,  0x519D7178,  0xE8A80A6F,  0x003A0004,
+    0xFFE300C6,  0x05C401AD,  0x532270A2,  0xE9F50A53,  0x004A0001,
+    0xFFE200C8,  0x05FC00FE,  0x54A36FC3,  0xEB3C0A33,  0x005AFFFC,
+    0xFFE200CA,  0x06340048,  0x56206EDA,  0xEC7D0A11,  0x0068FFF9,
+    0xFFE200CC,  0x066CFF8A,  0x57986DE8,  0xEDB809EC,  0x0075FFF7,
+    0xFFE200CD,  0x06A4FEC6,  0x590C6CEC,  0xEEED09C6,  0x0081FFF4,
+    0xFFE200CE,  0x06DCFDFC,  0x5A7B6BE7,  0xF01C099E,  0x008DFFF2,
+    0xFFE200CE,  0x0713FD2B,  0x5BE56ADA,  0xF1450973,  0x0097FFF0,
+    0xFFE300CD,  0x074BFC52,  0x5D4869C4,  0xF2680947,  0x00A0FFEE,
+    0xFFE300CC,  0x0781FB73,  0x5EA668A6,  0xF384091A,  0x00A8FFEC,
+    0xFFE400CA,  0x07B7FA8D,  0x5FFF6780,  0xF49908EB,  0x00B0FFEA,
+    0xFFE400C8,  0x07EDF9A0,  0x61506652,  0xF5A808BA,  0x00B6FFE9,
+    0xFFE500C5,  0x0822F8AC,  0x629B651C,  0xF6B00888,  0x00BCFFE7
+};
+
+
+const Int32 sbrDecoderFilterbankCoefficients_down_smpl[160] =
+{
+    0x0000FFEE,  0xFFF0FFEF, 0xFFEEFFED, 0xFFEBFFEA,
+    0xFFE9FFE8,  0xFFE7FFE6, 0xFFE6FFE7, 0xFFE7FFE8,
+    0xFFEAFFED,  0xFFEFFFF3, 0xFFF7FFFB, 0x00000007,
+    0x000D0014,  0x001C0025, 0x002E0037, 0x0041004B,
+    0x00560061,  0x006B0076, 0x0080008A, 0x0094009D,
+    0x00A500AC,  0x00B200B6, 0x00B800B9, 0x00B700B3,
+    0x00AD00A3,  0x00970087, 0x0074005D, 0x00420024,
+    0x0001FFDA,  0xFFAFFF7F, 0xFF4BFF12, 0xFED5FE93,
+    0x01B301FD,  0x024C029E, 0x02F4034D, 0x03A90408,
+    0x046904CC,  0x05300595, 0x05FA065E, 0x06C10722,
+    0x078007DA,  0x08300881, 0x08CB090F, 0x094A097C,
+    0x09A409C1,  0x09D209D5, 0x09CB09B2, 0x0988094D,
+    0x090108A2,  0x082F07A8, 0x070C0659, 0x059104B1,
+    0x03B902AA,  0x01810041, 0xFEE7FD74, 0xFBE9FA45,
+    0xF887F6B2,  0xF4C4F2BF, 0xF0A4EE72, 0xEC2AE9CF,
+    0xE760E4DE,  0xE24CDFA9, 0xDCF9DA3B, 0xD772D4A0,
+    0x2E3A311B,  0x33FF36E7, 0x39CE3CB4, 0x3F964273,
+    0x45484813,  0x4AD24D84, 0x502552B4, 0x55305795,
+    0x59E35C17,  0x5E2F602B, 0x620863C4, 0x655F66D7,
+    0x682B6959,  0x6A626B43, 0x6BFC6C8C, 0x6CF46D32,
+    0x6D476D32,  0x6CF46C8C, 0x6BFC6B43, 0x6A626959,
+    0x682B66D7,  0x655F63C4, 0x6208602B, 0x5E2F5C17,
+    0x59E35795,  0x553052B4, 0x50254D84, 0x4AD24813,
+    0x45484273,  0x3F963CB4, 0x39CE36E7, 0x33FF311B,
+    0xD1C6D4A0,  0xD772DA3B, 0xDCF9DFA9, 0xE24CE4DE,
+    0xE760E9CF,  0xEC2AEE72, 0xF0A4F2BF, 0xF4C4F6B2,
+    0xF887FA45,  0xFBE9FD74, 0xFEE70041, 0x018102AA,
+    0x03B904B1,  0x05910659, 0x070C07A8, 0x082F08A2,
+    0x0901094D,  0x098809B2, 0x09CB09D5, 0x09D209C1,
+    0x09A4097C,  0x094A090F, 0x08CB0881, 0x083007DA,
+    0x07800722,  0x06C1065E, 0x05FA0595, 0x053004CC,
+    0x04690408,  0x03A9034D, 0x02F4029E, 0x024C01FD,
+    0xFE4DFE93,  0xFED5FF12, 0xFF4BFF7F, 0xFFAFFFDA,
+    0x00010024,  0x0042005D, 0x00740087, 0x009700A3,
+    0x00AD00B3,  0x00B700B9, 0x00B800B6, 0x00B200AC,
+    0x00A5009D,  0x0094008A, 0x00800076, 0x006B0061,
+    0x0056004B,  0x00410037, 0x002E0025, 0x001C0014,
+    0x000D0007,  0x0000FFFB, 0xFFF7FFF3, 0xFFEFFFED,
+    0xFFEAFFE8,  0xFFE7FFE7, 0xFFE6FFE6, 0xFFE7FFE8,
+    0xFFE9FFEA,  0xFFEBFFED, 0xFFEEFFEF, 0xFFF0FFEE
+};
+
+const Int32 sbrDecoderFilterbankCoefficients_an_filt_LC[155] =
+{
+
+    Qfmt27(-0.00079446133872F), Qfmt27(0.02197766364781F), Qfmt27(0.54254182141522F), Qfmt27(-0.47923775873194F),
+    Qfmt27(-0.01574239605130F), Qfmt27(-0.00068946163857F), Qfmt27(0.02537571195384F), Qfmt27(0.57449847577240F),
+    Qfmt27(-0.44806230039026F), Qfmt27(-0.01291535202742F), Qfmt27(-0.00071286404460F), Qfmt27(0.02892516313544F),
+    Qfmt27(0.60657315615086F), Qfmt27(-0.41729436041451F), Qfmt27(-0.01026942774868F), Qfmt27(-0.00077308974337F),
+    Qfmt27(0.03262310249845F), Qfmt27(0.63865835544980F), Qfmt27(-0.38701849746199F), Qfmt27(-0.00782586328859F),
+    Qfmt27(-0.00083027488297F), Qfmt27(0.03646915244785F), Qfmt27(0.67068416485018F), Qfmt27(-0.35729827194706F),
+    Qfmt27(-0.00557215982767F), Qfmt27(-0.00089272089703F), Qfmt27(0.04045671426315F), Qfmt27(0.70254003810627F),
+    Qfmt27(-0.32819525024294F), Qfmt27(-0.00351102841332F), Qfmt27(-0.00095851011196F), Qfmt27(0.04455021764484F),
+    Qfmt27(0.73415149000395F), Qfmt27(-0.29977591877185F), Qfmt27(-0.00163598204794F), Qfmt27(-0.00101225729839F),
+    Qfmt27(0.04873676213679F), Qfmt27(0.76545064960593F), Qfmt27(-0.27208998714049F), Qfmt27(0.00003903936539F),
+    Qfmt27(-0.00105230782648F), Qfmt27(0.05300654158217F), Qfmt27(0.79631383686511F), Qfmt27(-0.24519750285673F),
+    Qfmt27(0.00154182229475F), Qfmt27(-0.00108630976316F), Qfmt27(0.05732502937107F), Qfmt27(0.82666485395476F),
+    Qfmt27(-0.21914753347432F), Qfmt27(0.00286720203220F), Qfmt27(-0.00110794157381F), Qfmt27(0.06167350555855F),
+    Qfmt27(0.85641712130638F), Qfmt27(-0.19396671004887F), Qfmt27(0.00402297937976F), Qfmt27(-0.00110360418081F),
+    Qfmt27(0.06602157445253F), Qfmt27(0.88547343436495F), Qfmt27(-0.16971665552213F), Qfmt27(0.00500649278750F),
+    Qfmt27(-0.00109714405326F), Qfmt27(0.07034096875232F), Qfmt27(0.91376152398903F), Qfmt27(-0.14641770628514F),
+    Qfmt27(0.00583386287581F), Qfmt27(-0.00106490281247F), Qfmt27(0.07461825625751F), Qfmt27(0.94117890777861F),
+    Qfmt27(-0.12410396326951F), Qfmt27(0.00651097277313F), Qfmt27(-0.00102041023958F), Qfmt27(0.07879625324269F),
+    Qfmt27(0.96765488212662F), Qfmt27(-0.10280530739363F), Qfmt27(0.00704839655425F), Qfmt27(-0.00094051141595F),
+    Qfmt27(0.08286099010631F), Qfmt27(0.99311573680798F), Qfmt27(-0.08254839941155F), Qfmt27(0.00745513427428F),
+    Qfmt27(-0.00084090835475F), Qfmt27(0.08675566213219F), Qfmt27(1.01745066253324F), Qfmt27(-0.06332944781672F),
+    Qfmt27(0.00774335382672F), Qfmt27(-0.00072769348801F), Qfmt27(0.09046949018457F), Qfmt27(1.04060828658052F),
+    Qfmt27(-0.04518854556363F), Qfmt27(0.00790787636150F), Qfmt27(-0.00057913742435F), Qfmt27(0.09395575430420F),
+    Qfmt27(1.06251808919053F), Qfmt27(-0.02811939233087F), Qfmt27(0.00797463714114F), Qfmt27(-0.00040969484059F),
+    Qfmt27(0.09716267023308F), Qfmt27(1.08310018709600F), Qfmt27(-0.01212147193047F), Qfmt27(0.00795079915733F),
+    Qfmt27(-0.00020454902123F), Qfmt27(0.10007381188066F), Qfmt27(1.10227871198194F), Qfmt27(0.00279527795884F),
+    Qfmt27(0.00784545014643F), Qfmt27(0.00001908481202F), Qfmt27(0.10262701466139F), Qfmt27(1.12001978353403F),
+    Qfmt27(0.01663452156443F), Qfmt27(0.00766458213130F), Qfmt27(0.00028892665922F), Qfmt27(0.10479373974558F),
+    Qfmt27(1.13624787143434F), Qfmt27(0.02941522773279F), Qfmt27(0.00741912981120F), Qfmt27(0.00056943874774F),
+    Qfmt27(0.10650970405576F), Qfmt27(1.15091404672203F), Qfmt27(0.04112872592057F), Qfmt27(0.00712664923329F),
+    Qfmt27(0.00088238158168F), Qfmt27(0.10776200996423F), Qfmt27(1.16395714324633F), Qfmt27(0.05181934748033F),
+    Qfmt27(0.00677868764313F), Qfmt27(0.00121741725989F), Qfmt27(0.10848340171661F), Qfmt27(1.17535833075364F),
+    Qfmt27(0.06148559051724F), Qfmt27(0.00639363830229F), Qfmt27(0.00159101288509F), Qfmt27(0.10864412991640F),
+    Qfmt27(1.18507099110810F), Qfmt27(0.07014197759039F), Qfmt27(0.00597707038378F), Qfmt27(0.00196610899088F),
+    Qfmt27(0.10819451041273F), Qfmt27(1.19306425909871F), Qfmt27(0.07784680399703F), Qfmt27(0.00554476792518F),
+    Qfmt27(0.00238550675072F), Qfmt27(0.10709920766553F), Qfmt27(1.19929775892826F), Qfmt27(0.08459352758522F),
+    Qfmt27(0.00509233837916F), Qfmt27(0.00280596092809F), Qfmt27(0.10531144797543F), Qfmt27(1.20377455661175F),
+    Qfmt27(0.09043115226911F), Qfmt27(0.00463008004888F), Qfmt27(0.00325513071185F), Qfmt27(0.10278145526768F),
+    Qfmt27(1.20646855283790F), Qfmt27(0.09539224314440F), Qfmt27(0.00416760958657F)
+};
+
+
+
+#ifdef HQ_SBR
+
+
+const Int32 sbrDecoderFilterbankCoefficients_an_filt[155] =
+{
+    Qfmt27(-0.000561769F),   Qfmt27(+ 0.015540555F),   Qfmt27(+ 0.383635001F),   Qfmt27(-0.338872269F),   Qfmt27(-0.011131555F),
+    Qfmt27(-0.000487523F),   Qfmt27(+ 0.017943338F),   Qfmt27(+ 0.406231768F),   Qfmt27(-0.316827891F),   Qfmt27(-0.009132533F),
+    Qfmt27(-0.000504071F),   Qfmt27(+ 0.020453179F),   Qfmt27(+ 0.428911992F),   Qfmt27(-0.295071672F),   Qfmt27(-0.007261582F),
+    Qfmt27(-0.000546657F),   Qfmt27(+ 0.023068017F),   Qfmt27(+ 0.451599654F),   Qfmt27(-0.273663404F),   Qfmt27(-0.005533721F),
+    Qfmt27(-0.000587093F),   Qfmt27(+ 0.025787585F),   Qfmt27(+ 0.474245321F),   Qfmt27(-0.252648031F),   Qfmt27(-0.003940112F),
+    Qfmt27(-0.000631249F),   Qfmt27(+ 0.028607217F),   Qfmt27(+ 0.496770825F),   Qfmt27(-0.232069087F),   Qfmt27(-0.002482672F),
+    Qfmt27(-0.000677769F),   Qfmt27(+ 0.031501761F),   Qfmt27(+ 0.519123497F),   Qfmt27(-0.211973585F),   Qfmt27(-0.001156814F),
+    Qfmt27(-0.000715774F),   Qfmt27(+ 0.034462095F),   Qfmt27(+ 0.541255345F),   Qfmt27(-0.192396675F),   Qfmt27(+ 0.000027605F),
+    Qfmt27(-0.000744094F),   Qfmt27(+ 0.037481285F),   Qfmt27(+ 0.563078914F),   Qfmt27(-0.173380817F),   Qfmt27(+ 0.001090233F),
+    Qfmt27(-0.000768137F),   Qfmt27(+ 0.040534917F),   Qfmt27(+ 0.584540324F),   Qfmt27(-0.154960707F),   Qfmt27(+ 0.002027418F),
+    Qfmt27(-0.000783433F),   Qfmt27(+ 0.043609754F),   Qfmt27(+ 0.605578354F),   Qfmt27(-0.137155176F),   Qfmt27(+ 0.002844676F),
+    Qfmt27(-0.000780366F),   Qfmt27(+ 0.046684303F),   Qfmt27(+ 0.626124270F),   Qfmt27(-0.120007798F),   Qfmt27(+ 0.003540125F),
+    Qfmt27(-0.000775798F),   Qfmt27(+ 0.049738576F),   Qfmt27(+ 0.646126970F),   Qfmt27(-0.103532953F),   Qfmt27(+ 0.004125164F),
+    Qfmt27(-0.000753000F),   Qfmt27(+ 0.052763075F),   Qfmt27(+ 0.665513988F),   Qfmt27(-0.087754754F),   Qfmt27(+ 0.004603953F),
+    Qfmt27(-0.000721539F),   Qfmt27(+ 0.055717365F),   Qfmt27(+ 0.684235329F),   Qfmt27(-0.072694330F),   Qfmt27(+ 0.004983969F),
+    Qfmt27(-0.000665042F),   Qfmt27(+ 0.058591568F),   Qfmt27(+ 0.702238872F),   Qfmt27(-0.058370533F),   Qfmt27(+ 0.005271576F),
+    Qfmt27(-0.000594612F),   Qfmt27(+ 0.061345517F),   Qfmt27(+ 0.719446263F),   Qfmt27(-0.044780682F),   Qfmt27(+ 0.005475378F),
+    Qfmt27(-0.000514557F),   Qfmt27(+ 0.063971590F),   Qfmt27(+ 0.735821176F),   Qfmt27(-0.031953127F),   Qfmt27(+ 0.005591713F),
+    Qfmt27(-0.000409512F),   Qfmt27(+ 0.066436751F),   Qfmt27(+ 0.751313746F),   Qfmt27(-0.019883413F),   Qfmt27(+ 0.005638920F),
+    Qfmt27(-0.000289698F),   Qfmt27(+ 0.068704383F),   Qfmt27(+ 0.765867487F),   Qfmt27(-0.008571175F),   Qfmt27(+ 0.005622064F),
+    Qfmt27(-0.000144638F),   Qfmt27(+ 0.070762871F),   Qfmt27(+ 0.779428752F),   Qfmt27(+ 0.001976560F),   Qfmt27(+ 0.005547571F),
+    Qfmt27(+ 0.000013495F),   Qfmt27(+ 0.072568258F),   Qfmt27(+ 0.791973584F),   Qfmt27(+ 0.011762383F),   Qfmt27(+ 0.005419678F),
+    Qfmt27(+ 0.000204302F),   Qfmt27(+ 0.074100364F),   Qfmt27(+ 0.803448575F),   Qfmt27(+ 0.020799707F),   Qfmt27(+ 0.005246117F),
+    Qfmt27(+ 0.000402654F),   Qfmt27(+ 0.075313734F),   Qfmt27(+ 0.813819127F),   Qfmt27(+ 0.029082401F),   Qfmt27(+ 0.005039302F),
+    Qfmt27(+ 0.000623938F),   Qfmt27(+ 0.076199248F),   Qfmt27(+ 0.823041989F),   Qfmt27(+ 0.036641812F),   Qfmt27(+ 0.004793256F),
+    Qfmt27(+ 0.000860844F),   Qfmt27(+ 0.076709349F),   Qfmt27(+ 0.831103846F),   Qfmt27(+ 0.043476878F),   Qfmt27(+ 0.004520985F),
+    Qfmt27(+ 0.001125016F),   Qfmt27(+ 0.076823001F),   Qfmt27(+ 0.837971734F),   Qfmt27(+ 0.049597868F),   Qfmt27(+ 0.004226427F),
+    Qfmt27(+ 0.001390249F),   Qfmt27(+ 0.076505072F),   Qfmt27(+ 0.843623828F),   Qfmt27(+ 0.055046003F),   Qfmt27(+ 0.003920743F),
+    Qfmt27(+ 0.001686808F),   Qfmt27(+ 0.075730576F),   Qfmt27(+ 0.848031578F),   Qfmt27(+ 0.059816657F),   Qfmt27(+ 0.003600827F),
+    Qfmt27(+ 0.001984114F),   Qfmt27(+ 0.074466439F),   Qfmt27(+ 0.851197152F),   Qfmt27(+ 0.063944481F),   Qfmt27(+ 0.003273961F),
+    Qfmt27(+ 0.002301725F),   Qfmt27(+ 0.072677464F),   Qfmt27(+ 0.853102095F),   Qfmt27(+ 0.067452502F),   Qfmt27(+ 0.002946945F)
+};
+
+
+
+#endif  /* HQ_SBR */
+
+
+#endif  /* AAC_PLUS */
diff --git a/media/libstagefright/codecs/aacdec/qmf_filterbank_coeff.h b/media/libstagefright/codecs/aacdec/qmf_filterbank_coeff.h
new file mode 100644
index 0000000..c8968cb
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/qmf_filterbank_coeff.h
@@ -0,0 +1,99 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Pathname: qmf_filterbank_coeff.h
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+
+------------------------------------------------------------------------------
+ INCLUDE DESCRIPTION
+
+ this file declares the scalefactor bands for all sampling rates
+
+------------------------------------------------------------------------------
+*/
+
+
+/*----------------------------------------------------------------------------
+; CONTINUE ONLY IF NOT ALREADY DEFINED
+----------------------------------------------------------------------------*/
+#ifndef QMF_FILTERBANK_COEFF_H
+#define QMF_FILTERBANK_COEFF_H
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+#include "pv_audio_type_defs.h"
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here.
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL VARIABLES REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+#define Qfmt(x)   (Int16)(x*(((Int32)1<<15)*1.11111111111111111F) + (x>=0?0.5F:-0.5F))
+
+
+#define Qfmt30(x)   (Int32)(x*((Int32)1<<30) + (x>=0?0.5F:-0.5F))
+#define Qfmt27(x)   (Int32)(x*(((Int32)1<<27)) + (x>=0?0.5F:-0.5F))
+
+extern const Int32 sbrDecoderFilterbankCoefficients[155];
+
+
+extern const Int32 sbrDecoderFilterbankCoefficients_down_smpl[160];
+extern const Int32 sbrDecoderFilterbankCoefficients_an_filt_LC[155];
+
+#ifdef HQ_SBR
+extern const Int32 sbrDecoderFilterbankCoefficients_an_filt[155];
+#endif
+
+/*----------------------------------------------------------------------------
+; SIMPLE TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; ENUMERATED TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; STRUCTURES TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; GLOBAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; END
+----------------------------------------------------------------------------*/
+#endif
+
+
diff --git a/media/libstagefright/codecs/aacdec/s_adif_header.h b/media/libstagefright/codecs/aacdec/s_adif_header.h
new file mode 100644
index 0000000..7fd49d3
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/s_adif_header.h
@@ -0,0 +1,98 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Pathname: s_ADIF_Header.h
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+ Who:                       Date:
+ Description:
+
+------------------------------------------------------------------------------
+ INCLUDE DESCRIPTION
+
+ This include file defines the structure, ADIF_Header
+
+------------------------------------------------------------------------------
+*/
+
+/*----------------------------------------------------------------------------
+; CONTINUE ONLY IF NOT ALREADY DEFINED
+----------------------------------------------------------------------------*/
+#ifndef S_ADIF_HEADER_H
+#define S_ADIF_HEADER_H
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+#include "pv_audio_type_defs.h"
+#include "e_adif_const.h"
+#include "e_rawbitstreamconst.h"
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here.
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL VARIABLES REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; SIMPLE TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; ENUMERATED TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; STRUCTURES TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+typedef struct
+{
+    Char    adif_id[LEN_ADIF_ID+1];
+    Int     copy_id_present;
+    Char    copy_id[LEN_COPYRT_ID+1];
+    Int     original_copy;
+    Int     home;
+    Int     bitstream_type;
+    Int32   bitrate;
+    Int     num_pce;
+    Int     prog_tags[(1<<LEN_TAG)];
+} ADIF_Header;
+
+/*----------------------------------------------------------------------------
+; GLOBAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; END
+----------------------------------------------------------------------------*/
+#endif
+
diff --git a/media/libstagefright/codecs/aacdec/s_bit_buffer.h b/media/libstagefright/codecs/aacdec/s_bit_buffer.h
new file mode 100644
index 0000000..9f0dbda
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/s_bit_buffer.h
@@ -0,0 +1,93 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Filename: s_bit_buffer.h
+ Funtions:
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+
+ Who:                                   Date: MM/DD/YYYY
+ Description:
+------------------------------------------------------------------------------
+
+----------------------------------------------------------------------------
+; CONTINUE ONLY IF NOT ALREADY DEFINED
+----------------------------------------------------------------------------*/
+#ifndef S_BIT_BUFFER_H
+#define S_BIT_BUFFER_H
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+
+#include "pv_audio_type_defs.h"
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here.
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL VARIABLES REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; SIMPLE TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; ENUMERATED TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; STRUCTURES TYPEDEF'S
+----------------------------------------------------------------------------*/
+typedef struct
+{
+    UChar *char_ptr;
+    UInt32 buffered_bits;
+    UInt32 buffer_word;
+    UInt32 nrBitsRead;
+    UInt32 bufferLen;
+}
+BIT_BUFFER;
+
+typedef BIT_BUFFER *HANDLE_BIT_BUFFER;
+
+
+/*----------------------------------------------------------------------------
+; GLOBAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+
+
+/*----------------------------------------------------------------------------
+; END
+----------------------------------------------------------------------------*/
+#endif
+
+
diff --git a/media/libstagefright/codecs/aacdec/s_bits.h b/media/libstagefright/codecs/aacdec/s_bits.h
new file mode 100644
index 0000000..cae69ad
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/s_bits.h
@@ -0,0 +1,112 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Pathname: s_BITS.h
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+ Description: Remove unused field.
+
+ Description: Change buffer type from UInt to UInt32, makes API much easier
+              to understand and describe, and getbits is faster on TI C55X
+              if the buffer is 32 bits instead of 16.
+
+ Description: Change buffer type from UInt32 to UChar.
+
+ Who:                                   Date:
+ Description:
+
+------------------------------------------------------------------------------
+ INCLUDE DESCRIPTION
+
+ This include file defines the structure, BITS
+
+------------------------------------------------------------------------------
+*/
+
+/*----------------------------------------------------------------------------
+; CONTINUE ONLY IF NOT ALREADY DEFINED
+----------------------------------------------------------------------------*/
+#ifndef  S_BITS_H
+#define  S_BITS_H
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+#include "pv_audio_type_defs.h"
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here.
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL VARIABLES REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; SIMPLE TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; ENUMERATED TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; STRUCTURES TYPEDEF'S
+----------------------------------------------------------------------------*/
+/*
+ * Name: BITS
+ * Description: Holds information for processing the input data buffer
+ *    as a "stream". The data is in packed format.
+ * Fields:
+ *    pBuffer - pointer to the beginning of the buffer. If the data type of
+ *        this changes, make sure to update the constants in ibstream.h
+ *    usedBits - number of bits read thus far from the buffer. Bit 0 is
+ *        the LSB of pBuffer[0].
+ *    availableBits - number of bits available in the buffer.
+ *    byteAlignOffset - used with ADTS in case sync word is not aligned
+                        on a boundary.
+ */
+typedef struct
+{
+    UChar    *pBuffer;
+    UInt      usedBits;      /* Keep this unsigned so can go to 65536 */
+    UInt      availableBits; /* Ditto */
+    UInt      inputBufferCurrentLength; /* Ditto */
+    Int      byteAlignOffset; /* Used in ADTS.  See find_adts_syncword() */
+} BITS;
+
+/*----------------------------------------------------------------------------
+; GLOBAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; END
+----------------------------------------------------------------------------*/
+#endif
+
diff --git a/media/libstagefright/codecs/aacdec/s_ch_info.h b/media/libstagefright/codecs/aacdec/s_ch_info.h
new file mode 100644
index 0000000..9fd259c
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/s_ch_info.h
@@ -0,0 +1,103 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Pathname: s_Ch_Info.h
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+ Who:                       Date:
+ Description:
+
+------------------------------------------------------------------------------
+ INCLUDE DESCRIPTION
+
+ This include file defines the structure, Ch_Info
+
+------------------------------------------------------------------------------
+*/
+
+/*----------------------------------------------------------------------------
+; CONTINUE ONLY IF NOT ALREADY DEFINED
+----------------------------------------------------------------------------*/
+#ifndef S_CH_INFO_H
+#define S_CH_INFO_H
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+#include "pv_audio_type_defs.h"
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here.
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL VARIABLES REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; SIMPLE TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; ENUMERATED TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; STRUCTURES TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+typedef struct
+{
+//    Int present;    /* channel present */
+    Int tag;        /* element tag */
+    Int cpe;        /* 0 if single channel, 1 if channel pair */
+//    Int common_window;  /* 1 if common window for cpe */
+//    Int ch_is_left; /* 1 if left channel of cpe */
+//    Int paired_ch;  /* index of paired channel in cpe */
+//    Int widx;       /* window element index for this channel */
+    Int is_present; /* intensity stereo is used */
+    Int ncch;       /* number of coupling channels for this ch */
+    /* #if (CChans > 0) */
+    /*    int cch[CChans];*/    /* coupling channel idx */
+    /*    int cc_dom[CChans];*/ /* coupling channel domain */
+    /*    int cc_ind[CChans];*/ /* independently switched coupling channel flag */
+    /* #endif */
+    Char *fext;     /* filename extension */
+
+} Ch_Info;
+
+/*----------------------------------------------------------------------------
+; GLOBAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; END
+----------------------------------------------------------------------------*/
+#endif
+
diff --git a/media/libstagefright/codecs/aacdec/s_crc_buffer.h b/media/libstagefright/codecs/aacdec/s_crc_buffer.h
new file mode 100644
index 0000000..69250e7
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/s_crc_buffer.h
@@ -0,0 +1,90 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Filename: s_crc_buffer.h
+ Funtions:
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+
+ Who:                                   Date: MM/DD/YYYY
+ Description:
+------------------------------------------------------------------------------
+
+
+----------------------------------------------------------------------------
+; CONTINUE ONLY IF NOT ALREADY DEFINED
+----------------------------------------------------------------------------*/
+#ifndef S_CRC_BUFFER_H
+#define S_CRC_BUFFER_H
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here.
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL VARIABLES REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; SIMPLE TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; ENUMERATED TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; STRUCTURES TYPEDEF'S
+----------------------------------------------------------------------------*/
+typedef struct
+{
+    unsigned short crcState;
+    unsigned short crcMask;
+    unsigned short crcPoly;
+}
+CRC_BUFFER;
+
+typedef CRC_BUFFER *HANDLE_CRC;
+
+
+/*----------------------------------------------------------------------------
+; GLOBAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+
+
+/*----------------------------------------------------------------------------
+; END
+----------------------------------------------------------------------------*/
+#endif
+
+
diff --git a/media/libstagefright/codecs/aacdec/s_elelist.h b/media/libstagefright/codecs/aacdec/s_elelist.h
new file mode 100644
index 0000000..40b2f13
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/s_elelist.h
@@ -0,0 +1,90 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Pathname: s_EleList.h
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+ Who:                       Date:
+ Description:
+
+------------------------------------------------------------------------------
+ INCLUDE DESCRIPTION
+
+ This include file defines the structure, EleList
+
+------------------------------------------------------------------------------
+*/
+
+/*----------------------------------------------------------------------------
+; CONTINUE ONLY IF NOT ALREADY DEFINED
+----------------------------------------------------------------------------*/
+#ifndef S_ELELIST_H
+#define S_ELELIST_H
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+#include "pv_audio_type_defs.h"
+#include "e_rawbitstreamconst.h"
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here.
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL VARIABLES REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; SIMPLE TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; ENUMERATED TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; STRUCTURES TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+typedef struct
+{
+    Int num_ele;
+    Int ele_is_cpe[(1<<LEN_TAG)];
+    Int ele_tag[(1<<LEN_TAG)];
+} EleList;
+
+/*----------------------------------------------------------------------------
+; GLOBAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; END
+----------------------------------------------------------------------------*/
+#endif
diff --git a/media/libstagefright/codecs/aacdec/s_frameinfo.h b/media/libstagefright/codecs/aacdec/s_frameinfo.h
new file mode 100644
index 0000000..871ae83
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/s_frameinfo.h
@@ -0,0 +1,127 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Pathname: s_frameinfo.h
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+ Description: Changed name of bk_sfb_top to frame_sfb_top.
+ Included "interface.h" for defintion of MAX_WIN.  This
+ will hopefully be simplified when interface.h is broken up into smaller
+ include files.
+
+ Description: Eliminated the never used array, group_offs[8]
+
+ Description:
+ (1) Modified to include the lines...
+
+    #ifdef __cplusplus
+    extern "C" {
+    #endif
+
+    #ifdef __cplusplus
+    }
+    #endif
+
+ (2) Updated the copyright header.
+
+ Description:
+
+------------------------------------------------------------------------------
+ INCLUDE DESCRIPTION
+
+ This include file defines the structure, FrameInfo
+
+------------------------------------------------------------------------------
+*/
+
+/*----------------------------------------------------------------------------
+; CONTINUE ONLY IF NOT ALREADY DEFINED
+----------------------------------------------------------------------------*/
+#ifndef S_FRAMEINFO_H
+#define S_FRAMEINFO_H
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+    /*----------------------------------------------------------------------------
+    ; INCLUDES
+    ----------------------------------------------------------------------------*/
+#include "pv_audio_type_defs.h"
+#include "e_blockswitching.h"
+
+    /*----------------------------------------------------------------------------
+    ; MACROS
+    ; Define module specific macros here
+    ----------------------------------------------------------------------------*/
+
+    /*----------------------------------------------------------------------------
+    ; DEFINES
+    ; Include all pre-processor statements here.
+    ----------------------------------------------------------------------------*/
+
+    /*----------------------------------------------------------------------------
+    ; EXTERNAL VARIABLES REFERENCES
+    ; Declare variables used in this module but defined elsewhere
+    ----------------------------------------------------------------------------*/
+
+    /*----------------------------------------------------------------------------
+    ; SIMPLE TYPEDEF'S
+    ----------------------------------------------------------------------------*/
+
+    /*----------------------------------------------------------------------------
+    ; ENUMERATED TYPEDEF'S
+    ----------------------------------------------------------------------------*/
+
+    /*----------------------------------------------------------------------------
+    ; STRUCTURES TYPEDEF'S
+    ----------------------------------------------------------------------------*/
+    typedef struct
+    {
+        Int     islong;                 /* true if long block */
+        Int     num_win;                /* sub-blocks (SB) per block */
+        Int     coef_per_frame;         /* coef's per block */
+        Int     sfb_per_frame;          /* sfb per block */
+        Int     coef_per_win[MAX_WIN];  /* coef's per SB */
+        Int     sfb_per_win[MAX_WIN];   /* sfb per SB */
+        Int     sectbits[MAX_WIN];
+        Int16   *win_sfb_top[MAX_WIN];  /* top coef per sfb per SB */
+        Int     *sfb_width_128;         /* sfb width for short blocks */
+
+        Int     frame_sfb_top[MAXBANDS];    /* Only used in calc_gsfb_table() -
+                                      it is simply a cum version of
+                                      the above information */
+        Int     num_groups;
+        Int     group_len[8];
+
+    } FrameInfo;
+
+    /*----------------------------------------------------------------------------
+    ; GLOBAL FUNCTION DEFINITIONS
+    ; Function Prototype declaration
+    ----------------------------------------------------------------------------*/
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* S_FRAMEINFO_H */
diff --git a/media/libstagefright/codecs/aacdec/s_hcb.h b/media/libstagefright/codecs/aacdec/s_hcb.h
new file mode 100644
index 0000000..6a64c27
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/s_hcb.h
@@ -0,0 +1,123 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Pathname: s_Hcb.h
+
+     Date: 05/07/2001
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+ Description:
+ (1) Modified to include the lines...
+
+    #ifdef __cplusplus
+    extern "C" {
+    #endif
+
+    #ifdef __cplusplus
+    }
+    #endif
+
+ (2) Updated the copyright header.
+
+ Description:
+ (1) LAV removed from structure definition, since it was never used.
+
+ Description: Huffman tables are stored as UInt16
+
+ Description: Modified the declaration of the structure so no pointers are
+              used in the structure.
+
+ Who:                       Date:
+ Description:
+
+------------------------------------------------------------------------------
+ INCLUDE DESCRIPTION
+
+ define the structure Hcb to store Huffman codebook information,
+ this structure was originally defined in all.h
+
+------------------------------------------------------------------------------
+*/
+
+/*----------------------------------------------------------------------------
+; CONTINUE ONLY IF NOT ALREADY DEFINED
+----------------------------------------------------------------------------*/
+#ifndef S_HCB_H
+#define S_HCB_H
+
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+#include    "pv_audio_type_defs.h"
+#include    "s_huffman.h"
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+    /*----------------------------------------------------------------------------
+    ; MACROS
+    ; Define module specific macros here
+    ----------------------------------------------------------------------------*/
+
+    /*----------------------------------------------------------------------------
+    ; DEFINES
+    ; Include all pre-processor statements here.
+    ----------------------------------------------------------------------------*/
+
+    /*----------------------------------------------------------------------------
+    ; EXTERNAL VARIABLES REFERENCES
+    ; Declare variables used in this module but defined elsewhere
+    ----------------------------------------------------------------------------*/
+
+    /*----------------------------------------------------------------------------
+    ; SIMPLE TYPEDEF'S
+    ----------------------------------------------------------------------------*/
+
+    /*----------------------------------------------------------------------------
+    ; ENUMERATED TYPEDEF'S
+    ----------------------------------------------------------------------------*/
+
+    /*----------------------------------------------------------------------------
+    ; STRUCTURES TYPEDEF'S
+    ----------------------------------------------------------------------------*/
+    typedef struct
+    {
+        Int     n;
+        Int     dim;
+        Int     mod;
+        Int     off;
+        Int     signed_cb;
+    } Hcb;
+
+    /*----------------------------------------------------------------------------
+    ; GLOBAL FUNCTION DEFINITIONS
+    ; Function Prototype declaration
+    ----------------------------------------------------------------------------*/
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* S_HCB_H */
+
diff --git a/media/libstagefright/codecs/aacdec/s_huffman.h b/media/libstagefright/codecs/aacdec/s_huffman.h
new file mode 100644
index 0000000..2db3dd9
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/s_huffman.h
@@ -0,0 +1,91 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Pathname: s_Huffman.h
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+ Description:   Changed "ulong" to "UInt32"
+
+ Description: add helper structure to speed up decode_huff_cw
+
+ Description: Remove the structure definition of Huffman
+
+ Description: Added definition for SBR Huffman, used for AAC plus
+
+ Who:                       Date:
+ Description:
+------------------------------------------------------------------------------
+ INCLUDE DESCRIPTION
+
+ This include file defines the structure, Huffman
+
+------------------------------------------------------------------------------
+*/
+
+/*----------------------------------------------------------------------------
+; CONTINUE ONLY IF NOT ALREADY DEFINED
+----------------------------------------------------------------------------*/
+#ifndef S_HUFFMAN_H
+#define S_HUFFMAN_H
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+#include "pv_audio_type_defs.h"
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here.
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL VARIABLES REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; SIMPLE TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; ENUMERATED TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; STRUCTURES TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+typedef const Char(*SbrHuffman)[2];
+
+/*----------------------------------------------------------------------------
+; GLOBAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; END
+----------------------------------------------------------------------------*/
+#endif
diff --git a/media/libstagefright/codecs/aacdec/s_hybrid.h b/media/libstagefright/codecs/aacdec/s_hybrid.h
new file mode 100644
index 0000000..3880d30
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/s_hybrid.h
@@ -0,0 +1,100 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Filename: s_hybrid.h
+ Funtions:
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+
+ Who:                                   Date: MM/DD/YYYY
+ Description:
+------------------------------------------------------------------------------
+
+
+----------------------------------------------------------------------------
+; CONTINUE ONLY IF NOT ALREADY DEFINED
+----------------------------------------------------------------------------*/
+#ifndef S_HYBRID_H
+#define S_HYBRID_H
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+
+#include    "ps_constants.h"
+#include    "pv_audio_type_defs.h"
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here.
+----------------------------------------------------------------------------*/
+#define HYBRID_FILTER_LENGTH        13
+#define HYBRID_FILTER_LENGTH_m_1    12
+#define HYBRID_FILTER_DELAY         6
+
+/*----------------------------------------------------------------------------
+; EXTERNAL VARIABLES REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; SIMPLE TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; ENUMERATED TYPEDEF'S
+----------------------------------------------------------------------------*/
+typedef enum
+{
+
+    HYBRID_2_REAL = 2,
+    HYBRID_4_CPLX = 4,
+    HYBRID_8_CPLX = 8
+
+} HYBRID_RES;
+
+/*----------------------------------------------------------------------------
+; STRUCTURES TYPEDEF'S
+----------------------------------------------------------------------------*/
+typedef struct
+{
+    Int32   nQmfBands;
+    Int32   *pResolution;
+    Int32   qmfBufferMove;
+
+    Int32 **mQmfBufferReal;
+    Int32 **mQmfBufferImag;
+    Int32 *mTempReal;
+    Int32 *mTempImag;
+
+
+} HYBRID;
+
+/*----------------------------------------------------------------------------
+; END
+----------------------------------------------------------------------------*/
+
+#endif      /*  S_HYBRID_H */
diff --git a/media/libstagefright/codecs/aacdec/s_lt_pred_status.h b/media/libstagefright/codecs/aacdec/s_lt_pred_status.h
new file mode 100644
index 0000000..4b5b56e
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/s_lt_pred_status.h
@@ -0,0 +1,174 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Pathname: LT_PRED_STATUS.h
+
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+ Description:
+ (1) Merged in #defines from ltp_common.h, thereby eliminating that file.
+
+ Description:
+ (1) Modified to include the lines...
+
+    #ifdef __cplusplus
+    extern "C" {
+    #endif
+
+    #ifdef __cplusplus
+    }
+    #endif
+
+ (2) Updated the copyright header.
+
+ Description: Moved large ltp_buffer up to s_tDec_Int_Chan.h, since this
+ move allowed for other elements in this structure to be shared with
+ the fxpCoef array.
+
+ Description: Decreased size of LTP buffers from 4096 to 3072.  The upper 1024
+ elements in the LTP buffers were never touched in the code.  This saves
+ 4 kilobytes in memory.
+
+ Description: Decreased size of LTP buffers again from 3072 to 2048.  This
+ time, I realized that 1024 elements were duplicated in the 32-bit array
+ pVars->pChVars[]->time_quant.  Rather than copy this data EVERY frame
+ from a 32-bit to a 16-bit LTP buffer, the data is accessed only
+ when it is needed.  This saves both MIPS and memory.
+
+ Who:                       Date:
+ Description:
+------------------------------------------------------------------------------
+ INCLUDE DESCRIPTION
+
+ define LT_PRED_STATUS structure for pulse data decoding.
+
+------------------------------------------------------------------------------
+*/
+
+/*----------------------------------------------------------------------------
+; CONTINUE ONLY IF NOT ALREADY DEFINED
+----------------------------------------------------------------------------*/
+#ifndef S_LT_PRED_STATUS_H
+#define S_LT_PRED_STATUS_H
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+    /*----------------------------------------------------------------------------
+    ; INCLUDES
+    ----------------------------------------------------------------------------*/
+#include "pv_audio_type_defs.h"
+#include "e_blockswitching.h"
+
+    /*----------------------------------------------------------------------------
+    ; MACROS
+    ; Define module specific macros here
+    ----------------------------------------------------------------------------*/
+
+    /*----------------------------------------------------------------------------
+    ; DEFINES
+    ; Include all pre-processor statements here.
+    ----------------------------------------------------------------------------*/
+    /*
+      Macro:    MAX_SHORT_WINDOWS
+      Purpose:  Number of short windows in one long window.
+      Explanation:  -  */
+#ifndef MAX_SHORT_WINDOWS
+#define MAX_SHORT_WINDOWS NSHORT
+#endif
+
+    /*
+      Macro:    MAX_SCFAC_BANDS
+      Purpose:  Maximum number of scalefactor bands in one frame.
+      Explanation:  -  */
+#ifndef MAX_SCFAC_BANDS
+#define MAX_SCFAC_BANDS MAXBANDS
+#endif
+
+    /*
+      Macro:    BLOCK_LEN_LONG
+      Purpose:  Length of one long window
+      Explanation:  -  */
+#ifndef BLOCK_LEN_LONG
+#define BLOCK_LEN_LONG LN2
+#endif
+
+
+    /*
+      Macro:    LTP_MAX_BLOCK_LEN_LONG
+      Purpose:  Informs the routine of the maximum block size used.
+      Explanation:  This is needed since the TwinVQ long window
+            is different from the AAC long window.  */
+#define LTP_MAX_BLOCK_LEN_LONG BLOCK_LEN_LONG //(2 * BLOCK_LEN_LONG) 
+
+    /*
+      Macro:    LT_BLEN
+      Purpose:  Length of the history buffer.
+      Explanation:  Has to hold 2 long windows of time domain data.  */
+#ifndef LT_BLEN
+#define LT_BLEN (2 * LTP_MAX_BLOCK_LEN_LONG)
+#endif
+
+    /*----------------------------------------------------------------------------
+    ; EXTERNAL VARIABLES REFERENCES
+    ; Declare variables used in this module but defined elsewhere
+    ----------------------------------------------------------------------------*/
+
+    /*----------------------------------------------------------------------------
+    ; SIMPLE TYPEDEF'S
+    ----------------------------------------------------------------------------*/
+
+    /*----------------------------------------------------------------------------
+    ; ENUMERATED TYPEDEF'S
+    ----------------------------------------------------------------------------*/
+
+    /*----------------------------------------------------------------------------
+    ; STRUCTURES TYPEDEF'S
+    ----------------------------------------------------------------------------*/
+    /*
+      Type:     LT_PRED_STATUS
+      Purpose:  Type of the struct holding the LTP encoding parameters.
+      Explanation:  -  */
+    typedef struct
+    {
+        Int weight_index;
+        Int win_prediction_used[MAX_SHORT_WINDOWS];
+        Int sfb_prediction_used[MAX_SCFAC_BANDS];
+        Bool ltp_data_present;
+
+        Int delay[MAX_SHORT_WINDOWS];
+    }
+    LT_PRED_STATUS;
+
+    /*----------------------------------------------------------------------------
+    ; GLOBAL FUNCTION DEFINITIONS
+    ; Function Prototype declaration
+    ----------------------------------------------------------------------------*/
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* S_LT_PRED_STATUS_H */
+
+
diff --git a/media/libstagefright/codecs/aacdec/s_mc_info.h b/media/libstagefright/codecs/aacdec/s_mc_info.h
new file mode 100644
index 0000000..9006119
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/s_mc_info.h
@@ -0,0 +1,116 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Pathname: s_MC_Info.h
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+ Description: (1) use enum type for audioObjectType (2) update revision history
+
+ Who:                       Date:
+ Description:
+------------------------------------------------------------------------------
+ INCLUDE DESCRIPTION
+
+ This include file defines the structure, MC_Info
+
+------------------------------------------------------------------------------
+*/
+
+/*----------------------------------------------------------------------------
+; CONTINUE ONLY IF NOT ALREADY DEFINED
+----------------------------------------------------------------------------*/
+#ifndef S_MC_INFO_H
+#define S_MC_INFO_H
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+#include "pv_audio_type_defs.h"
+#include "e_rawbitstreamconst.h"
+#include "s_ch_info.h"
+#include "chans.h"
+#include "e_tmp4audioobjecttype.h"
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here.
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL VARIABLES REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; SIMPLE TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; ENUMERATED TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; STRUCTURES TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+typedef struct
+{
+    Int nch;        /* total number of audio channels */
+    Int nfsce;      /* number of front SCE's pror to first front CPE */
+    Int nfch;       /* number of front channels */
+    Int nsch;       /* number of side channels */
+    Int nbch;       /* number of back channels */
+    Int nlch;       /* number of lfe channels */
+    Int ncch;       /* number of valid coupling channels */
+    tMP4AudioObjectType audioObjectType;    /* Should eventually be called object */
+    Int sampling_rate_idx;
+
+    Int implicit_channeling;
+    Int  upsamplingFactor;
+#ifdef AAC_PLUS
+    bool bDownSampledSbr;
+    Int HE_AAC_level;
+#endif
+    /* All AAC content should be aware of these flag */
+    /*  AAC+ content Flag */
+    Int sbrPresentFlag;
+    /*  Enhanced AAC+ content Flag */
+    Int psPresentFlag;
+    tMP4AudioObjectType ExtendedAudioObjectType;    /* Should eventually be called object */
+
+    Ch_Info ch_info[Chans];
+} MC_Info;
+
+/*----------------------------------------------------------------------------
+; GLOBAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; END
+----------------------------------------------------------------------------*/
+#endif
+
diff --git a/media/libstagefright/codecs/aacdec/s_mixdown.h b/media/libstagefright/codecs/aacdec/s_mixdown.h
new file mode 100644
index 0000000..7f456d5
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/s_mixdown.h
@@ -0,0 +1,88 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Pathname: s_MIXdown.h
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+ Who:                       Date:
+ Description:
+
+------------------------------------------------------------------------------
+ INCLUDE DESCRIPTION
+
+ This include file defines the structure, MIXdown
+
+------------------------------------------------------------------------------
+*/
+
+/*----------------------------------------------------------------------------
+; CONTINUE ONLY IF NOT ALREADY DEFINED
+----------------------------------------------------------------------------*/
+#ifndef S_MIXDOWN_H
+#define S_MIXDOWN_H
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+#include "pv_audio_type_defs.h"
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here.
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL VARIABLES REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; SIMPLE TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; ENUMERATED TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; STRUCTURES TYPEDEF'S
+----------------------------------------------------------------------------*/
+typedef struct
+{
+    Int present;
+    Int ele_tag;
+    Int pseudo_enab;
+} MIXdown;
+
+/*----------------------------------------------------------------------------
+; GLOBAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; END
+----------------------------------------------------------------------------*/
+#endif
diff --git a/media/libstagefright/codecs/aacdec/s_patch.h b/media/libstagefright/codecs/aacdec/s_patch.h
new file mode 100644
index 0000000..554fc2d
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/s_patch.h
@@ -0,0 +1,121 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Filename: s_patch.h
+ Funtions:
+
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+
+ Who:                                   Date: MM/DD/YYYY
+ Description:
+------------------------------------------------------------------------------
+SC 29 Software Copyright Licencing Disclaimer:
+
+This software module was originally developed by
+  Coding Technologies
+
+and edited by
+  -
+
+in the course of development of the ISO/IEC 13818-7 and ISO/IEC 14496-3
+standards for reference purposes and its performance may not have been
+optimized. This software module is an implementation of one or more tools as
+specified by the ISO/IEC 13818-7 and ISO/IEC 14496-3 standards.
+ISO/IEC gives users free license to this software module or modifications
+thereof for use in products claiming conformance to audiovisual and
+image-coding related ITU Recommendations and/or ISO/IEC International
+Standards. ISO/IEC gives users the same free license to this software module or
+modifications thereof for research purposes and further ISO/IEC standardisation.
+Those intending to use this software module in products are advised that its
+use may infringe existing patents. ISO/IEC have no liability for use of this
+software module or modifications thereof. Copyright is not released for
+products that do not conform to audiovisual and image-coding related ITU
+Recommendations and/or ISO/IEC International Standards.
+The original developer retains full right to modify and use the code for its
+own purpose, assign or donate the code to a third party and to inhibit third
+parties from using the code for products that do not conform to audiovisual and
+image-coding related ITU Recommendations and/or ISO/IEC International Standards.
+This copyright notice must be included in all copies or derivative works.
+Copyright (c) ISO/IEC 2002.
+
+ $Id: ct_envcalc.h,v 1.3 2002/11/29 16:11:49 kaehleof Exp $
+*/
+
+/*----------------------------------------------------------------------------
+; CONTINUE ONLY IF NOT ALREADY DEFINED
+----------------------------------------------------------------------------*/
+#ifndef S_PATCH_H
+#define S_PATCH_H
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here.
+----------------------------------------------------------------------------*/
+#define MAX_NUM_PATCHES   6
+
+#define     SBR_NUM_COLUMNS      38
+#define     SBR_NUM_BANDS        48
+#define     SBR_NUM_BANDS_OVR_4 (SBR_NUM_BANDS>>2)
+
+/*----------------------------------------------------------------------------
+; EXTERNAL VARIABLES REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; SIMPLE TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; ENUMERATED TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; STRUCTURES TYPEDEF'S
+----------------------------------------------------------------------------*/
+struct PATCH
+{
+    Int32 noOfPatches;
+    Int32 targetStartBand[MAX_NUM_PATCHES];
+};
+
+/*----------------------------------------------------------------------------
+; GLOBAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+
+
+/*----------------------------------------------------------------------------
+; END
+----------------------------------------------------------------------------*/
+#endif
+
+
diff --git a/media/libstagefright/codecs/aacdec/s_progconfig.h b/media/libstagefright/codecs/aacdec/s_progconfig.h
new file mode 100644
index 0000000..e58e5fc
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/s_progconfig.h
@@ -0,0 +1,108 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Pathname: s_ProgConfig.h
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+ Who:                       Date:
+ Description:
+
+------------------------------------------------------------------------------
+ INCLUDE DESCRIPTION
+
+ This include file defines the structure, ProgConfig
+
+------------------------------------------------------------------------------
+*/
+
+/*----------------------------------------------------------------------------
+; CONTINUE ONLY IF NOT ALREADY DEFINED
+----------------------------------------------------------------------------*/
+#ifndef S_PROGCONFIG_H
+#define S_PROGCONFIG_H
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+#include "pv_audio_type_defs.h"
+#include "s_mixdown.h"
+#include "s_elelist.h"
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here.
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL VARIABLES REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; SIMPLE TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; ENUMERATED TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; STRUCTURES TYPEDEF'S
+----------------------------------------------------------------------------*/
+typedef struct
+{
+    Int     profile;
+    Int     sampling_rate_idx;
+    EleList front;
+    EleList side;
+    EleList back;
+    EleList lfe;
+    EleList data;
+    EleList coupling;
+    MIXdown mono_mix;
+    MIXdown stereo_mix;
+    MIXdown matrix_mix;
+
+    Char    comments[(1<<LEN_PC_COMM)+1]; /* TO BE DELETED */
+
+    Int32   buffer_fullness;    /* put this transport level info here */
+    Bool    file_is_adts;       /* For ADTS use only */
+    Int32   headerless_frames;  /* For ADTS use only */
+    Int32   frame_length;       /* For use by ADTS only */
+    Int32   CRC_absent;         /* For use by ADTS only */
+    UInt32  CRC_check;          /* For use by ADTS only */
+
+} ProgConfig;
+
+/*----------------------------------------------------------------------------
+; GLOBAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; END
+----------------------------------------------------------------------------*/
+#endif
diff --git a/media/libstagefright/codecs/aacdec/s_ps_dec.h b/media/libstagefright/codecs/aacdec/s_ps_dec.h
new file mode 100644
index 0000000..8b4391c
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/s_ps_dec.h
@@ -0,0 +1,154 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/****************************************************************************
+
+SC 29 Software Copyright Licencing Disclaimer:
+
+This software module was originally developed by
+  Coding Technologies
+
+and edited by
+  -
+
+in the course of development of the ISO/IEC 13818-7 and ISO/IEC 14496-3
+standards for reference purposes and its performance may not have been
+optimized. This software module is an implementation of one or more tools as
+specified by the ISO/IEC 13818-7 and ISO/IEC 14496-3 standards.
+ISO/IEC gives users free license to this software module or modifications
+thereof for use in products claiming conformance to audiovisual and
+image-coding related ITU Recommendations and/or ISO/IEC International
+Standards. ISO/IEC gives users the same free license to this software module or
+modifications thereof for research purposes and further ISO/IEC standardisation.
+Those intending to use this software module in products are advised that its
+use may infringe existing patents. ISO/IEC have no liability for use of this
+software module or modifications thereof. Copyright is not released for
+products that do not conform to audiovisual and image-coding related ITU
+Recommendations and/or ISO/IEC International Standards.
+The original developer retains full right to modify and use the code for its
+own purpose, assign or donate the code to a third party and to inhibit third
+parties from using the code for products that do not conform to audiovisual and
+image-coding related ITU Recommendations and/or ISO/IEC International Standards.
+This copyright notice must be included in all copies or derivative works.
+Copyright (c) ISO/IEC 2003.
+
+*******************************************************************************/
+
+#ifndef S_PS_DEC_H
+#define S_PS_DEC_H
+
+
+#include "s_hybrid.h"
+#include "s_patch.h"
+
+/****************************************************************
+  Type definitions
+ ****************************************************************/
+struct PS_DEC
+{
+
+    Int psDetected;
+    Int32 *R_ch_qmf_filter_history;
+    Int32 invNoSubSamples;
+
+    Int32 bForceMono;
+    UInt32 noSubSamples;
+    Int32 usb;
+    Int32 lastUsb;
+
+    Int32 bPsDataAvail;
+
+    UInt32 bEnableIid;
+    UInt32 bEnableIcc;
+
+    UInt32 bEnableExt;
+    Int32 bFineIidQ;
+
+    Int32 aIidPrevFrameIndex[NO_HI_RES_BINS];
+    Int32 aIccPrevFrameIndex[NO_HI_RES_BINS];
+
+    UInt32 freqResIid;
+    UInt32 freqResIcc;
+
+    UInt32 bFrameClass;
+    UInt32 noEnv;
+    UInt32 aEnvStartStop[MAX_NO_PS_ENV+1];
+
+    UInt32 abIidDtFlag[MAX_NO_PS_ENV];
+    UInt32 abIccDtFlag[MAX_NO_PS_ENV];
+
+    Int32   delayBufIndex;
+
+    UInt32 aDelayRBufIndexSer[NO_SERIAL_ALLPASS_LINKS];
+
+    Int32 **aaaRealDelayRBufferSerQmf[NO_SERIAL_ALLPASS_LINKS];
+    Int32 **aaaImagDelayRBufferSerQmf[NO_SERIAL_ALLPASS_LINKS];
+
+    Int32 **aaaRealDelayRBufferSerSubQmf[NO_SERIAL_ALLPASS_LINKS];
+    Int32 **aaaImagDelayRBufferSerSubQmf[NO_SERIAL_ALLPASS_LINKS];
+
+    Int32 **aaRealDelayBufferQmf;
+    Int32 **aaImagDelayBufferQmf;
+    Int32 **aaRealDelayBufferSubQmf;
+    Int32 **aaImagDelayBufferSubQmf;
+
+    Int32 *aPeakDecayFast;
+    Int32 *aPrevNrg;
+    Int32 *aPrevPeakDiff;
+
+    Int32 *mHybridRealLeft;
+    Int32 *mHybridImagLeft;
+    Int32 *mHybridRealRight;
+    Int32 *mHybridImagRight;
+
+
+    HYBRID *hHybrid;
+
+
+
+    Int32 h11Prev[NO_IID_GROUPS];
+    Int32 h12Prev[NO_IID_GROUPS];
+    Int32 h21Prev[NO_IID_GROUPS];
+    Int32 h22Prev[NO_IID_GROUPS];
+
+    Int32 H11[NO_IID_GROUPS];
+    Int32 H12[NO_IID_GROUPS];
+    Int32 H21[NO_IID_GROUPS];
+    Int32 H22[NO_IID_GROUPS];
+
+    Int32 deltaH11[NO_IID_GROUPS];
+    Int32 deltaH12[NO_IID_GROUPS];
+    Int32 deltaH21[NO_IID_GROUPS];
+    Int32 deltaH22[NO_IID_GROUPS];
+
+    Int32(*qmfBufferReal)[64];
+    Int32(*qmfBufferImag)[64];
+
+    Int32 aDelayBufIndex[NO_DELAY_CHANNELS];
+    Int32 aNoSampleDelay[NO_DELAY_CHANNELS];  /////
+    Int32 aaIidIndex[MAX_NO_PS_ENV+1][NO_HI_RES_BINS];
+    Int32 aaIccIndex[MAX_NO_PS_ENV+1][NO_HI_RES_BINS];
+
+};
+
+typedef struct PS_DEC STRUCT_PS_DEC;
+typedef struct PS_DEC * HANDLE_PS_DEC;
+
+
+
+#endif      /*  E_PS_DEC_H */
+
diff --git a/media/libstagefright/codecs/aacdec/s_pulseinfo.h b/media/libstagefright/codecs/aacdec/s_pulseinfo.h
new file mode 100644
index 0000000..a7ced04
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/s_pulseinfo.h
@@ -0,0 +1,97 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Pathname: s_PulseInfo.h
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+ Description:  Comment out unused field.
+
+ Description:  Fix ARM warnings, update copyright.
+
+ Who:                                       Date:
+ Description:
+
+------------------------------------------------------------------------------
+ INCLUDE DESCRIPTION
+
+ define PulseInfo structure for pulse data decoding.
+
+------------------------------------------------------------------------------
+*/
+
+/*----------------------------------------------------------------------------
+; CONTINUE ONLY IF NOT ALREADY DEFINED
+----------------------------------------------------------------------------*/
+#ifndef S_PULSEINFO_H
+#define S_PULSEINFO_H
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+#include "pv_audio_type_defs.h"
+#include "e_rawbitstreamconst.h"
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here.
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL VARIABLES REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; SIMPLE TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; ENUMERATED TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; STRUCTURES TYPEDEF'S
+----------------------------------------------------------------------------*/
+typedef struct
+{
+    Int pulse_data_present;
+    Int number_pulse;
+    Int pulse_start_sfb;
+    Int pulse_offset[NUM_PULSE_LINES];
+    Int pulse_amp[NUM_PULSE_LINES];
+} PulseInfo;
+
+/*----------------------------------------------------------------------------
+; GLOBAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; END
+----------------------------------------------------------------------------*/
+#endif
+
+
diff --git a/media/libstagefright/codecs/aacdec/s_sbr_channel.h b/media/libstagefright/codecs/aacdec/s_sbr_channel.h
new file mode 100644
index 0000000..99e28dd
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/s_sbr_channel.h
@@ -0,0 +1,115 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Filename: s_sbr_channel.h
+ Funtions:
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+
+ Who:                                   Date: MM/DD/YYYY
+ Description:
+------------------------------------------------------------------------------
+
+
+----------------------------------------------------------------------------
+; CONTINUE ONLY IF NOT ALREADY DEFINED
+----------------------------------------------------------------------------*/
+#ifndef S_SBR_CHANNEL_H
+#define S_SBR_CHANNEL_H
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+
+#include    "s_sbr_frame_data.h"
+#include    "e_sbr_sync_state.h"
+
+#ifdef PARAMETRICSTEREO
+#include "s_ps_dec.h"
+
+#endif
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here.
+----------------------------------------------------------------------------*/
+#define MAXNRELEMENTS 1
+#define MAXNRSBRCHANNELS (MAXNRELEMENTS*2)
+
+#ifdef PARAMETRICSTEREO
+#define MAXNRQMFCHANNELS MAXNRSBRCHANNELS
+#else
+#define MAXNRQMFCHANNELS MAXNRSBRCHANNELS
+#endif
+
+
+/*----------------------------------------------------------------------------
+; EXTERNAL VARIABLES REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; SIMPLE TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; ENUMERATED TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; STRUCTURES TYPEDEF'S
+----------------------------------------------------------------------------*/
+typedef struct
+{
+    Int32 outFrameSize;
+    SBR_SYNC_STATE syncState;
+    SBR_FRAME_DATA frameData;
+
+} SBR_CHANNEL;
+
+typedef struct
+{
+    SBR_CHANNEL SbrChannel[MAXNRSBRCHANNELS];
+    Int32 setStreamType;
+#ifdef PARAMETRICSTEREO
+    HANDLE_PS_DEC hParametricStereoDec;
+    STRUCT_PS_DEC ParametricStereoDec;
+#endif
+
+} SBRDECODER_DATA;
+
+
+/*----------------------------------------------------------------------------
+; GLOBAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+
+
+/*----------------------------------------------------------------------------
+; END
+----------------------------------------------------------------------------*/
+#endif
+
+
diff --git a/media/libstagefright/codecs/aacdec/s_sbr_dec.h b/media/libstagefright/codecs/aacdec/s_sbr_dec.h
new file mode 100644
index 0000000..810479c
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/s_sbr_dec.h
@@ -0,0 +1,145 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Filename: s_sbr_dec.h
+ Funtions:
+    get_dse
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+
+ Who:                                   Date: MM/DD/YYYY
+ Description:
+------------------------------------------------------------------------------
+SC 29 Software Copyright Licencing Disclaimer:
+
+This software module was originally developed by
+  Coding Technologies
+
+and edited by
+  -
+
+in the course of development of the ISO/IEC 13818-7 and ISO/IEC 14496-3
+standards for reference purposes and its performance may not have been
+optimized. This software module is an implementation of one or more tools as
+specified by the ISO/IEC 13818-7 and ISO/IEC 14496-3 standards.
+ISO/IEC gives users free license to this software module or modifications
+thereof for use in products claiming conformance to audiovisual and
+image-coding related ITU Recommendations and/or ISO/IEC International
+Standards. ISO/IEC gives users the same free license to this software module or
+modifications thereof for research purposes and further ISO/IEC standardisation.
+Those intending to use this software module in products are advised that its
+use may infringe existing patents. ISO/IEC have no liability for use of this
+software module or modifications thereof. Copyright is not released for
+products that do not conform to audiovisual and image-coding related ITU
+Recommendations and/or ISO/IEC International Standards.
+The original developer retains full right to modify and use the code for its
+own purpose, assign or donate the code to a third party and to inhibit third
+parties from using the code for products that do not conform to audiovisual and
+image-coding related ITU Recommendations and/or ISO/IEC International Standards.
+This copyright notice must be included in all copies or derivative works.
+Copyright (c) ISO/IEC 2002.
+
+ $Id: ct_envcalc.h,v 1.3 2002/11/29 16:11:49 kaehleof Exp $
+*/
+
+/*----------------------------------------------------------------------------
+; CONTINUE ONLY IF NOT ALREADY DEFINED
+----------------------------------------------------------------------------*/
+#ifndef S_SBR_DEC_H
+#define S_SBR_DEC_H
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+
+#include    "s_sbr_frame_data.h"
+#include    "pv_audio_type_defs.h"
+#include    "s_patch.h"
+#include    "e_blockswitching.h"
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here.
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL VARIABLES REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; SIMPLE TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; ENUMERATED TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; STRUCTURES TYPEDEF'S
+----------------------------------------------------------------------------*/
+typedef struct
+{
+    Int32 outSampleRate;
+    Int32 LC_aacP_DecoderFlag;  /* Low Complexity decoder flag  */
+
+    Int32 startIndexCodecQmf;
+    Int32 lowBandAddSamples;
+    Int32 noCols;
+    Int32 qmfBufLen;
+    Int32 bufWriteOffs;
+    Int32 bufReadOffs;
+
+    Int32 sbStopCodec;
+    Int   lowSubband;
+    Int   prevLowSubband;
+    Int32 highSubband;
+    Int32 noSubbands;
+
+    Int   FreqBandTable[2][MAX_FREQ_COEFFS + 1];
+    Int32 FreqBandTableNoise[MAX_NOISE_COEFFS + 1];
+    Int32 V_k_master[MAX_FREQ_COEFFS + 1];         /* Master BandTable which freqBandTable is derived from*/
+    Int32 NSfb[2];
+    Int32 NoNoiseBands;                            /* Number of noisebands */
+    Int32 Num_Master;                              /* Number of bands in V_k_master*/
+
+    struct PATCH Patch;                         /* Used by sbr_generate_high_freq */
+    /* Used by calc_sbr_envelope */
+    Int32 gateMode[4];
+    Int32 limSbc[4][12 + 1];                            /* Limiting bands */
+
+    Int32 sqrt_cache[8][4];                     /* cache memory for repeated sqrt() calculations */
+
+} SBR_DEC;
+
+
+
+/*----------------------------------------------------------------------------
+; END
+----------------------------------------------------------------------------*/
+#endif
+
+
diff --git a/media/libstagefright/codecs/aacdec/s_sbr_element_stream.h b/media/libstagefright/codecs/aacdec/s_sbr_element_stream.h
new file mode 100644
index 0000000..e9b6780
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/s_sbr_element_stream.h
@@ -0,0 +1,92 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Filename: s_sbr_element_stream.h
+ Funtions:
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+
+ Who:                                   Date: MM/DD/YYYY
+ Description:
+------------------------------------------------------------------------------
+
+
+----------------------------------------------------------------------------
+; CONTINUE ONLY IF NOT ALREADY DEFINED
+----------------------------------------------------------------------------*/
+#ifndef S_SBR_ELEMENT_STREAM_H
+#define S_SBR_ELEMENT_STREAM_H
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here.
+----------------------------------------------------------------------------*/
+
+#define MAXSBRBYTES 1024
+
+/*----------------------------------------------------------------------------
+; EXTERNAL VARIABLES REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; SIMPLE TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; ENUMERATED TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; STRUCTURES TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+typedef struct
+{
+    Int32 ElementID;
+    Int32 ExtensionType;
+    Int32 Payload;
+    UChar Data[MAXSBRBYTES];
+}
+SBR_ELEMENT_STREAM;
+
+/*----------------------------------------------------------------------------
+; GLOBAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+
+
+/*----------------------------------------------------------------------------
+; END
+----------------------------------------------------------------------------*/
+#endif
+
+
diff --git a/media/libstagefright/codecs/aacdec/s_sbr_frame_data.h b/media/libstagefright/codecs/aacdec/s_sbr_frame_data.h
new file mode 100644
index 0000000..89d1bb1
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/s_sbr_frame_data.h
@@ -0,0 +1,181 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Filename: s_sbr_frame_data.h
+ Funtions:
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+
+ Who:                                   Date: MM/DD/YYYY
+ Description:
+------------------------------------------------------------------------------
+
+
+----------------------------------------------------------------------------
+; CONTINUE ONLY IF NOT ALREADY DEFINED
+----------------------------------------------------------------------------*/
+#ifndef S_SBR_FRAME_DATA_H
+#define S_SBR_FRAME_DATA_H
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+#include    "pv_audio_type_defs.h"
+#include    "s_sbr_header_data.h"
+#include    "e_invf_mode.h"
+#include    "e_coupling_mode.h"
+#include    "sbr_constants.h"
+#include    "s_patch.h"
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here.
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL VARIABLES REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; SIMPLE TYPEDEF'S
+----------------------------------------------------------------------------*/
+/*----------------------------------------------------------------------------
+; ENUMERATED TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; STRUCTURES TYPEDEF'S
+----------------------------------------------------------------------------*/
+typedef struct
+{
+    Int32 nScaleFactors;            /* total number of scalefactors in frame */
+    Int32 nNoiseFactors;
+    Int32 crcCheckSum;
+    Int32 frameClass;
+    Int32 frameInfo[LENGTH_FRAME_INFO];
+    Int32 nSfb[2];
+    Int32 nNfb;
+    Int32 offset;
+    Int32 ampRes;
+    Int32 nNoiseFloorEnvelopes;
+    Int32 p;
+    Int32 prevEnvIsShort;
+
+    Int32 reset_flag;
+
+
+    SBR_HEADER_DATA sbr_header;
+
+
+    /* dynamic control signals */
+    Int32 domain_vec1[MAX_ENVELOPES];
+    Int32 domain_vec2[MAX_ENVELOPES];
+
+
+    INVF_MODE sbr_invf_mode[MAX_NUM_NOISE_VALUES];
+    INVF_MODE sbr_invf_mode_prev[MAX_NUM_NOISE_VALUES];
+
+    COUPLING_MODE coupling;               /*  3 possibilities: off, level, pan */
+
+
+    Int32 addHarmonics[MAX_NUM_ENVELOPE_VALUES];
+
+    /* Used by calc_sbr_envelope */
+    Int32 hFp[64];
+    Int32 harm_index;
+    Int32 phase_index;
+    Int32 sUp;
+
+    /*
+     *    envelope data
+     */
+
+    Int32 iEnvelope_man[MAX_NUM_ENVELOPE_VALUES]; /* mantissa */
+    Int32 iEnvelope_exp[MAX_NUM_ENVELOPE_VALUES]; /* exponent */
+    Int32 sfb_nrg_prev_man[MAX_FREQ_COEFFS];      /* mantissa */
+
+
+    /*
+     *    noise data
+     */
+
+    Int32 sbrNoiseFloorLevel_man[MAX_NUM_NOISE_VALUES]; /* mantissa */
+    Int32 sbrNoiseFloorLevel_exp[MAX_NUM_NOISE_VALUES]; /* exponent */
+    Int32 prevNoiseLevel_man[MAX_NUM_NOISE_VALUES]; /* mantissa */
+
+    Int32  BwVector[MAX_NUM_PATCHES];
+    Int32  BwVectorOld[MAX_NUM_PATCHES];
+    /* Both implement a pseudo circular buffer  */
+
+    /*
+     * 40 ==  Biggest of  autoCorrLength(38) + sbrDec->bufReadOffs (2)  and
+     *    sbrDec->noCols (32) + sbrDec->bufWriteOffs  (6)
+     */
+    Int32 codecQmfBufferReal[40][32];
+    Int32 *sbrQmfBufferReal;
+    Int32 HistsbrQmfBufferReal[6*SBR_NUM_BANDS];
+#ifdef HQ_SBR
+    Int32 codecQmfBufferImag[40][32];
+    Int32 *sbrQmfBufferImag;
+    Int32 HistsbrQmfBufferImag[6*SBR_NUM_BANDS];
+#endif
+    Int16  V[1152];     /* Used by calc_sbr_synfilterbank as freq. history buffer */
+
+
+    Int32 degreeAlias[64];
+
+
+#ifdef HQ_SBR
+
+    Int32 fBuffer_man[5][64];        /* smoothing history buffers */
+    Int32 fBufferN_man[5][64];
+    Int32 fBuffer_exp[5][64];        /* smoothing history buffers */
+    Int32 fBufferN_exp[5][64];
+
+    Int32 *fBuf_man[64];        /* pointer to smoothing history buffers */
+    Int32 *fBuf_exp[64];        /* pointer to smoothing history buffers */
+    Int32 *fBufN_man[64];
+    Int32 *fBufN_exp[64];
+
+
+#endif
+
+}
+SBR_FRAME_DATA;
+
+
+/*----------------------------------------------------------------------------
+; GLOBAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+
+
+/*----------------------------------------------------------------------------
+; END
+----------------------------------------------------------------------------*/
+#endif
+
+
diff --git a/media/libstagefright/codecs/aacdec/s_sbr_header_data.h b/media/libstagefright/codecs/aacdec/s_sbr_header_data.h
new file mode 100644
index 0000000..7d7d746
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/s_sbr_header_data.h
@@ -0,0 +1,112 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Filename: s_sbr_header_data.h
+ Funtions:
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+
+ Who:                                   Date: MM/DD/YYYY
+ Description:
+------------------------------------------------------------------------------
+
+
+----------------------------------------------------------------------------
+; CONTINUE ONLY IF NOT ALREADY DEFINED
+----------------------------------------------------------------------------*/
+#ifndef S_SBR_HEADER_DATA_H
+#define S_SBR_HEADER_DATA_H
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+#include    "pv_audio_type_defs.h"
+#include    "e_sbr_header_status.h"
+#include    "e_sbr_master_status.h"
+#include    "e_sr_mode.h"
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here.
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL VARIABLES REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; SIMPLE TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; ENUMERATED TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; STRUCTURES TYPEDEF'S
+----------------------------------------------------------------------------*/
+typedef struct
+{
+    SBR_HEADER_STATUS status;      /* the current status of the header     */
+    SBR_MASTER_STATUS masterStatus;/* status of v_k_master freq table      */
+
+    /* Changes in these variables indicates an error */
+    Int32 crcEnable;
+    SR_MODE sampleRateMode;
+    Int32 ampResolution;
+
+    /* Changes in these variables causes a reset of the decoder */
+    Int32 startFreq;
+    Int32 stopFreq;
+    Int32 xover_band;
+    Int32 freqScale;
+    Int32 alterScale;
+    Int32 noise_bands;               /* noise bands per octave, read from bitstream */
+
+    /* Helper variable*/
+    Int32 noNoiseBands;              /* actual number of noise bands to read from the bitstream */
+
+    Int32 limiterBands;
+    Int32 limiterGains;
+    Int32 interpolFreq;
+    Int32 smoothingLength;
+}
+SBR_HEADER_DATA;
+
+typedef SBR_HEADER_DATA *HANDLE_SBR_HEADER_DATA;
+
+/*----------------------------------------------------------------------------
+; GLOBAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+
+
+/*----------------------------------------------------------------------------
+; END
+----------------------------------------------------------------------------*/
+#endif
+
+
diff --git a/media/libstagefright/codecs/aacdec/s_sbrbitstream.h b/media/libstagefright/codecs/aacdec/s_sbrbitstream.h
new file mode 100644
index 0000000..609463a
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/s_sbrbitstream.h
@@ -0,0 +1,91 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Filename: s_sbrbitstream.h
+ Funtions:
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+
+ Who:                                   Date: MM/DD/YYYY
+ Description:
+------------------------------------------------------------------------------
+
+
+----------------------------------------------------------------------------
+; CONTINUE ONLY IF NOT ALREADY DEFINED
+----------------------------------------------------------------------------*/
+#ifndef S_SBRBITSTREAM_H
+#define S_SBRBITSTREAM_H
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+
+#include    "s_sbr_element_stream.h"
+#include    "s_sbr_channel.h"
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here.
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL VARIABLES REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; SIMPLE TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; ENUMERATED TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; STRUCTURES TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+typedef struct
+{
+    Int32 NrElements;
+    Int32 NrElementsCore;
+    SBR_ELEMENT_STREAM sbrElement[MAXNRELEMENTS];
+}
+SBRBITSTREAM;
+
+/*----------------------------------------------------------------------------
+; GLOBAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+
+
+/*----------------------------------------------------------------------------
+; END
+----------------------------------------------------------------------------*/
+#endif
+
+
diff --git a/media/libstagefright/codecs/aacdec/s_sectinfo.h b/media/libstagefright/codecs/aacdec/s_sectinfo.h
new file mode 100644
index 0000000..83dcc31
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/s_sectinfo.h
@@ -0,0 +1,91 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Pathname: ./include/s_SectInfo.h
+
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+ Who:                       Date:
+ Description:
+
+------------------------------------------------------------------------------
+ INCLUDE DESCRIPTION
+
+ defines a structre that holds the Huffman codebook index and section
+ boundary information for each Frame.
+
+------------------------------------------------------------------------------
+*/
+
+/*----------------------------------------------------------------------------
+; CONTINUE ONLY IF NOT ALREADY DEFINED
+----------------------------------------------------------------------------*/
+#ifndef S_SECTINFO_H
+#define S_SECTINFO_H
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+#include "pv_audio_type_defs.h"
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here.
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL VARIABLES REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; SIMPLE TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; ENUMERATED TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; STRUCTURES TYPEDEF'S
+----------------------------------------------------------------------------*/
+typedef struct
+{
+    Int   sect_cb;
+    Int   sect_end;
+} SectInfo;
+
+/*----------------------------------------------------------------------------
+; GLOBAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; END
+----------------------------------------------------------------------------*/
+#endif
+
+
diff --git a/media/libstagefright/codecs/aacdec/s_sr_info.h b/media/libstagefright/codecs/aacdec/s_sr_info.h
new file mode 100644
index 0000000..9b71003
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/s_sr_info.h
@@ -0,0 +1,91 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Pathname: s_SR_info.h
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+ Description: Modified the declaration of the structure so no pointers are
+              used in the structure.
+
+ Who:                       Date:
+ Description:
+
+------------------------------------------------------------------------------
+ INCLUDE DESCRIPTION
+
+ This include file defines the structure, SR_Info
+
+------------------------------------------------------------------------------
+*/
+
+/*----------------------------------------------------------------------------
+; CONTINUE ONLY IF NOT ALREADY DEFINED
+----------------------------------------------------------------------------*/
+#ifndef S_SR_INFO_H
+#define S_SR_INFO_H
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+#include "pv_audio_type_defs.h"
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here.
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL VARIABLES REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; SIMPLE TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; ENUMERATED TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; STRUCTURES TYPEDEF'S
+----------------------------------------------------------------------------*/
+typedef struct
+{
+    Int32   samp_rate;
+    Int     nsfb1024;
+    Int     nsfb128;
+} SR_Info;
+
+/*----------------------------------------------------------------------------
+; GLOBAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; END
+----------------------------------------------------------------------------*/
+#endif
diff --git a/media/libstagefright/codecs/aacdec/s_tdec_int_chan.h b/media/libstagefright/codecs/aacdec/s_tdec_int_chan.h
new file mode 100644
index 0000000..f7a3602
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/s_tdec_int_chan.h
@@ -0,0 +1,183 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Pathname: s_tDec_Int_Chan.h
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+ Description: Change data types of win
+
+ Description: Remove wnd_shape structure.
+
+ Description: Remove dependency on window_block.h, Fix header too.
+
+ Description:
+ Modified to utilize memory in the last 1024 elements in fxpCoef.
+
+ Description:
+ (1) Modified to include the lines...
+
+    #ifdef __cplusplus
+    extern "C" {
+    #endif
+
+    #ifdef __cplusplus
+    }
+    #endif
+
+ (2) Updated the copyright header.
+
+ Description:
+ (1) Move temporary FrameInfo structure into the shared region with fxpCoef.
+ (2) Add more comments detailing the size of the shared structure.
+
+ Description:
+ (1) Changed time_quant from 2048 Int32 buffer to 1024 Int32 buffer.
+
+ Who:                                         Date:
+ Description:
+
+------------------------------------------------------------------------------
+ INCLUDE DESCRIPTION
+
+ This include file defines the structure, tDec_Int_Chan
+
+------------------------------------------------------------------------------
+*/
+
+/*----------------------------------------------------------------------------
+; CONTINUE ONLY IF NOT ALREADY DEFINED
+----------------------------------------------------------------------------*/
+#ifndef S_TDEC_INT_CHAN_H
+#define S_TDEC_INT_CHAN_H
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+    /*----------------------------------------------------------------------------
+    ; INCLUDES
+    ----------------------------------------------------------------------------*/
+#include "pv_audio_type_defs.h"
+#include "e_rawbitstreamconst.h"
+#include "s_tns_frame_info.h"
+#include "s_wnd_shape.h"
+#include "s_lt_pred_status.h"
+#include "s_sectinfo.h"
+#include "s_frameinfo.h"
+#include "e_window_shape.h"
+#include "e_window_sequence.h"
+#include "window_block_fxp.h"
+
+    /*----------------------------------------------------------------------------
+    ; MACROS
+    ; Define module specific macros here
+    ----------------------------------------------------------------------------*/
+
+    /*----------------------------------------------------------------------------
+    ; DEFINES
+    ; Include all pre-processor statements here.
+    ----------------------------------------------------------------------------*/
+
+    /*----------------------------------------------------------------------------
+    ; EXTERNAL VARIABLES REFERENCES
+    ; Declare variables used in this module but defined elsewhere
+    ----------------------------------------------------------------------------*/
+
+    /*----------------------------------------------------------------------------
+    ; SIMPLE TYPEDEF'S
+    ----------------------------------------------------------------------------*/
+
+    /*----------------------------------------------------------------------------
+    ; ENUMERATED TYPEDEF'S
+    ----------------------------------------------------------------------------*/
+
+    /*----------------------------------------------------------------------------
+    ; STRUCTURES TYPEDEF'S
+    ----------------------------------------------------------------------------*/
+
+    /* This structure was created with the specific goal in mind of sharing memory
+     * with the last 1024 data elements in fxpCoef.
+     *
+     * The size of this structure must NOT exceed 4 kilobytes
+     * Also, the size of the fxpCoef array cannot be less than 8 kilobytes
+     *
+     * The fxpCoef array is declared as an Int32, so its size should not vary
+     * from platform to platform.
+     *
+     * The shared structure is 3,640 bytes (3.55 KB), on a 32-bit platform,
+     * which represents the worst case.
+     */
+    typedef struct
+    {
+        TNS_frame_info       tns;
+
+        FrameInfo            frameInfo;
+
+        Int                  factors[MAXBANDS];
+        Int                  cb_map[MAXBANDS];
+        Int                  group[NSHORT];
+        Int                  qFormat[MAXBANDS];
+
+        Int                  max_sfb;
+        LT_PRED_STATUS       lt_status;
+
+    } per_chan_share_w_fxpCoef;
+
+    /*
+     * This structure contains one per channel.
+     */
+    typedef struct
+    {
+#ifdef AAC_PLUS
+        Int16                ltp_buffer[LT_BLEN + 2*288]; /* LT_BLEN  = 2048 + 2*288 */
+#else
+        Int16                ltp_buffer[LT_BLEN]; /* LT_BLEN  = 2048 */
+#endif
+
+
+        Int32                time_quant[LONG_WINDOW]; /*  1024 holds overlap&add */
+
+        Int32                *fxpCoef;         /* Spectrum coeff.*/
+
+        per_chan_share_w_fxpCoef * pShareWfxpCoef;
+
+        Int32                abs_max_per_window[NUM_SHORT_WINDOWS];
+
+        WINDOW_SEQUENCE      wnd;
+
+
+        WINDOW_SHAPE         wnd_shape_prev_bk;
+        WINDOW_SHAPE         wnd_shape_this_bk;
+
+    } tDec_Int_Chan;
+
+    /*----------------------------------------------------------------------------
+    ; GLOBAL FUNCTION DEFINITIONS
+    ; Function Prototype declaration
+    ----------------------------------------------------------------------------*/
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* S_TDEC_INT_CHAN_H */
+
diff --git a/media/libstagefright/codecs/aacdec/s_tdec_int_file.h b/media/libstagefright/codecs/aacdec/s_tdec_int_file.h
new file mode 100644
index 0000000..d0ffb0b
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/s_tdec_int_file.h
@@ -0,0 +1,277 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Pathname: s_tDec_Int_File.h
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+ Description: Remove unneeded structure elements, clean up.
+
+ Description: Remove block.h, not needed, chains in other not needed files.
+
+ Description: Added declaration of scratch memory, scratchTnsDecCoefMem,
+ which will be utilized by tns_decode_coef().
+
+ Description:
+ (1) Modified to include the lines...
+
+    #ifdef __cplusplus
+    extern "C" {
+    #endif
+
+    #ifdef __cplusplus
+    }
+    #endif
+
+ (2) Updated the copyright header.
+
+ Description: Per review comments...
+ (1) Removed declaration of unused variable, savedMCInfo
+ (2) Commented out ADTS related variables.
+ (3) Slight re-wording of comment for clarity.
+
+ Description:
+ (1) Moved scratch_prog_config into the scratch union.
+
+ Description:
+ (1) Added ltp state variable.
+
+ Description: Make tDec_Int_perChan an array of structures.
+              In the user applications, the malloc command will allocate a
+              continuous chunk of memory.
+
+ Description:
+           (1) Added the array data_stream_bytes[] to structure tDec_Int_File.
+               This to support Data Streaming Elements (DSE).
+           (2) Updated the copyright header.
+
+
+ Who:                                       Date:
+ Description:
+
+------------------------------------------------------------------------------
+ INCLUDE DESCRIPTION
+
+ This include file defines the structure, tDec_Int_Chan
+
+------------------------------------------------------------------------------
+*/
+
+/*----------------------------------------------------------------------------
+; CONTINUE ONLY IF NOT ALREADY DEFINED
+----------------------------------------------------------------------------*/
+#ifndef S_TDEC_INT_FILE_H
+#define S_TDEC_INT_FILE_H
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+    /*----------------------------------------------------------------------------
+    ; INCLUDES
+    ----------------------------------------------------------------------------*/
+#include "pv_audio_type_defs.h"
+#include "s_progconfig.h"
+#include "s_frameinfo.h"
+#include "s_mc_info.h"
+#include "s_adif_header.h"
+#include "s_tdec_int_chan.h"
+#include "s_pulseinfo.h"
+#include "s_bits.h"
+#include "s_hcb.h"
+#include "e_infoinitconst.h"
+
+#include "s_sbr_channel.h"
+#include "s_sbr_dec.h"
+#include "s_sbrbitstream.h"
+
+    /*----------------------------------------------------------------------------
+    ; MACROS
+    ; Define module specific macros here
+    ----------------------------------------------------------------------------*/
+
+    /*----------------------------------------------------------------------------
+    ; DEFINES
+    ; Include all pre-processor statements here.
+    ----------------------------------------------------------------------------*/
+
+    /*----------------------------------------------------------------------------
+    ; EXTERNAL VARIABLES REFERENCES
+    ; Declare variables used in this module but defined elsewhere
+    ----------------------------------------------------------------------------*/
+
+    /*----------------------------------------------------------------------------
+    ; SIMPLE TYPEDEF'S
+    ----------------------------------------------------------------------------*/
+
+    /*----------------------------------------------------------------------------
+    ; ENUMERATED TYPEDEF'S
+    ----------------------------------------------------------------------------*/
+
+    /*----------------------------------------------------------------------------
+    ; STRUCTURES TYPEDEF'S
+    ----------------------------------------------------------------------------*/
+
+
+
+
+
+    /*
+     * Note: most of the names of the variables put into this structure were kept
+     * the same because the name is also used in called functions.
+     *
+     * bno - block number
+     *
+     */
+    typedef struct
+    {
+        UInt32         bno;
+        Int            status;  /* save the status */
+
+        bool           aacPlusEnabled;
+        bool           aacConfigUtilityEnabled;
+
+        Int            current_program;
+        Int            frameLength;
+        Int            adif_test;
+
+        BITS           inputStream;
+
+        ProgConfig     prog_config;
+
+        Int            SFBWidth128[(1<<LEN_MAX_SFBS)];
+
+        /*
+         * One of the two arrays should be deleted in the final version.
+         */
+        FrameInfo      longFrameInfo;
+        FrameInfo      shortFrameInfo;
+        FrameInfo     *winmap[NUM_WIN_SEQ];
+
+        /*
+         * Pns variables.
+         */
+        Int32          pns_cur_noise_state;
+
+        /*
+         *
+         */
+        MC_Info        mc_info;
+
+        Int            ltp_buffer_state;
+
+        /*
+         *  For eaac+, a scratch matrix is created with the rigth element ( perChan[1] is not used)
+         *  and the fxpCoef matrix. These  2 matrices are [2][38][64] == 4864 Int32
+         *    2349 coming from the perChan[1] plus 4096 coming from fxpCoef
+         */
+        tDec_Int_Chan  perChan[Chans];
+
+        Int32          fxpCoef[2][LN];         /* LN  = 2048     */
+
+
+
+#ifdef AAC_PLUS
+
+        SBRDECODER_DATA sbrDecoderData;/* allocates 2 SBR_CHANNEL, each has a SBR_FRAME_DATA */
+        SBR_DEC         sbrDec;
+        SBRBITSTREAM    sbrBitStr;
+
+#endif
+
+
+        /*
+         * If ADTS support is needed, the following variables will
+         * be required.
+         */
+        UInt32         syncword;
+        Int            invoke;
+
+        Int         mask[MAXBANDS];
+        Int         hasmask;
+
+
+        /*  SBR usage
+         *  These two unions are used for the SBR tool and used
+         *  as a single 2560 int32 continuous memory for circular
+         *  buffering the synthesis QMF's bank history
+         */
+
+        /* This union specifies memory for arrays which are used
+         * by only one function.  This is the simplest type of scratch
+         * memory to implement, since there are no worries about
+         * function interaction.
+         */
+        union scratch_memory
+        {
+            Int32  fft[LONG_WINDOW];    /* 1024, as needed by the FFT */
+            Int32  tns_inv_filter[TNS_MAX_ORDER];
+            Int32  tns_decode_coef[2*TNS_MAX_ORDER];
+            Int    huffbook_used[248];
+            Int16  tmp_spec[LN2];  /* Used in conjunction with quant_spec */
+
+            ADIF_Header    adif_header;
+
+            ProgConfig     scratch_prog_config;
+
+
+            Int32  scratch_mem[16][64];
+        } scratch;
+
+        /* This union tries to take advantage of the fact that
+         * some variables are only used before LTP, and
+         * the long array, predictedSamples, is only used after LTP.
+         */
+
+        /*
+         *  also used by the circular buffer scheme on aac+ (needs 4096 + 1152)
+         *  from scratch_mem[2] + 5248  (uses most of shared_memory).
+         *  For eaac+, shared memory is used by sbrQmfBufferReal which needs
+         *  1824 bytes
+         */
+        union shared_memory
+        {
+            Int32       predictedSamples[LONG_BLOCK1];  /* 2048 Int32 */
+
+            Char        data_stream_bytes[(1<<LEN_D_CNT)+1];
+
+            struct
+            {
+                Int16         quantSpec[LN2];
+                SectInfo    sect[MAXBANDS + 1];
+                PulseInfo   pulseInfo;
+            } a;
+
+        } share;
+
+
+    } tDec_Int_File;
+
+    /*----------------------------------------------------------------------------
+    ; GLOBAL FUNCTION DEFINITIONS
+    ; Function Prototype declaration
+    ----------------------------------------------------------------------------*/
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* S_TDEC_INT_FILE_H */
diff --git a/media/libstagefright/codecs/aacdec/s_tns_frame_info.h b/media/libstagefright/codecs/aacdec/s_tns_frame_info.h
new file mode 100644
index 0000000..61af0ac
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/s_tns_frame_info.h
@@ -0,0 +1,147 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Pathname: s_TNS_frame_info.h
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+ Description: Modified to eliminate triple-nested structure, which wasted
+ 2 KB of memory.
+
+ Description:
+ (1) Modified to include the lines...
+
+    #ifdef __cplusplus
+    extern "C" {
+    #endif
+
+    #ifdef __cplusplus
+    }
+    #endif
+
+ (2) Updated the copyright header.
+
+ Description:
+ (1) Changed hard coded size of arrays from "8" to "TNS_MAX_WIN"
+ (2) Moved elements from s_TNSinfo.h up to the level of TNS_frame_info
+ (3) Added Bool "tns_data_present" for future use.
+ (4) Moved lpc_coef up from s_TNSfilt.h (allowed for use of smaller array.)
+
+ Description:
+ (1) Removed the array "coef_res", which is now a local variable on the
+ stack inside get_tns.c
+
+ Who:                       Date:
+ Description:
+
+------------------------------------------------------------------------------
+ INCLUDE DESCRIPTION
+
+ This include file defines the structure, s_TNS_frame_info
+
+------------------------------------------------------------------------------
+*/
+
+/*----------------------------------------------------------------------------
+; CONTINUE ONLY IF NOT ALREADY DEFINED
+----------------------------------------------------------------------------*/
+#ifndef S_TNS_FRAME_INFO_H
+#define S_TNS_FRAME_INFO_H
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+    /*----------------------------------------------------------------------------
+    ; INCLUDES
+    ----------------------------------------------------------------------------*/
+#include "pv_audio_type_defs.h"
+#include "e_tns_const.h"
+#include "s_tnsfilt.h"
+
+    /*----------------------------------------------------------------------------
+    ; MACROS
+    ; Define module specific macros here
+    ----------------------------------------------------------------------------*/
+
+    /*----------------------------------------------------------------------------
+    ; DEFINES
+    ; Include all pre-processor statements here.
+    ----------------------------------------------------------------------------*/
+
+    /*----------------------------------------------------------------------------
+    ; EXTERNAL VARIABLES REFERENCES
+    ; Declare variables used in this module but defined elsewhere
+    ----------------------------------------------------------------------------*/
+
+    /*----------------------------------------------------------------------------
+    ; SIMPLE TYPEDEF'S
+    ----------------------------------------------------------------------------*/
+
+    /*----------------------------------------------------------------------------
+    ; ENUMERATED TYPEDEF'S
+    ----------------------------------------------------------------------------*/
+
+    /*----------------------------------------------------------------------------
+    ; STRUCTURES TYPEDEF'S
+    ----------------------------------------------------------------------------*/
+    typedef struct
+    {
+        Bool tns_data_present;
+
+        /* Information about the number of filters for each window. */
+        Int n_filt[TNS_MAX_WIN];
+
+        /*
+         * Filter Information
+         *
+         * For short windows, there is a maximum of
+         * 1 filter per window (8 total)
+         *
+         * For long windows, there is a maximum of 3 filters
+         *
+         */
+        TNSfilt filt[TNS_MAX_WIN];
+
+        /*
+         * For short windows, there is a maximum of 8 filters,
+         * each of order 7 (requring 56 Ints)
+         *
+         * For long windows, there is a maximum of 3 filters,
+         * each of order 20 (requiring 60 Ints)
+         *
+         * So, 3*TNS_MAX_ORDER declares an array of sufficient
+         * size (60) for both cases.
+         */
+        Int32 lpc_coef[3*TNS_MAX_ORDER];
+
+    } TNS_frame_info;
+
+    /*----------------------------------------------------------------------------
+    ; GLOBAL FUNCTION DEFINITIONS
+    ; Function Prototype declaration
+    ----------------------------------------------------------------------------*/
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* S_TNS_FRAME_INFO_H */
diff --git a/media/libstagefright/codecs/aacdec/s_tnsfilt.h b/media/libstagefright/codecs/aacdec/s_tnsfilt.h
new file mode 100644
index 0000000..c1d78af
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/s_tnsfilt.h
@@ -0,0 +1,132 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Pathname: s_TNSfilt.h
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+ Description: Added lpc, start, & size, so the data from
+ tns_inv_subblock can be shared with tns_decode_subblock.
+
+ Description: Removed lpc to save 2KB of memory (on 32-bit machines.)
+ This change requires tns_decode_coef.c to perform calculations in place.
+
+ Description: Removed start & size.  start_band and stop_band can simply
+ take on a new meaning after this function.  (coef index, rather than
+ scalefactor band index.)
+
+ Description: Had to add "start_coef" and "stop_coef" in order to preserve
+ values "start_band" and "stop_band."  This required a change to
+ tns_setup_filter.c also.
+
+ Description: Had to add element "q_lpc" to store the q-format of the lpc
+ coefficients passed via "coef."
+
+ Description: Moved lpc_coef array up to the s_TNS_frame_info.h structure.
+
+ Description:
+ (1) Modified to include the lines...
+
+    #ifdef __cplusplus
+    extern "C" {
+    #endif
+
+    #ifdef __cplusplus
+    }
+    #endif
+
+ (2) Updated the copyright header.
+
+ Who:                       Date:
+ Description:
+------------------------------------------------------------------------------
+ INCLUDE DESCRIPTION
+
+ This include file defines the structure, s_TNSfilt
+
+------------------------------------------------------------------------------
+*/
+
+/*----------------------------------------------------------------------------
+; CONTINUE ONLY IF NOT ALREADY DEFINED
+----------------------------------------------------------------------------*/
+#ifndef S_TNSFILT_H
+#define S_TNSFILT_H
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+    /*----------------------------------------------------------------------------
+    ; INCLUDES
+    ----------------------------------------------------------------------------*/
+#include "pv_audio_type_defs.h"
+#include "e_tns_const.h"
+
+    /*----------------------------------------------------------------------------
+    ; MACROS
+    ; Define module specific macros here
+    ----------------------------------------------------------------------------*/
+
+    /*----------------------------------------------------------------------------
+    ; DEFINES
+    ; Include all pre-processor statements here.
+    ----------------------------------------------------------------------------*/
+
+    /*----------------------------------------------------------------------------
+    ; EXTERNAL VARIABLES REFERENCES
+    ; Declare variables used in this module but defined elsewhere
+    ----------------------------------------------------------------------------*/
+
+    /*----------------------------------------------------------------------------
+    ; SIMPLE TYPEDEF'S
+    ----------------------------------------------------------------------------*/
+
+    /*----------------------------------------------------------------------------
+    ; ENUMERATED TYPEDEF'S
+    ----------------------------------------------------------------------------*/
+
+    /*----------------------------------------------------------------------------
+    ; STRUCTURES TYPEDEF'S
+    ----------------------------------------------------------------------------*/
+
+    typedef struct
+    {
+        Int start_band;
+        Int stop_band;
+        Int start_coef;
+        Int stop_coef;
+        UInt order;
+        Int direction;
+        Int q_lpc;
+
+    } TNSfilt;
+
+    /*----------------------------------------------------------------------------
+    ; GLOBAL FUNCTION DEFINITIONS
+    ; Function Prototype declaration
+    ----------------------------------------------------------------------------*/
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* S_TNSFILT_H */
diff --git a/media/libstagefright/codecs/aacdec/s_wnd_shape.h b/media/libstagefright/codecs/aacdec/s_wnd_shape.h
new file mode 100644
index 0000000..c8a05c8
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/s_wnd_shape.h
@@ -0,0 +1,89 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Pathname: s_Wnd_Shape.h
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+ Description:  Change data type to Int
+
+ Who:                                       Date:
+ Description:
+
+------------------------------------------------------------------------------
+ INCLUDE DESCRIPTION
+
+ This include file defines the structure, Wnd_Shape
+
+------------------------------------------------------------------------------
+*/
+
+/*----------------------------------------------------------------------------
+; CONTINUE ONLY IF NOT ALREADY DEFINED
+----------------------------------------------------------------------------*/
+#ifndef S_WND_SHAPE_H
+#define S_WND_SHAPE_H
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+#include "pv_audio_type_defs.h"
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here.
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL VARIABLES REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; SIMPLE TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; ENUMERATED TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; STRUCTURES TYPEDEF'S
+----------------------------------------------------------------------------*/
+typedef struct
+{
+    Int    this_bk;
+    Int    prev_bk;
+} Wnd_Shape;
+
+/*----------------------------------------------------------------------------
+; GLOBAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; END
+----------------------------------------------------------------------------*/
+#endif
diff --git a/media/libstagefright/codecs/aacdec/sbr_aliasing_reduction.cpp b/media/libstagefright/codecs/aacdec/sbr_aliasing_reduction.cpp
new file mode 100644
index 0000000..efbab7d
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/sbr_aliasing_reduction.cpp
@@ -0,0 +1,366 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Filename: sbr_aliasing_reduction.c
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+
+ Who:                                   Date: MM/DD/YYYY
+ Description:
+
+------------------------------------------------------------------------------
+ INPUT AND OUTPUT DEFINITIONS
+
+
+
+------------------------------------------------------------------------------
+ FUNCTION DESCRIPTION
+
+
+------------------------------------------------------------------------------
+ REQUIREMENTS
+
+
+------------------------------------------------------------------------------
+ REFERENCES
+
+SC 29 Software Copyright Licencing Disclaimer:
+
+This software module was originally developed by
+  Coding Technologies
+
+and edited by
+  -
+
+in the course of development of the ISO/IEC 13818-7 and ISO/IEC 14496-3
+standards for reference purposes and its performance may not have been
+optimized. This software module is an implementation of one or more tools as
+specified by the ISO/IEC 13818-7 and ISO/IEC 14496-3 standards.
+ISO/IEC gives users free license to this software module or modifications
+thereof for use in products claiming conformance to audiovisual and
+image-coding related ITU Recommendations and/or ISO/IEC International
+Standards. ISO/IEC gives users the same free license to this software module or
+modifications thereof for research purposes and further ISO/IEC standardisation.
+Those intending to use this software module in products are advised that its
+use may infringe existing patents. ISO/IEC have no liability for use of this
+software module or modifications thereof. Copyright is not released for
+products that do not conform to audiovisual and image-coding related ITU
+Recommendations and/or ISO/IEC International Standards.
+The original developer retains full right to modify and use the code for its
+own purpose, assign or donate the code to a third party and to inhibit third
+parties from using the code for products that do not conform to audiovisual and
+image-coding related ITU Recommendations and/or ISO/IEC International Standards.
+This copyright notice must be included in all copies or derivative works.
+Copyright (c) ISO/IEC 2002.
+
+------------------------------------------------------------------------------
+ PSEUDO-CODE
+
+------------------------------------------------------------------------------
+*/
+
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+
+#ifdef AAC_PLUS
+
+
+
+#include    "sbr_aliasing_reduction.h"
+#include    "pv_sqrt.h"
+
+#include    "aac_mem_funcs.h"
+
+#include    "pv_div.h"
+#include    "fxp_mul32.h"
+
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here. Include conditional
+; compile variables also.
+----------------------------------------------------------------------------*/
+
+#define Q30fmt(x)   (Int32)(x*((Int32)1<<30) + (x>=0?0.5F:-0.5F))
+
+/*----------------------------------------------------------------------------
+; LOCAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; LOCAL STORE/BUFFER/POINTER DEFINITIONS
+; Variable declaration - defined here and used outside this module
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL FUNCTION REFERENCES
+; Declare functions defined elsewhere and referenced in this module
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL GLOBAL STORE/BUFFER/POINTER REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; FUNCTION CODE
+----------------------------------------------------------------------------*/
+
+#include "pv_normalize.h"
+#include  "sbr_constants.h"
+
+/*******************************************************************************
+ Functionname:  sbr_aliasing_reduction
+ *******************************************************************************
+ Description:
+ Arguments:
+
+ Return:        none
+*******************************************************************************/
+void sbr_aliasing_reduction(Int32 *degreeAlias,
+                            Int32  * nrg_gain_man,
+                            Int32  * nrg_gain_exp,
+                            Int32  * nrg_est_man,
+                            Int32  * nrg_est_exp,
+                            Int32  * dontUseTheseGainValues,
+                            Int32    noSubbands,
+                            Int32    lowSubband,
+                            Int32  sqrt_cache[][4],
+                            Int32 * groupVector)
+{
+
+    Int32 temp1;
+    Int32 est_total;
+    Int32 ref_total_man;
+    Int32 ref_total_exp;
+    Int32 tmp_q1;
+    Int32 tmp_q2;
+    Int32 tmp_q3;
+    Int32 tmp_q4;
+    Int32 bst_man;
+    Int32 bst_exp;
+    struct intg_div   quotient;
+    struct intg_sqrt  root_sq;
+    Int32 group;
+    Int32 grouping = 0;
+    Int32 index = 0;
+    Int32 noGroups;
+    Int32 k;
+
+
+    /* Calculate grouping*/
+    for (k = 0; k < noSubbands - 1; k++)
+    {
+        if (degreeAlias[k + lowSubband + 1] && dontUseTheseGainValues[k] == 0)
+        {
+            if (grouping == 0)
+            {
+                groupVector[index] = k + lowSubband;
+                grouping = 1;
+                index++;
+            }
+        }
+        else
+        {
+            if (grouping)
+            {
+                groupVector[index] = k + lowSubband;
+
+                if (! dontUseTheseGainValues[k])
+                {
+                    (groupVector[index])++;
+                }
+                grouping = 0;
+                index++;
+            }
+        }
+    }
+
+    if (grouping)
+    {
+        groupVector[index] = noSubbands + lowSubband;
+        index++;
+    }
+    noGroups = (index >> 1);
+
+
+
+    /*Calculate new gain*/
+    for (group = 0; group < noGroups; group ++)
+    {
+
+        int startGroup = groupVector[(group<<1)] - lowSubband;
+        int stopGroup  = groupVector[(group<<1)+1] - lowSubband;
+
+
+        est_total = 0;
+        ref_total_man = 0;
+
+        tmp_q1 = -100;
+        tmp_q2 = -100;
+
+        for (k = startGroup; k < stopGroup; k++)
+        {
+            if (tmp_q1 < nrg_est_exp[k])
+            {
+                tmp_q1 = nrg_est_exp[k];    /* max */
+            }
+            if (tmp_q2 < (nrg_est_exp[k] + (nrg_gain_exp[k] << 1)))
+            {
+                tmp_q2 = (nrg_est_exp[k] + (nrg_gain_exp[k] << 1));  /* max */
+            }
+        }
+
+
+        k -= startGroup;        /*  number of element used in the addition */
+        /* adjust Q format */
+        tmp_q2 += 59 - pv_normalize(k);
+
+        for (k = startGroup; k < stopGroup; k++)
+        {
+            /*
+             *  est_total += nrg_est[k]
+             *  ref_total += nrg_est[k]*nrg_gain[k]*nrg_gain[k
+             */
+            est_total += nrg_est_man[k] >> (tmp_q1 - nrg_est_exp[k]);
+
+            if (tmp_q2 - (nrg_est_exp[k] + (nrg_gain_exp[k] << 1)) < 60)
+            {
+                nrg_gain_man[k] = fxp_mul32_Q28(nrg_gain_man[k], nrg_gain_man[k]);
+                nrg_gain_exp[k] = (nrg_gain_exp[k] << 1) + 28;
+                tmp_q3          = fxp_mul32_Q28(nrg_gain_man[k], nrg_est_man[k]);
+                ref_total_man    += tmp_q3 >> (tmp_q2 - (nrg_est_exp[k] + nrg_gain_exp[k]));
+            }
+        }
+
+        ref_total_exp = tmp_q2 + 28;
+
+        pv_div(ref_total_man, est_total, &quotient);
+
+        tmp_q2 += - tmp_q1 - quotient.shift_factor - 2;
+
+
+
+        for (k = startGroup; k < stopGroup; k++)
+        {
+            Int32 alpha;
+            temp1 = k + lowSubband;
+            if (k < noSubbands - 1)
+            {
+                alpha = degreeAlias[temp1 + 1] > degreeAlias[temp1 ] ?
+                        degreeAlias[temp1 + 1] : degreeAlias[temp1 ];
+            }
+            else
+            {
+                alpha = degreeAlias[temp1];
+            }
+
+            /*
+             *  nrg_gain[k] = alpha*newGain + (1.0f-alpha)*nrg_gain[k]*nrg_gain[k];
+             */
+
+            tmp_q1 = tmp_q2 > nrg_gain_exp[k] ? tmp_q2 : nrg_gain_exp[k];
+            tmp_q1++;
+
+            tmp_q3 = fxp_mul32_Q30(alpha, quotient.quotient);
+            tmp_q4 = fxp_mul32_Q30(Q30fmt(1.0f) - alpha, nrg_gain_man[k]);
+
+            nrg_gain_man[k] = (tmp_q3 >> (tmp_q1 - tmp_q2)) +
+                              (tmp_q4 >> (tmp_q1 - nrg_gain_exp[k]));
+
+            nrg_gain_exp[k] = tmp_q1;
+        }
+
+
+        bst_exp = -100;
+
+        for (k = startGroup; k < stopGroup; k++)
+        {
+            if (bst_exp < nrg_gain_exp[k] + nrg_est_exp[k])
+            {
+                bst_exp = nrg_gain_exp[k] + nrg_est_exp[k];    /* max */
+            }
+        }
+
+        k -= startGroup;        /*  number of element used in the addition */
+
+        while (k != 0)          /*  bit guard protection depends on log2(k)  */
+        {
+            k >>= 1;
+            bst_exp++;           /*  add extra bit-overflow-guard */
+        }
+
+        bst_man = 0;
+
+        for (k = startGroup; k < stopGroup; k++)
+        {
+            tmp_q2 =  fxp_mul32_Q28(nrg_gain_man[k], nrg_est_man[k]);
+            bst_man +=  tmp_q2 >> (bst_exp - nrg_gain_exp[k] - nrg_est_exp[k]);
+        }
+
+        bst_exp += 28;  /* compensate for shift down */
+
+        if (bst_man)
+        {
+            /*
+             *  bst = ref_total / bst
+             */
+
+            pv_div(ref_total_man, bst_man, &quotient);
+            bst_exp = ref_total_exp - bst_exp - quotient.shift_factor - 30;
+            bst_man = quotient.quotient;      /*  Q30 */
+
+            for (k = startGroup; k < stopGroup; k++)
+            {
+                tmp_q1 = fxp_mul32_Q30(bst_man, nrg_gain_man[k]);
+                pv_sqrt(tmp_q1, (bst_exp + nrg_gain_exp[k] + 60), &root_sq, sqrt_cache[0]);
+                nrg_gain_man[k] = root_sq.root;
+                nrg_gain_exp[k] = root_sq.shift_factor;
+            }
+        }
+        else
+        {
+            pv_memset((void *)&nrg_gain_man[startGroup],
+                      0,
+                      (stopGroup - startGroup)*sizeof(nrg_gain_man[0]));
+
+            pv_memset((void *)&nrg_gain_exp[startGroup],
+                      0,
+                      (stopGroup - startGroup)*sizeof(nrg_gain_exp[0]));
+
+        }
+
+    }
+}
+
+#endif
+
+
+
diff --git a/media/libstagefright/codecs/aacdec/sbr_aliasing_reduction.h b/media/libstagefright/codecs/aacdec/sbr_aliasing_reduction.h
new file mode 100644
index 0000000..2ce99ec
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/sbr_aliasing_reduction.h
@@ -0,0 +1,92 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Filename: sbr_aliasing_reduction.h
+ Funtions:
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+
+ Who:                                   Date: MM/DD/YYYY
+ Description:
+------------------------------------------------------------------------------
+
+
+----------------------------------------------------------------------------
+; CONTINUE ONLY IF NOT ALREADY DEFINED
+----------------------------------------------------------------------------*/
+#ifndef SBR_ALIASING_REDUCTION_H
+#define SBR_ALIASING_REDUCTION_H
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+#include "pv_audio_type_defs.h"
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here.
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL VARIABLES REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; SIMPLE TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; ENUMERATED TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; STRUCTURES TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; GLOBAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+
+void sbr_aliasing_reduction(Int32 *degreeAlias,
+                            Int32  * nrg_gain_man,
+                            Int32  * nrg_gain_exp,
+                            Int32  * nrg_est_man,
+                            Int32  * nrg_est_exp,
+                            Int32  * dontUseTheseGainValues,
+                            Int32    noSubbands,
+                            Int32    lowSubband,
+                            Int32  sqrt_cache[][4],
+                            Int32 * groupVector);
+
+
+/*----------------------------------------------------------------------------
+; END
+----------------------------------------------------------------------------*/
+#endif
+
+
diff --git a/media/libstagefright/codecs/aacdec/sbr_applied.cpp b/media/libstagefright/codecs/aacdec/sbr_applied.cpp
new file mode 100644
index 0000000..c8b81b2
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/sbr_applied.cpp
@@ -0,0 +1,435 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+  Filename: sbr_applied.c
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+
+ Who:                                   Date: MM/DD/YYYY
+ Description:
+
+------------------------------------------------------------------------------
+ INPUT AND OUTPUT DEFINITIONS
+
+    INPUT
+
+    SBRDECODER self,
+    SBRBITSTREAM * stream,
+    float *timeData,
+    int numChannels
+
+    OUTPUT
+
+    errorCode, noError if successful
+
+------------------------------------------------------------------------------
+ FUNCTION DESCRIPTION
+
+        sbr decoder processing, set up SBR decoder phase 2 in case of
+        different cotrol data
+
+------------------------------------------------------------------------------
+ REQUIREMENTS
+
+
+------------------------------------------------------------------------------
+ REFERENCES
+
+SC 29 Software Copyright Licencing Disclaimer:
+
+This software module was originally developed by
+  Coding Technologies
+
+and edited by
+  -
+
+in the course of development of the ISO/IEC 13818-7 and ISO/IEC 14496-3
+standards for reference purposes and its performance may not have been
+optimized. This software module is an implementation of one or more tools as
+specified by the ISO/IEC 13818-7 and ISO/IEC 14496-3 standards.
+ISO/IEC gives users free license to this software module or modifications
+thereof for use in products claiming conformance to audiovisual and
+image-coding related ITU Recommendations and/or ISO/IEC International
+Standards. ISO/IEC gives users the same free license to this software module or
+modifications thereof for research purposes and further ISO/IEC standardisation.
+Those intending to use this software module in products are advised that its
+use may infringe existing patents. ISO/IEC have no liability for use of this
+software module or modifications thereof. Copyright is not released for
+products that do not conform to audiovisual and image-coding related ITU
+Recommendations and/or ISO/IEC International Standards.
+The original developer retains full right to modify and use the code for its
+own purpose, assign or donate the code to a third party and to inhibit third
+parties from using the code for products that do not conform to audiovisual and
+image-coding related ITU Recommendations and/or ISO/IEC International Standards.
+This copyright notice must be included in all copies or derivative works.
+Copyright (c) ISO/IEC 2002.
+
+------------------------------------------------------------------------------
+ PSEUDO-CODE
+
+------------------------------------------------------------------------------
+*/
+
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+#ifdef AAC_PLUS
+
+
+#include    "sbr_applied.h"
+#include    "sbr_read_data.h"
+
+#include    "sbr_decode_envelope.h"
+#include    "decode_noise_floorlevels.h"
+#include    "sbr_requantize_envelope_data.h"
+#include    "sbr_envelope_unmapping.h"
+#include    "sbr_dec.h"
+#include    "e_sbr_element_id.h"
+#include    "aac_mem_funcs.h"
+
+#ifdef PARAMETRICSTEREO
+#include    "ps_bstr_decoding.h"
+#include    "ps_allocate_decoder.h"
+
+#endif
+
+#include    "init_sbr_dec.h"
+
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here. Include conditional
+; compile variables also.
+----------------------------------------------------------------------------*/
+#define LEFT  (0)
+#define RIGHT (1)
+
+
+/*----------------------------------------------------------------------------
+; LOCAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; LOCAL STORE/BUFFER/POINTER DEFINITIONS
+; Variable declaration - defined here and used outside this module
+----------------------------------------------------------------------------*/
+/*----------------------------------------------------------------------------
+; EXTERNAL FUNCTION REFERENCES
+; Declare functions defined elsewhere and referenced in this module
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL GLOBAL STORE/BUFFER/POINTER REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; FUNCTION CODE
+----------------------------------------------------------------------------*/
+
+SBR_ERROR  sbr_applied(SBRDECODER_DATA * self,
+                       SBRBITSTREAM * stream,
+                       Int16 *ch_left,
+                       Int16 *ch_right,
+                       Int16 *timeData,
+                       SBR_DEC *sbrDec,
+                       tDec_Int_File  *pVars,
+                       Int32 numChannels)
+{
+    SBR_ERROR err = SBRDEC_OK ;
+
+    Int32 eleChannels = 0;
+
+    SBR_CHANNEL *SbrChannel = self->SbrChannel;
+
+    /* Get SBR or PS Data only when available */
+    if (stream->NrElements)
+    {
+        /* read frame data from bitstream */
+
+        err = sbr_read_data(self,
+                            sbrDec,
+                            stream);
+
+        if (err != SBRDEC_OK)
+        {
+            /*
+             * This error condition disables any further SBR processing
+             */
+            self->SbrChannel[LEFT].syncState = UPSAMPLING;
+            if (eleChannels == 2)
+            {
+                self->SbrChannel[RIGHT].syncState = UPSAMPLING;
+            }
+        }
+
+        /*
+         *  Setting bistream and decoding type is only done once,
+         */
+        if (SbrChannel[LEFT].syncState == SBR_ACTIVE && self->setStreamType)
+        {
+            self->setStreamType = 0;  /* Disable Lock for AAC stream type setting  */
+
+#ifdef HQ_SBR
+#ifdef PARAMETRICSTEREO
+
+            Int sbrEnablePS = self->hParametricStereoDec->psDetected;
+
+            pVars->mc_info.psPresentFlag  = sbrEnablePS;
+
+            if (sbrEnablePS)   /* Initialize PS arrays */
+            {
+                pVars->mc_info.ExtendedAudioObjectType = MP4AUDIO_PS;
+                ps_allocate_decoder(self, 32);
+
+                /* Disable LC (or Enable HQ)  if PS is detected */
+                sbrDec->LC_aacP_DecoderFlag = OFF;
+            }
+            else
+            {
+                /*
+                 *  Do not downgrade stream type from eaac+, if it has been explicitly declared
+                 */
+                if (pVars->mc_info.ExtendedAudioObjectType != MP4AUDIO_PS)
+                {
+                    pVars->mc_info.ExtendedAudioObjectType = MP4AUDIO_SBR;
+
+                    if (pVars->mc_info.nch > 1)
+                    {
+                        sbrDec->LC_aacP_DecoderFlag = ON;    /* Enable LC for stereo */
+                    }
+                    else
+                    {
+                        sbrDec->LC_aacP_DecoderFlag = OFF;    /* Disable LC, Enable HQ for mono */
+                    }
+                }
+                else
+                {
+                    sbrEnablePS = 1;  /* Force this condition as it was explicititly declared */
+                    pVars->mc_info.psPresentFlag  = sbrEnablePS;
+
+                }
+            }
+#else
+
+            pVars->mc_info.ExtendedAudioObjectType = MP4AUDIO_SBR;
+
+            if (pVars->mc_info.nch > 1)
+            {
+                sbrDec->LC_aacP_DecoderFlag = ON;    /* Enable LC for stereo */
+            }
+            else
+            {
+                sbrDec->LC_aacP_DecoderFlag = OFF;    /* Disable LC, Enable HQ for mono */
+            }
+#endif
+
+#else
+            pVars->mc_info.ExtendedAudioObjectType = MP4AUDIO_SBR;
+
+            sbrDec->LC_aacP_DecoderFlag = ON;       /* Enable LC for all sbr decoding */
+
+#endif
+
+        }   /*   (SbrChannel[LEFT].syncState == SBR_ACTIVE && lock)  */
+        else
+        {
+            /*
+             *  Default setting for upsampler
+             */
+            if (pVars->mc_info.ExtendedAudioObjectType == MP4AUDIO_AAC_LC)
+            {
+                /*
+                 *  Change only in implicit signalling, otherwise keep original declaration
+                 */
+                pVars->mc_info.ExtendedAudioObjectType = MP4AUDIO_SBR;
+            }
+
+#ifdef HQ_SBR
+            if (pVars->mc_info.nch > 1)
+            {
+                sbrDec->LC_aacP_DecoderFlag = ON;    /* Enable LC for stereo */
+            }
+            else
+            {
+                sbrDec->LC_aacP_DecoderFlag = OFF;    /* Disable LC, Enable HQ for mono */
+            }
+#else
+            sbrDec->LC_aacP_DecoderFlag = ON;       /* Enable LC for all sbr decoding */
+
+#endif
+            /* mask error and let upsampler run */
+            err = SBRDEC_OK;
+
+        }
+
+        /* decoding */
+        eleChannels = (stream->sbrElement [LEFT].ElementID == SBR_ID_CPE) ? 2 : 1;
+
+        if (SbrChannel[LEFT].syncState == SBR_ACTIVE)
+        {
+
+            sbr_decode_envelope(&(SbrChannel[LEFT].frameData));
+
+            decode_noise_floorlevels(&(SbrChannel[LEFT].frameData));
+
+            if (! SbrChannel[LEFT].frameData.coupling)
+            {
+                sbr_requantize_envelope_data(&(SbrChannel[LEFT].frameData));
+            }
+
+            if (eleChannels == 2)
+            {
+
+                sbr_decode_envelope(&(SbrChannel[RIGHT].frameData));
+
+                decode_noise_floorlevels(&(SbrChannel[RIGHT].frameData));
+
+                if (SbrChannel[RIGHT].frameData.coupling)
+                {
+                    sbr_envelope_unmapping(&(SbrChannel[ LEFT].frameData),
+                                           &(SbrChannel[RIGHT].frameData));
+                }
+                else
+                {
+                    sbr_requantize_envelope_data(&(SbrChannel[RIGHT].frameData));
+                }
+            }
+        }
+        else            /* enable upsampling until valid SBR is obtained */
+        {
+            /*
+             *  Incomplete sbr frame, or disabled SBR section
+             *  Set the decoder to act as a regular upsampler
+             */
+
+            init_sbr_dec((sbrDec->outSampleRate >> 1),
+                         pVars->mc_info.upsamplingFactor,
+                         sbrDec,
+                         &(self->SbrChannel[LEFT].frameData));
+
+            if ((eleChannels == 2) && (SbrChannel[RIGHT].syncState != SBR_ACTIVE))
+            {
+                init_sbr_dec((sbrDec->outSampleRate >> 1),
+                             pVars->mc_info.upsamplingFactor,
+                             sbrDec,
+                             &(self->SbrChannel[RIGHT].frameData));
+
+            }
+
+        }
+
+    }
+
+
+#ifdef HQ_SBR
+#ifdef PARAMETRICSTEREO
+    if (pVars->mc_info.ExtendedAudioObjectType == MP4AUDIO_PS)
+    {
+        ps_bstr_decoding(self->hParametricStereoDec);
+        /* allocate pointer for rigth channel qmf filter history  */
+        Int16 *tempInt16Ptr = (Int16 *)SbrChannel[RIGHT].frameData.V;
+        self->hParametricStereoDec->R_ch_qmf_filter_history = (Int32 *)tempInt16Ptr;
+
+
+        /*
+         * 1824 (48*38) Int32 needed by each matrix sbrQmfBufferReal, sbrQmfBufferImag
+         * pVars->share.predictedSamples  has 2048 available
+         * pVars->fxpCoef[1]  has 2048 available
+         */
+        SbrChannel[LEFT].frameData.sbrQmfBufferReal = pVars->share.predictedSamples;
+        SbrChannel[LEFT].frameData.sbrQmfBufferImag = &pVars->fxpCoef[0][920];
+
+        sbr_dec(ch_left,
+                timeData,
+                &(SbrChannel[LEFT].frameData),
+                (SbrChannel[LEFT].syncState == SBR_ACTIVE),
+                sbrDec,
+                &timeData[RIGHT],
+                self->hParametricStereoDec,
+                pVars);
+    }
+    else
+    {
+#endif
+#endif
+
+        SbrChannel[LEFT].frameData.sbrQmfBufferReal = pVars->fxpCoef[LEFT];
+#ifdef HQ_SBR
+        SbrChannel[LEFT].frameData.sbrQmfBufferImag = pVars->fxpCoef[RIGHT];
+#endif
+
+        sbr_dec(ch_left,
+                timeData,
+                &(SbrChannel[LEFT].frameData),
+                (SbrChannel[LEFT].syncState == SBR_ACTIVE),
+                sbrDec,
+#ifdef HQ_SBR
+#ifdef PARAMETRICSTEREO
+                NULL,
+                NULL,
+#endif
+#endif
+                pVars);
+
+        if (numChannels == 2)
+        {
+            SbrChannel[RIGHT].frameData.sbrQmfBufferReal = pVars->fxpCoef[LEFT];
+#ifdef HQ_SBR
+            SbrChannel[RIGHT].frameData.sbrQmfBufferImag = pVars->fxpCoef[RIGHT];
+#endif
+
+            sbr_dec(ch_right,
+                    &timeData[RIGHT],
+                    &(SbrChannel[RIGHT].frameData),
+                    (SbrChannel[RIGHT].syncState == SBR_ACTIVE),
+                    sbrDec,
+#ifdef HQ_SBR
+#ifdef PARAMETRICSTEREO
+                    NULL,
+                    NULL,
+#endif
+#endif
+                    pVars);
+
+        }
+
+
+#ifdef HQ_SBR
+#ifdef PARAMETRICSTEREO
+    }
+#endif
+#endif
+
+    return err;
+}
+
+
+#endif
+
diff --git a/media/libstagefright/codecs/aacdec/sbr_applied.h b/media/libstagefright/codecs/aacdec/sbr_applied.h
new file mode 100644
index 0000000..6878537
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/sbr_applied.h
@@ -0,0 +1,136 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Filename: sbr_applied.h
+ Funtions:
+    get_dse
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+
+ Who:                                   Date: MM/DD/YYYY
+ Description:
+------------------------------------------------------------------------------
+SC 29 Software Copyright Licencing Disclaimer:
+
+This software module was originally developed by
+  Coding Technologies
+
+and edited by
+  -
+
+in the course of development of the ISO/IEC 13818-7 and ISO/IEC 14496-3
+standards for reference purposes and its performance may not have been
+optimized. This software module is an implementation of one or more tools as
+specified by the ISO/IEC 13818-7 and ISO/IEC 14496-3 standards.
+ISO/IEC gives users free license to this software module or modifications
+thereof for use in products claiming conformance to audiovisual and
+image-coding related ITU Recommendations and/or ISO/IEC International
+Standards. ISO/IEC gives users the same free license to this software module or
+modifications thereof for research purposes and further ISO/IEC standardisation.
+Those intending to use this software module in products are advised that its
+use may infringe existing patents. ISO/IEC have no liability for use of this
+software module or modifications thereof. Copyright is not released for
+products that do not conform to audiovisual and image-coding related ITU
+Recommendations and/or ISO/IEC International Standards.
+The original developer retains full right to modify and use the code for its
+own purpose, assign or donate the code to a third party and to inhibit third
+parties from using the code for products that do not conform to audiovisual and
+image-coding related ITU Recommendations and/or ISO/IEC International Standards.
+This copyright notice must be included in all copies or derivative works.
+Copyright (c) ISO/IEC 2002.
+
+ $Id: ct_envcalc.h,v 1.3 2002/11/29 16:11:49 kaehleof Exp $
+*/
+
+/*----------------------------------------------------------------------------
+; CONTINUE ONLY IF NOT ALREADY DEFINED
+----------------------------------------------------------------------------*/
+#ifndef SBR_APPLIED_H
+#define SBR_APPLIED_H
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+#include "e_sbr_error.h"
+#include "s_sbr_channel.h"
+#include "s_sbrbitstream.h"
+#include "sbr_dec.h"
+#include "pv_audio_type_defs.h"
+#include "s_tdec_int_file.h"
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here.
+----------------------------------------------------------------------------*/
+#define MAX_FRAME_SIZE  1024
+
+/*----------------------------------------------------------------------------
+; EXTERNAL VARIABLES REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; SIMPLE TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; ENUMERATED TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; STRUCTURES TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; GLOBAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+
+    SBR_ERROR  sbr_applied(SBRDECODER_DATA * self,
+    SBRBITSTREAM * stream,
+    Int16 *ch_left,
+    Int16 *ch_right,
+    Int16 *timeData,
+    SBR_DEC *sbrDec,
+    tDec_Int_File  *pVars,
+    Int32 numChannels);
+
+#ifdef __cplusplus
+}
+#endif
+
+/*----------------------------------------------------------------------------
+; END
+----------------------------------------------------------------------------*/
+#endif
+
+
diff --git a/media/libstagefright/codecs/aacdec/sbr_code_book_envlevel.cpp b/media/libstagefright/codecs/aacdec/sbr_code_book_envlevel.cpp
new file mode 100644
index 0000000..9db3221
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/sbr_code_book_envlevel.cpp
@@ -0,0 +1,403 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Filename: sbr_code_book_envlevel.c
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+
+ Who:                                   Date: MM/DD/YYYY
+ Description:
+
+------------------------------------------------------------------------------
+ INPUT AND OUTPUT DEFINITIONS
+
+
+
+------------------------------------------------------------------------------
+ FUNCTION DESCRIPTION
+
+
+------------------------------------------------------------------------------
+ REQUIREMENTS
+
+
+------------------------------------------------------------------------------
+ REFERENCES
+
+SC 29 Software Copyright Licencing Disclaimer:
+
+This software module was originally developed by
+  Coding Technologies
+
+and edited by
+  -
+
+in the course of development of the ISO/IEC 13818-7 and ISO/IEC 14496-3
+standards for reference purposes and its performance may not have been
+optimized. This software module is an implementation of one or more tools as
+specified by the ISO/IEC 13818-7 and ISO/IEC 14496-3 standards.
+ISO/IEC gives users free license to this software module or modifications
+thereof for use in products claiming conformance to audiovisual and
+image-coding related ITU Recommendations and/or ISO/IEC International
+Standards. ISO/IEC gives users the same free license to this software module or
+modifications thereof for research purposes and further ISO/IEC standardisation.
+Those intending to use this software module in products are advised that its
+use may infringe existing patents. ISO/IEC have no liability for use of this
+software module or modifications thereof. Copyright is not released for
+products that do not conform to audiovisual and image-coding related ITU
+Recommendations and/or ISO/IEC International Standards.
+The original developer retains full right to modify and use the code for its
+own purpose, assign or donate the code to a third party and to inhibit third
+parties from using the code for products that do not conform to audiovisual and
+image-coding related ITU Recommendations and/or ISO/IEC International Standards.
+This copyright notice must be included in all copies or derivative works.
+Copyright (c) ISO/IEC 2002.
+
+------------------------------------------------------------------------------
+ PSEUDO-CODE
+
+------------------------------------------------------------------------------
+*/
+
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+
+#ifdef AAC_PLUS
+
+
+#include   "pv_audio_type_defs.h"
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+    /*----------------------------------------------------------------------------
+    ; DEFINES
+    ; Include all pre-processor statements here. Include conditional
+    ; compile variables also.
+    ----------------------------------------------------------------------------*/
+
+    /*----------------------------------------------------------------------------
+    ; LOCAL FUNCTION DEFINITIONS
+    ; Function Prototype declaration
+    ----------------------------------------------------------------------------*/
+
+    /*----------------------------------------------------------------------------
+    ; LOCAL STORE/BUFFER/POINTER DEFINITIONS
+    ; Variable declaration - defined here and used outside this module
+    ----------------------------------------------------------------------------*/
+
+    /*----------------------------------------------------------------------------
+    ; EXTERNAL FUNCTION REFERENCES
+    ; Declare functions defined elsewhere and referenced in this module
+    ----------------------------------------------------------------------------*/
+
+    /*----------------------------------------------------------------------------
+    ; EXTERNAL GLOBAL STORE/BUFFER/POINTER REFERENCES
+    ; Declare variables used in this module but defined elsewhere
+    ----------------------------------------------------------------------------*/
+    /*******************************************************************************/
+    /* table       : envelope level, 1.5 dB                                        */
+    /* theor range : [-58,58], CODE_BOOK_SCF_LAV   = 58                            */
+    /* implem range: [-60,60], CODE_BOOK_SCF_LAV10 = 60                            */
+    /* raw stats   : envelopeLevel_00 (yes, wrong suffix in name)  KK 01-03-09     */
+    /*******************************************************************************/
+
+    /* direction: time
+       raw table: HuffCode3C2FIX.m/envelopeLevel_00T_cF.mat/m_hALC_cF
+       built by : FH 01-07-05 */
+
+    extern const Char bookSbrEnvLevel10T[120][2] =
+    {
+        {   1,   2 },    { -64, -65 },    {   3,   4 },    { -63, -66 },
+        {   5,   6 },    { -62, -67 },    {   7,   8 },    { -61, -68 },
+        {   9,  10 },    { -60, -69 },    {  11,  12 },    { -59, -70 },
+        {  13,  14 },    { -58, -71 },    {  15,  16 },    { -57, -72 },
+        {  17,  18 },    { -73, -56 },    {  19,  21 },    { -74,  20 },
+        { -55, -75 },    {  22,  26 },    {  23,  24 },    { -54, -76 },
+        { -77,  25 },    { -53, -78 },    {  27,  34 },    {  28,  29 },
+        { -52, -79 },    {  30,  31 },    { -80, -51 },    {  32,  33 },
+        { -83, -82 },    { -81, -50 },    {  35,  57 },    {  36,  40 },
+        {  37,  38 },    { -88, -84 },    { -48,  39 },    { -90, -85 },
+        {  41,  46 },    {  42,  43 },    { -49, -87 },    {  44,  45 },
+        { -89, -86 },    { -124, -123 },    {  47,  50 },    {  48,  49 },
+        { -122, -121 },    { -120, -119 },    {  51,  54 },    {  52,  53 },
+        { -118, -117 },    { -116, -115 },    {  55,  56 },    { -114, -113 },
+        { -112, -111 },    {  58,  89 },    {  59,  74 },    {  60,  67 },
+        {  61,  64 },    {  62,  63 },    { -110, -109 },    { -108, -107 },
+        {  65,  66 },    { -106, -105 },    { -104, -103 },    {  68,  71 },
+        {  69,  70 },    { -102, -101 },    { -100, -99 },    {  72,  73 },
+        { -98, -97 },    { -96, -95 },    {  75,  82 },    {  76,  79 },
+        {  77,  78 },    { -94, -93 },    { -92, -91 },    {  80,  81 },
+        { -47, -46 },    { -45, -44 },    {  83,  86 },    {  84,  85 },
+        { -43, -42 },    { -41, -40 },    {  87,  88 },    { -39, -38 },
+        { -37, -36 },    {  90, 105 },    {  91,  98 },    {  92,  95 },
+        {  93,  94 },    { -35, -34 },    { -33, -32 },    {  96,  97 },
+        { -31, -30 },    { -29, -28 },    {  99, 102 },    { 100, 101 },
+        { -27, -26 },    { -25, -24 },    { 103, 104 },    { -23, -22 },
+        { -21, -20 },    { 106, 113 },    { 107, 110 },    { 108, 109 },
+        { -19, -18 },    { -17, -16 },    { 111, 112 },    { -15, -14 },
+        { -13, -12 },    { 114, 117 },    { 115, 116 },    { -11, -10 },
+        {  -9,  -8 },    { 118, 119 },    {  -7,  -6 },    {  -5,  -4 }
+    };
+
+    /* direction: freq
+       raw table: HuffCode3C2FIX.m/envelopeLevel_00F_cF.mat/m_hALC_cF
+       built by : FH 01-07-05 */
+
+    extern const Char bookSbrEnvLevel10F[120][2] =
+    {
+        {   1,   2 },    { -64, -65 },    {   3,   4 },    { -63, -66 },
+        {   5,   6 },    { -67, -62 },    {   7,   8 },    { -68, -61 },
+        {   9,  10 },    { -69, -60 },    {  11,  13 },    { -70,  12 },
+        { -59, -71 },    {  14,  16 },    { -58,  15 },    { -72, -57 },
+        {  17,  19 },    { -73,  18 },    { -56, -74 },    {  20,  23 },
+        {  21,  22 },    { -55, -75 },    { -54, -53 },    {  24,  27 },
+        {  25,  26 },    { -76, -52 },    { -77, -51 },    {  28,  31 },
+        {  29,  30 },    { -50, -78 },    { -79, -49 },    {  32,  36 },
+        {  33,  34 },    { -48, -47 },    { -80,  35 },    { -81, -82 },
+        {  37,  47 },    {  38,  41 },    {  39,  40 },    { -83, -46 },
+        { -45, -84 },    {  42,  44 },    { -85,  43 },    { -44, -43 },
+        {  45,  46 },    { -88, -87 },    { -86, -90 },    {  48,  66 },
+        {  49,  56 },    {  50,  53 },    {  51,  52 },    { -92, -42 },
+        { -41, -39 },    {  54,  55 },    { -105, -89 },    { -38, -37 },
+        {  57,  60 },    {  58,  59 },    { -94, -91 },    { -40, -36 },
+        {  61,  63 },    { -20,  62 },    { -115, -110 },    {  64,  65 },
+        { -108, -107 },    { -101, -97 },    {  67,  89 },    {  68,  75 },
+        {  69,  72 },    {  70,  71 },    { -95, -93 },    { -34, -27 },
+        {  73,  74 },    { -22, -17 },    { -16, -124 },    {  76,  82 },
+        {  77,  79 },    { -123,  78 },    { -122, -121 },    {  80,  81 },
+        { -120, -119 },    { -118, -117 },    {  83,  86 },    {  84,  85 },
+        { -116, -114 },    { -113, -112 },    {  87,  88 },    { -111, -109 },
+        { -106, -104 },    {  90, 105 },    {  91,  98 },    {  92,  95 },
+        {  93,  94 },    { -103, -102 },    { -100, -99 },    {  96,  97 },
+        { -98, -96 },    { -35, -33 },    {  99, 102 },    { 100, 101 },
+        { -32, -31 },    { -30, -29 },    { 103, 104 },    { -28, -26 },
+        { -25, -24 },    { 106, 113 },    { 107, 110 },    { 108, 109 },
+        { -23, -21 },    { -19, -18 },    { 111, 112 },    { -15, -14 },
+        { -13, -12 },    { 114, 117 },    { 115, 116 },    { -11, -10 },
+        {  -9,  -8 },    { 118, 119 },    {  -7,  -6 },    {  -5,  -4 }
+    };
+
+    /*******************************************************************************/
+    /* table       : envelope balance, 1.5 dB                                      */
+    /* theor range : [-48,48], CODE_BOOK_SCF_LAV = 48                              */
+    /* implem range: same but mapped to [-24,24], CODE_BOOK_SCF_LAV_BALANCE10 = 24 */
+    /* raw stats   : envelopePan_00 (yes, wrong suffix in name)  KK 01-03-09       */
+    /*******************************************************************************/
+
+    /* direction: time
+       raw table: HuffCode3C.m/envelopePan_00T.mat/v_hALB
+       built by : FH 01-05-15 */
+
+    extern const Char bookSbrEnvBalance10T[48][2] =
+    {
+        { -64,   1 },    { -63,   2 },    { -65,   3 },    { -62,   4 },
+        { -66,   5 },    { -61,   6 },    { -67,   7 },    { -60,   8 },
+        { -68,   9 },    {  10,  11 },    { -69, -59 },    {  12,  13 },
+        { -70, -58 },    {  14,  28 },    {  15,  21 },    {  16,  18 },
+        { -57,  17 },    { -71, -56 },    {  19,  20 },    { -88, -87 },
+        { -86, -85 },    {  22,  25 },    {  23,  24 },    { -84, -83 },
+        { -82, -81 },    {  26,  27 },    { -80, -79 },    { -78, -77 },
+        {  29,  36 },    {  30,  33 },    {  31,  32 },    { -76, -75 },
+        { -74, -73 },    {  34,  35 },    { -72, -55 },    { -54, -53 },
+        {  37,  41 },    {  38,  39 },    { -52, -51 },    { -50,  40 },
+        { -49, -48 },    {  42,  45 },    {  43,  44 },    { -47, -46 },
+        { -45, -44 },    {  46,  47 },    { -43, -42 },    { -41, -40 }
+    };
+
+    /* direction: freq
+       raw table: HuffCode3C.m/envelopePan_00T.mat/v_hALB
+       built by : FH 01-05-15 */
+
+    extern const Char bookSbrEnvBalance10F[48][2] =
+    {
+        { -64,   1 },    { -65,   2 },    { -63,   3 },    { -66,   4 },
+        { -62,   5 },    { -61,   6 },    { -67,   7 },    { -68,   8 },
+        { -60,   9 },    {  10,  11 },    { -69, -59 },    { -70,  12 },
+        { -58,  13 },    {  14,  17 },    { -71,  15 },    { -57,  16 },
+        { -56, -73 },    {  18,  32 },    {  19,  25 },    {  20,  22 },
+        { -72,  21 },    { -88, -87 },    {  23,  24 },    { -86, -85 },
+        { -84, -83 },    {  26,  29 },    {  27,  28 },    { -82, -81 },
+        { -80, -79 },    {  30,  31 },    { -78, -77 },    { -76, -75 },
+        {  33,  40 },    {  34,  37 },    {  35,  36 },    { -74, -55 },
+        { -54, -53 },    {  38,  39 },    { -52, -51 },    { -50, -49 },
+        {  41,  44 },    {  42,  43 },    { -48, -47 },    { -46, -45 },
+        {  45,  46 },    { -44, -43 },    { -42,  47 },    { -41, -40 }
+    };
+
+    /*******************************************************************************/
+    /* table       : envelope level, 3.0 dB                                        */
+    /* theor range : [-29,29], CODE_BOOK_SCF_LAV   = 29                            */
+    /* implem range: [-31,31], CODE_BOOK_SCF_LAV11 = 31                            */
+    /* raw stats   : envelopeLevel_11  KK 00-02-03                                 */
+    /*******************************************************************************/
+
+    /* direction: time
+       raw table: HuffCode2.m
+       built by : FH 00-02-04 */
+
+    extern const Char bookSbrEnvLevel11T[62][2] =
+    {
+        { -64,   1 },    { -65,   2 },    { -63,   3 },    { -66,   4 },
+        { -62,   5 },    { -67,   6 },    { -61,   7 },    { -68,   8 },
+        { -60,   9 },    {  10,  11 },    { -69, -59 },    {  12,  14 },
+        { -70,  13 },    { -71, -58 },    {  15,  18 },    {  16,  17 },
+        { -72, -57 },    { -73, -74 },    {  19,  22 },    { -56,  20 },
+        { -55,  21 },    { -54, -77 },    {  23,  31 },    {  24,  25 },
+        { -75, -76 },    {  26,  27 },    { -78, -53 },    {  28,  29 },
+        { -52, -95 },    { -94,  30 },    { -93, -92 },    {  32,  47 },
+        {  33,  40 },    {  34,  37 },    {  35,  36 },    { -91, -90 },
+        { -89, -88 },    {  38,  39 },    { -87, -86 },    { -85, -84 },
+        {  41,  44 },    {  42,  43 },    { -83, -82 },    { -81, -80 },
+        {  45,  46 },    { -79, -51 },    { -50, -49 },    {  48,  55 },
+        {  49,  52 },    {  50,  51 },    { -48, -47 },    { -46, -45 },
+        {  53,  54 },    { -44, -43 },    { -42, -41 },    {  56,  59 },
+        {  57,  58 },    { -40, -39 },    { -38, -37 },    {  60,  61 },
+        { -36, -35 },    { -34, -33 }
+    };
+
+    /* direction: freq
+       raw table: HuffCode2.m
+       built by : FH 00-02-04 */
+
+    extern const Char bookSbrEnvLevel11F[62][2] =
+    {
+        { -64,   1 },    { -65,   2 },    { -63,   3 },    { -66,   4 },
+        { -62,   5 },    { -67,   6 },    {   7,   8 },    { -61, -68 },
+        {   9,  10 },    { -60, -69 },    {  11,  12 },    { -59, -70 },
+        {  13,  14 },    { -58, -71 },    {  15,  16 },    { -57, -72 },
+        {  17,  19 },    { -56,  18 },    { -55, -73 },    {  20,  24 },
+        {  21,  22 },    { -74, -54 },    { -53,  23 },    { -75, -76 },
+        {  25,  30 },    {  26,  27 },    { -52, -51 },    {  28,  29 },
+        { -77, -79 },    { -50, -49 },    {  31,  39 },    {  32,  35 },
+        {  33,  34 },    { -78, -46 },    { -82, -88 },    {  36,  37 },
+        { -83, -48 },    { -47,  38 },    { -86, -85 },    {  40,  47 },
+        {  41,  44 },    {  42,  43 },    { -80, -44 },    { -43, -42 },
+        {  45,  46 },    { -39, -87 },    { -84, -40 },    {  48,  55 },
+        {  49,  52 },    {  50,  51 },    { -95, -94 },    { -93, -92 },
+        {  53,  54 },    { -91, -90 },    { -89, -81 },    {  56,  59 },
+        {  57,  58 },    { -45, -41 },    { -38, -37 },    {  60,  61 },
+        { -36, -35 },    { -34, -33 }
+    };
+
+    /*******************************************************************************/
+    /* table       : envelope balance, 3.0 dB                                      */
+    /* theor range : [-24,24], CODE_BOOK_SCF_LAV = 24                              */
+    /* implem range: same but mapped to [-12,12], CODE_BOOK_SCF_LAV_BALANCE11 = 12 */
+    /* raw stats   : envelopeBalance_11  KK 00-02-03                               */
+    /*******************************************************************************/
+
+    /* direction: time
+       raw table: HuffCode3C.m/envelopeBalance_11T.mat/v_hALB
+       built by : FH 01-05-15 */
+
+    extern const Char bookSbrEnvBalance11T[24][2] =
+    {
+        { -64,   1 },    { -63,   2 },    { -65,   3 },    { -66,   4 },
+        { -62,   5 },    { -61,   6 },    { -67,   7 },    { -68,   8 },
+        { -60,   9 },    {  10,  16 },    {  11,  13 },    { -69,  12 },
+        { -76, -75 },    {  14,  15 },    { -74, -73 },    { -72, -71 },
+        {  17,  20 },    {  18,  19 },    { -70, -59 },    { -58, -57 },
+        {  21,  22 },    { -56, -55 },    { -54,  23 },    { -53, -52 }
+    };
+
+    /* direction: time (?)
+       raw table: HuffCode3C.m/envelopeBalance_11T.mat/v_hALB
+       built by : FH 01-05-15 */
+
+    extern const Char bookSbrEnvBalance11F[24][2] =
+    {
+        { -64,   1 },    { -65,   2 },    { -63,   3 },    { -66,   4 },
+        { -62,   5 },    { -61,   6 },    { -67,   7 },    { -68,   8 },
+        { -60,   9 },    {  10,  13 },    { -69,  11 },    { -59,  12 },
+        { -58, -76 },    {  14,  17 },    {  15,  16 },    { -75, -74 },
+        { -73, -72 },    {  18,  21 },    {  19,  20 },    { -71, -70 },
+        { -57, -56 },    {  22,  23 },    { -55, -54 },    { -53, -52 }
+    };
+
+    /*******************************************************************************/
+    /* table       : noise level, 3.0 dB                                           */
+    /* theor range : [-29,29], CODE_BOOK_SCF_LAV   = 29                            */
+    /* implem range: [-31,31], CODE_BOOK_SCF_LAV11 = 31                            */
+    /* raw stats   : noiseLevel_11  KK 00-02-03                                    */
+    /*******************************************************************************/
+
+    /* direction: time
+       raw table: HuffCode2.m
+       built by : FH 00-02-04 */
+
+    extern const Char bookSbrNoiseLevel11T[62][2] =
+    {
+        { -64,   1 },    { -63,   2 },    { -65,   3 },    { -66,   4 },
+        { -62,   5 },    { -67,   6 },    {   7,   8 },    { -61, -68 },
+        {   9,  30 },    {  10,  15 },    { -60,  11 },    { -69,  12 },
+        {  13,  14 },    { -59, -53 },    { -95, -94 },    {  16,  23 },
+        {  17,  20 },    {  18,  19 },    { -93, -92 },    { -91, -90 },
+        {  21,  22 },    { -89, -88 },    { -87, -86 },    {  24,  27 },
+        {  25,  26 },    { -85, -84 },    { -83, -82 },    {  28,  29 },
+        { -81, -80 },    { -79, -78 },    {  31,  46 },    {  32,  39 },
+        {  33,  36 },    {  34,  35 },    { -77, -76 },    { -75, -74 },
+        {  37,  38 },    { -73, -72 },    { -71, -70 },    {  40,  43 },
+        {  41,  42 },    { -58, -57 },    { -56, -55 },    {  44,  45 },
+        { -54, -52 },    { -51, -50 },    {  47,  54 },    {  48,  51 },
+        {  49,  50 },    { -49, -48 },    { -47, -46 },    {  52,  53 },
+        { -45, -44 },    { -43, -42 },    {  55,  58 },    {  56,  57 },
+        { -41, -40 },    { -39, -38 },    {  59,  60 },    { -37, -36 },
+        { -35,  61 },    { -34, -33 }
+    };
+
+    /*******************************************************************************/
+    /* table       : noise balance, 3.0 dB                                         */
+    /* theor range : [-24,24], CODE_BOOK_SCF_LAV = 24                              */
+    /* implem range: same but mapped to [-12,12], CODE_BOOK_SCF_LAV_BALANCE11 = 12 */
+    /* raw stats   : noiseBalance_11  KK 00-02-03                                  */
+    /*******************************************************************************/
+
+    /* direction: time
+       raw table: HuffCode3C.m/noiseBalance_11.mat/v_hALB
+       built by : FH 01-05-15 */
+
+    extern const Char bookSbrNoiseBalance11T[24][2] =
+    {
+        { -64,   1 },    { -65,   2 },    { -63,   3 },    {   4,   9 },
+        { -66,   5 },    { -62,   6 },    {   7,   8 },    { -76, -75 },
+        { -74, -73 },    {  10,  17 },    {  11,  14 },    {  12,  13 },
+        { -72, -71 },    { -70, -69 },    {  15,  16 },    { -68, -67 },
+        { -61, -60 },    {  18,  21 },    {  19,  20 },    { -59, -58 },
+        { -57, -56 },    {  22,  23 },    { -55, -54 },    { -53, -52 }
+    };
+
+#ifdef __cplusplus
+}
+#endif
+
+
+#endif
+
+
diff --git a/media/libstagefright/codecs/aacdec/sbr_code_book_envlevel.h b/media/libstagefright/codecs/aacdec/sbr_code_book_envlevel.h
new file mode 100644
index 0000000..3df0531
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/sbr_code_book_envlevel.h
@@ -0,0 +1,103 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Pathname: sbr_code_book_envlevel.h
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+
+------------------------------------------------------------------------------
+ INCLUDE DESCRIPTION
+
+ this file declares the scalefactor bands for all sampling rates
+
+------------------------------------------------------------------------------
+*/
+
+
+/*----------------------------------------------------------------------------
+; CONTINUE ONLY IF NOT ALREADY DEFINED
+----------------------------------------------------------------------------*/
+#ifndef SBR_CODE_BOOK_ENVLEVEL_H
+#define SBR_CODE_BOOK_ENVLEVEL_H
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+    /*----------------------------------------------------------------------------
+    ; DEFINES
+    ; Include all pre-processor statements here.
+    ----------------------------------------------------------------------------*/
+
+    /*----------------------------------------------------------------------------
+    ; EXTERNAL VARIABLES REFERENCES
+    ; Declare variables used in this module but defined elsewhere
+    ----------------------------------------------------------------------------*/
+    extern const Char bookSbrEnvLevel10T[120][2];
+    extern const Char bookSbrEnvLevel10F[120][2];
+    extern const Char bookSbrEnvBalance10T[48][2];
+    extern const Char bookSbrEnvBalance10F[48][2];
+    extern const Char bookSbrEnvLevel11T[62][2];
+    extern const Char bookSbrEnvLevel11F[62][2];
+    extern const Char bookSbrEnvBalance11T[24][2];
+    extern const Char bookSbrEnvBalance11F[24][2];
+    extern const Char bookSbrNoiseLevel11T[62][2];
+    extern const Char bookSbrNoiseBalance11T[24][2];
+
+    /*----------------------------------------------------------------------------
+    ; SIMPLE TYPEDEF'S
+    ----------------------------------------------------------------------------*/
+
+    /*----------------------------------------------------------------------------
+    ; ENUMERATED TYPEDEF'S
+    ----------------------------------------------------------------------------*/
+
+    /*----------------------------------------------------------------------------
+    ; STRUCTURES TYPEDEF'S
+    ----------------------------------------------------------------------------*/
+
+    /*----------------------------------------------------------------------------
+    ; GLOBAL FUNCTION DEFINITIONS
+    ; Function Prototype declaration
+    ----------------------------------------------------------------------------*/
+
+    /*----------------------------------------------------------------------------
+    ; END
+    ----------------------------------------------------------------------------*/
+
+#ifdef __cplusplus
+}
+#endif
+
+
+
+#endif
+
+
diff --git a/media/libstagefright/codecs/aacdec/sbr_constants.h b/media/libstagefright/codecs/aacdec/sbr_constants.h
new file mode 100644
index 0000000..d54a699
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/sbr_constants.h
@@ -0,0 +1,210 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Filename: sbr_constants.h
+ Funtions:
+
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+
+ Who:                                   Date: MM/DD/YYYY
+ Description:
+------------------------------------------------------------------------------
+SC 29 Software Copyright Licencing Disclaimer:
+
+This software module was originally developed by
+  Coding Technologies
+
+and edited by
+  -
+
+in the course of development of the ISO/IEC 13818-7 and ISO/IEC 14496-3
+standards for reference purposes and its performance may not have been
+optimized. This software module is an implementation of one or more tools as
+specified by the ISO/IEC 13818-7 and ISO/IEC 14496-3 standards.
+ISO/IEC gives users free license to this software module or modifications
+thereof for use in products claiming conformance to audiovisual and
+image-coding related ITU Recommendations and/or ISO/IEC International
+Standards. ISO/IEC gives users the same free license to this software module or
+modifications thereof for research purposes and further ISO/IEC standardisation.
+Those intending to use this software module in products are advised that its
+use may infringe existing patents. ISO/IEC have no liability for use of this
+software module or modifications thereof. Copyright is not released for
+products that do not conform to audiovisual and image-coding related ITU
+Recommendations and/or ISO/IEC International Standards.
+The original developer retains full right to modify and use the code for its
+own purpose, assign or donate the code to a third party and to inhibit third
+parties from using the code for products that do not conform to audiovisual and
+image-coding related ITU Recommendations and/or ISO/IEC International Standards.
+This copyright notice must be included in all copies or derivative works.
+Copyright (c) ISO/IEC 2002.
+
+*/
+
+/*----------------------------------------------------------------------------
+; CONTINUE ONLY IF NOT ALREADY DEFINED
+----------------------------------------------------------------------------*/
+#ifndef SBR_CONSTANTS_H
+#define SBR_CONSTANTS_H
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here.
+----------------------------------------------------------------------------*/
+
+
+#define SBR_AMP_RES_1_5         0
+#define SBR_AMP_RES_3_0         1
+
+#define MAX_NOISE_ENVELOPES     2
+#define MAX_NOISE_COEFFS        5
+#define MAX_NUM_NOISE_VALUES     (MAX_NOISE_ENVELOPES * MAX_NOISE_COEFFS)
+
+#define MAX_ENVELOPES           5
+#define MAX_FREQ_COEFFS         58
+#define MAX_NUM_ENVELOPE_VALUES (MAX_ENVELOPES * MAX_FREQ_COEFFS)
+
+#define MAX_NUM_CHANNELS            2
+#define NOISE_FLOOR_OFFSET          6
+#define NOISE_FLOOR_OFFSET_PLUS_1   7
+
+#define LOW_RES                     0
+#define HIGH_RES                    1
+
+#define LO                          0
+#define HI                          1
+
+#define TIME                        1
+#define FREQ                        0
+
+#define LENGTH_FRAME_INFO           35
+
+#define SI_SBR_CRC_BITS             10
+
+#define SBR_FREQ_SCALE_DEFAULT      2
+#define SBR_ALTER_SCALE_DEFAULT     1
+#define SBR_NOISE_BANDS_DEFAULT     2
+
+#define SBR_LIMITER_BANDS_DEFAULT      2
+#define SBR_LIMITER_GAINS_DEFAULT      2
+#define SBR_INTERPOL_FREQ_DEFAULT      1
+#define SBR_SMOOTHING_LENGTH_DEFAULT   1
+
+/* header */
+#define SI_SBR_AMP_RES_BITS            1
+#define SI_SBR_START_FREQ_BITS         4
+#define SI_SBR_STOP_FREQ_BITS          4
+#define SI_SBR_XOVER_BAND_BITS         3
+#define SI_SBR_RESERVED_BITS_HDR       2
+#define SI_SBR_DATA_EXTRA_BITS         1
+#define SI_SBR_HEADER_EXTRA_1_BITS     1
+#define SI_SBR_HEADER_EXTRA_2_BITS     1
+
+#define SI_SBR_FREQ_SCALE_BITS         2
+#define SI_SBR_ALTER_SCALE_BITS        1
+#define SI_SBR_NOISE_BANDS_BITS        2
+
+#define SI_SBR_LIMITER_BANDS_BITS      2
+#define SI_SBR_LIMITER_GAINS_BITS      2
+#define SI_SBR_INTERPOL_FREQ_BITS      1
+#define SI_SBR_SMOOTHING_LENGTH_BITS   1
+
+
+/* data */
+#define SI_SBR_RESERVED_PRESENT        1
+#define SI_SBR_RESERVED_BITS_DATA      4
+
+#define SI_SBR_COUPLING_BITS           1
+
+#define SI_SBR_INVF_MODE_BITS          2
+
+#define SI_SBR_EXTENDED_DATA_BITS      1
+#define SI_SBR_EXTENSION_SIZE_BITS     4
+#define SI_SBR_EXTENSION_ESC_COUNT_BITS   8
+#define SI_SBR_EXTENSION_ID_BITS          2
+
+#define SI_SBR_NOISE_MODE_BITS         1
+#define SI_SBR_DOMAIN_BITS             1
+
+#define SI_SBR_START_ENV_BITS_AMP_RES_3_0           6
+#define SI_SBR_START_ENV_BITS_BALANCE_AMP_RES_3_0   5
+#define SI_SBR_START_NOISE_BITS_AMP_RES_3_0         5
+#define SI_SBR_START_NOISE_BITS_BALANCE_AMP_RES_3_0 5
+
+#define SI_SBR_START_ENV_BITS_AMP_RES_1_5           7
+#define SI_SBR_START_ENV_BITS_BALANCE_AMP_RES_1_5   6
+
+
+#define SBR_CLA_BITS  2
+#define SBR_ABS_BITS  2
+#define SBR_RES_BITS  1
+#define SBR_REL_BITS  2
+#define SBR_ENV_BITS  2
+#define SBR_NUM_BITS  2
+
+
+#define FIXFIX  0
+#define FIXVAR  1
+#define VARFIX  2
+#define VARVAR  3
+
+
+#define    LEN_EX_TYPE  (4)
+#define    LEN_NIBBLE   (4)
+
+
+/*----------------------------------------------------------------------------
+; EXTERNAL VARIABLES REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; SIMPLE TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; ENUMERATED TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; STRUCTURES TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; GLOBAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; END
+----------------------------------------------------------------------------*/
+#endif
+
+
diff --git a/media/libstagefright/codecs/aacdec/sbr_crc_check.cpp b/media/libstagefright/codecs/aacdec/sbr_crc_check.cpp
new file mode 100644
index 0000000..3bb4398
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/sbr_crc_check.cpp
@@ -0,0 +1,191 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Filename: sbr_crc_check.c
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+
+ Who:                                   Date: MM/DD/YYYY
+ Description:
+
+------------------------------------------------------------------------------
+ INPUT AND OUTPUT DEFINITIONS
+
+
+------------------------------------------------------------------------------
+ FUNCTION DESCRIPTION
+
+
+------------------------------------------------------------------------------
+ REQUIREMENTS
+
+
+------------------------------------------------------------------------------
+ REFERENCES
+
+SC 29 Software Copyright Licencing Disclaimer:
+
+This software module was originally developed by
+  Coding Technologies
+
+and edited by
+  -
+
+in the course of development of the ISO/IEC 13818-7 and ISO/IEC 14496-3
+standards for reference purposes and its performance may not have been
+optimized. This software module is an implementation of one or more tools as
+specified by the ISO/IEC 13818-7 and ISO/IEC 14496-3 standards.
+ISO/IEC gives users free license to this software module or modifications
+thereof for use in products claiming conformance to audiovisual and
+image-coding related ITU Recommendations and/or ISO/IEC International
+Standards. ISO/IEC gives users the same free license to this software module or
+modifications thereof for research purposes and further ISO/IEC standardisation.
+Those intending to use this software module in products are advised that its
+use may infringe existing patents. ISO/IEC have no liability for use of this
+software module or modifications thereof. Copyright is not released for
+products that do not conform to audiovisual and image-coding related ITU
+Recommendations and/or ISO/IEC International Standards.
+The original developer retains full right to modify and use the code for its
+own purpose, assign or donate the code to a third party and to inhibit third
+parties from using the code for products that do not conform to audiovisual and
+image-coding related ITU Recommendations and/or ISO/IEC International Standards.
+This copyright notice must be included in all copies or derivative works.
+Copyright (c) ISO/IEC 2002.
+
+------------------------------------------------------------------------------
+ PSEUDO-CODE
+
+------------------------------------------------------------------------------
+*/
+
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+
+#ifdef AAC_PLUS
+
+
+#include "sbr_crc_check.h"
+#include "s_crc_buffer.h"
+#include "buf_getbits.h"
+#include "sbr_constants.h"
+#include "check_crc.h"
+
+
+
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here. Include conditional
+; compile variables also.
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; LOCAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; LOCAL STORE/BUFFER/POINTER DEFINITIONS
+; Variable declaration - defined here and used outside this module
+----------------------------------------------------------------------------*/
+
+const unsigned short MAXCRCSTEP = 16;
+
+/*----------------------------------------------------------------------------
+; EXTERNAL FUNCTION REFERENCES
+; Declare functions defined elsewhere and referenced in this module
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL GLOBAL STORE/BUFFER/POINTER REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; FUNCTION CODE
+----------------------------------------------------------------------------*/
+
+Int32 sbr_crc_check(BIT_BUFFER * hBitBuf, UInt32 NrBits)
+{
+    Int32 crcResult = 1;
+    BIT_BUFFER BitBufferCRC;
+    UInt32 NrCrcBits;
+
+    UInt32 crcCheckSum;
+
+    Int32 i;
+    CRC_BUFFER CrcBuf;
+    UInt32 bValue;
+    Int32 CrcStep;
+    Int32 CrcNrBitsRest;
+
+    crcCheckSum = buf_getbits(hBitBuf, SI_SBR_CRC_BITS);
+
+
+    /*
+     *    Copy Bit buffer State
+     */
+
+    BitBufferCRC.char_ptr       = hBitBuf->char_ptr;
+    BitBufferCRC.buffer_word    = hBitBuf->buffer_word;
+    BitBufferCRC.buffered_bits  = hBitBuf->buffered_bits;
+    BitBufferCRC.nrBitsRead     = hBitBuf->nrBitsRead;
+    BitBufferCRC.bufferLen      = hBitBuf->bufferLen;
+
+
+    NrCrcBits = min(NrBits, BitBufferCRC.bufferLen - BitBufferCRC.nrBitsRead);
+
+
+    CrcStep = NrCrcBits / MAXCRCSTEP;
+    CrcNrBitsRest = (NrCrcBits - CrcStep * MAXCRCSTEP);
+
+    CrcBuf.crcState = CRCSTART;
+    CrcBuf.crcMask  = CRCMASK;
+    CrcBuf.crcPoly  = CRCPOLY;
+
+    for (i = 0; i < CrcStep; i++)
+    {
+        bValue = buf_getbits(&BitBufferCRC, MAXCRCSTEP);
+        check_crc(&CrcBuf, bValue, MAXCRCSTEP);
+    }
+
+    bValue = buf_getbits(&BitBufferCRC, CrcNrBitsRest);
+    check_crc(&CrcBuf, bValue, CrcNrBitsRest);
+
+    if ((UInt32)(CrcBuf.crcState & CRCRANGE) != crcCheckSum)
+    {
+        crcResult = 0;
+    }
+
+    return (crcResult);
+}
+
+#endif
+
+
diff --git a/media/libstagefright/codecs/aacdec/sbr_crc_check.h b/media/libstagefright/codecs/aacdec/sbr_crc_check.h
new file mode 100644
index 0000000..9e6b1be
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/sbr_crc_check.h
@@ -0,0 +1,98 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Filename: sbr_crc_check.h
+ Funtions:
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+
+ Who:                                   Date: MM/DD/YYYY
+ Description:
+------------------------------------------------------------------------------
+
+
+----------------------------------------------------------------------------
+; CONTINUE ONLY IF NOT ALREADY DEFINED
+----------------------------------------------------------------------------*/
+#ifndef SBR_CRC_CHECK_H
+#define SBR_CRC_CHECK_H
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+#include "pv_audio_type_defs.h"
+#include "s_bit_buffer.h"
+
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here.
+----------------------------------------------------------------------------*/
+#define CRCPOLY  0x0233
+#define CRCMASK  0x0200
+#define CRCSTART 0x0000
+#define CRCRANGE 0x03FF
+
+#define SBR_EXTENSION      13 /* 1101 */
+#define SBR_EXTENSION_CRC  14 /* 1110 */
+
+
+
+#ifndef min
+#define min(a, b) ((a) < (b) ? (a) : (b))
+#endif
+
+/*----------------------------------------------------------------------------
+; EXTERNAL VARIABLES REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; SIMPLE TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; ENUMERATED TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; STRUCTURES TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; GLOBAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+Int32 sbr_crc_check(BIT_BUFFER * hBitBuf,
+                    UInt32 NrBits);
+
+
+/*----------------------------------------------------------------------------
+; END
+----------------------------------------------------------------------------*/
+#endif
+
+
diff --git a/media/libstagefright/codecs/aacdec/sbr_create_limiter_bands.cpp b/media/libstagefright/codecs/aacdec/sbr_create_limiter_bands.cpp
new file mode 100644
index 0000000..9472ffc
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/sbr_create_limiter_bands.cpp
@@ -0,0 +1,253 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Filename: sbr_create_limiter_bands.c
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+
+ Who:                                   Date: MM/DD/YYYY
+ Description:
+
+------------------------------------------------------------------------------
+ INPUT AND OUTPUT DEFINITIONS
+
+
+
+------------------------------------------------------------------------------
+ FUNCTION DESCRIPTION
+
+
+------------------------------------------------------------------------------
+ REQUIREMENTS
+
+
+------------------------------------------------------------------------------
+ REFERENCES
+
+SC 29 Software Copyright Licencing Disclaimer:
+
+This software module was originally developed by
+  Coding Technologies
+
+and edited by
+  -
+
+in the course of development of the ISO/IEC 13818-7 and ISO/IEC 14496-3
+standards for reference purposes and its performance may not have been
+optimized. This software module is an implementation of one or more tools as
+specified by the ISO/IEC 13818-7 and ISO/IEC 14496-3 standards.
+ISO/IEC gives users free license to this software module or modifications
+thereof for use in products claiming conformance to audiovisual and
+image-coding related ITU Recommendations and/or ISO/IEC International
+Standards. ISO/IEC gives users the same free license to this software module or
+modifications thereof for research purposes and further ISO/IEC standardisation.
+Those intending to use this software module in products are advised that its
+use may infringe existing patents. ISO/IEC have no liability for use of this
+software module or modifications thereof. Copyright is not released for
+products that do not conform to audiovisual and image-coding related ITU
+Recommendations and/or ISO/IEC International Standards.
+The original developer retains full right to modify and use the code for its
+own purpose, assign or donate the code to a third party and to inhibit third
+parties from using the code for products that do not conform to audiovisual and
+image-coding related ITU Recommendations and/or ISO/IEC International Standards.
+This copyright notice must be included in all copies or derivative works.
+Copyright (c) ISO/IEC 2002.
+
+------------------------------------------------------------------------------
+ PSEUDO-CODE
+
+------------------------------------------------------------------------------
+*/
+
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+
+#ifdef AAC_PLUS
+
+
+#include    "sbr_create_limiter_bands.h"
+#include    "shellsort.h"
+#include    "s_patch.h"
+#include    "pv_log2.h"
+
+#include "fxp_mul32.h"
+
+#define R_SHIFT     29
+#define Q_fmt(x)   (Int32)(x*((Int32)1<<R_SHIFT) + (x>=0?0.5F:-0.5F))
+
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here. Include conditional
+; compile variables also.
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; LOCAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; LOCAL STORE/BUFFER/POINTER DEFINITIONS
+; Variable declaration - defined here and used outside this module
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL FUNCTION REFERENCES
+; Declare functions defined elsewhere and referenced in this module
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL GLOBAL STORE/BUFFER/POINTER REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; FUNCTION CODE
+----------------------------------------------------------------------------*/
+
+void sbr_create_limiter_bands(Int32 limSbc[][13],
+                              Int32 *gateMode,
+                              Int   *freqTable,
+                              struct PATCH Patch,
+                              const Int32 noBands)
+{
+    Int32 i;
+    Int32 j;
+    Int32 k;
+    Int isPatchBorder[2];
+    Int32 patchBorders[MAX_NUM_PATCHES + 1];
+    Int32 workLimiterBandTable[32 + MAX_NUM_PATCHES + 1];
+
+    Int32 nOctaves;
+    const Int32 limiterBandsPerOctave[4] =
+        {Q_fmt(0.0F), Q_fmt(1.2F),
+         Q_fmt(2.0F), Q_fmt(3.0F)
+        };
+
+    Int32 tmp_q1;
+
+    Int32 noPatches = Patch.noOfPatches;
+    Int32 lowSubband = freqTable[0];
+    Int32 highSubband = freqTable[noBands];
+
+
+    for (i = 0; i < noPatches; i++)
+    {
+        patchBorders[i] = Patch.targetStartBand[i] - lowSubband;
+    }
+    patchBorders[i] = highSubband - lowSubband;
+
+    /* First band: 1 limiter band. */
+    limSbc[0][0] = freqTable[0] - lowSubband;
+    limSbc[0][1] = freqTable[noBands] - lowSubband;
+    gateMode[0] = 1;
+
+    /* Next three bands: 1.2, 2, 3 limiter bands/octave plus bandborders at patchborders. */
+    for (i = 1; i < 4; i++)
+    {
+
+        for (k = 0; k <= noBands; k++)
+        {
+            workLimiterBandTable[k] = freqTable[k] - lowSubband;
+        }
+
+        for (k = 1; k < noPatches; k++)
+        {
+            workLimiterBandTable[noBands+k] = patchBorders[k];
+        }
+
+        gateMode[i] = noBands + noPatches - 1;
+        shellsort(workLimiterBandTable, gateMode[i] + 1);
+
+        for (j = 1; j <= gateMode[i]; j++)
+        {
+            tmp_q1 = ((workLimiterBandTable[j] + lowSubband) << 20) / (workLimiterBandTable[j-1] + lowSubband);
+
+            nOctaves = pv_log2(tmp_q1);
+
+            tmp_q1 = fxp_mul32_Q20(nOctaves, limiterBandsPerOctave[i]);
+            if (tmp_q1 < Q_fmt(0.49))
+            {
+                if (workLimiterBandTable[j] == workLimiterBandTable[j-1])
+                {
+                    workLimiterBandTable[j] = highSubband;
+                    shellsort(workLimiterBandTable, gateMode[i] + 1);
+                    gateMode[i]--;
+                    j--;
+                    continue;
+                }
+
+                isPatchBorder[0] = isPatchBorder[1] = 0;
+
+                for (k = 0; k <= noPatches; k++)
+                {
+                    if (workLimiterBandTable[j-1] == patchBorders[k])
+                    {
+                        isPatchBorder[0] = 1;
+                        break;
+                    }
+                }
+
+                for (k = 0; k <= noPatches; k++)
+                {
+                    if (workLimiterBandTable[j] == patchBorders[k])
+                    {
+                        isPatchBorder[1] = 1;
+                        break;
+                    }
+                }
+
+                if (!isPatchBorder[1])
+                {
+                    workLimiterBandTable[j] = highSubband;
+                    shellsort(workLimiterBandTable, gateMode[i] + 1);
+                    gateMode[i]--;
+                    j--;
+                }
+                else if (!isPatchBorder[0])
+                {
+                    workLimiterBandTable[j-1] = highSubband;
+                    shellsort(workLimiterBandTable, gateMode[i] + 1);
+                    gateMode[i]--;
+                    j--;
+                }
+            }
+        }
+        for (k = 0; k <= gateMode[i]; k++)
+        {
+            limSbc[i][k] = workLimiterBandTable[k];
+        }
+    }
+}
+
+
+
+#endif
+
diff --git a/media/libstagefright/codecs/aacdec/sbr_create_limiter_bands.h b/media/libstagefright/codecs/aacdec/sbr_create_limiter_bands.h
new file mode 100644
index 0000000..7a53944
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/sbr_create_limiter_bands.h
@@ -0,0 +1,95 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Filename: sbr_create_limiter_bands.h
+ Funtions:
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+
+ Who:                                   Date: MM/DD/YYYY
+ Description:
+------------------------------------------------------------------------------
+
+
+----------------------------------------------------------------------------
+; CONTINUE ONLY IF NOT ALREADY DEFINED
+----------------------------------------------------------------------------*/
+#ifndef SBR_CREATE_LIMITER_BANDS_H
+#define SBR_CREATE_LIMITER_BANDS_H
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+#include    "pv_audio_type_defs.h"
+#include    "sbr_generate_high_freq.h"
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here.
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL VARIABLES REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; SIMPLE TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; ENUMERATED TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; STRUCTURES TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; GLOBAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+    void sbr_create_limiter_bands(Int32 limSbc[4][12 + 1],
+    Int32 gateMode[4],
+    Int   *freqTable,
+    struct PATCH Patch,
+    const Int32 noBands);
+
+#ifdef __cplusplus
+}
+#endif
+
+/*----------------------------------------------------------------------------
+; END
+----------------------------------------------------------------------------*/
+#endif
+
+
diff --git a/media/libstagefright/codecs/aacdec/sbr_dec.cpp b/media/libstagefright/codecs/aacdec/sbr_dec.cpp
new file mode 100644
index 0000000..8519b17
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/sbr_dec.cpp
@@ -0,0 +1,960 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2010 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Filename: sbr_dec.c
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+
+ Who:                                   Date: MM/DD/YYYY
+ Description:
+
+------------------------------------------------------------------------------
+ INPUT AND OUTPUT DEFINITIONS
+
+
+
+------------------------------------------------------------------------------
+ FUNCTION DESCRIPTION
+
+    sbr decoder core function
+
+------------------------------------------------------------------------------
+ REQUIREMENTS
+
+
+------------------------------------------------------------------------------
+ REFERENCES
+
+SC 29 Software Copyright Licencing Disclaimer:
+
+This software module was originally developed by
+  Coding Technologies
+
+and edited by
+  -
+
+in the course of development of the ISO/IEC 13818-7 and ISO/IEC 14496-3
+standards for reference purposes and its performance may not have been
+optimized. This software module is an implementation of one or more tools as
+specified by the ISO/IEC 13818-7 and ISO/IEC 14496-3 standards.
+ISO/IEC gives users free license to this software module or modifications
+thereof for use in products claiming conformance to audiovisual and
+image-coding related ITU Recommendations and/or ISO/IEC International
+Standards. ISO/IEC gives users the same free license to this software module or
+modifications thereof for research purposes and further ISO/IEC standardisation.
+Those intending to use this software module in products are advised that its
+use may infringe existing patents. ISO/IEC have no liability for use of this
+software module or modifications thereof. Copyright is not released for
+products that do not conform to audiovisual and image-coding related ITU
+Recommendations and/or ISO/IEC International Standards.
+The original developer retains full right to modify and use the code for its
+own purpose, assign or donate the code to a third party and to inhibit third
+parties from using the code for products that do not conform to audiovisual and
+image-coding related ITU Recommendations and/or ISO/IEC International Standards.
+This copyright notice must be included in all copies or derivative works.
+Copyright (c) ISO/IEC 2002.
+
+------------------------------------------------------------------------------
+ PSEUDO-CODE
+
+------------------------------------------------------------------------------
+*/
+
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+#ifdef AAC_PLUS
+
+
+#include    "s_sbr_frame_data.h"
+#include    "calc_sbr_synfilterbank.h"
+#include    "calc_sbr_anafilterbank.h"
+#include    "calc_sbr_envelope.h"
+#include    "sbr_generate_high_freq.h"
+#include    "sbr_dec.h"
+#include    "decode_noise_floorlevels.h"
+#include    "aac_mem_funcs.h"
+#include    "fxp_mul32.h"
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here. Include conditional
+; compile variables also.
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; LOCAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+/*----------------------------------------------------------------------------
+; LOCAL STORE/BUFFER/POINTER DEFINITIONS
+; Variable declaration - defined here and used outside this module
+----------------------------------------------------------------------------*/
+
+
+/*----------------------------------------------------------------------------
+; EXTERNAL FUNCTION REFERENCES
+; Declare functions defined elsewhere and referenced in this module
+----------------------------------------------------------------------------*/
+#include "pv_audio_type_defs.h"
+
+#ifdef PARAMETRICSTEREO
+
+#include   "ps_applied.h"
+#include   "ps_init_stereo_mixing.h"
+
+#endif
+
+/*----------------------------------------------------------------------------
+; EXTERNAL GLOBAL STORE/BUFFER/POINTER REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; FUNCTION CODE
+----------------------------------------------------------------------------*/
+
+void sbr_dec(Int16 *inPcmData,
+             Int16 *ftimeOutPtr,
+             SBR_FRAME_DATA * hFrameData,
+             int32_t applyProcessing,
+             SBR_DEC *sbrDec,
+#ifdef HQ_SBR
+#ifdef PARAMETRICSTEREO
+             Int16 * ftimeOutPtrPS,
+             HANDLE_PS_DEC hParametricStereoDec,
+#endif
+#endif
+             tDec_Int_File  *pVars)
+{
+    int32_t   i;
+    int32_t   j;
+    int32_t   m;
+
+    int32_t  *frameInfo = hFrameData->frameInfo;
+    Int  num_qmf_bands;
+
+#ifdef HQ_SBR
+#ifdef PARAMETRICSTEREO
+
+    int32_t env;
+
+    int32_t *qmf_PS_generated_Real;
+    int32_t *qmf_PS_generated_Imag;
+
+    int32_t *Sr_x;
+    int32_t *Si_x;
+
+
+#endif
+#endif
+
+    int32_t(*scratch_mem)[64];
+    Int16 *circular_buffer_s;
+
+    int32_t   k;
+    int32_t *Sr;
+    int32_t *Si;
+    int32_t *ptr_tmp1;
+    int32_t *ptr_tmp2;
+    scratch_mem = pVars->scratch.scratch_mem;
+
+
+    if (applyProcessing)
+    {
+        num_qmf_bands = sbrDec->lowSubband;
+    }
+    else
+    {
+        num_qmf_bands = 32;     /* becomes a resampler by 2  */
+    }
+
+    /* -------------------------------------------------- */
+    /*
+     *    Re-Load Buffers
+     */
+    pv_memmove(&hFrameData->sbrQmfBufferReal[0],
+               &hFrameData->HistsbrQmfBufferReal[0],
+               6*SBR_NUM_BANDS*sizeof(*hFrameData->sbrQmfBufferReal));
+#ifdef HQ_SBR
+
+
+    if (sbrDec->LC_aacP_DecoderFlag == OFF)
+    {
+        pv_memmove(&hFrameData->sbrQmfBufferImag[0],
+                   &hFrameData->HistsbrQmfBufferImag[0],
+                   6*SBR_NUM_BANDS*sizeof(*hFrameData->sbrQmfBufferImag));
+    }
+#endif
+    /* -------------------------------------------------- */
+
+
+    /*
+     *    low band codec signal subband filtering
+     */
+
+    for (i = 0; i < 32; i++)
+    {
+
+        if (sbrDec->LC_aacP_DecoderFlag == ON)
+        {
+
+            calc_sbr_anafilterbank_LC(hFrameData->codecQmfBufferReal[sbrDec->bufWriteOffs + i],
+                                      &inPcmData[319] + (i << 5),
+                                      scratch_mem,
+                                      num_qmf_bands);
+
+        }
+#ifdef HQ_SBR
+        else
+        {
+
+            calc_sbr_anafilterbank(hFrameData->codecQmfBufferReal[sbrDec->bufWriteOffs + i],
+                                   hFrameData->codecQmfBufferImag[sbrDec->bufWriteOffs + i],
+                                   &inPcmData[319] + (i << 5),
+                                   scratch_mem,
+                                   num_qmf_bands);
+        }
+#endif
+
+    }
+
+    if (pVars->ltp_buffer_state)
+    {
+        pv_memcpy(&inPcmData[-1024-288], &inPcmData[1024], 288*sizeof(*inPcmData));
+    }
+    else
+    {
+        pv_memcpy(&inPcmData[1024 + 288], &inPcmData[1024], 288*sizeof(*inPcmData));
+    }
+
+
+    if (applyProcessing)
+    {
+
+        /*
+         *  Inverse filtering of lowband + HF generation
+         */
+
+        if (sbrDec->LC_aacP_DecoderFlag == ON)
+        {
+
+            sbr_generate_high_freq((int32_t(*)[32])(hFrameData->codecQmfBufferReal + sbrDec->bufReadOffs),
+                                   NULL,
+                                   (int32_t *)(hFrameData->sbrQmfBufferReal),
+                                   NULL,
+                                   hFrameData->sbr_invf_mode,
+                                   hFrameData->sbr_invf_mode_prev,
+                                   &(sbrDec->FreqBandTableNoise[1]),
+                                   sbrDec->NoNoiseBands,
+                                   sbrDec->lowSubband,
+                                   sbrDec->V_k_master,
+                                   sbrDec->Num_Master,
+                                   sbrDec->outSampleRate,
+                                   frameInfo,
+                                   hFrameData->degreeAlias,
+                                   scratch_mem,
+                                   hFrameData->BwVector,/* */
+                                   hFrameData->BwVectorOld,
+                                   &(sbrDec->Patch),
+                                   sbrDec->LC_aacP_DecoderFlag,
+                                   &(sbrDec->highSubband));
+
+
+            /*
+             *      Adjust envelope of current frame.
+             */
+
+            calc_sbr_envelope(hFrameData,
+                              (int32_t *)(hFrameData->sbrQmfBufferReal),
+                              NULL,
+                              sbrDec->FreqBandTable,
+                              sbrDec->NSfb,
+                              sbrDec->FreqBandTableNoise,
+                              sbrDec->NoNoiseBands,
+                              hFrameData->reset_flag,
+                              hFrameData->degreeAlias,
+                              &(hFrameData->harm_index),
+                              &(hFrameData->phase_index),
+                              hFrameData->hFp,
+                              &(hFrameData->sUp),
+                              sbrDec->limSbc,
+                              sbrDec->gateMode,
+#ifdef HQ_SBR
+                              NULL,
+                              NULL,
+                              NULL,
+                              NULL,
+#endif
+                              scratch_mem,
+                              sbrDec->Patch,
+                              sbrDec->sqrt_cache,
+                              sbrDec->LC_aacP_DecoderFlag);
+        }
+#ifdef HQ_SBR
+        else
+        {
+
+            sbr_generate_high_freq((int32_t(*)[32])(hFrameData->codecQmfBufferReal + sbrDec->bufReadOffs),
+                                   (int32_t(*)[32])(hFrameData->codecQmfBufferImag + sbrDec->bufReadOffs),
+                                   (int32_t *)(hFrameData->sbrQmfBufferReal),
+                                   (int32_t *)(hFrameData->sbrQmfBufferImag),
+                                   hFrameData->sbr_invf_mode,
+                                   hFrameData->sbr_invf_mode_prev,
+                                   &(sbrDec->FreqBandTableNoise[1]),
+                                   sbrDec->NoNoiseBands,
+                                   sbrDec->lowSubband,
+                                   sbrDec->V_k_master,
+                                   sbrDec->Num_Master,
+                                   sbrDec->outSampleRate,
+                                   frameInfo,
+                                   NULL,
+                                   scratch_mem,
+                                   hFrameData->BwVector,
+                                   hFrameData->BwVectorOld,
+                                   &(sbrDec->Patch),
+                                   sbrDec->LC_aacP_DecoderFlag,
+                                   &(sbrDec->highSubband));
+
+            /*
+             *      Adjust envelope of current frame.
+             */
+
+            calc_sbr_envelope(hFrameData,
+                              (int32_t *)(hFrameData->sbrQmfBufferReal),
+                              (int32_t *)(hFrameData->sbrQmfBufferImag),
+                              sbrDec->FreqBandTable,
+                              sbrDec->NSfb,
+                              sbrDec->FreqBandTableNoise,
+                              sbrDec->NoNoiseBands,
+                              hFrameData->reset_flag,
+                              NULL,
+                              &(hFrameData->harm_index),
+                              &(hFrameData->phase_index),
+                              hFrameData->hFp,
+                              &(hFrameData->sUp),
+                              sbrDec->limSbc,
+                              sbrDec->gateMode,
+                              hFrameData->fBuf_man,
+                              hFrameData->fBuf_exp,
+                              hFrameData->fBufN_man,
+                              hFrameData->fBufN_exp,
+                              scratch_mem,
+                              sbrDec->Patch,
+                              sbrDec->sqrt_cache,
+                              sbrDec->LC_aacP_DecoderFlag);
+
+        }
+#endif
+
+
+    }
+    else   /*  else for applyProcessing */
+    {
+        /* no sbr, set high band buffers to zero */
+
+        for (i = 0; i < SBR_NUM_COLUMNS; i++)
+        {
+            pv_memset((void *)&hFrameData->sbrQmfBufferReal[i*SBR_NUM_BANDS],
+                      0,
+                      SBR_NUM_BANDS*sizeof(*hFrameData->sbrQmfBufferReal));
+
+#ifdef HQ_SBR
+            pv_memset((void *)&hFrameData->sbrQmfBufferImag[i*SBR_NUM_BANDS],
+                      0,
+                      SBR_NUM_BANDS*sizeof(*hFrameData->sbrQmfBufferImag));
+
+#endif
+        }
+
+    }
+
+
+    /*
+     *  Synthesis subband filtering.
+     */
+
+#ifdef HQ_SBR
+
+#ifdef PARAMETRICSTEREO
+
+
+    /*
+     * psPresentFlag set implies hParametricStereoDec !=NULL, second condition is
+     * is just here to prevent CodeSonar warnings.
+     */
+    if ((pVars->mc_info.psPresentFlag) && (applyProcessing) &&
+            (hParametricStereoDec != NULL))
+    {
+
+        /*
+         *  qmfBufferReal uses the rigth aac channel ( perChan[1] is not used)
+         *  followed by the buffer fxpCoef[2][2048]  which makes a total of
+         *  2349 + 2048*2 = 6445
+         *  These  2 matrices (qmfBufferReal & qmfBufferImag) are
+         *  [2][38][64] == 4864 int32_t
+         */
+
+
+        tDec_Int_Chan *tmpx = &pVars->perChan[1];
+        /*
+         *  dereferencing type-punned pointer avoid
+         *  breaking strict-aliasing rules
+         */
+        int32_t *tmp = (int32_t *)tmpx;
+        hParametricStereoDec->qmfBufferReal = (int32_t(*)[64]) tmp;
+
+        tmp = (int32_t *) & hParametricStereoDec->qmfBufferReal[38][0];
+        hParametricStereoDec->qmfBufferImag = (int32_t(*)[64]) tmp;
+
+        for (i = 0; i < 32; i++)
+        {
+            Int   xoverBand;
+
+            if (i < ((hFrameData->frameInfo[1]) << 1))
+            {
+                xoverBand = sbrDec->prevLowSubband;
+            }
+            else
+            {
+                xoverBand = sbrDec->lowSubband;
+            }
+
+            if (xoverBand > sbrDec->highSubband)
+            {
+                /*
+                 * error condition, default to upsampling mode
+                 * and make sure that the number of bands for xover does
+                 * not exceed the number of high freq bands.
+                 */
+                xoverBand = (sbrDec->highSubband > 32)? 32: sbrDec->highSubband;
+            }
+
+            m = sbrDec->bufReadOffs + i;    /*  2 + i */
+
+            Sr_x = hParametricStereoDec->qmfBufferReal[i];
+            Si_x = hParametricStereoDec->qmfBufferImag[i];
+
+
+
+            for (int32_t j = 0; j < xoverBand; j++)
+            {
+                Sr_x[j] = shft_lft_1(hFrameData->codecQmfBufferReal[m][j]);
+                Si_x[j] = shft_lft_1(hFrameData->codecQmfBufferImag[m][j]);
+            }
+
+
+
+
+            pv_memcpy(&Sr_x[xoverBand],
+                      &hFrameData->sbrQmfBufferReal[i*SBR_NUM_BANDS],
+                      (sbrDec->highSubband - xoverBand)*sizeof(*Sr_x));
+
+            pv_memcpy(&Si_x[xoverBand],
+                      &hFrameData->sbrQmfBufferImag[i*SBR_NUM_BANDS],
+                      (sbrDec->highSubband - xoverBand)*sizeof(*Si_x));
+
+            pv_memset((void *)&Sr_x[sbrDec->highSubband],
+                      0,
+                      (64 - sbrDec->highSubband)*sizeof(*Sr_x));
+
+            pv_memset((void *)&Si_x[sbrDec->highSubband],
+                      0,
+                      (64 - sbrDec->highSubband)*sizeof(*Si_x));
+
+
+        }
+
+        for (i = 32; i < 32 + 6; i++)
+        {
+            m = sbrDec->bufReadOffs + i;     /*  2 + i */
+
+            for (int32_t j = 0; j < 5; j++)
+            {
+                hParametricStereoDec->qmfBufferReal[i][j] = shft_lft_1(hFrameData->codecQmfBufferReal[m][j]);
+                hParametricStereoDec->qmfBufferImag[i][j] = shft_lft_1(hFrameData->codecQmfBufferImag[m][j]);
+            }
+
+        }
+
+
+        /*
+         *    Update Buffers
+         */
+        for (i = 0; i < sbrDec->bufWriteOffs; i++)     /* sbrDec->bufWriteOffs set to 8 and unchanged */
+        {
+            j = sbrDec->noCols + i;                    /* sbrDec->noCols set to 32 and unchanged */
+
+            pv_memmove(hFrameData->codecQmfBufferReal[i],         /* to    */
+                       hFrameData->codecQmfBufferReal[j],        /* from  */
+                       sizeof(*hFrameData->codecQmfBufferReal[i]) << 5);
+
+            pv_memmove(hFrameData->codecQmfBufferImag[i],
+                       hFrameData->codecQmfBufferImag[j],
+                       sizeof(*hFrameData->codecQmfBufferImag[i]) << 5);
+        }
+
+
+        pv_memmove(&hFrameData->HistsbrQmfBufferReal[0],
+                   &hFrameData->sbrQmfBufferReal[32*SBR_NUM_BANDS],
+                   6*SBR_NUM_BANDS*sizeof(*hFrameData->sbrQmfBufferReal));
+
+        pv_memmove(&hFrameData->HistsbrQmfBufferImag[0],
+                   &hFrameData->sbrQmfBufferImag[32*SBR_NUM_BANDS],
+                   6*SBR_NUM_BANDS*sizeof(*hFrameData->sbrQmfBufferImag));
+
+
+        /*
+         *   Needs whole QMF matrix formed before applying
+         *   Parametric stereo processing.
+         */
+
+        qmf_PS_generated_Real = scratch_mem[0];
+        qmf_PS_generated_Imag = scratch_mem[1];
+        env = 0;
+
+        /*
+         *  Set circular buffer for Left channel
+         */
+
+        circular_buffer_s = (Int16 *)scratch_mem[7];
+
+
+        if (pVars->mc_info.bDownSampledSbr)
+        {
+            pv_memmove(&circular_buffer_s[2048],
+                       hFrameData->V,
+                       640*sizeof(*circular_buffer_s));
+        }
+        else
+        {
+            pv_memmove(&circular_buffer_s[4096],
+                       hFrameData->V,
+                       1152*sizeof(*circular_buffer_s));
+
+        }
+
+
+        /*
+         *  Set Circular buffer for PS hybrid analysis
+         */
+
+        int32_t *pt_temp = &scratch_mem[2][32];
+
+        for (i = 0, j = 0; i < 3; i++)
+        {
+
+            pv_memmove(&pt_temp[ j],
+                       hParametricStereoDec->hHybrid->mQmfBufferReal[i],
+                       HYBRID_FILTER_LENGTH_m_1*sizeof(*hParametricStereoDec->hHybrid->mQmfBufferReal));
+            pv_memmove(&pt_temp[ j + 44],
+                       hParametricStereoDec->hHybrid->mQmfBufferImag[i],
+                       HYBRID_FILTER_LENGTH_m_1*sizeof(*hParametricStereoDec->hHybrid->mQmfBufferImag));
+            j += 88;
+        }
+
+
+        pv_memset((void *)&qmf_PS_generated_Real[hParametricStereoDec->usb],
+                  0,
+                  (64 - hParametricStereoDec->usb)*sizeof(*qmf_PS_generated_Real));
+
+        pv_memset((void *)&qmf_PS_generated_Imag[hParametricStereoDec->usb],
+                  0,
+                  (64 - hParametricStereoDec->usb)*sizeof(*qmf_PS_generated_Imag));
+
+
+        for (i = 0; i < 32; i++)
+        {
+            if (i == (Int)hParametricStereoDec-> aEnvStartStop[env])
+            {
+                ps_init_stereo_mixing(hParametricStereoDec, env, sbrDec->highSubband);
+                env++;
+            }
+
+
+            ps_applied(hParametricStereoDec,
+                       &hParametricStereoDec->qmfBufferReal[i],
+                       &hParametricStereoDec->qmfBufferImag[i],
+                       qmf_PS_generated_Real,
+                       qmf_PS_generated_Imag,
+                       scratch_mem[2],
+                       i);
+
+            /* Create time samples for regular mono channel */
+
+            if (pVars->mc_info.bDownSampledSbr)
+            {
+                calc_sbr_synfilterbank(hParametricStereoDec->qmfBufferReal[i],  /* realSamples  */
+                                       hParametricStereoDec->qmfBufferImag[i], /* imagSamples  */
+                                       ftimeOutPtr + (i << 6),
+                                       &circular_buffer_s[1984 - (i<<6)],
+                                       pVars->mc_info.bDownSampledSbr);
+            }
+            else
+            {
+                calc_sbr_synfilterbank(hParametricStereoDec->qmfBufferReal[i],  /* realSamples  */
+                                       hParametricStereoDec->qmfBufferImag[i], /* imagSamples  */
+                                       ftimeOutPtr + (i << 7),
+                                       &circular_buffer_s[3968 - (i<<7)],
+                                       pVars->mc_info.bDownSampledSbr);
+
+            }
+
+            pv_memmove(hParametricStereoDec->qmfBufferReal[i], qmf_PS_generated_Real, 64*sizeof(*qmf_PS_generated_Real));
+            pv_memmove(hParametricStereoDec->qmfBufferImag[i], qmf_PS_generated_Imag, 64*sizeof(*qmf_PS_generated_Real));
+
+        }
+
+
+        /*
+         *  Save Circular buffer history used on PS hybrid analysis
+         */
+
+
+        pt_temp = &scratch_mem[2][64];
+
+        for (i = 0, j = 0; i < 3; i++)
+        {
+            pv_memmove(hParametricStereoDec->hHybrid->mQmfBufferReal[i],
+                       &pt_temp[ j],
+                       HYBRID_FILTER_LENGTH_m_1*sizeof(*hParametricStereoDec->hHybrid->mQmfBufferReal));
+
+            pv_memmove(hParametricStereoDec->hHybrid->mQmfBufferImag[i],
+                       &pt_temp[ j + 44],
+                       HYBRID_FILTER_LENGTH_m_1*sizeof(*hParametricStereoDec->hHybrid->mQmfBufferImag));
+
+            j += 88;
+        }
+
+
+        pv_memmove(hFrameData->V, &circular_buffer_s[0], 1152*sizeof(*circular_buffer_s));
+
+        /*
+         *  Set circular buffer for Right channel
+         */
+
+        circular_buffer_s = (Int16 *)scratch_mem[5];
+
+        if (pVars->mc_info.bDownSampledSbr)
+        {
+            pv_memmove(&circular_buffer_s[2048],
+                       (int32_t *)hParametricStereoDec->R_ch_qmf_filter_history,
+                       640*sizeof(*circular_buffer_s));
+        }
+        else
+        {
+            pv_memmove(&circular_buffer_s[4096],
+                       (int32_t *)hParametricStereoDec->R_ch_qmf_filter_history,
+                       1152*sizeof(*circular_buffer_s));
+
+        }
+
+
+        for (i = 0; i < 32; i++)
+        {
+            if (pVars->mc_info.bDownSampledSbr)
+            {
+
+                calc_sbr_synfilterbank(hParametricStereoDec->qmfBufferReal[i],  /* realSamples  */
+                                       hParametricStereoDec->qmfBufferImag[i], /* imagSamples  */
+                                       ftimeOutPtrPS + (i << 6),
+                                       &circular_buffer_s[1984 - (i<<6)],
+                                       pVars->mc_info.bDownSampledSbr);
+            }
+            else
+            {
+                calc_sbr_synfilterbank(hParametricStereoDec->qmfBufferReal[i],  /* realSamples  */
+                                       hParametricStereoDec->qmfBufferImag[i], /* imagSamples  */
+                                       ftimeOutPtrPS + (i << 7),
+                                       &circular_buffer_s[3968 - (i<<7)],
+                                       pVars->mc_info.bDownSampledSbr);
+            }
+
+        }
+
+        if (pVars->mc_info.bDownSampledSbr)
+        {
+            pv_memmove((int32_t *)hParametricStereoDec->R_ch_qmf_filter_history, &circular_buffer_s[0], 640*sizeof(*circular_buffer_s));
+        }
+        else
+        {
+            pv_memmove((int32_t *)hParametricStereoDec->R_ch_qmf_filter_history, &circular_buffer_s[0], 1152*sizeof(*circular_buffer_s));
+        }
+
+
+
+
+
+    }
+    else    /*  else -- sbrEnablePS  */
+    {
+
+#endif      /*   PARAMETRICSTEREO */
+#endif      /*   HQ_SBR */
+
+        /*
+         *  Use shared aac memory as continuous buffer
+         */
+
+
+        Sr  = scratch_mem[0];
+        Si  = scratch_mem[1];
+
+        circular_buffer_s = (Int16*)scratch_mem[2];
+
+        if (pVars->mc_info.bDownSampledSbr)
+        {
+
+            pv_memmove(&circular_buffer_s[2048],
+                       hFrameData->V,
+                       640*sizeof(*circular_buffer_s));
+        }
+        else
+        {
+            pv_memmove(&circular_buffer_s[4096],
+                       hFrameData->V,
+                       1152*sizeof(*circular_buffer_s));
+        }
+
+        for (i = 0; i < 32; i++)
+        {
+            Int   xoverBand;
+
+            if (applyProcessing)
+            {
+                if (i < ((hFrameData->frameInfo[1]) << 1))
+                {
+                    xoverBand = sbrDec->prevLowSubband;
+
+                }
+                else
+                {
+                    xoverBand = sbrDec->lowSubband;
+                }
+
+                if (xoverBand > sbrDec->highSubband)
+                {
+                    /*
+                     * error condition, default to upsampling mode
+                     * and make sure that the number of bands for xover does
+                     * not exceed the number of high freq bands.
+                     */
+                    xoverBand = (sbrDec->highSubband > 32)? 32: sbrDec->highSubband;
+                }
+            }
+            else
+            {
+                xoverBand = 32;
+                sbrDec->highSubband = 32;
+            }
+
+
+            m = sbrDec->bufReadOffs + i;    /* sbrDec->bufReadOffs == 2 */
+
+
+            ptr_tmp1 = (hFrameData->codecQmfBufferReal[m]);
+            ptr_tmp2 = Sr;
+
+            if (sbrDec->LC_aacP_DecoderFlag == ON)
+            {
+
+                for (k = (xoverBand >> 1); k != 0; k--)
+                {
+                    *(ptr_tmp2++) = (*(ptr_tmp1++)) >> 9;
+                    *(ptr_tmp2++) = (*(ptr_tmp1++)) >> 9;
+                }
+                if (xoverBand & 1)
+                {
+                    *(ptr_tmp2++) = (*(ptr_tmp1)) >> 9;
+                }
+
+                ptr_tmp1 = &hFrameData->sbrQmfBufferReal[i*SBR_NUM_BANDS];
+
+
+                for (k = xoverBand; k < sbrDec->highSubband; k++)
+                {
+                    *(ptr_tmp2++) = (*(ptr_tmp1++)) << 1;
+                }
+
+                pv_memset((void *)ptr_tmp2,
+                          0,
+                          (64 - sbrDec->highSubband)*sizeof(*ptr_tmp2));
+
+
+                if (pVars->mc_info.bDownSampledSbr)
+                {
+                    calc_sbr_synfilterbank_LC(Sr,               /* realSamples  */
+                                              ftimeOutPtr + (i << 6),
+                                              &circular_buffer_s[1984 - (i<<6)],
+                                              pVars->mc_info.bDownSampledSbr);
+                }
+                else
+                {
+                    calc_sbr_synfilterbank_LC(Sr,               /* realSamples  */
+                                              ftimeOutPtr + (i << 7),
+                                              &circular_buffer_s[3968 - (i<<7)],
+                                              pVars->mc_info.bDownSampledSbr);
+                }
+            }
+#ifdef HQ_SBR
+            else
+            {
+
+                for (k = xoverBand; k != 0; k--)
+                {
+                    *(ptr_tmp2++) = shft_lft_1(*(ptr_tmp1++));
+                }
+
+                ptr_tmp1 = &hFrameData->sbrQmfBufferReal[i*SBR_NUM_BANDS];
+                ptr_tmp2 = &Sr[xoverBand];
+
+
+                for (k = xoverBand; k < sbrDec->highSubband; k++)
+                {
+                    *(ptr_tmp2++) = (*(ptr_tmp1++));
+                }
+
+                pv_memset((void *)ptr_tmp2,
+                          0,
+                          (64 - sbrDec->highSubband)*sizeof(*ptr_tmp2));
+
+
+                ptr_tmp1 = (hFrameData->codecQmfBufferImag[m]);
+                ptr_tmp2 = Si;
+
+                for (k = (xoverBand >> 1); k != 0; k--)
+                {
+                    *(ptr_tmp2++) = shft_lft_1(*(ptr_tmp1++));
+                    *(ptr_tmp2++) = shft_lft_1(*(ptr_tmp1++));
+                }
+                if (xoverBand & 1)
+                {
+                    *(ptr_tmp2) = shft_lft_1(*(ptr_tmp1));
+                }
+
+                ptr_tmp1 = &hFrameData->sbrQmfBufferImag[i*SBR_NUM_BANDS];
+                ptr_tmp2 = &Si[xoverBand];
+
+                for (k = xoverBand; k < sbrDec->highSubband; k++)
+                {
+                    *(ptr_tmp2++) = (*(ptr_tmp1++));
+                }
+
+                pv_memset((void *)ptr_tmp2,
+                          0,
+                          (64 - sbrDec->highSubband)*sizeof(*ptr_tmp2));
+
+
+                if (pVars->mc_info.bDownSampledSbr)
+                {
+                    calc_sbr_synfilterbank(Sr,              /* realSamples  */
+                                           Si,             /* imagSamples  */
+                                           ftimeOutPtr + (i << 6),
+                                           &circular_buffer_s[1984 - (i<<6)],
+                                           pVars->mc_info.bDownSampledSbr);
+                }
+                else
+                {
+                    calc_sbr_synfilterbank(Sr,              /* realSamples  */
+                                           Si,             /* imagSamples  */
+                                           ftimeOutPtr + (i << 7),
+                                           &circular_buffer_s[3968 - (i<<7)],
+                                           pVars->mc_info.bDownSampledSbr);
+                }
+            }
+#endif
+
+        }
+
+        if (pVars->mc_info.bDownSampledSbr)
+        {
+            pv_memmove(hFrameData->V, &circular_buffer_s[0], 640*sizeof(*circular_buffer_s));
+        }
+        else
+        {
+            pv_memmove(hFrameData->V, &circular_buffer_s[0], 1152*sizeof(*circular_buffer_s));
+        }
+
+
+
+
+        /*
+         *    Update Buffers
+         */
+        for (i = 0; i < sbrDec->bufWriteOffs; i++)     /* sbrDec->bufWriteOffs set to 8 and unchanged */
+        {
+            j = sbrDec->noCols + i;                    /* sbrDec->noCols set to 32 and unchanged */
+
+            pv_memmove(hFrameData->codecQmfBufferReal[i],         /* to    */
+                       hFrameData->codecQmfBufferReal[j],        /* from  */
+                       sizeof(*hFrameData->codecQmfBufferReal[i]) << 5);
+        }
+
+
+        pv_memmove(&hFrameData->HistsbrQmfBufferReal[0],
+                   &hFrameData->sbrQmfBufferReal[32*SBR_NUM_BANDS],
+                   6*SBR_NUM_BANDS*sizeof(*hFrameData->sbrQmfBufferReal));
+
+#ifdef HQ_SBR
+        if (sbrDec->LC_aacP_DecoderFlag == OFF)
+        {
+            for (i = 0; i < sbrDec->bufWriteOffs; i++)     /* sbrDec->bufWriteOffs set to 6 and unchanged */
+            {
+                j = sbrDec->noCols + i;                    /* sbrDec->noCols set to 32 and unchanged */
+
+
+                pv_memmove(hFrameData->codecQmfBufferImag[i],
+                           hFrameData->codecQmfBufferImag[j],
+                           sizeof(*hFrameData->codecQmfBufferImag[i]) << 5);
+
+            }
+
+            pv_memmove(&hFrameData->HistsbrQmfBufferImag[0],
+                       &hFrameData->sbrQmfBufferImag[32*SBR_NUM_BANDS],
+                       6*SBR_NUM_BANDS*sizeof(*hFrameData->sbrQmfBufferImag));
+        }
+#endif
+
+
+#ifdef HQ_SBR
+#ifdef PARAMETRICSTEREO
+    }
+#endif
+#endif
+
+
+    hFrameData->reset_flag = 0;
+    if (applyProcessing)
+    {
+        sbrDec->prevLowSubband = sbrDec->lowSubband;
+    }
+
+}
+
+
+#endif      /*  AAC_PLUS */
diff --git a/media/libstagefright/codecs/aacdec/sbr_dec.h b/media/libstagefright/codecs/aacdec/sbr_dec.h
new file mode 100644
index 0000000..ba7c1f3
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/sbr_dec.h
@@ -0,0 +1,144 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Filename: sbr_dec.h
+ Funtions:
+    get_dse
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+
+ Who:                                   Date: MM/DD/YYYY
+ Description:
+------------------------------------------------------------------------------
+SC 29 Software Copyright Licencing Disclaimer:
+
+This software module was originally developed by
+  Coding Technologies
+
+and edited by
+  -
+
+in the course of development of the ISO/IEC 13818-7 and ISO/IEC 14496-3
+standards for reference purposes and its performance may not have been
+optimized. This software module is an implementation of one or more tools as
+specified by the ISO/IEC 13818-7 and ISO/IEC 14496-3 standards.
+ISO/IEC gives users free license to this software module or modifications
+thereof for use in products claiming conformance to audiovisual and
+image-coding related ITU Recommendations and/or ISO/IEC International
+Standards. ISO/IEC gives users the same free license to this software module or
+modifications thereof for research purposes and further ISO/IEC standardisation.
+Those intending to use this software module in products are advised that its
+use may infringe existing patents. ISO/IEC have no liability for use of this
+software module or modifications thereof. Copyright is not released for
+products that do not conform to audiovisual and image-coding related ITU
+Recommendations and/or ISO/IEC International Standards.
+The original developer retains full right to modify and use the code for its
+own purpose, assign or donate the code to a third party and to inhibit third
+parties from using the code for products that do not conform to audiovisual and
+image-coding related ITU Recommendations and/or ISO/IEC International Standards.
+This copyright notice must be included in all copies or derivative works.
+Copyright (c) ISO/IEC 2002.
+
+ $Id: ct_envcalc.h,v 1.3 2002/11/29 16:11:49 kaehleof Exp $
+*/
+
+/*----------------------------------------------------------------------------
+; CONTINUE ONLY IF NOT ALREADY DEFINED
+----------------------------------------------------------------------------*/
+#ifndef SBR_DEC_H
+#define SBR_DEC_H
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+
+#include    "s_sbr_frame_data.h"
+#include    "pv_audio_type_defs.h"
+#include    "s_patch.h"
+#include    "e_blockswitching.h"
+#include    "s_sbr_dec.h"
+#include    "s_tdec_int_file.h"
+#ifdef PARAMETRICSTEREO
+#include    "s_ps_dec.h"
+#endif
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here.
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL VARIABLES REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; SIMPLE TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; ENUMERATED TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; STRUCTURES TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+
+/*----------------------------------------------------------------------------
+; GLOBAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+
+
+    void sbr_dec(Int16 *inPcmData,
+    Int16 *ftimeOutPtr,
+    SBR_FRAME_DATA * hFrameData,
+    Int32 applyProcessing,
+    SBR_DEC *sbrDec,
+#ifdef HQ_SBR
+#ifdef PARAMETRICSTEREO
+    Int16 * ftimeOutPtrPS,
+    HANDLE_PS_DEC hParametricStereoDec,
+#endif
+#endif
+    tDec_Int_File  *pVars);
+
+#ifdef __cplusplus
+}
+#endif
+
+/*----------------------------------------------------------------------------
+; END
+----------------------------------------------------------------------------*/
+#endif
+
+
diff --git a/media/libstagefright/codecs/aacdec/sbr_decode_envelope.cpp b/media/libstagefright/codecs/aacdec/sbr_decode_envelope.cpp
new file mode 100644
index 0000000..771bb32
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/sbr_decode_envelope.cpp
@@ -0,0 +1,286 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Filename: sbr_decode_envelope.c
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+
+ Who:                                   Date: MM/DD/YYYY
+ Description:
+
+------------------------------------------------------------------------------
+ INPUT AND OUTPUT DEFINITIONS
+
+
+
+------------------------------------------------------------------------------
+ FUNCTION DESCRIPTION
+
+
+------------------------------------------------------------------------------
+ REQUIREMENTS
+
+
+------------------------------------------------------------------------------
+ REFERENCES
+
+SC 29 Software Copyright Licencing Disclaimer:
+
+This software module was originally developed by
+  Coding Technologies
+
+and edited by
+  -
+
+in the course of development of the ISO/IEC 13818-7 and ISO/IEC 14496-3
+standards for reference purposes and its performance may not have been
+optimized. This software module is an implementation of one or more tools as
+specified by the ISO/IEC 13818-7 and ISO/IEC 14496-3 standards.
+ISO/IEC gives users free license to this software module or modifications
+thereof for use in products claiming conformance to audiovisual and
+image-coding related ITU Recommendations and/or ISO/IEC International
+Standards. ISO/IEC gives users the same free license to this software module or
+modifications thereof for research purposes and further ISO/IEC standardisation.
+Those intending to use this software module in products are advised that its
+use may infringe existing patents. ISO/IEC have no liability for use of this
+software module or modifications thereof. Copyright is not released for
+products that do not conform to audiovisual and image-coding related ITU
+Recommendations and/or ISO/IEC International Standards.
+The original developer retains full right to modify and use the code for its
+own purpose, assign or donate the code to a third party and to inhibit third
+parties from using the code for products that do not conform to audiovisual and
+image-coding related ITU Recommendations and/or ISO/IEC International Standards.
+This copyright notice must be included in all copies or derivative works.
+Copyright (c) ISO/IEC 2002.
+
+------------------------------------------------------------------------------
+ PSEUDO-CODE
+
+------------------------------------------------------------------------------
+*/
+
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+
+#ifdef AAC_PLUS
+
+
+#include    "sbr_decode_envelope.h"
+#include    "sbr_constants.h"
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here. Include conditional
+; compile variables also.
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; LOCAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+void mapLowResEnergyVal(
+    Int32  currVal,
+    Int32 *prevData,
+    Int32 offset,
+    Int32 index,
+    Int32 res);
+
+Int32 indexLow2High(Int32 offset,
+                    Int32 index,
+                    Int32 res);
+
+/*----------------------------------------------------------------------------
+; LOCAL STORE/BUFFER/POINTER DEFINITIONS
+; Variable declaration - defined here and used outside this module
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL FUNCTION REFERENCES
+; Declare functions defined elsewhere and referenced in this module
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL GLOBAL STORE/BUFFER/POINTER REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; FUNCTION CODE
+----------------------------------------------------------------------------*/
+
+
+void sbr_decode_envelope(SBR_FRAME_DATA * hFrameData)
+
+{
+    Int32 i;
+    Int32 no_of_bands;
+    Int32 band;
+    Int32 freqRes;
+    Int32 *iEnvelope    = hFrameData->iEnvelope_man;
+    Int32 *sfb_nrg_prev = hFrameData->sfb_nrg_prev_man;
+
+    Int32  offset       = hFrameData->offset;
+    Int32 *nSfb         = hFrameData->nSfb;
+    Int32 *domain_vec   = hFrameData->domain_vec1;
+    Int32 *frameInfo    = hFrameData->frameInfo;
+
+
+
+    for (i = 0; i < frameInfo[0]; i++)
+    {
+        freqRes = frameInfo[frameInfo[0] + i + 2];
+        no_of_bands = nSfb[freqRes];
+
+        if (domain_vec[i] == 0)
+        {
+            mapLowResEnergyVal(*iEnvelope,
+                               sfb_nrg_prev,
+                               offset,
+                               0,
+                               freqRes);
+            iEnvelope++;
+
+            for (band = 1; band < no_of_bands; band++)
+            {
+                *iEnvelope +=  *(iEnvelope - 1);
+
+                mapLowResEnergyVal(*iEnvelope,
+                                   sfb_nrg_prev,
+                                   offset,
+                                   band,
+                                   freqRes);
+                iEnvelope++;
+            }
+        }
+        else
+        {
+            for (band = 0; band < no_of_bands; band++)
+            {
+                *iEnvelope +=  sfb_nrg_prev[ indexLow2High(offset, band, freqRes)];
+
+                mapLowResEnergyVal(*iEnvelope,
+                                   sfb_nrg_prev,
+                                   offset,
+                                   band,
+                                   freqRes);
+                iEnvelope++;
+            }
+        }
+    }
+}
+
+
+
+void mapLowResEnergyVal(
+    Int32  currVal,
+    Int32 *prevData,
+    Int32  offset,
+    Int32  index,
+    Int32  res)
+{
+    Int32 tmp;
+
+    if (res == LO)
+    {
+        if (offset >= 0)
+        {
+            if (index < offset)
+            {
+                prevData[index] = currVal;
+            }
+            else
+            {
+                tmp = (index << 1) - offset;
+                prevData[tmp    ] = currVal;
+                prevData[tmp +1 ] = currVal;
+            }
+        }
+        else
+        {
+            offset = -offset;
+            if (index < offset)
+            {
+                tmp = (index << 1) + index;
+                prevData[tmp    ] = currVal;
+                prevData[tmp + 1] = currVal;
+                prevData[tmp + 2] = currVal;
+            }
+            else
+            {
+                tmp = (index << 1) + offset;
+                prevData[tmp    ] = currVal;
+                prevData[tmp + 1] = currVal;
+            }
+        }
+    }
+    else
+    {
+        prevData[index] = currVal;
+    }
+}
+
+
+Int32 indexLow2High(Int32 offset,
+                    Int32 index,
+                    Int32 res)
+{
+    if (res == LO)
+    {
+        if (offset >= 0)
+        {
+            if (index < offset)
+            {
+                return(index);
+            }
+            else
+            {
+                return((index << 1) - offset);
+            }
+        }
+        else
+        {
+            offset = -offset;
+            if (index < offset)
+            {
+                return((index << 1) + index);
+            }
+            else
+            {
+                return((index << 1) + offset);
+            }
+        }
+    }
+    else
+    {
+        return(index);
+    }
+}
+
+#endif
+
diff --git a/media/libstagefright/codecs/aacdec/sbr_decode_envelope.h b/media/libstagefright/codecs/aacdec/sbr_decode_envelope.h
new file mode 100644
index 0000000..19c04a9
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/sbr_decode_envelope.h
@@ -0,0 +1,94 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Filename: sbr_decode_envelope.h
+ Funtions:
+    decodeEnvelope
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+
+ Who:                                   Date: MM/DD/YYYY
+ Description:
+------------------------------------------------------------------------------
+
+
+----------------------------------------------------------------------------
+; CONTINUE ONLY IF NOT ALREADY DEFINED
+----------------------------------------------------------------------------*/
+#ifndef SBR_DECODE_ENVELOPE_H
+#define SBR_DECODE_ENVELOPE_H
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+#include    "pv_audio_type_defs.h"
+#include    "s_sbr_frame_data.h"
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here.
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL VARIABLES REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; SIMPLE TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; ENUMERATED TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; STRUCTURES TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+
+/*----------------------------------------------------------------------------
+; GLOBAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+    void sbr_decode_envelope(SBR_FRAME_DATA * hFrameData);
+
+#ifdef __cplusplus
+}
+#endif
+
+/*----------------------------------------------------------------------------
+; END
+----------------------------------------------------------------------------*/
+#endif
+
+
diff --git a/media/libstagefright/codecs/aacdec/sbr_decode_huff_cw.cpp b/media/libstagefright/codecs/aacdec/sbr_decode_huff_cw.cpp
new file mode 100644
index 0000000..290fd18
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/sbr_decode_huff_cw.cpp
@@ -0,0 +1,149 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Filename: sbr_decode_huff_cw.c
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+
+ Who:                                   Date: MM/DD/YYYY
+ Description:
+
+------------------------------------------------------------------------------
+ INPUT AND OUTPUT DEFINITIONS
+
+        SbrHuffman          h,     pointer to huffman codebook table
+        BIT_BUFFER    * hBitBuf    pointer  to Bitbuffer
+
+    return    decoded value
+------------------------------------------------------------------------------
+ FUNCTION DESCRIPTION
+
+  Decodes one huffman code word
+
+  Reads bits from the bitstream until a valid codeword is found.
+  The table entries are interpreted either as index to the next entry
+  or - if negative - as the codeword.
+
+------------------------------------------------------------------------------
+ REQUIREMENTS
+
+
+------------------------------------------------------------------------------
+ REFERENCES
+
+SC 29 Software Copyright Licencing Disclaimer:
+
+This software module was originally developed by
+  Coding Technologies
+
+and edited by
+  -
+
+in the course of development of the ISO/IEC 13818-7 and ISO/IEC 14496-3
+standards for reference purposes and its performance may not have been
+optimized. This software module is an implementation of one or more tools as
+specified by the ISO/IEC 13818-7 and ISO/IEC 14496-3 standards.
+ISO/IEC gives users free license to this software module or modifications
+thereof for use in products claiming conformance to audiovisual and
+image-coding related ITU Recommendations and/or ISO/IEC International
+Standards. ISO/IEC gives users the same free license to this software module or
+modifications thereof for research purposes and further ISO/IEC standardisation.
+Those intending to use this software module in products are advised that its
+use may infringe existing patents. ISO/IEC have no liability for use of this
+software module or modifications thereof. Copyright is not released for
+products that do not conform to audiovisual and image-coding related ITU
+Recommendations and/or ISO/IEC International Standards.
+The original developer retains full right to modify and use the code for its
+own purpose, assign or donate the code to a third party and to inhibit third
+parties from using the code for products that do not conform to audiovisual and
+image-coding related ITU Recommendations and/or ISO/IEC International Standards.
+This copyright notice must be included in all copies or derivative works.
+Copyright (c) ISO/IEC 2002.
+
+------------------------------------------------------------------------------
+ PSEUDO-CODE
+
+------------------------------------------------------------------------------
+*/
+
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+
+#ifdef AAC_PLUS
+
+
+#include    "sbr_decode_huff_cw.h"
+#include    "buf_getbits.h"
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here. Include conditional
+; compile variables also.
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; LOCAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; LOCAL STORE/BUFFER/POINTER DEFINITIONS
+; Variable declaration - defined here and used outside this module
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL FUNCTION REFERENCES
+; Declare functions defined elsewhere and referenced in this module
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL GLOBAL STORE/BUFFER/POINTER REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; FUNCTION CODE
+----------------------------------------------------------------------------*/
+
+Int32 sbr_decode_huff_cw(SbrHuffman h,
+                         BIT_BUFFER * hBitBuf)
+{
+    Int32 bits;
+    Char index = 0;
+
+    while (index >= 0)
+    {
+        bits = buf_get_1bit(hBitBuf);
+        index = h[index][bits];
+    }
+
+    return((Int32)index + 64); /* Add offset */
+}
+
+#endif
diff --git a/media/libstagefright/codecs/aacdec/sbr_decode_huff_cw.h b/media/libstagefright/codecs/aacdec/sbr_decode_huff_cw.h
new file mode 100644
index 0000000..bfbdb67
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/sbr_decode_huff_cw.h
@@ -0,0 +1,93 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Filename: sbr_decode_huff_cw.h
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+
+ Who:                                   Date: MM/DD/YYYY
+ Description:
+------------------------------------------------------------------------------
+
+
+----------------------------------------------------------------------------
+; CONTINUE ONLY IF NOT ALREADY DEFINED
+----------------------------------------------------------------------------*/
+#ifndef SBR_DECODE_HUFF_CW_H
+#define SBR_DECODE_HUFF_CW_H
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+#include    "pv_audio_type_defs.h"
+#include    "s_bit_buffer.h"
+#include    "s_huffman.h"
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here.
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL VARIABLES REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; SIMPLE TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; ENUMERATED TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; STRUCTURES TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; GLOBAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+    Int32 sbr_decode_huff_cw(SbrHuffman h,
+    BIT_BUFFER * hBitBuf);
+
+#ifdef __cplusplus
+}
+#endif
+
+/*----------------------------------------------------------------------------
+; END
+----------------------------------------------------------------------------*/
+#endif
+
+
diff --git a/media/libstagefright/codecs/aacdec/sbr_downsample_lo_res.cpp b/media/libstagefright/codecs/aacdec/sbr_downsample_lo_res.cpp
new file mode 100644
index 0000000..c2b007a
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/sbr_downsample_lo_res.cpp
@@ -0,0 +1,162 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Filename: sbr_downsample_lo_res.c
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+
+ Who:                                   Date: MM/DD/YYYY
+ Description:
+
+------------------------------------------------------------------------------
+ INPUT AND OUTPUT DEFINITIONS
+
+
+
+------------------------------------------------------------------------------
+ FUNCTION DESCRIPTION
+
+
+------------------------------------------------------------------------------
+ REQUIREMENTS
+
+
+------------------------------------------------------------------------------
+ REFERENCES
+
+SC 29 Software Copyright Licencing Disclaimer:
+
+This software module was originally developed by
+  Coding Technologies
+
+and edited by
+  -
+
+in the course of development of the ISO/IEC 13818-7 and ISO/IEC 14496-3
+standards for reference purposes and its performance may not have been
+optimized. This software module is an implementation of one or more tools as
+specified by the ISO/IEC 13818-7 and ISO/IEC 14496-3 standards.
+ISO/IEC gives users free license to this software module or modifications
+thereof for use in products claiming conformance to audiovisual and
+image-coding related ITU Recommendations and/or ISO/IEC International
+Standards. ISO/IEC gives users the same free license to this software module or
+modifications thereof for research purposes and further ISO/IEC standardisation.
+Those intending to use this software module in products are advised that its
+use may infringe existing patents. ISO/IEC have no liability for use of this
+software module or modifications thereof. Copyright is not released for
+products that do not conform to audiovisual and image-coding related ITU
+Recommendations and/or ISO/IEC International Standards.
+The original developer retains full right to modify and use the code for its
+own purpose, assign or donate the code to a third party and to inhibit third
+parties from using the code for products that do not conform to audiovisual and
+image-coding related ITU Recommendations and/or ISO/IEC International Standards.
+This copyright notice must be included in all copies or derivative works.
+Copyright (c) ISO/IEC 2002.
+
+------------------------------------------------------------------------------
+ PSEUDO-CODE
+
+------------------------------------------------------------------------------
+*/
+
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+
+#ifdef AAC_PLUS
+
+
+#include    "sbr_downsample_lo_res.h"
+#include    "sbr_constants.h"
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here. Include conditional
+; compile variables also.
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; LOCAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; LOCAL STORE/BUFFER/POINTER DEFINITIONS
+; Variable declaration - defined here and used outside this module
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL FUNCTION REFERENCES
+; Declare functions defined elsewhere and referenced in this module
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL GLOBAL STORE/BUFFER/POINTER REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; FUNCTION CODE
+----------------------------------------------------------------------------*/
+
+void  sbr_downsample_lo_res(Int32 v_result[],
+                            Int32 num_result,
+                            Int   freqBandTableRef[],
+                            Int32 num_Ref)
+{
+    Int32 step;
+    Int32 i, j;
+    Int32 org_length;
+    Int32 result_length;
+    Int32 v_index[MAX_FREQ_COEFFS/2];
+
+    /* init */
+    org_length = num_Ref;
+    result_length = num_result;
+
+    v_index[0] = 0; /* Always use left border */
+    i = 0;
+    while (org_length > 0)  /* Create downsample vector */
+    {
+        i++;
+        step = org_length / result_length; /* floor; */
+        org_length = org_length - step;
+        result_length--;
+        v_index[i] = v_index[i-1] + step;
+    }
+
+    for (j = 0; j <= i; j++)   /* Use downsample vector to index LoResolution vector. */
+    {
+        v_result[j] = freqBandTableRef[ v_index[j]];
+    }
+
+}  /* End downSampleLoRes */
+
+#endif
+
+
diff --git a/media/libstagefright/codecs/aacdec/sbr_downsample_lo_res.h b/media/libstagefright/codecs/aacdec/sbr_downsample_lo_res.h
new file mode 100644
index 0000000..2f49aea
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/sbr_downsample_lo_res.h
@@ -0,0 +1,97 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Filename: sbr_downsample_lo_res.h
+ Funtions:
+    get_dse
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+
+ Who:                                   Date: MM/DD/YYYY
+ Description:
+------------------------------------------------------------------------------
+
+
+ ----------------------------------------------------------------------------
+; CONTINUE ONLY IF NOT ALREADY DEFINED
+----------------------------------------------------------------------------*/
+#ifndef SBR_DOWNSAMPLE_LO_RES_H
+#define SBR_DOWNSAMPLE_LO_RES_H
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+#include "pv_audio_type_defs.h"
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here.
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL VARIABLES REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; SIMPLE TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; ENUMERATED TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; STRUCTURES TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+
+/*----------------------------------------------------------------------------
+; GLOBAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+    void  sbr_downsample_lo_res(Int32 v_result[],
+    Int32 num_result,
+    Int   freqBandTableRef[],
+    Int32 num_Ref);
+
+#ifdef __cplusplus
+}
+#endif
+
+
+/*----------------------------------------------------------------------------
+; END
+----------------------------------------------------------------------------*/
+#endif
+
+
diff --git a/media/libstagefright/codecs/aacdec/sbr_envelope_calc_tbl.cpp b/media/libstagefright/codecs/aacdec/sbr_envelope_calc_tbl.cpp
new file mode 100644
index 0000000..2ed76dd
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/sbr_envelope_calc_tbl.cpp
@@ -0,0 +1,424 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Filename: sbr_envelope_calc_tbl.c
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+
+ Who:                                   Date: MM/DD/YYYY
+ Description:
+
+------------------------------------------------------------------------------
+ INPUT AND OUTPUT DEFINITIONS
+
+
+
+------------------------------------------------------------------------------
+ FUNCTION DESCRIPTION
+
+
+------------------------------------------------------------------------------
+ REQUIREMENTS
+
+
+------------------------------------------------------------------------------
+ REFERENCES
+
+SC 29 Software Copyright Licencing Disclaimer:
+
+This software module was originally developed by
+  Coding Technologies
+
+and edited by
+  -
+
+in the course of development of the ISO/IEC 13818-7 and ISO/IEC 14496-3
+standards for reference purposes and its performance may not have been
+optimized. This software module is an implementation of one or more tools as
+specified by the ISO/IEC 13818-7 and ISO/IEC 14496-3 standards.
+ISO/IEC gives users free license to this software module or modifications
+thereof for use in products claiming conformance to audiovisual and
+image-coding related ITU Recommendations and/or ISO/IEC International
+Standards. ISO/IEC gives users the same free license to this software module or
+modifications thereof for research purposes and further ISO/IEC standardisation.
+Those intending to use this software module in products are advised that its
+use may infringe existing patents. ISO/IEC have no liability for use of this
+software module or modifications thereof. Copyright is not released for
+products that do not conform to audiovisual and image-coding related ITU
+Recommendations and/or ISO/IEC International Standards.
+The original developer retains full right to modify and use the code for its
+own purpose, assign or donate the code to a third party and to inhibit third
+parties from using the code for products that do not conform to audiovisual and
+image-coding related ITU Recommendations and/or ISO/IEC International Standards.
+This copyright notice must be included in all copies or derivative works.
+Copyright (c) ISO/IEC 2002.
+
+------------------------------------------------------------------------------
+ PSEUDO-CODE
+
+------------------------------------------------------------------------------
+*/
+
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+
+#ifdef AAC_PLUS
+
+
+#include    "sbr_envelope_calc_tbl.h"
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here. Include conditional
+; compile variables also.
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; LOCAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; LOCAL STORE/BUFFER/POINTER DEFINITIONS
+; Variable declaration - defined here and used outside this module
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL FUNCTION REFERENCES
+; Declare functions defined elsewhere and referenced in this module
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL GLOBAL STORE/BUFFER/POINTER REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; FUNCTION CODE
+----------------------------------------------------------------------------*/
+#define Q30_fmt(x)   (Int32)(x*((Int32)1<<30) + (x>=0?0.5F:-0.5F))
+#define Qfmt15(x)    (Int16)(x*((Int32)1<<15) + (x>=0?0.5F:-0.5F))
+
+
+const Int32 limGains[5] = { Q30_fmt(0.70795f), Q30_fmt(1.0f),
+                            Q30_fmt(1.41254f), Q30_fmt(1.16415321826935f), 33
+                          };
+
+const Int32 smoothLengths[2] = { 4, 0 };
+
+const Int16 rP_LCx[512] =
+{
+    Qfmt15(-0.99948153278296f), Qfmt15(0.97113454393991f), Qfmt15(0.14130051758487f), Qfmt15(-0.47005496701697f),
+    Qfmt15(0.80705063769351f), Qfmt15(-0.38981478896926f), Qfmt15(-0.01053049862020f), Qfmt15(-0.91266367957293f),
+    Qfmt15(0.54840422910309f), Qfmt15(0.40009252867955f), Qfmt15(-0.99867974711855f), Qfmt15(-0.95531076805040f),
+    Qfmt15(-0.45725933317144f), Qfmt15(-0.72929675029275f), Qfmt15(0.75622801399036f), Qfmt15(0.07069442601050f),
+    Qfmt15(0.74496252926055f), Qfmt15(-0.96440182703856f), Qfmt15(0.30424629369539f), Qfmt15(0.66565033746925f),
+    Qfmt15(0.91697008020594f), Qfmt15(-0.70774918760427f), Qfmt15(-0.70051415345560f), Qfmt15(-0.99496513054797f),
+    Qfmt15(0.98164490790123f), Qfmt15(-0.54671580548181f), Qfmt15(-0.01689629065389f), Qfmt15(-0.86110349531986f),
+    Qfmt15(-0.98892980586032f), Qfmt15(0.51756627678691f), Qfmt15(-0.99635026409640f), Qfmt15(-0.99969370862163f),
+    Qfmt15(0.55266258627194f), Qfmt15(0.34581177741673f), Qfmt15(0.62664209577999f), Qfmt15(-0.77149701404973f),
+    Qfmt15(-0.91592244254432f), Qfmt15(-0.76285492357887f), Qfmt15(0.79788337195331f), Qfmt15(0.54473080610200f),
+    Qfmt15(-0.85639281671058f), Qfmt15(-0.92882402971423f), Qfmt15(-0.11708371046774f), Qfmt15(0.21356749817493f),
+    Qfmt15(-0.76191692573909f), Qfmt15(0.98111043100884f), Qfmt15(-0.85913269895572f), Qfmt15(-0.93307242253692f),
+    Qfmt15(0.30485754879632f), Qfmt15(0.85289650925190f), Qfmt15(0.91328082618125f), Qfmt15(-0.05890199924154f),
+    Qfmt15(0.28398686150148f), Qfmt15(0.95258164539612f), Qfmt15(-0.78566324168507f), Qfmt15(-0.95789495447877f),
+    Qfmt15(0.82411158711197f), Qfmt15(-0.65185446735885f), Qfmt15(-0.93643603134666f), Qfmt15(0.91427159529618f),
+    Qfmt15(-0.70395684036886f), Qfmt15(0.00563771969365f), Qfmt15(0.89065051931895f), Qfmt15(-0.68683707712762f),
+    Qfmt15(0.72165342518718f), Qfmt15(-0.62928247730667f), Qfmt15(0.29938434065514f), Qfmt15(-0.91781958879280f),
+    Qfmt15(0.99298717043688f), Qfmt15(0.82368298622748f), Qfmt15(-0.98512833386833f), Qfmt15(-0.95915368242257f),
+    Qfmt15(-0.21411126572790f), Qfmt15(-0.68821476106884f), Qfmt15(0.91851997982317f), Qfmt15(-0.96062769559127f),
+    Qfmt15(0.51646184922287f), Qfmt15(0.61130721139669f), Qfmt15(0.47336129371299f), Qfmt15(0.90998308703519f),
+    Qfmt15(0.44844799194357f), Qfmt15(0.66614891079092f), Qfmt15(0.74922239129237f), Qfmt15(-0.99571588506485f),
+    Qfmt15(0.97401082477563f), Qfmt15(0.72683747733879f), Qfmt15(0.95432193457128f), Qfmt15(-0.72962208425191f),
+    Qfmt15(-0.85359479233537f), Qfmt15(-0.81412430338535f), Qfmt15(-0.87930772356786f), Qfmt15(-0.71573331064977f),
+    Qfmt15(0.83524300028228f), Qfmt15(-0.48086065601423f), Qfmt15(0.97139128574778f), Qfmt15(0.51992825347895f),
+    Qfmt15(-0.00848591195325f), Qfmt15(-0.70294374303036f), Qfmt15(-0.95894428168140f), Qfmt15(0.97079252950321f),
+    Qfmt15(-0.92404293670797f), Qfmt15(-0.69506469500450f), Qfmt15(0.26559203620024f), Qfmt15(0.28038443336943f),
+    Qfmt15(-0.74138124825523f), Qfmt15(-0.01752795995444f), Qfmt15(-0.55126773094930f), Qfmt15(0.97960898850996f),
+    Qfmt15(-0.99196309146936f), Qfmt15(-0.67684928085260f), Qfmt15(0.09140039465500f), Qfmt15(-0.71658965751996f),
+    Qfmt15(0.81014640078925f), Qfmt15(0.40616991671205f), Qfmt15(-0.67680188682972f), Qfmt15(0.86849774348749f),
+    Qfmt15(-0.99500381284851f), Qfmt15(0.84329189340667f), Qfmt15(-0.09215968531446f), Qfmt15(0.99956173327206f),
+    Qfmt15(-0.79732779473535f), Qfmt15(0.96349973642406f), Qfmt15(-0.79942778496547f), Qfmt15(-0.11566039853896f),
+    Qfmt15(-0.39922954514662f), Qfmt15(0.99089197565987f), Qfmt15(0.28631285179909f), Qfmt15(-0.83302725605608f),
+    Qfmt15(0.95404443402072f), Qfmt15(-0.06449863579434f), Qfmt15(-0.99575054486311f), Qfmt15(-0.65501142790847f),
+    Qfmt15(-0.81254441908887f), Qfmt15(-0.99646369485481f), Qfmt15(0.00287840603348f), Qfmt15(0.70176989408455f),
+    Qfmt15(0.96361882270190f), Qfmt15(-0.68883758192426f), Qfmt15(-0.34875585502238f), Qfmt15(0.91980081243087f),
+    Qfmt15(-0.99009048343881f), Qfmt15(0.68865791458395f), Qfmt15(-0.99484402129368f), Qfmt15(0.94214511408023f),
+    Qfmt15(-0.67414626793544f), Qfmt15(-0.47339353684664f), Qfmt15(0.14323651387360f), Qfmt15(-0.29268293575672f),
+    Qfmt15(0.43793861458754f), Qfmt15(-0.36345126374441f), Qfmt15(-0.08750604656825f), Qfmt15(-0.96495267812511f),
+    Qfmt15(0.55526940659947f), Qfmt15(0.73538215752630f), Qfmt15(-0.30889773919437f), Qfmt15(0.03574995626194f),
+    Qfmt15(0.98720684660488f), Qfmt15(-0.81689296271203f), Qfmt15(0.67866860118215f), Qfmt15(-0.15808569732583f),
+    Qfmt15(0.80723395114371f), Qfmt15(0.47788757329038f), Qfmt15(0.96367554763201f), Qfmt15(-0.99143875716818f),
+    Qfmt15(0.83081876925833f), Qfmt15(-0.58753191905341f), Qfmt15(0.95538108220960f), Qfmt15(-0.96490920476211f),
+    Qfmt15(-0.97327101028521f), Qfmt15(0.91400366022124f), Qfmt15(-0.99925837363824f), Qfmt15(-0.86875903507313f),
+    Qfmt15(-0.26240034795124f), Qfmt15(-0.24664412953388f), Qfmt15(0.02416275806869f), Qfmt15(0.82068619590515f),
+    Qfmt15(0.88547373760759f), Qfmt15(-0.18173078152226f), Qfmt15(0.09355476558534f), Qfmt15(-0.54668414224090f),
+    Qfmt15(0.37050990604091f), Qfmt15(-0.70373594262891f), Qfmt15(-0.34600785879594f), Qfmt15(-0.68774481731008f),
+    Qfmt15(-0.26843291251234f), Qfmt15(0.49072334613242f), Qfmt15(0.38975993093975f), Qfmt15(-0.97757125224150f),
+    Qfmt15(-0.17325552859616f), Qfmt15(0.99948035025744f), Qfmt15(-0.64946246527458f), Qfmt15(-0.12016920576437f),
+    Qfmt15(-0.58947456517751f), Qfmt15(-0.41815140454465f), Qfmt15(0.99885650204884f), Qfmt15(-0.56649614128386f),
+    Qfmt15(0.94138021032330f), Qfmt15(-0.75725076534641f), Qfmt15(0.20541973692630f), Qfmt15(0.99980371023351f),
+    Qfmt15(0.29078277605775f), Qfmt15(-0.62858772103030f), Qfmt15(0.43440904467688f), Qfmt15(-0.98298583762390f),
+    Qfmt15(0.19513029146934f), Qfmt15(-0.95476662400101f), Qfmt15(0.93379635304810f), Qfmt15(-0.85235410573336f),
+    Qfmt15(-0.86425093011245f), Qfmt15(0.38879779059045f), Qfmt15(0.92045124735495f), Qfmt15(0.89162532251878f),
+    Qfmt15(-0.36834336949252f), Qfmt15(0.93891760988045f), Qfmt15(0.99267657565094f), Qfmt15(-0.94063471614176f),
+    Qfmt15(0.99740224117019f), Qfmt15(-0.35899413170555f), Qfmt15(0.05237237274947f), Qfmt15(0.36703583957424f),
+    Qfmt15(0.91653180367913f), Qfmt15(0.69000803499316f), Qfmt15(-0.38658751133527f), Qfmt15(-0.29250814029851f),
+    Qfmt15(-0.60182204677608f), Qfmt15(-0.97418588163217f), Qfmt15(0.88461574003963f), Qfmt15(0.05198933055162f),
+    Qfmt15(-0.53499621979720f), Qfmt15(-0.49429560226497f), Qfmt15(-0.98935142339139f), Qfmt15(-0.98081380091130f),
+    Qfmt15(-0.27338148835532f), Qfmt15(0.06310802338302f), Qfmt15(-0.20461677199539f), Qfmt15(0.66223843141647f),
+    Qfmt15(-0.84764345483665f), Qfmt15(-0.89039863483811f), Qfmt15(0.95903308477986f), Qfmt15(0.73504123909879f),
+    Qfmt15(-0.31744434966056f), Qfmt15(-0.34110827591623f), Qfmt15(0.47803883714199f), Qfmt15(0.98299195879514f),
+    Qfmt15(-0.30963073129751f), Qfmt15(0.99992588229018f), Qfmt15(-0.93149731080767f), Qfmt15(0.99923472302773f),
+    Qfmt15(-0.26024169633417f), Qfmt15(-0.35712514743563f), Qfmt15(-0.99899084509530f), Qfmt15(0.86557171579452f),
+    Qfmt15(0.33408042438752f), Qfmt15(0.99010736374716f), Qfmt15(-0.66694269691195f), Qfmt15(0.64016792079480f),
+    Qfmt15(0.99570534804836f), Qfmt15(-0.63431466947340f), Qfmt15(-0.07706847005931f), Qfmt15(0.98590090577724f),
+    Qfmt15(0.80099335254678f), Qfmt15(0.78368131392666f), Qfmt15(0.08707806671691f), Qfmt15(-0.86811883080712f),
+    Qfmt15(-0.39466529740375f), Qfmt15(0.97875325649683f), Qfmt15(-0.95038560288864f), Qfmt15(0.17005239424212f),
+    Qfmt15(-0.76910792026848f), Qfmt15(0.99743281016846f), Qfmt15(0.95437383549973f), Qfmt15(0.99578905365569f),
+    Qfmt15(0.28058259829990f), Qfmt15(0.85256524470573f), Qfmt15(-0.50608540105128f), Qfmt15(-0.97210735183243f),
+    Qfmt15(0.95424048234441f), Qfmt15(-0.96926570524023f), Qfmt15(0.30872163214726f), Qfmt15(-0.24523839572639f),
+    Qfmt15(-0.33813265086024f), Qfmt15(-0.05826828420146f), Qfmt15(-0.22898461455054f), Qfmt15(-0.18509915019881f),
+    Qfmt15(-0.10488238045009f), Qfmt15(-0.71886586182037f), Qfmt15(0.99793873738654f), Qfmt15(0.57563307626120f),
+    Qfmt15(0.28909646383717f), Qfmt15(0.42188998312520f), Qfmt15(0.93335049681047f), Qfmt15(-0.97087374418267f),
+    Qfmt15(0.36722871286923f), Qfmt15(-0.81093025665696f), Qfmt15(-0.26240603062237f), Qfmt15(0.83996497984604f),
+    Qfmt15(-0.99909615720225f), Qfmt15(0.74649464155061f), Qfmt15(-0.74774595569805f), Qfmt15(0.95781667469567f),
+    Qfmt15(0.95472308713099f), Qfmt15(0.48708332746299f), Qfmt15(0.46332038247497f), Qfmt15(-0.76497004940162f),
+    Qfmt15(0.57397389364339f), Qfmt15(0.75374316974495f), Qfmt15(-0.59174397685714f), Qfmt15(0.75087906691890f),
+    Qfmt15(-0.98607857336230f), Qfmt15(-0.40761056640505f), Qfmt15(0.66929266740477f), Qfmt15(-0.97463695257310f),
+    Qfmt15(0.90145509409859f), Qfmt15(-0.87259289048043f), Qfmt15(-0.91529461447692f), Qfmt15(-0.03305738840705f),
+    Qfmt15(0.07223051368337f), Qfmt15(0.99498012188353f), Qfmt15(-0.74904939500519f), Qfmt15(0.04585228574211f),
+    Qfmt15(-0.89054954257993f), Qfmt15(-0.83782144651251f), Qfmt15(0.33454804933804f), Qfmt15(-0.99707579362824f),
+    Qfmt15(-0.22827527843994f), Qfmt15(0.67248046289143f), Qfmt15(-0.05146538187944f), Qfmt15(0.99947295749905f),
+    Qfmt15(0.66951124390363f), Qfmt15(-0.99602956559179f), Qfmt15(0.82104905483590f), Qfmt15(0.99186510988782f),
+    Qfmt15(-0.65284592392918f), Qfmt15(0.93885443798188f), Qfmt15(0.96735248738388f), Qfmt15(-0.22225968841114f),
+    Qfmt15(-0.44132783753414f), Qfmt15(-0.85694974219574f), Qfmt15(0.91783042091762f), Qfmt15(0.72556974415690f),
+    Qfmt15(-0.99711581834508f), Qfmt15(0.77638976371966f), Qfmt15(0.07717324253925f), Qfmt15(-0.56049829194163f),
+    Qfmt15(0.98398893639988f), Qfmt15(0.47546946844938f), Qfmt15(0.65675089314631f), Qfmt15(0.03273375457980f),
+    Qfmt15(-0.38684144784738f), Qfmt15(-0.97346267944545f), Qfmt15(-0.53282156061942f), Qfmt15(0.99817310731176f),
+    Qfmt15(-0.50254500772635f), Qfmt15(0.01995873238855f), Qfmt15(0.99930381973804f), Qfmt15(0.82907767600783f),
+    Qfmt15(-0.58660709669728f), Qfmt15(-0.17573736667267f), Qfmt15(0.83434292401346f), Qfmt15(0.05946491307025f),
+    Qfmt15(0.81505484574602f), Qfmt15(-0.44976380954860f), Qfmt15(-0.89746474625671f), Qfmt15(0.39677256130792f),
+    Qfmt15(-0.07588948563079f), Qfmt15(0.76343198951445f), Qfmt15(-0.74490104699626f), Qfmt15(0.64880119792759f),
+    Qfmt15(0.62319537462542f), Qfmt15(0.42215817594807f), Qfmt15(0.02704554141885f), Qfmt15(0.80001773566818f),
+    Qfmt15(-0.79351832348816f), Qfmt15(0.63872359151636f), Qfmt15(0.52890520960295f), Qfmt15(0.74238552914587f),
+    Qfmt15(0.99096131449250f), Qfmt15(-0.80412329643109f), Qfmt15(-0.64612616129736f), Qfmt15(0.11657770663191f),
+    Qfmt15(-0.95053182488101f), Qfmt15(-0.62228872928622f), Qfmt15(0.03004475787316f), Qfmt15(-0.97987214341034f),
+    Qfmt15(-0.99986980746200f), Qfmt15(0.89110648599879f), Qfmt15(0.10407960510582f), Qfmt15(0.95964737821728f),
+    Qfmt15(0.50843233159162f), Qfmt15(0.17006334670615f), Qfmt15(0.25872675063360f), Qfmt15(-0.01115998681937f),
+    Qfmt15(-0.79598702973261f), Qfmt15(-0.99264708948101f), Qfmt15(-0.99829663752818f), Qfmt15(-0.70801016548184f),
+    Qfmt15(-0.70467057786826f), Qfmt15(0.99846021905254f), Qfmt15(-0.63364968534650f), Qfmt15(-0.16258217500792f),
+    Qfmt15(-0.43645594360633f), Qfmt15(-0.99848471702976f), Qfmt15(-0.16796458968998f), Qfmt15(-0.87979225745213f),
+    Qfmt15(0.44183099021786f), Qfmt15(0.93310180125532f), Qfmt15(-0.93941931782002f), Qfmt15(-0.88590003188677f),
+    Qfmt15(0.99971463703691f), Qfmt15(-0.75376385639978f), Qfmt15(0.93887685615875f), Qfmt15(0.85126435782309f),
+    Qfmt15(0.39701421446381f), Qfmt15(-0.37024464187437f), Qfmt15(-0.36024828242896f), Qfmt15(-0.93388812549209f),
+    Qfmt15(-0.65298804552119f), Qfmt15(0.11960319006843f), Qfmt15(0.94292565553160f), Qfmt15(0.75081145286948f),
+    Qfmt15(0.56721979748394f), Qfmt15(0.46857766746029f), Qfmt15(0.97312313923635f), Qfmt15(-0.38299976567017f),
+    Qfmt15(0.41025800019463f), Qfmt15(0.09638062008048f), Qfmt15(-0.85283249275397f), Qfmt15(0.88866808958124f),
+    Qfmt15(-0.48202429536989f), Qfmt15(0.27572582416567f), Qfmt15(-0.65889129659168f), Qfmt15(0.98838086953732f),
+    Qfmt15(-0.20651349620689f), Qfmt15(-0.62126416356920f), Qfmt15(0.20320105410437f), Qfmt15(-0.97790548600584f),
+    Qfmt15(0.11112534735126f), Qfmt15(-0.41368337314182f), Qfmt15(0.24133038992960f), Qfmt15(-0.66393410674885f),
+    Qfmt15(-0.53697829178752f), Qfmt15(-0.97224737889348f), Qfmt15(0.87392477144549f), Qfmt15(0.19050361015753f),
+    Qfmt15(-0.46353441212724f), Qfmt15(-0.07064096339021f), Qfmt15(-0.92444085484466f), Qfmt15(-0.83822593578728f),
+    Qfmt15(0.75214681811150f), Qfmt15(-0.42102998829339f), Qfmt15(-0.72094786237696f), Qfmt15(0.78843311019251f),
+    Qfmt15(0.97394027897442f), Qfmt15(0.99206463477946f), Qfmt15(0.76789609461795f), Qfmt15(-0.82002421836409f),
+    Qfmt15(0.81924990025724f), Qfmt15(-0.26719850873357f), Qfmt15(-0.43311260380975f), Qfmt15(0.99194979673836f),
+    Qfmt15(-0.80692001248487f), Qfmt15(0.43080003649976f), Qfmt15(0.67709491937357f), Qfmt15(0.56151770568316f),
+    Qfmt15(0.10831862810749f), Qfmt15(0.91229417540436f), Qfmt15(-0.48972893932274f), Qfmt15(-0.89033658689697f),
+    Qfmt15(0.65269447475094f), Qfmt15(0.67439478141121f), Qfmt15(-0.47770832416973f), Qfmt15(-0.99715979260878f),
+    Qfmt15(-0.90889593602546f), Qfmt15(-0.06618622548177f), Qfmt15(0.99430266919728f), Qfmt15(0.97686402381843f),
+    Qfmt15(0.94813650221268f), Qfmt15(-0.95434497492853f), Qfmt15(-0.49104783137150f), Qfmt15(0.99881175120751f),
+    Qfmt15(0.50449166760303f), Qfmt15(0.47162891065108f), Qfmt15(-0.62081581361840f), Qfmt15(-0.43867015250812f),
+    Qfmt15(0.98630563232075f), Qfmt15(-0.61510362277374f), Qfmt15(-0.03841517601843f), Qfmt15(-0.30102157304644f),
+    Qfmt15(0.41881284182683f), Qfmt15(-0.86135454941237f), Qfmt15(0.67226861393788f), Qfmt15(-0.70737398842068f),
+    Qfmt15(0.94044946687963f), Qfmt15(-0.82386352534327f), Qfmt15(-0.32070666698656f), Qfmt15(0.57593163224487f),
+    Qfmt15(-0.36326018419965f), Qfmt15(0.99979044674350f), Qfmt15(-0.92366023326932f), Qfmt15(-0.44607178518598f),
+    Qfmt15(0.44226800932956f), Qfmt15(0.03671907158312f), Qfmt15(0.52175424682195f), Qfmt15(-0.94701139690956f),
+    Qfmt15(-0.98759606946049f), Qfmt15(0.87434794743625f), Qfmt15(-0.93412041758744f), Qfmt15(0.96063943315511f),
+    Qfmt15(0.97534253457837f), Qfmt15(0.99642466504163f), Qfmt15(-0.94705089665984f), Qfmt15(0.91599807087376f)
+};
+
+
+#ifdef HQ_SBR
+
+
+const Int32 fir_table[5][5] =
+{
+    { Q30_fmt(1.0f)},
+    { Q30_fmt(0.33333333333333f), Q30_fmt(0.66666666666666f)},
+    { Q30_fmt(0.12500000000000f), Q30_fmt(0.37500000000000f),
+      Q30_fmt(0.50000000000000f)},
+    { Q30_fmt(0.05857864376269f), Q30_fmt(0.20000000000000f),
+      Q30_fmt(0.34142135623731f), Q30_fmt(0.40000000000000f)},
+    { Q30_fmt(0.03183050093751f), Q30_fmt(0.11516383427084f),
+      Q30_fmt(0.21816949906249f), Q30_fmt(0.30150283239582f),
+      Q30_fmt(0.33333333333333f)}
+};
+
+
+
+const Int32 rPxx[512] =
+{
+
+    0x8010B3DB,  0x7C4DA98F, 0x12168648, 0xC3D4D033,
+    0x674D25F5,  0xCE1972A6, 0xFEA5AA4A, 0x8B2DF13E,
+    0x46326048,  0x3336815E, 0x802A8F2B, 0x85B7745C,
+    0xC577B766,  0xA2A5828C, 0x60CB1AD1, 0x090C9BD7,
+    0x5F5A8B4D,  0x848D86BB, 0x26F1C0B7, 0x553352C1,
+    0x755E166B,  0xA5674343, 0xA654C5F5, 0x80A48CB4,
+    0x7DA69CD8,  0xBA04FCB4, 0xFDD4005E, 0x91C63676,
+    0x816A8F82,  0x423F55AA, 0x8077B59E, 0x80097DE9,
+    0x46BD4C18,  0x2C437971, 0x5035A0C2, 0x9D3ED49F,
+    0x8AC204B8,  0x9E5A8B0A, 0x662088B9, 0x45B9F0BC,
+    0x9261364F,  0x891B23AD, 0xF1028040, 0x1B568BE1,
+    0x9E787FB3,  0x7D94854D, 0x92077A94, 0x88903F45,
+    0x2705A5B4,  0x6D2B3BDC, 0x74E58034, 0xF8745A8C,
+    0x24592C54,  0x79EDB9BB, 0x9B6E9F44, 0x8563E5DA,
+    0x697C7BB7,  0xAC8F8E6A, 0x88227FD5, 0x7506822F,
+    0xA5E34B42,  0x00B94F10, 0x72004390, 0xA814676E,
+    0x5C5EA758,  0xAF721171, 0x2652C50C, 0x8A84A142,
+    0x7F19343E,  0x696EA13B, 0x81E68008, 0x853980F9,
+    0xE4968869,  0xA7E7DD92, 0x75910BFA, 0x85092E35,
+    0x421BA4A3,  0x4E3F3C18, 0x3C97DD02, 0x74797BCB,
+    0x39667EFD,  0x55447BA2, 0x5FE68CF3, 0x808B4390,
+    0x7CABEA6B,  0x5D08C27A, 0x7A265820, 0xA29A9DF0,
+    0x92BC7195,  0x97CA8338, 0x8F725FAD, 0xA46281D3,
+    0x6AE86B23,  0xC2728178, 0x7C566684, 0x428C66B7,
+    0xFEE89DDB,  0xA60546DC, 0x8540C89D, 0x7C420BF0,
+    0x89B86D72,  0xA7077E3F, 0x21FF5DD7, 0x23E3129C,
+    0xA1197F1D,  0xFDC0963F, 0xB96F8168, 0x7D6387A6,
+    0x810655C8,  0xA95C102B, 0x0BB3E5B4, 0xA44682D4,
+    0x67B244C3,  0x33FDDE1D, 0xA95D78F5, 0x6F2AE887,
+    0x80A3FC9F,  0x6BF00D52, 0xF4325902, 0x7FF1F02C,
+    0x99F08AC5,  0x7B537BB2, 0x99AB5255, 0xF1302497,
+    0xCCE4787B,  0x7ED58A28, 0x24A68B79, 0x955EA9D0,
+    0x7A1D3EED,  0xF7BD0429, 0x808A3642, 0xAC2769A8,
+    0x97FDBDE9,  0x80736C25, 0x005E52E7, 0x59D3E5D0,
+    0x7B57341A,  0xA7D374E9, 0xD35A5B7B, 0x75BB5520,
+    0x81446DE8,  0x5825473E, 0x80A8E653, 0x78978062,
+    0xA9B43F6B,  0xC366920A, 0x1255877D, 0xDA88075F,
+    0x380E9AFF,  0xD1795309, 0xF4CB7D09, 0x847BBAED,
+    0x471364FA,  0x5E207B74, 0xD87498BF, 0x0493836B,
+    0x7E5C3DF6,  0x976F8BBC, 0x56DE680A, 0xEBC26D28,
+    0x6753E05B,  0x3D2BC4B0, 0x7B593143, 0x8118E010,
+    0x6A5786AD,  0xB4CA01A7, 0x7A49927C, 0x847DAE0C,
+    0x836B0FD8,  0x74FD4A34, 0x80175AFC, 0x90CBE605,
+    0xDE68A89E,  0xE06C8FD0, 0x031822CE, 0x690B9315,
+    0x71568D43,  0xE8BBDE85, 0x0BFA4633, 0xBA057ADA,
+    0x2F6CB34F,  0xA5EB74C5, 0xD3B480B6, 0xA7F7D94A,
+    0xDDA26A63,  0x3ED0C5EF, 0x31E37A42, 0x82DE06CB,
+    0xE9D18940,  0x7FEE4A9A, 0xACDD57DD, 0xF09CB6D9,
+    0xB48BD364,  0xCA7814D5, 0x7FDA0E41, 0xB77C8C2A,
+    0x787E2D29,  0x9F1144AC, 0x1A4B871E, 0x7FF96630,
+    0x25382D4D,  0xAF89319E, 0x379A81DB, 0x822D1AE8,
+    0x18FA875E,  0x85C97DE7, 0x7786A544, 0x92E5F550,
+    0x915FC560,  0x31C47C82, 0x75D0B014, 0x72204656,
+    0xD0D87B76,  0x782E8CD6, 0x7F0FFB2F, 0x879834E7,
+    0x7FAAEA73,  0xD20BC44E, 0x06B4DF2C, 0x2EFBCE84,
+    0x7550D8D7,  0x5851746A, 0xCE837F5C, 0xDA8D2FEE,
+    0xB2F66F13,  0x834D7B7A, 0x713A499C, 0x06A81B39,
+    0xBB847C77,  0xC0B97DAC, 0x815CCC7A, 0x8274A2BD,
+    0xDD007FEF,  0x0814BA2F, 0xE5CDEDCE, 0x54C45CD5,
+    0x937F0309,  0x8E0671BF, 0x7AC1623B, 0x5E15FB32,
+    0xD75CD0D9,  0xD4553378, 0x3D30CD88, 0x7DD2028C,
+    0xD85CE8DB,  0x7FFDDE5A, 0x88C48228, 0x7FE6996A,
+    0xDEAF9EB7,  0xD24818B4, 0x80205F8B, 0x6ECA4728,
+    0x2AC36E51,  0x7EBB05E4, 0xAAA08AB1, 0x51F01408,
+    0x7F723AAE,  0xAECD1AFB, 0xF6218D55, 0x7E3170F2,
+    0x6686D0D3,  0x644F3A3F, 0x0B256799, 0x90E0325D,
+    0xCD7AAA7B,  0x7D47A33C, 0x865972A3, 0x15C445FE,
+    0x9D8D84D3,  0x7FAB36A7, 0x7A287C29, 0x7F75BABD,
+    0x23EA92BC,  0x6D20AD59, 0xBF37ABB6, 0x8391E26E,
+    0x7A2480F8,  0x83EE5E6E, 0x27843523, 0xE09A50E7,
+    0xD4B6CE82,  0xF889F71C, 0xE2AF7C3A, 0xE84D3CE2,
+    0xF2918FA6,  0xA3FB63E0, 0x7FBB7340, 0x49AE8B79,
+    0x25017B45,  0x36003DA1, 0x7777C844, 0x83B96EE4,
+    0x2F015392,  0x98320B3C, 0xDE68893F, 0x6B834779,
+    0x801D8516,  0x5F8C0F8C, 0xA049DD90, 0x7A999AD0,
+    0x7A33F500,  0x3E587FFF, 0x3B4E0E09, 0x9E147230,
+    0x49772D2B,  0x607A7BC7, 0xB4408D8F, 0x601CDA17,
+    0x81C7200B,  0xCBD28CBD, 0x55AB7E3E, 0x833EFFC0,
+    0x73627FB7,  0x904E7F04, 0x8AD7EBE6, 0xFBC3D05F,
+    0x093F8E53,  0x7F5B7C47, 0xA01E7FFA, 0x05DE7FC2,
+    0x8E01D74D,  0x94C17CF9, 0x2AD2919F, 0x805F7757,
+    0xE2C61829,  0x5613FB53, 0xF9688978, 0x7FEE77D6,
+    0x55B27E98,  0x8081C6D6, 0x69177F69, 0x7EF45C30,
+    0xAC6E42CC,  0x782BA021, 0x7BD17457, 0xE38B491E,
+    0xC781895B,  0x924E71B8, 0x757BC4A8, 0x5CDF8020,
+    0x805E4A82,  0x636078BA, 0x09E14B0E, 0xB84069A0,
+    0x7DF23284,  0x3CDC57D2, 0x54101777, 0x0431A015,
+    0xCE7A41B6,  0x8365846A, 0xBBCB8AF9, 0x7FC34E40,
+    0xBFAB8E4B,  0x028E6D15, 0x7FE8790F, 0x6A1EF7E6,
+    0xB4E97BF4,  0xE980C257, 0x6ACBEF53, 0x079C1A41,
+    0x685386CC,  0xC66D3458, 0x8D1F7FCD, 0x32C9A02E,
+    0xF6475ED7,  0x61B7356F, 0xA0A6793F, 0x530B34E9,
+    0x4FC488D4,  0x3609F61F, 0x0376F90F, 0x6666752C,
+    0x9A6DD1A5,  0x51C10A67, 0x43B34CDC, 0x5F0605C0,
+    0x7ED7E718,  0x99118EB3, 0xAD4A5C69, 0x0EEC94E8,
+    0x865483EA,  0xB05769F0, 0x03D88055, 0x82932EC1,
+    0x8003D1E3,  0x720F82B1, 0x0D526304, 0x7AD5D2A3,
+    0x41147B04,  0x15C49D9F, 0x211E7FDC, 0xFE907E12,
+    0x9A1C7C55,  0x80F08095, 0x80370267, 0xA55F2B1C,
+    0xA5CC7763,  0x7FCD81A1, 0xAEE3EAE8, 0xEB2F8532,
+    0xC82186A5,  0x80317B31, 0xEA7E814B, 0x8F62A430,
+    0x388D883A,  0x776F801B, 0x87C0B7CA, 0x8E9A3CF5,
+    0x7FF6949E,  0x9F83010B, 0x782CF18C, 0x6CF54301,
+    0x32D168AD,  0xD09A908B, 0xD1E22C5C, 0x887593DE,
+    0xAC6AE864,  0x0F4F7FDE, 0x78B16A72, 0x601AD283,
+    0x489AE12D,  0x3BFAD96A, 0x7C8E8093, 0xCEF87E19,
+    0x348302B6,  0x0C5605A6, 0x92D57516, 0x71BF8056,
+    0xC24C8416,  0x234B4B0D, 0xABA84B4F, 0x7E827FFD,
+    0xE58F45E1,  0xB079B355, 0x1A0290CA, 0x82D37B40,
+    0x0E391B80,  0xCB0B241E, 0x1EE441A8, 0xAB03F56F,
+    0xBB438301,  0x838C1C43, 0x6FDCEF9D, 0x1862020D,
+    0xC4A98614,  0xF6F38710, 0x89ABF29B, 0x94B4FDD3,
+    0x6046800E,  0xCA1A7FA4, 0xA3B7D32F, 0x64EB43A6,
+    0x7CA9DDD3,  0x7EFBB705, 0x624A9E0D, 0x9708A1E0,
+    0x68DC7F9C,  0xDDCB5832, 0xC88E6D35, 0x7EF77599,
+    0x98B6D63B,  0x3724E3F0, 0x56AA85C9, 0x47DFA582,
+    0x0DDDF4F3,  0x74C5AB88, 0xC14F480C, 0x8E08A446,
+    0x538B545F,  0x56529770, 0xC2D9EA81, 0x805C883B,
+    0x8BA84F67,  0xF785E183, 0x7F441814, 0x7D09DB4D,
+    0x795C8330,  0x85D79A19, 0xC1242A1B, 0x7FD871E9,
+    0x409391EC,  0x3C5EE815, 0xB0885FFF, 0xC7D87FFE,
+    0x7E3EBB6A,  0xB1438D6B, 0xFB13A68A, 0xD976F62D,
+    0x359B02CD,  0x91BE7EA6, 0x560CEEB8, 0xA5739E04,
+    0x78600B8E,  0x968A0B6C, 0xD6F1402E, 0x49B88152,
+    0xD17F0986,  0x7FF8EDE8, 0x89C48295, 0xC6E6BA93,
+    0x389C5B4C,  0x04B3516A, 0x42C892B0, 0x86C7FDA8,
+    0x81956954,  0x6FEA726E, 0x886E34F5, 0x7AF57730,
+    0x7CD76E45,  0x7F8A59D7, 0x86C6DA22, 0x753F825E
+};
+
+
+#endif
+
+
+#endif
+
diff --git a/media/libstagefright/codecs/aacdec/sbr_envelope_calc_tbl.h b/media/libstagefright/codecs/aacdec/sbr_envelope_calc_tbl.h
new file mode 100644
index 0000000..60e806d
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/sbr_envelope_calc_tbl.h
@@ -0,0 +1,96 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Filename: sbr_envelope_calc_tbl.h
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+
+ Who:                                   Date: MM/DD/YYYY
+ Description:
+------------------------------------------------------------------------------
+
+
+----------------------------------------------------------------------------
+; CONTINUE ONLY IF NOT ALREADY DEFINED
+----------------------------------------------------------------------------*/
+#ifndef SBR_ENVELOPE_CALC_TBL_H
+#define SBR_ENVELOPE_CALC_TBL_H
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+#include "pv_audio_type_defs.h"
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here.
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL VARIABLES REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+
+extern const Int32 limGains[5];
+
+extern const Int32 smoothLengths[2];
+
+extern const Int16 rP_LCx[512];
+
+#ifdef HQ_SBR
+
+
+extern const Int32 fir_table[5][5];
+
+extern const Int32 rPxx[512];
+
+#endif
+
+/*----------------------------------------------------------------------------
+; SIMPLE TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; ENUMERATED TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; STRUCTURES TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; GLOBAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+
+
+/*----------------------------------------------------------------------------
+; END
+----------------------------------------------------------------------------*/
+#endif
+
+
diff --git a/media/libstagefright/codecs/aacdec/sbr_envelope_unmapping.cpp b/media/libstagefright/codecs/aacdec/sbr_envelope_unmapping.cpp
new file mode 100644
index 0000000..7fce46b
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/sbr_envelope_unmapping.cpp
@@ -0,0 +1,427 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Filename: sbr_envelope_unmapping.c
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+
+ Who:                                   Date: MM/DD/YYYY
+ Description:
+
+------------------------------------------------------------------------------
+ INPUT AND OUTPUT DEFINITIONS
+
+
+
+------------------------------------------------------------------------------
+ FUNCTION DESCRIPTION
+
+
+------------------------------------------------------------------------------
+ REQUIREMENTS
+
+
+------------------------------------------------------------------------------
+ REFERENCES
+
+SC 29 Software Copyright Licencing Disclaimer:
+
+This software module was originally developed by
+  Coding Technologies
+
+and edited by
+  -
+
+in the course of development of the ISO/IEC 13818-7 and ISO/IEC 14496-3
+standards for reference purposes and its performance may not have been
+optimized. This software module is an implementation of one or more tools as
+specified by the ISO/IEC 13818-7 and ISO/IEC 14496-3 standards.
+ISO/IEC gives users free license to this software module or modifications
+thereof for use in products claiming conformance to audiovisual and
+image-coding related ITU Recommendations and/or ISO/IEC International
+Standards. ISO/IEC gives users the same free license to this software module or
+modifications thereof for research purposes and further ISO/IEC standardisation.
+Those intending to use this software module in products are advised that its
+use may infringe existing patents. ISO/IEC have no liability for use of this
+software module or modifications thereof. Copyright is not released for
+products that do not conform to audiovisual and image-coding related ITU
+Recommendations and/or ISO/IEC International Standards.
+The original developer retains full right to modify and use the code for its
+own purpose, assign or donate the code to a third party and to inhibit third
+parties from using the code for products that do not conform to audiovisual and
+image-coding related ITU Recommendations and/or ISO/IEC International Standards.
+This copyright notice must be included in all copies or derivative works.
+Copyright (c) ISO/IEC 2002.
+
+------------------------------------------------------------------------------
+ PSEUDO-CODE
+
+------------------------------------------------------------------------------
+*/
+
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+
+#ifdef AAC_PLUS
+
+
+#include    "sbr_envelope_unmapping.h"
+#include    "sbr_constants.h"
+
+#include "fxp_mul32.h"
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here. Include conditional
+; compile variables also.
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; LOCAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; LOCAL STORE/BUFFER/POINTER DEFINITIONS
+; Variable declaration - defined here and used outside this module
+----------------------------------------------------------------------------*/
+
+#define R_SHIFT     30
+#define Qfmt(x)   (Int32)(x*((Int32)1<<R_SHIFT) + (x>=0?0.5F:-0.5F))
+
+/*
+ *  1./(1+2.^-[0:10])
+ */
+const Int32 one_over_one_plus_two_to_n[11] =
+{
+    Qfmt(0.50000000000000F), Qfmt(0.66666666666667F), Qfmt(0.80000000000000F),
+    Qfmt(0.88888888888889F), Qfmt(0.94117647058824F), Qfmt(0.96969696969697F),
+    Qfmt(0.98461538461538F), Qfmt(0.99224806201550F), Qfmt(0.99610894941634F),
+    Qfmt(0.99805068226121F), Qfmt(0.99902439024390F)
+};
+
+/*
+ *  1./(1+2.^[0.5:-1:-10.5])
+ */
+const Int32 one_over_one_plus_sq_2_by_two_to_n[12] =
+{
+    Qfmt(0.41421356237310F), Qfmt(0.58578643762690F), Qfmt(0.73879612503626F),
+    Qfmt(0.84977889517767F), Qfmt(0.91878969685839F), Qfmt(0.95767628767521F),
+    Qfmt(0.97838063800882F), Qfmt(0.98907219289563F), Qfmt(0.99450607818892F),
+    Qfmt(0.99724547251514F), Qfmt(0.99862083678608F), Qfmt(0.99930994254211F)
+};
+
+/*----------------------------------------------------------------------------
+; EXTERNAL FUNCTION REFERENCES
+; Declare functions defined elsewhere and referenced in this module
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL GLOBAL STORE/BUFFER/POINTER REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; FUNCTION CODE
+----------------------------------------------------------------------------*/
+
+void sbr_envelope_unmapping(SBR_FRAME_DATA * hFrameData1,
+                            SBR_FRAME_DATA * hFrameData2)
+
+{
+    Int32 i;
+    Int32 tempLeft;
+    Int32 tempRight;
+
+    Int32 tmp;
+    Int32 *iEnvelopeLeft_man    = hFrameData1->iEnvelope_man;
+    Int32 *iEnvelopeLeft_exp    = hFrameData1->iEnvelope_exp;
+    Int32 *noiseFloorLeft_man   = hFrameData1->sbrNoiseFloorLevel_man;
+    Int32 *noiseFloorLeft_exp   = hFrameData1->sbrNoiseFloorLevel_exp;
+
+    Int32 *iEnvelopeRight_man   = hFrameData2->iEnvelope_man;
+    Int32 *iEnvelopeRight_exp   = hFrameData2->iEnvelope_exp;
+    Int32 *noiseFloorRight_man  = hFrameData2->sbrNoiseFloorLevel_man;
+    Int32 *noiseFloorRight_exp  = hFrameData2->sbrNoiseFloorLevel_exp;
+
+
+    if (hFrameData2->ampRes)
+    {
+        for (i = 0; i < hFrameData1->nScaleFactors; i++)
+        {
+            tempRight = iEnvelopeRight_man[i];
+            tempLeft  = iEnvelopeLeft_man[i];
+            /*  iEnvelope[i] always positive  6 bits max */
+
+            iEnvelopeLeft_exp[i] = tempLeft + 7;
+
+            iEnvelopeRight_exp[i] = tempRight - 12;
+            iEnvelopeRight_man[i] = Qfmt(1.000F);
+
+            /*
+             *  iEnvelopeRight[i] = tempLeft / (1 + tempRight);
+             *  iEnvelopeLeft[i]  = tempRight * iEnvelopeRight[i];
+             *
+             *
+             *   iEnvelopeRight[i] = k*2^n/(1+2^m) =  k*2^(n-m)/(1 + 2^-m);
+             *   where k = 1 or sqrt(2)
+             */
+            if (iEnvelopeRight_exp[i] >= 0)
+            {
+                if (iEnvelopeRight_exp[i] < 11)
+                {
+                    iEnvelopeRight_man[i] = one_over_one_plus_two_to_n[ iEnvelopeRight_exp[i]];
+                }
+                else        /*  1/(1+2^-m) == 1 - 2^-m ;  for m >= 10  */
+                {
+                    iEnvelopeRight_man[i] -= (Qfmt(1.000F) >> iEnvelopeRight_exp[i]);
+                }
+                iEnvelopeRight_exp[i] = iEnvelopeLeft_exp[i] - iEnvelopeRight_exp[i];
+            }
+            else
+            {
+                if (iEnvelopeRight_exp[i] > -11)
+                {
+                    iEnvelopeRight_man[i] -= one_over_one_plus_two_to_n[ -iEnvelopeRight_exp[i]];
+                    iEnvelopeRight_exp[i] = iEnvelopeLeft_exp[i] - iEnvelopeRight_exp[i];
+
+                }
+                else        /*  1/(1+2^m) == 2^-m ;  for m >= 10  */
+                {
+                    iEnvelopeRight_exp[i] = iEnvelopeLeft_exp[i];
+                    iEnvelopeLeft_exp[i] = 0;
+                }
+            }
+
+            iEnvelopeLeft_man[i]  = iEnvelopeRight_man[i];
+        }
+    }
+    else
+    {
+        for (i = 0; i < hFrameData1->nScaleFactors; i++)
+        {
+            /*  iEnvelope[i] always positive  7 bits max */
+            tempRight = iEnvelopeRight_man[i];
+            tempLeft  = iEnvelopeLeft_man[i];
+
+            iEnvelopeLeft_exp[i] = (tempLeft >> 1) + 7;
+            if (tempLeft & 0x1)   /*  odd */
+            {
+                iEnvelopeLeft_man[i] = Qfmt(1.41421356237310F);
+            }
+            else
+            {
+                iEnvelopeLeft_man[i] = Qfmt(1.000F);
+            }
+
+            iEnvelopeRight_exp[i] = (tempRight >> 1) - 12;
+            if (tempRight & 0x1)   /*  odd */
+            {
+                if (iEnvelopeRight_exp[i] > 0)
+                {
+                    iEnvelopeRight_man[i] = Qfmt(1.41421356237310F);
+                }
+                else
+                {
+                    iEnvelopeRight_man[i] = Qfmt(0.7071067811865F);
+                }
+            }
+            else
+            {
+                iEnvelopeRight_man[i] = Qfmt(1.000F);
+            }
+
+            if (iEnvelopeRight_man[i] == Qfmt(1.000F))
+            {
+
+                /*
+                 *  iEnvelopeRight[i] = tempLeft / (1 + tempRight);
+                 *  iEnvelopeLeft[i]  = tempRight * iEnvelopeRight[i];
+                 *
+                 *
+                 *   iEnvelopeRight[i] = k*2^n/(1+2^m) =  k*2^(n-m)/(1 + 2^-m);
+                 *   where k = 1 or sqrt(2)
+                 */
+                if (iEnvelopeRight_exp[i] >= 0)
+                {
+                    if (iEnvelopeRight_exp[i] < 11)
+                    {
+                        iEnvelopeRight_man[i] = one_over_one_plus_two_to_n[ iEnvelopeRight_exp[i]];
+                    }
+                    else        /*  1/(1+2^-m) == 1 - 2^-m ;  for m >= 10  */
+                    {
+                        iEnvelopeRight_man[i] -= (Qfmt(1.000F) >> iEnvelopeRight_exp[i]);
+                    }
+                    iEnvelopeRight_exp[i] = iEnvelopeLeft_exp[i] - iEnvelopeRight_exp[i];
+
+                }
+                else
+                {
+                    if (iEnvelopeRight_exp[i] > -11)
+                    {
+                        iEnvelopeRight_man[i] -= one_over_one_plus_two_to_n[ -iEnvelopeRight_exp[i]];
+                        iEnvelopeRight_exp[i] = iEnvelopeLeft_exp[i] - iEnvelopeRight_exp[i];
+                    }
+                    else        /*  1/(1+2^m) == 2^-m ;  for m >= 10  */
+                    {
+                        iEnvelopeRight_exp[i] = iEnvelopeLeft_exp[i];
+                        iEnvelopeLeft_exp[i]  = 0;
+                    }
+                }
+
+                /*
+                 *  apply "k" factor 1 or sqrt(2)
+                 *
+                 *   (2^m)*2*k*2^n/(1+2^m) =  k*2^(n+1)/(1 + 2^-m);
+                 *
+                 */
+                if (iEnvelopeLeft_man[i] != Qfmt(1.000F))
+                {
+                    iEnvelopeRight_man[i] = fxp_mul32_Q30(iEnvelopeLeft_man[i], iEnvelopeRight_man[i]);
+                }
+
+                iEnvelopeLeft_man[i]  = iEnvelopeRight_man[i];
+
+            }
+            else
+            {
+
+                /*
+                *  iEnvelopeRight[i] = tempLeft / (1 + tempRight);
+                *  iEnvelopeLeft[i]  = tempRight * iEnvelopeRight[i];
+                *
+                *
+                *   iEnvelopeRight[i] = k*2^n/(1+q2^m) =  k*2^(n-m)/(1 + q2^-m);
+                *   where k = 1 or sqrt(2)
+                *   and q = sqrt(2)
+                    */
+                if (iEnvelopeRight_exp[i] >= 0)
+                {
+                    if (iEnvelopeRight_exp[i] < 12)
+                    {
+                        iEnvelopeRight_man[i] = one_over_one_plus_sq_2_by_two_to_n[ iEnvelopeRight_exp[i]];
+                    }
+                    else        /*  1/(1+2^-m) == 1 - 2^-m ;  for m >= 11  */
+                    {
+                        iEnvelopeRight_man[i] = Qfmt(1.000F) - (Qfmt(1.000F) >> iEnvelopeRight_exp[i]);
+                    }
+                }
+                else
+                {
+                    if (iEnvelopeRight_exp[i] > -12)
+                    {
+                        iEnvelopeRight_man[i] = Qfmt(1.000F) - one_over_one_plus_sq_2_by_two_to_n[ -iEnvelopeRight_exp[i]];
+                    }
+                    else        /*  1/(1+2^m) == 2^-m ;  for m >= 11  */
+                    {
+                        iEnvelopeRight_man[i] = Qfmt(1.000F);
+                        iEnvelopeRight_exp[i] = 0;
+                    }
+                }
+
+                iEnvelopeRight_exp[i] = iEnvelopeLeft_exp[i] - iEnvelopeRight_exp[i];
+
+                /*
+                *  apply "k" factor 1 or sqrt(2)
+                *
+                *   Right ==    k*2^(n-m)/(1 + q2^-m)
+                *   Left  == (q2^m)*k*2^n/(1 + q2^m) =  qk*2^n/(1 + q2^-m);
+                */
+                if (iEnvelopeLeft_man[i] != Qfmt(1.000F))
+                {
+                    /*
+                    *   k/(1 + q2^-m);
+                        */
+                    tmp = iEnvelopeRight_man[i];
+                    iEnvelopeRight_man[i] = fxp_mul32_Q30(iEnvelopeLeft_man[i], iEnvelopeRight_man[i]);
+                    iEnvelopeLeft_man[i] = tmp;
+                    iEnvelopeLeft_exp[i] += 1;      /* extra one due to sqrt(2)^2 */
+                }
+                else
+                {
+                    iEnvelopeLeft_man[i]  = fxp_mul32_Q30(iEnvelopeRight_man[i], Qfmt(1.41421356237310F));
+                }
+
+            }       /*  end of     if (iEnvelopeRight_man[i] == Qfmt( 1.000F) )  */
+        }      /* end of for loop */
+    }     /*  end  if (hFrameData2->ampRes) */
+
+
+    for (i = 0; i < hFrameData1->nNoiseFactors; i++)
+    {
+
+        noiseFloorLeft_exp[i]  = NOISE_FLOOR_OFFSET_PLUS_1 - noiseFloorLeft_man[i];
+        noiseFloorRight_exp[i] = noiseFloorRight_man[i] - SBR_ENERGY_PAN_OFFSET_INT;
+
+
+        /*
+         *  noiseFloorRight[i] = tempLeft / (1.0f + tempRight);
+         *  noiseFloorLeft[i]  = tempRight*noiseFloorRight[i];
+         *
+         *
+         *   noiseFloorRight[i] = 2^n/(1+2^m) =  2^(n-m)/(1 + 2^-m);
+         */
+        if (noiseFloorRight_exp[i] >= 0)
+        {
+            if (noiseFloorRight_exp[i] < 11)
+            {
+                noiseFloorRight_man[i] = one_over_one_plus_two_to_n[ noiseFloorRight_exp[i]];
+            }
+            else        /*  1/(1+2^-m) == 1 - 2^-m ;  for m >= 10  */
+            {
+                noiseFloorRight_man[i] = Qfmt(1.000F) - (Qfmt(1.000F) >> noiseFloorRight_exp[i]);
+            }
+        }
+        else
+        {
+            if (noiseFloorRight_exp[i] > -11)
+            {
+                noiseFloorRight_man[i] = Qfmt(1.000F) - one_over_one_plus_two_to_n[ -noiseFloorRight_exp[i]];
+            }
+            else        /*  1/(1+2^m) == 2^-m ;  for m >= 10  */
+            {
+                noiseFloorRight_man[i] = Qfmt(1.000F);
+                noiseFloorRight_exp[i] = 0;
+            }
+        }
+
+        noiseFloorRight_exp[i] = noiseFloorLeft_exp[i] - noiseFloorRight_exp[i];
+
+        /*
+         *   (2^m)*2^n/(1+2^m) =  2^n/(1 + 2^-m);
+         */
+
+        noiseFloorLeft_man[i] = noiseFloorRight_man[i];
+        noiseFloorLeft_exp[i] = noiseFloorLeft_exp[i];
+
+    }
+}
+
+#endif
+
diff --git a/media/libstagefright/codecs/aacdec/sbr_envelope_unmapping.h b/media/libstagefright/codecs/aacdec/sbr_envelope_unmapping.h
new file mode 100644
index 0000000..b949830
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/sbr_envelope_unmapping.h
@@ -0,0 +1,89 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Filename: sbr_envelope_unmapping.h
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+
+ Who:                                   Date: MM/DD/YYYY
+ Description:
+------------------------------------------------------------------------------
+
+
+----------------------------------------------------------------------------
+; CONTINUE ONLY IF NOT ALREADY DEFINED
+----------------------------------------------------------------------------*/
+#ifndef SBR_ENVELOPE_UNMAPPING_H
+#define SBR_ENVELOPE_UNMAPPING_H
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+#include    "pv_audio_type_defs.h"
+#include    "s_sbr_frame_data.h"
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here.
+----------------------------------------------------------------------------*/
+
+#define UNMAPPING_SCALE_INT         (-18)           /*  factor's 2-exponent */
+#define SBR_ENERGY_PAN_OFFSET_INT   12
+
+
+
+/*----------------------------------------------------------------------------
+; EXTERNAL VARIABLES REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; SIMPLE TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; ENUMERATED TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; STRUCTURES TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+
+/*----------------------------------------------------------------------------
+; GLOBAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+
+void sbr_envelope_unmapping(SBR_FRAME_DATA * hFrameData1,
+                            SBR_FRAME_DATA * hFrameData2);
+
+/*----------------------------------------------------------------------------
+; END
+----------------------------------------------------------------------------*/
+#endif
+
+
diff --git a/media/libstagefright/codecs/aacdec/sbr_extract_extended_data.cpp b/media/libstagefright/codecs/aacdec/sbr_extract_extended_data.cpp
new file mode 100644
index 0000000..92b22f7
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/sbr_extract_extended_data.cpp
@@ -0,0 +1,223 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Filename: sbr_extract_extended_data.c
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+
+ Who:                                   Date: MM/DD/YYYY
+ Description:
+
+------------------------------------------------------------------------------
+ INPUT AND OUTPUT DEFINITIONS
+
+    SBR_FRAME_DATA *hFrameData,     Destination for extracted data of left channel
+    SBR_FRAME_DATA *hFrameDataRight Destination for extracted data of right channel
+    BIT_BUFFER hBitBuf              pointer to bit buffer
+
+
+------------------------------------------------------------------------------
+ FUNCTION DESCRIPTION
+
+  Reads extension data from the bitstream
+
+  The bitstream format allows up to 4 kinds of extended data element.
+  Extended data may contain several elements, each identified by a 2-bit-ID.
+
+------------------------------------------------------------------------------
+ REQUIREMENTS
+
+
+------------------------------------------------------------------------------
+ REFERENCES
+
+SC 29 Software Copyright Licencing Disclaimer:
+
+This software module was originally developed by
+  Coding Technologies
+
+and edited by
+  -
+
+in the course of development of the ISO/IEC 13818-7 and ISO/IEC 14496-3
+standards for reference purposes and its performance may not have been
+optimized. This software module is an implementation of one or more tools as
+specified by the ISO/IEC 13818-7 and ISO/IEC 14496-3 standards.
+ISO/IEC gives users free license to this software module or modifications
+thereof for use in products claiming conformance to audiovisual and
+image-coding related ITU Recommendations and/or ISO/IEC International
+Standards. ISO/IEC gives users the same free license to this software module or
+modifications thereof for research purposes and further ISO/IEC standardisation.
+Those intending to use this software module in products are advised that its
+use may infringe existing patents. ISO/IEC have no liability for use of this
+software module or modifications thereof. Copyright is not released for
+products that do not conform to audiovisual and image-coding related ITU
+Recommendations and/or ISO/IEC International Standards.
+The original developer retains full right to modify and use the code for its
+own purpose, assign or donate the code to a third party and to inhibit third
+parties from using the code for products that do not conform to audiovisual and
+image-coding related ITU Recommendations and/or ISO/IEC International Standards.
+This copyright notice must be included in all copies or derivative works.
+Copyright (c) ISO/IEC 2002.
+
+------------------------------------------------------------------------------
+ PSEUDO-CODE
+
+------------------------------------------------------------------------------
+*/
+
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+
+#ifdef AAC_PLUS
+
+
+#include    "sbr_extract_extended_data.h"
+#include    "buf_getbits.h"
+
+#ifdef PARAMETRICSTEREO
+#include    "ps_read_data.h"
+#endif
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here. Include conditional
+; compile variables also.
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; LOCAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; LOCAL STORE/BUFFER/POINTER DEFINITIONS
+; Variable declaration - defined here and used outside this module
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL FUNCTION REFERENCES
+; Declare functions defined elsewhere and referenced in this module
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL GLOBAL STORE/BUFFER/POINTER REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; FUNCTION CODE
+----------------------------------------------------------------------------*/
+
+void sbr_extract_extended_data(BIT_BUFFER * hBitBuf
+#ifdef PARAMETRICSTEREO         /* Parametric Stereo Decoder */
+                               , HANDLE_PS_DEC hParametricStereoDec
+#endif
+                              )
+{
+    Int32 extended_data;
+    Int32 i;
+    Int32 nBitsLeft;
+    Int32 extension_id;
+
+    extended_data = buf_get_1bit(hBitBuf);    /*  SI_SBR_EXTENDED_DATA_BITS  */
+
+    if (extended_data)
+    {
+        Int32 cnt;
+
+        cnt = buf_getbits(hBitBuf, SI_SBR_EXTENSION_SIZE_BITS);
+        if (cnt == (1 << SI_SBR_EXTENSION_SIZE_BITS) - 1)
+        {
+            cnt += buf_getbits(hBitBuf, SI_SBR_EXTENSION_ESC_COUNT_BITS);
+        }
+
+        nBitsLeft = (cnt << 3);
+        while (nBitsLeft > 7)
+        {
+            extension_id = buf_getbits(hBitBuf, SI_SBR_EXTENSION_ID_BITS);
+            nBitsLeft -= SI_SBR_EXTENSION_ID_BITS;
+
+            switch (extension_id)
+            {
+#ifdef HQ_SBR
+#ifdef PARAMETRICSTEREO
+
+                    /*
+                     *  Parametric Coding supports the Transient, Sinusoidal, Noise, and
+                     *  Parametric Stereo tools (MPEG4).
+                     *  3GPP use aac+ hq along with ps for enhanced aac+
+                     *  The PS tool uses complex-value QMF data, therefore can not be used
+                     *  with low power version of aac+
+                     */
+                case EXTENSION_ID_PS_CODING:
+
+                    if (hParametricStereoDec != NULL)
+                    {
+                        if (!hParametricStereoDec->psDetected)
+                        {
+                            /* parametric stereo detected */
+                            hParametricStereoDec->psDetected = 1;
+                        }
+
+                        nBitsLeft -= ps_read_data(hParametricStereoDec,
+                                                  hBitBuf,
+                                                  nBitsLeft);
+
+                    }
+
+                    break;
+#endif
+#endif
+                case 0:
+
+                default:
+                    /*   An unknown extension id causes the remaining extension data
+                     *   to be skipped
+                     */
+                    cnt = nBitsLeft >> 3; /* number of remaining bytes */
+
+                    for (i = 0; i < cnt; i++)
+                    {
+                        buf_getbits(hBitBuf, 8);
+                    }
+
+                    nBitsLeft -= (cnt << 3);
+            }
+        }
+        /* read fill bits for byte alignment */
+        buf_getbits(hBitBuf, nBitsLeft);
+    }
+}
+
+
+#endif
+
+
+
diff --git a/media/libstagefright/codecs/aacdec/sbr_extract_extended_data.h b/media/libstagefright/codecs/aacdec/sbr_extract_extended_data.h
new file mode 100644
index 0000000..bbca3b9
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/sbr_extract_extended_data.h
@@ -0,0 +1,93 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Filename: sbr_extract_extended_data.h
+ Funtions:
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+
+ Who:                                   Date: MM/DD/YYYY
+ Description:
+------------------------------------------------------------------------------
+
+
+----------------------------------------------------------------------------
+; CONTINUE ONLY IF NOT ALREADY DEFINED
+----------------------------------------------------------------------------*/
+#ifndef SBR_EXTRACT_EXTENDED_DATA_H
+#define SBR_EXTRACT_EXTENDED_DATA_H
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+#include    "pv_audio_type_defs.h"
+#include    "s_bit_buffer.h"
+#include    "s_sbr_frame_data.h"
+
+#ifdef PARAMETRICSTEREO
+#include    "s_ps_dec.h"
+#endif
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here.
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL VARIABLES REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; SIMPLE TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; ENUMERATED TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; STRUCTURES TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; GLOBAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+
+void sbr_extract_extended_data(BIT_BUFFER * hBitBuf
+#ifdef PARAMETRICSTEREO         /* Parametric Stereo Decoder */
+                               , HANDLE_PS_DEC hParametricStereoDec
+#endif
+                              );
+
+
+/*----------------------------------------------------------------------------
+; END
+----------------------------------------------------------------------------*/
+#endif
+
+
diff --git a/media/libstagefright/codecs/aacdec/sbr_find_start_andstop_band.cpp b/media/libstagefright/codecs/aacdec/sbr_find_start_andstop_band.cpp
new file mode 100644
index 0000000..fc3d38f
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/sbr_find_start_andstop_band.cpp
@@ -0,0 +1,198 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Filename: sbr_find_start_andstop_band.c
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+
+ Who:                                   Date: MM/DD/YYYY
+ Description:
+
+------------------------------------------------------------------------------
+ INPUT AND OUTPUT DEFINITIONS
+
+
+
+------------------------------------------------------------------------------
+ FUNCTION DESCRIPTION
+
+
+------------------------------------------------------------------------------
+ REQUIREMENTS
+
+
+------------------------------------------------------------------------------
+ REFERENCES
+
+SC 29 Software Copyright Licencing Disclaimer:
+
+This software module was originally developed by
+  Coding Technologies
+
+and edited by
+  -
+
+in the course of development of the ISO/IEC 13818-7 and ISO/IEC 14496-3
+standards for reference purposes and its performance may not have been
+optimized. This software module is an implementation of one or more tools as
+specified by the ISO/IEC 13818-7 and ISO/IEC 14496-3 standards.
+ISO/IEC gives users free license to this software module or modifications
+thereof for use in products claiming conformance to audiovisual and
+image-coding related ITU Recommendations and/or ISO/IEC International
+Standards. ISO/IEC gives users the same free license to this software module or
+modifications thereof for research purposes and further ISO/IEC standardisation.
+Those intending to use this software module in products are advised that its
+use may infringe existing patents. ISO/IEC have no liability for use of this
+software module or modifications thereof. Copyright is not released for
+products that do not conform to audiovisual and image-coding related ITU
+Recommendations and/or ISO/IEC International Standards.
+The original developer retains full right to modify and use the code for its
+own purpose, assign or donate the code to a third party and to inhibit third
+parties from using the code for products that do not conform to audiovisual and
+image-coding related ITU Recommendations and/or ISO/IEC International Standards.
+This copyright notice must be included in all copies or derivative works.
+Copyright (c) ISO/IEC 2002.
+
+------------------------------------------------------------------------------
+ PSEUDO-CODE
+
+------------------------------------------------------------------------------
+*/
+
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+
+#ifdef AAC_PLUS
+
+
+#include    "sbr_find_start_andstop_band.h"
+#include    "get_sbr_startfreq.h"
+#include    "get_sbr_stopfreq.h"
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here. Include conditional
+; compile variables also.
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; LOCAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; LOCAL STORE/BUFFER/POINTER DEFINITIONS
+; Variable declaration - defined here and used outside this module
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL FUNCTION REFERENCES
+; Declare functions defined elsewhere and referenced in this module
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL GLOBAL STORE/BUFFER/POINTER REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; FUNCTION CODE
+----------------------------------------------------------------------------*/
+
+SBR_ERROR sbr_find_start_andstop_band(const Int32 samplingFreq,
+                                      const Int32 startFreq,
+                                      const Int32 stopFreq,
+                                      Int   *lsbM,
+                                      Int   *usb)
+{
+    /* Update startFreq struct */
+    *lsbM = get_sbr_startfreq(samplingFreq, startFreq);
+
+    if (*lsbM == 0)
+    {
+        return(SBRDEC_ILLEGAL_SCFACTORS);
+    }
+
+    /*Update stopFreq struct */
+    if (stopFreq < 13)
+    {
+        *usb = get_sbr_stopfreq(samplingFreq, stopFreq);
+    }
+    else if (stopFreq == 13)
+    {
+        *usb = 64;
+    }
+    else if (stopFreq == 14)
+    {
+        *usb = (*lsbM) << 1;
+    }
+    else
+    {
+        *usb = 3 * *lsbM;
+    }
+
+    /* limit to Nyqvist */
+    if (*usb > 64)
+    {
+        *usb = 64;
+    }
+
+    /* test for invalid lsb, usb combinations */
+    if ((*usb - *lsbM) > 48)
+    {
+        /*
+         *  invalid SBR bitstream ?
+         */
+        return(SBRDEC_INVALID_BITSTREAM);
+    }
+
+    if ((samplingFreq == 44100) && ((*usb - *lsbM) > 35))
+    {
+        /*
+         *  invalid SBR bitstream ?
+         */
+        return(SBRDEC_INVALID_BITSTREAM);
+    }
+
+    if ((samplingFreq >= 48000) && ((*usb - *lsbM) > 32))
+    {
+        /*
+         *  invalid SBR bitstream ?
+         */
+        return(SBRDEC_INVALID_BITSTREAM);
+    }
+
+    return(SBRDEC_OK);
+
+}
+
+#endif
+
+
+
diff --git a/media/libstagefright/codecs/aacdec/sbr_find_start_andstop_band.h b/media/libstagefright/codecs/aacdec/sbr_find_start_andstop_band.h
new file mode 100644
index 0000000..88283c6
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/sbr_find_start_andstop_band.h
@@ -0,0 +1,89 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+ Filename: sbr_find_start_andstop_band.h
+ Funtions:
+    get_dse
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+
+ Who:                                   Date: MM/DD/YYYY
+ Description:
+------------------------------------------------------------------------------
+
+
+ ----------------------------------------------------------------------------
+; CONTINUE ONLY IF NOT ALREADY DEFINED
+----------------------------------------------------------------------------*/
+#ifndef SBR_FIND_START_ANDSTOP_BAND_H
+#define SBR_FIND_START_ANDSTOP_BAND_H
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+#include "pv_audio_type_defs.h"
+#include "e_sbr_error.h"
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here.
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL VARIABLES REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; SIMPLE TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; ENUMERATED TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; STRUCTURES TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+
+/*----------------------------------------------------------------------------
+; GLOBAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+
+SBR_ERROR sbr_find_start_andstop_band(const Int32 samplingFreq,
+                                      const Int32 startFreq,
+                                      const Int32 stopFreq,
+                                      Int *lsbM,
+                                      Int *usb);
+
+
+/*----------------------------------------------------------------------------
+; END
+----------------------------------------------------------------------------*/
+#endif
+
+
diff --git a/media/libstagefright/codecs/aacdec/sbr_generate_high_freq.cpp b/media/libstagefright/codecs/aacdec/sbr_generate_high_freq.cpp
new file mode 100644
index 0000000..2126e47
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/sbr_generate_high_freq.cpp
@@ -0,0 +1,1040 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Filename: sbr_generate_high_freq.c
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+
+ Who:                                   Date: MM/DD/YYYY
+ Description:
+
+------------------------------------------------------------------------------
+ INPUT AND OUTPUT DEFINITIONS
+
+
+
+------------------------------------------------------------------------------
+ FUNCTION DESCRIPTION
+
+    HF generator with built-in QMF bank inverse filtering function
+
+------------------------------------------------------------------------------
+ REQUIREMENTS
+
+
+------------------------------------------------------------------------------
+ REFERENCES
+
+SC 29 Software Copyright Licencing Disclaimer:
+
+This software module was originally developed by
+  Coding Technologies
+
+and edited by
+  -
+
+in the course of development of the ISO/IEC 13818-7 and ISO/IEC 14496-3
+standards for reference purposes and its performance may not have been
+optimized. This software module is an implementation of one or more tools as
+specified by the ISO/IEC 13818-7 and ISO/IEC 14496-3 standards.
+ISO/IEC gives users free license to this software module or modifications
+thereof for use in products claiming conformance to audiovisual and
+image-coding related ITU Recommendations and/or ISO/IEC International
+Standards. ISO/IEC gives users the same free license to this software module or
+modifications thereof for research purposes and further ISO/IEC standardisation.
+Those intending to use this software module in products are advised that its
+use may infringe existing patents. ISO/IEC have no liability for use of this
+software module or modifications thereof. Copyright is not released for
+products that do not conform to audiovisual and image-coding related ITU
+Recommendations and/or ISO/IEC International Standards.
+The original developer retains full right to modify and use the code for its
+own purpose, assign or donate the code to a third party and to inhibit third
+parties from using the code for products that do not conform to audiovisual and
+image-coding related ITU Recommendations and/or ISO/IEC International Standards.
+This copyright notice must be included in all copies or derivative works.
+Copyright (c) ISO/IEC 2002.
+
+------------------------------------------------------------------------------
+ PSEUDO-CODE
+
+------------------------------------------------------------------------------
+*/
+
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+#ifdef AAC_PLUS
+
+
+
+#include    "sbr_generate_high_freq.h"
+#include    "calc_auto_corr.h"
+#include    "sbr_inv_filt_levelemphasis.h"
+#include    "pv_div.h"
+#include    "fxp_mul32.h"
+#include    "aac_mem_funcs.h"
+#include    "sbr_constants.h"
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here. Include conditional
+; compile variables also.
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; LOCAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+    void high_freq_coeff_LC(Int32 sourceBufferReal[][32],
+    Int32 *alphar[2],
+    Int32 *degreeAlias,
+    Int32 *v_k_master,
+    Int32 *scratch_mem);
+
+
+    void high_freq_generation_LC(Int32 sourceBufferReal[][32],
+                                 Int32 *targetBufferReal,
+                                 Int32 *alphar[2],
+                                 Int32 *degreeAlias,
+                                 Int32 *invFiltBandTable,
+                                 Int32 targetStopBand,
+                                 Int32 patchDistance,
+                                 Int32 numBandsInPatch,
+                                 Int32 startSample,
+                                 Int32 slopeLength,
+                                 Int32 stopSample,
+                                 Int32 *BwVector,
+                                 Int32 sbrStartFreqOffset);
+
+
+#ifdef HQ_SBR
+
+    void high_freq_coeff(Int32 sourceBufferReal[][32],
+                         Int32 sourceBufferImag[][32],
+                         Int32 *alphar[2],
+                         Int32 *alphai[2],
+                         Int32 *v_k_master);
+
+    void high_freq_generation(Int32 sourceBufferReal[][32],
+                              Int32 sourceBufferImag[][32],
+                              Int32 *targetBufferReal,
+                              Int32 *targetBufferImag,
+                              Int32 *alphar[2],
+                              Int32 *alphai[2],
+                              Int32 *invFiltBandTable,
+                              Int32 targetStopBand,
+                              Int32 patchDistance,
+                              Int32 numBandsInPatch,
+                              Int32 startSample,
+                              Int32 slopeLength,
+                              Int32 stopSample,
+                              Int32 *BwVector,
+                              Int32 sbrStartFreqOffset);
+
+
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+
+/*----------------------------------------------------------------------------
+; LOCAL STORE/BUFFER/POINTER DEFINITIONS
+; Variable declaration - defined here and used outside this module
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL FUNCTION REFERENCES
+; Declare functions defined elsewhere and referenced in this module
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL GLOBAL STORE/BUFFER/POINTER REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; FUNCTION CODE
+----------------------------------------------------------------------------*/
+
+void sbr_generate_high_freq(Int32 sourceBufferReal[][32],
+                            Int32 sourceBufferImag[][32],
+                            Int32 *targetBufferReal,
+                            Int32 *targetBufferImag,
+                            INVF_MODE *invFiltMode,
+                            INVF_MODE *prevInvFiltMode,
+                            Int32 *invFiltBandTable,
+                            Int32 noInvFiltBands,
+                            Int32 highBandStartSb,
+                            Int32  *v_k_master,
+                            Int32 numMaster,
+                            Int32 fs,
+                            Int32   *frameInfo,
+                            Int32 *degreeAlias,
+                            Int32  scratch_mem[][64],
+                            Int32  BwVector[MAX_NUM_PATCHES],
+                            Int32  BwVectorOld[MAX_NUM_PATCHES],
+                            struct PATCH *Patch,
+                            Int32 LC_flag,
+                            Int32 *highBandStopSb)
+{
+    Int32    i;
+    Int32    patch;
+    Int32    startSample;
+    Int32    stopSample;
+    Int32    goalSb;
+    Int32    targetStopBand;
+    Int32    sourceStartBand;
+    Int32    patchDistance;
+    Int32    numBandsInPatch;
+    Int32    sbrStartFreqOffset;
+
+    Int32  *alphar[2];
+    Int32  *alphai[2];
+
+    Int32    lsb = v_k_master[0];                           /* Lowest subband related to the synthesis filterbank */
+    Int32    usb = v_k_master[numMaster];                   /* Stop subband related to the synthesis filterbank */
+    Int32  xoverOffset = highBandStartSb - v_k_master[0]; /* Calculate distance in subbands between k0 and kx */
+
+
+
+    Int    slopeLength = 0;
+
+    Int32 firstSlotOffs = frameInfo[1];
+    Int32 lastSlotOffs  = frameInfo[frameInfo[0] + 1] - 16;
+
+
+    alphar[0] = scratch_mem[0];
+    alphar[1] = scratch_mem[1];
+    alphai[0] = scratch_mem[2];
+    alphai[1] = scratch_mem[3];
+
+
+    startSample = (firstSlotOffs << 1);
+    stopSample  = (lastSlotOffs << 1) + 32;
+
+
+    sbr_inv_filt_levelemphasis(invFiltMode,
+                               prevInvFiltMode,
+                               noInvFiltBands,
+                               BwVector,
+                               BwVectorOld);
+
+
+    if (LC_flag == ON)
+    {
+        /* Set subbands to zero  */
+
+        pv_memset((void *)&targetBufferReal[startSample*SBR_NUM_BANDS],
+                  0,
+                  (stopSample - startSample)*SBR_NUM_BANDS*sizeof(targetBufferReal[0]));
+
+        high_freq_coeff_LC(sourceBufferReal,
+                           alphar,
+                           degreeAlias,
+                           v_k_master,
+                           scratch_mem[4]);
+    }
+#ifdef HQ_SBR
+    else
+    {
+        /* Set subbands to zero  */
+
+        pv_memset((void *)&targetBufferReal[startSample*SBR_NUM_BANDS],
+                  0,
+                  (stopSample - startSample)*SBR_NUM_BANDS*sizeof(targetBufferReal[0]));
+        pv_memset((void *)&targetBufferImag[startSample*SBR_NUM_BANDS],
+                  0,
+                  (stopSample - startSample)*SBR_NUM_BANDS*sizeof(targetBufferImag[0]));
+
+        high_freq_coeff(sourceBufferReal,
+                        sourceBufferImag,
+                        alphar,
+                        alphai,
+                        v_k_master);
+
+    }
+#endif     /*  #ifdef HQ_SBR */
+
+
+
+
+    /*
+     * Initialize the patching parameter
+     */
+    switch (fs)
+
+    {
+            /*
+             *  goalSb = (int)( 2.048e6f / fs + 0.5f );
+             */
+        case 48000:
+            goalSb = 43;  /* 16 kHz band */
+            break;
+        case 32000:
+            goalSb = 64;  /* 16 kHz band */
+            break;
+        case 24000:
+            goalSb = 85;  /* 16 kHz band */
+            break;
+        case 22050:
+            goalSb = 93;  /* 16 kHz band */
+            break;
+        case 16000:
+            goalSb = 128;  /* 16 kHz band */
+            break;
+        case 44100:
+        default:
+            goalSb = 46;  /* 16 kHz band */
+            break;
+    }
+
+    i = 0;
+
+    if (goalSb > v_k_master[0])
+    {
+        if (goalSb < v_k_master[numMaster])
+        {
+            while (v_k_master[i] < goalSb)
+            {
+                i++;
+            }
+        }
+        else
+        {
+            i = numMaster;
+        }
+    }
+
+    goalSb =  v_k_master[i];
+
+    /* First patch */
+    sourceStartBand = xoverOffset + 1;
+    targetStopBand = lsb + xoverOffset;
+
+    /* even (odd) numbered channel must be patched to even (odd) numbered channel */
+    patch = 0;
+
+
+    sbrStartFreqOffset = targetStopBand;
+
+    while (targetStopBand < usb)
+    {
+        Patch->targetStartBand[patch] = targetStopBand;
+
+        numBandsInPatch = goalSb - targetStopBand;                   /* get the desired range of the patch */
+
+        if (numBandsInPatch >= lsb - sourceStartBand)
+        {
+            /* desired number bands are not available -> patch whole source range */
+            patchDistance   = targetStopBand - sourceStartBand;        /* get the targetOffset */
+            patchDistance   = patchDistance & ~1;                      /* rounding off odd numbers and make all even */
+            numBandsInPatch = lsb - (targetStopBand - patchDistance);
+
+            if (targetStopBand + numBandsInPatch > v_k_master[0])
+            {
+                i = numMaster;
+                if (targetStopBand + numBandsInPatch < v_k_master[numMaster])
+                {
+                    while (v_k_master[i] > targetStopBand + numBandsInPatch)
+                    {
+                        i--;
+                    }
+                }
+            }
+            else
+            {
+                i = 0;
+            }
+            numBandsInPatch =  v_k_master[i] - targetStopBand;
+        }
+
+        /* desired number bands are available -> get the minimal even patching distance */
+        patchDistance   = numBandsInPatch + targetStopBand - lsb;  /* get minimal distance */
+        patchDistance   = (patchDistance + 1) & ~1;                /* rounding up odd numbers and make all even */
+
+        /* All patches but first */
+        sourceStartBand = 1;
+
+        /* Check if we are close to goalSb */
+        if (goalSb - (targetStopBand + numBandsInPatch) < 3)
+        { /* MPEG doc */
+            goalSb = usb;
+        }
+
+
+        if ((numBandsInPatch < 3) && (patch > 0))
+        {
+            if (LC_flag == ON)
+            {
+
+                pv_memset((void *) &degreeAlias[targetStopBand], 0, numBandsInPatch*sizeof(*degreeAlias));
+            }
+            break;
+        }
+
+        if (numBandsInPatch <= 0)
+        {
+            continue;
+        }
+
+
+        /*
+         *  High Frequency generation
+         */
+
+        if (LC_flag == ON)
+        {
+
+            high_freq_generation_LC(sourceBufferReal,
+                                    (Int32 *)targetBufferReal,
+                                    alphar,
+                                    degreeAlias,
+                                    invFiltBandTable,
+                                    targetStopBand,
+                                    patchDistance,
+                                    numBandsInPatch,
+                                    startSample,
+                                    slopeLength,
+                                    stopSample,
+                                    BwVector,
+                                    sbrStartFreqOffset);
+
+        }
+#ifdef HQ_SBR
+        else
+        {
+
+            high_freq_generation(sourceBufferReal,
+                                 sourceBufferImag,
+                                 (Int32 *)targetBufferReal,
+                                 (Int32 *)targetBufferImag,
+                                 alphar,
+                                 alphai,
+                                 invFiltBandTable,
+                                 targetStopBand,
+                                 patchDistance,
+                                 numBandsInPatch,
+                                 startSample,
+                                 slopeLength,
+                                 stopSample,
+                                 BwVector,
+                                 sbrStartFreqOffset);
+
+        }
+#endif
+
+        targetStopBand += numBandsInPatch;
+
+        patch++;
+
+    }  /* targetStopBand */
+
+    Patch->noOfPatches = patch;
+
+    pv_memmove(BwVectorOld, BwVector, noInvFiltBands*sizeof(BwVector[0]));
+
+    *highBandStopSb = goalSb;
+
+
+}
+
+
+/*----------------------------------------------------------------------------
+; FUNCTION CODE
+----------------------------------------------------------------------------*/
+
+
+void high_freq_coeff_LC(Int32 sourceBufferReal[][32],
+                        Int32 *alphar[2],
+                        Int32 *degreeAlias,
+                        Int32 *v_k_master,
+                        Int32 *scratch_mem)
+{
+
+    Int32  fac;
+    Int32 *k1;
+    struct ACORR_COEFS ac;
+    struct intg_div  quotient;
+
+    Int32 temp1;
+    Int32 temp2;
+    Int32 temp3;
+    Int32 autoCorrLength;
+    Int32 loBand;
+
+    k1 = scratch_mem;
+
+
+    autoCorrLength = 38;
+
+    for (loBand = 1; loBand < v_k_master[0]; loBand++)
+    {
+
+        calc_auto_corr_LC(&ac,
+                          sourceBufferReal,
+                          loBand,
+                          autoCorrLength);
+
+        if (ac.r11r && ac.det)
+        {
+
+            pv_div(ac.r01r, ac.r11r, &quotient);
+
+            fac = -(quotient.quotient >> 2);   /*  Q28 */
+
+            if (quotient.shift_factor > 0)
+            {
+                fac >>= quotient.shift_factor;    /* Q28 */
+            }
+            else if (quotient.shift_factor < 0)
+            {
+                if (quotient.shift_factor > -4)     /* |fac| < 8 */
+                {
+                    fac <<= (-quotient.shift_factor); /* Q28 */
+                }
+                else
+                {
+                    fac = 0x80000000;     /* overshoot possible fac = -8 */
+                }
+            }
+
+            /*
+             *  prevent for overflow of reflection coefficients
+             */
+            if (quotient.shift_factor > 0)
+            {
+                k1[loBand] = - quotient.quotient >> quotient.shift_factor;
+            }
+            else if (quotient.shift_factor == 0)
+            {
+                if (quotient.quotient >= 0x40000000)
+                {
+                    k1[loBand] = (Int32)0xC0000000;   /* -1.0 in Q30  */
+                }
+                else if (quotient.quotient <= (Int32)0xC0000000)
+                {
+                    k1[loBand] = 0x40000000;   /*  1.0 in Q30  */
+                }
+                else
+                {
+                    k1[loBand] = -quotient.quotient;
+                }
+            }
+            else
+            {
+                if (quotient.quotient > 0)
+                {
+                    k1[loBand] = (Int32)0xC0000000;   /* -1.0 in Q30  */
+                }
+                else
+                {
+                    k1[loBand] = 0x40000000;   /*  1.0 in Q30  */
+                }
+            }
+            /*
+             *   alphar[1][loBand] = ( ac.r01r * ac.r12r - ac.r02r * ac.r11r ) / ac.det;
+             */
+
+            temp1  = -fxp_mul32_Q30(ac.r02r, ac.r11r);
+            temp1  =  fxp_mac32_Q30(ac.r01r, ac.r12r, temp1);
+
+            temp2 = ac.det;
+            temp3 = temp1 > 0 ? temp1 : -temp1;
+            temp2 = temp2 > 0 ? temp2 : -temp2;
+
+            /* prevent for shootovers */
+            if ((temp3 >> 2) >= temp2 || fac == (Int32)0x80000000)
+            {
+                alphar[0][loBand] = 0;
+                alphar[1][loBand] = 0;
+            }
+            else
+            {
+                pv_div(temp1, ac.det, &quotient);
+                /*
+                 *  alphar[1][loBand] is lesser than 4.0
+                 */
+                alphar[1][loBand] = quotient.quotient;
+                quotient.shift_factor += 2;             /* Q28 */
+
+                if (quotient.shift_factor > 0)
+                {
+                    alphar[1][loBand] >>= quotient.shift_factor;    /* Q28 */
+                }
+                else if (quotient.shift_factor < 0)     /* at this point can only be -1 */
+                {
+                    alphar[1][loBand] <<= (-quotient.shift_factor); /* Q28 */
+                }
+
+                /*
+                 *  alphar[0][loBand] = - ( ac.r01r + alphar[1][loBand] * ac.r12r ) / ac.r11r;
+                 */
+
+                pv_div(ac.r12r, ac.r11r, &quotient);
+
+                temp3 = (quotient.quotient >> 2);       /*  Q28 */
+
+                if (quotient.shift_factor > 0)
+                {
+                    temp3 >>= quotient.shift_factor;    /* Q28 */
+                }
+                else if (quotient.shift_factor < 0)
+                {
+                    temp3 <<= (-quotient.shift_factor); /* Q28 */
+                }
+
+                alphar[0][loBand] = fac - fxp_mul32_Q28(alphar[1][loBand], temp3) ;    /* Q28 */
+
+                if ((alphar[0][loBand] >= 0x40000000) || (alphar[0][loBand] <= (Int32)0xC0000000))
+                {
+                    alphar[0][loBand] = 0;
+                    alphar[1][loBand] = 0;
+                }
+
+            }
+
+        }
+        else
+        {
+            alphar[0][loBand] = 0;
+            alphar[1][loBand] = 0;
+
+            k1[loBand] = 0;
+        }
+
+    }
+
+    k1[0] = 0;
+    degreeAlias[1] = 0;
+    for (loBand = 2; loBand < v_k_master[0]; loBand++)
+    {
+        degreeAlias[loBand] = 0;
+        if ((!(loBand & 1)) && (k1[loBand] < 0))
+        {
+            if (k1[loBand-1] < 0)
+            { // 2-CH Aliasing Detection
+                degreeAlias[loBand]   = 0x40000000;
+                if (k1[loBand-2] > 0)
+                { // 3-CH Aliasing Detection
+                    degreeAlias[loBand-1] = 0x40000000 - fxp_mul32_Q30(k1[loBand-1], k1[loBand-1]);
+
+                }
+            }
+            else if (k1[loBand-2] > 0)
+            { // 3-CH Aliasing Detection
+                degreeAlias[loBand] = 0x40000000 - fxp_mul32_Q30(k1[loBand-1], k1[loBand-1]);
+            }
+        }
+        if ((loBand & 1) && (k1[loBand] > 0))
+        {
+            if (k1[loBand-1] > 0)
+            { // 2-CH Aliasing Detection
+                degreeAlias[loBand]   = 0x40000000;
+                if (k1[loBand-2] < 0)
+                { // 3-CH Aliasing Detection
+                    degreeAlias[loBand-1] = 0x40000000 - fxp_mul32_Q30(k1[loBand-1], k1[loBand-1]);
+                }
+            }
+            else if (k1[loBand-2] < 0)
+            { // 3-CH Aliasing Detection
+                degreeAlias[loBand] = 0x40000000 - fxp_mul32_Q30(k1[loBand-1], k1[loBand-1]);
+            }
+        }
+    }
+
+}
+
+
+/*----------------------------------------------------------------------------
+; FUNCTION CODE
+----------------------------------------------------------------------------*/
+
+void high_freq_generation_LC(Int32 sourceBufferReal[][32],
+                             Int32 *targetBufferReal,
+                             Int32 *alphar[2],
+                             Int32 *degreeAlias,
+                             Int32 *invFiltBandTable,
+                             Int32 targetStopBand,
+                             Int32 patchDistance,
+                             Int32 numBandsInPatch,
+                             Int32 startSample,
+                             Int32 slopeLength,
+                             Int32 stopSample,
+                             Int32 *BwVector,
+                             Int32 sbrStartFreqOffset)
+{
+
+    Int32  temp1;
+    Int32  temp2;
+    Int32  temp3;
+
+
+    Int32  a0r;
+    Int32  a1r;
+    Int32  i;
+    Int32  bw;
+    Int32  hiBand;
+    Int32  bwIndex;
+    Int32  loBand;
+    Int32  j;
+
+    bwIndex = 0;
+
+    for (hiBand = targetStopBand; hiBand < targetStopBand + numBandsInPatch; hiBand++)
+    {
+        loBand = hiBand - patchDistance;
+
+        if (hiBand != targetStopBand)
+        {
+            degreeAlias[hiBand] = degreeAlias[loBand];
+        }
+        else
+        {
+            degreeAlias[hiBand] = 0;
+        }
+
+        while (hiBand >= invFiltBandTable[bwIndex])
+        {
+            bwIndex++;
+        }
+
+        bw = BwVector[bwIndex];
+
+        /*
+         *  Inverse Filtering
+         */
+
+
+        j = hiBand - sbrStartFreqOffset;
+
+        if (bw > 0 && (alphar[0][loBand] | alphar[1][loBand]))
+        {
+            /* Apply current bandwidth expansion factor */
+            a0r = fxp_mul32_Q29(bw, alphar[0][loBand]);
+
+            bw  = fxp_mul32_Q31(bw, bw) << 2;
+
+            a1r = fxp_mul32_Q28(bw, alphar[1][loBand]);
+
+            i = startSample + slopeLength;
+
+            temp1 = sourceBufferReal[i    ][loBand];
+            temp2 = sourceBufferReal[i - 1][loBand];
+            temp3 = sourceBufferReal[i - 2][loBand];
+
+            for (; i < stopSample + slopeLength - 1; i++)
+            {
+
+
+                targetBufferReal[i*SBR_NUM_BANDS + j] = temp1 + fxp_mul32_Q28(a0r, temp2)  +
+                                                        fxp_mul32_Q28(a1r, temp3);
+
+
+                temp3 = temp2;
+                temp2 = temp1;
+                temp1 = sourceBufferReal[i + 1][loBand];
+            }
+            targetBufferReal[i*SBR_NUM_BANDS + j] = temp1 + fxp_mul32_Q28(a0r, temp2)  +
+                                                    fxp_mul32_Q28(a1r, temp3);
+
+        }
+        else
+        {
+
+            for (i = startSample + slopeLength; i < stopSample + slopeLength; i++)
+            {
+                targetBufferReal[i*SBR_NUM_BANDS + j] = sourceBufferReal[i][loBand];
+            }
+        }
+
+
+    }  /* hiBand */
+
+}
+
+
+#ifdef HQ_SBR
+
+/*----------------------------------------------------------------------------
+; FUNCTION CODE
+----------------------------------------------------------------------------*/
+
+void high_freq_coeff(Int32 sourceBufferReal[][32],
+                     Int32 sourceBufferImag[][32],
+                     Int32 *alphar[2],
+                     Int32 *alphai[2],
+                     Int32 *v_k_master)
+{
+
+    Int32  overflow_flag;
+
+    Int32  temp1r;
+    Int32  temp1i;
+    Int32  temp0r;
+    Int32  temp0i;
+    Int32  loBand;
+
+    struct ACORR_COEFS ac;
+    struct intg_div  quotient;
+
+    Int32 autoCorrLength;
+
+    autoCorrLength = 38;
+
+    for (loBand = 1; loBand < v_k_master[0]; loBand++)
+    {
+
+        calc_auto_corr(&ac,
+                       sourceBufferReal,
+                       sourceBufferImag,
+                       loBand,
+                       autoCorrLength);
+
+
+        overflow_flag = 0;
+
+        if (ac.det < 1)
+        {
+            /* ---  */
+            temp1r = 0;
+            temp1i = 0;
+            alphar[1][loBand] = 0;
+            alphai[1][loBand] = 0;
+
+        }
+        else
+        {
+
+            temp1r =  fxp_mul32_Q29(ac.r01r, ac.r12r);
+            temp1r =  fxp_msu32_Q29(ac.r01i, ac.r12i, temp1r);
+            temp1r =  fxp_msu32_Q29(ac.r02r, ac.r11r, temp1r);
+
+            temp1i =  fxp_mul32_Q29(ac.r01r, ac.r12i);
+            temp1i =  fxp_msu32_Q29(ac.r02i, ac.r11r, temp1i);
+            temp1i =  fxp_mac32_Q29(ac.r01i, ac.r12r, temp1i);
+
+            pv_div(temp1r, ac.det, &quotient);
+            overflow_flag = (quotient.shift_factor < -2) ? 1 : 0;
+            temp1r = quotient.quotient >> (2 + quotient.shift_factor);   /*  Q28 */
+            pv_div(temp1i, ac.det, &quotient);
+            overflow_flag = (quotient.shift_factor < -2) ? 1 : 0;
+            temp1i = quotient.quotient >> (2 + quotient.shift_factor);   /*  Q28 */
+
+            alphar[1][loBand] = temp1r;
+            alphai[1][loBand] = temp1i;
+
+        }
+
+        if (ac.r11r == 0)
+        {
+            temp0r = 0;
+            temp0i = 0;
+            alphar[0][loBand] = 0;
+            alphai[0][loBand] = 0;
+
+        }
+        else
+        {
+            temp0r = - (ac.r01r + fxp_mul32_Q28(temp1r, ac.r12r) + fxp_mul32_Q28(temp1i, ac.r12i));
+            temp0i = - (ac.r01i + fxp_mul32_Q28(temp1i, ac.r12r) - fxp_mul32_Q28(temp1r, ac.r12i));
+
+            pv_div(temp0r, ac.r11r, &quotient);
+            overflow_flag = (quotient.shift_factor < -2) ? 1 : 0;
+            temp0r = quotient.quotient >> (2 + quotient.shift_factor);   /*  Q28 */
+            pv_div(temp0i, ac.r11r, &quotient);
+            overflow_flag = (quotient.shift_factor < -2) ? 1 : 0;
+            temp0i = quotient.quotient >> (2 + quotient.shift_factor);   /*  Q28 */
+
+            alphar[0][loBand] = temp0r;
+            alphai[0][loBand] = temp0i;
+
+        }
+
+        /* prevent for shootovers */
+
+        if (fxp_mul32_Q28((temp0r >> 2), (temp0r >> 2)) + fxp_mul32_Q28((temp0i >> 2), (temp0i >> 2)) >= 0x10000000 ||
+                fxp_mul32_Q28((temp1r >> 2), (temp1r >> 2)) + fxp_mul32_Q28((temp1i >> 2), (temp1i >> 2)) >= 0x10000000 ||
+                overflow_flag)     /*  0x10000000 == 1 in Q28 */
+
+        {
+            alphar[0][loBand] = 0;
+            alphar[1][loBand] = 0;
+            alphai[0][loBand] = 0;
+            alphai[1][loBand] = 0;
+
+        }
+    }
+}
+
+/*----------------------------------------------------------------------------
+; FUNCTION CODE
+----------------------------------------------------------------------------*/
+
+
+
+void high_freq_generation(Int32 sourceBufferReal[][32],
+                          Int32 sourceBufferImag[][32],
+                          Int32 *targetBufferReal,
+                          Int32 *targetBufferImag,
+                          Int32 *alphar[2],
+                          Int32 *alphai[2],
+                          Int32 *invFiltBandTable,
+                          Int32 targetStopBand,
+                          Int32 patchDistance,
+                          Int32 numBandsInPatch,
+                          Int32 startSample,
+                          Int32 slopeLength,
+                          Int32 stopSample,
+                          Int32 *BwVector,
+                          Int32 sbrStartFreqOffset)
+{
+    Int32  temp1_r;
+    Int32  temp2_r;
+    Int32  temp3_r;
+    Int32  temp1_i;
+    Int32  temp2_i;
+    Int32  temp3_i;
+
+
+    Int32  a0i;
+    Int32  a1i;
+    Int32  a0r;
+    Int32  a1r;
+    Int32  i;
+    Int32  bw;
+    Int32  hiBand;
+    Int32  bwIndex;
+    Int32  loBand;
+    Int32  j;
+
+
+
+    int64_t tmp;
+
+    bwIndex = 0;
+
+    for (hiBand = targetStopBand; hiBand < targetStopBand + numBandsInPatch; hiBand++)
+    {
+
+        loBand = hiBand - patchDistance;
+
+        while (hiBand >= invFiltBandTable[bwIndex])
+        {
+            bwIndex++;
+        }
+
+        bw = BwVector[bwIndex];
+
+        /*
+         *  Inverse Filtering
+         */
+
+
+        j = hiBand - sbrStartFreqOffset;
+
+        if (bw >= 0 && (alphar[0][loBand] | alphar[1][loBand] |
+                        alphai[0][loBand] | alphai[1][loBand]))
+        {
+            /* Apply current bandwidth expansion factor */
+            a0r = fxp_mul32_Q29(bw, alphar[0][loBand]);
+            a0i = fxp_mul32_Q29(bw, alphai[0][loBand]);
+
+
+            bw  = fxp_mul32_Q30(bw, bw);
+
+
+            a1r = fxp_mul32_Q28(bw, alphar[1][loBand]);
+            a1i = fxp_mul32_Q28(bw, alphai[1][loBand]);
+
+
+            i  = startSample + slopeLength;
+            j += i * SBR_NUM_BANDS;
+
+            temp1_r = sourceBufferReal[i    ][loBand];
+            temp2_r = sourceBufferReal[i - 1][loBand];
+            temp3_r = sourceBufferReal[i - 2][loBand];
+
+            temp1_i = sourceBufferImag[i    ][loBand];
+            temp2_i = sourceBufferImag[i - 1][loBand];
+            temp3_i = sourceBufferImag[i - 2][loBand];
+
+            while (i < stopSample + slopeLength)
+            {
+                tmp =  fxp_mac64_Q31(((int64_t)temp1_r << 28),  a0r, temp2_r);
+                tmp =  fxp_mac64_Q31(tmp, -a0i, temp2_i);
+                tmp =  fxp_mac64_Q31(tmp,  a1r, temp3_r);
+                targetBufferReal[j] = (Int32)(fxp_mac64_Q31(tmp, -a1i, temp3_i) >> 28);
+
+                tmp =  fxp_mac64_Q31(((int64_t)temp1_i << 28),  a0i, temp2_r);
+                tmp =  fxp_mac64_Q31(tmp,  a0r, temp2_i);
+                tmp =  fxp_mac64_Q31(tmp,  a1i, temp3_r);
+                targetBufferImag[j] = (Int32)(fxp_mac64_Q31(tmp,  a1r, temp3_i) >> 28);
+
+                i++;
+                j += SBR_NUM_BANDS;
+
+                temp3_r  = temp2_r;
+                temp2_r  = temp1_r;
+                temp1_r  = sourceBufferReal[i ][loBand];
+
+                temp3_i  = temp2_i;
+                temp2_i  = temp1_i;
+                temp1_i  = sourceBufferImag[i ][loBand];
+
+            }
+
+        }
+
+
+
+        else
+        {
+            i = startSample + slopeLength;
+            j += i * SBR_NUM_BANDS;
+
+            for (; i < stopSample + slopeLength; i++)
+            {
+                targetBufferReal[j] = sourceBufferReal[i][loBand];
+                targetBufferImag[j] = sourceBufferImag[i][loBand];
+                j += SBR_NUM_BANDS;
+            }
+        }
+    }
+}
+
+#endif
+
+
+#endif
diff --git a/media/libstagefright/codecs/aacdec/sbr_generate_high_freq.h b/media/libstagefright/codecs/aacdec/sbr_generate_high_freq.h
new file mode 100644
index 0000000..0e9c928
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/sbr_generate_high_freq.h
@@ -0,0 +1,144 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Filename: sbr_generate_high_freq.h
+ Funtions:
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+
+ Who:                                   Date: MM/DD/YYYY
+ Description:
+------------------------------------------------------------------------------
+SC 29 Software Copyright Licencing Disclaimer:
+
+This software module was originally developed by
+  Coding Technologies
+
+and edited by
+  -
+
+in the course of development of the ISO/IEC 13818-7 and ISO/IEC 14496-3
+standards for reference purposes and its performance may not have been
+optimized. This software module is an implementation of one or more tools as
+specified by the ISO/IEC 13818-7 and ISO/IEC 14496-3 standards.
+ISO/IEC gives users free license to this software module or modifications
+thereof for use in products claiming conformance to audiovisual and
+image-coding related ITU Recommendations and/or ISO/IEC International
+Standards. ISO/IEC gives users the same free license to this software module or
+modifications thereof for research purposes and further ISO/IEC standardisation.
+Those intending to use this software module in products are advised that its
+use may infringe existing patents. ISO/IEC have no liability for use of this
+software module or modifications thereof. Copyright is not released for
+products that do not conform to audiovisual and image-coding related ITU
+Recommendations and/or ISO/IEC International Standards.
+The original developer retains full right to modify and use the code for its
+own purpose, assign or donate the code to a third party and to inhibit third
+parties from using the code for products that do not conform to audiovisual and
+image-coding related ITU Recommendations and/or ISO/IEC International Standards.
+This copyright notice must be included in all copies or derivative works.
+Copyright (c) ISO/IEC 2002.
+
+ $Id: ct_envcalc.h,v 1.3 2002/11/29 16:11:49 kaehleof Exp $
+*/
+
+/*----------------------------------------------------------------------------
+; CONTINUE ONLY IF NOT ALREADY DEFINED
+----------------------------------------------------------------------------*/
+#ifndef SBR_GENERATE_HIGH_FREQ_H
+#define SBR_GENERATE_HIGH_FREQ_H
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+
+#include    "e_invf_mode.h"
+#include    "s_patch.h"
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+    /*----------------------------------------------------------------------------
+    ; DEFINES
+    ; Include all pre-processor statements here.
+    ----------------------------------------------------------------------------*/
+
+    /*----------------------------------------------------------------------------
+    ; EXTERNAL VARIABLES REFERENCES
+    ; Declare variables used in this module but defined elsewhere
+    ----------------------------------------------------------------------------*/
+
+    /*----------------------------------------------------------------------------
+    ; SIMPLE TYPEDEF'S
+    ----------------------------------------------------------------------------*/
+
+    /*----------------------------------------------------------------------------
+    ; ENUMERATED TYPEDEF'S
+    ----------------------------------------------------------------------------*/
+
+    /*----------------------------------------------------------------------------
+    ; STRUCTURES TYPEDEF'S
+    ----------------------------------------------------------------------------*/
+
+    /*----------------------------------------------------------------------------
+    ; GLOBAL FUNCTION DEFINITIONS
+    ; Function Prototype declaration
+    ----------------------------------------------------------------------------*/
+
+
+
+
+    void sbr_generate_high_freq(
+        Int32 sourceBufferReal[][32],
+        Int32 sourceBufferImag[][32],
+        Int32 *targetBufferReal,
+        Int32 *targetBufferImag,
+        INVF_MODE *invFiltMode,
+        INVF_MODE *prevInvFiltMode,
+        Int32 *invFiltBandTable,
+        Int32 noInvFiltBands,
+        Int32 highBandStartSb,
+        Int32 *v_k_master,
+        Int32 numMaster,
+        Int32 fs,
+        Int32 *frameInfo,
+        Int32 *degreeAlias,
+        Int32 scratch_mem[][64],
+        Int32 BwVector[MAX_NUM_PATCHES],
+        Int32 BwVectorOld[MAX_NUM_PATCHES],
+        struct PATCH * Patch,
+        Int32 LC_flag,
+        Int32 *highBandStopSb);
+
+#ifdef __cplusplus
+}
+#endif
+
+/*----------------------------------------------------------------------------
+; END
+----------------------------------------------------------------------------*/
+#endif
+
+
diff --git a/media/libstagefright/codecs/aacdec/sbr_get_additional_data.cpp b/media/libstagefright/codecs/aacdec/sbr_get_additional_data.cpp
new file mode 100644
index 0000000..60072dd
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/sbr_get_additional_data.cpp
@@ -0,0 +1,145 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Filename: sbr_get_additional_data.c
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+
+ Who:                                   Date: MM/DD/YYYY
+ Description:
+
+------------------------------------------------------------------------------
+ INPUT AND OUTPUT DEFINITIONS
+
+
+
+------------------------------------------------------------------------------
+ FUNCTION DESCRIPTION
+
+
+------------------------------------------------------------------------------
+ REQUIREMENTS
+
+
+------------------------------------------------------------------------------
+ REFERENCES
+
+SC 29 Software Copyright Licencing Disclaimer:
+
+This software module was originally developed by
+  Coding Technologies
+
+and edited by
+  -
+
+in the course of development of the ISO/IEC 13818-7 and ISO/IEC 14496-3
+standards for reference purposes and its performance may not have been
+optimized. This software module is an implementation of one or more tools as
+specified by the ISO/IEC 13818-7 and ISO/IEC 14496-3 standards.
+ISO/IEC gives users free license to this software module or modifications
+thereof for use in products claiming conformance to audiovisual and
+image-coding related ITU Recommendations and/or ISO/IEC International
+Standards. ISO/IEC gives users the same free license to this software module or
+modifications thereof for research purposes and further ISO/IEC standardisation.
+Those intending to use this software module in products are advised that its
+use may infringe existing patents. ISO/IEC have no liability for use of this
+software module or modifications thereof. Copyright is not released for
+products that do not conform to audiovisual and image-coding related ITU
+Recommendations and/or ISO/IEC International Standards.
+The original developer retains full right to modify and use the code for its
+own purpose, assign or donate the code to a third party and to inhibit third
+parties from using the code for products that do not conform to audiovisual and
+image-coding related ITU Recommendations and/or ISO/IEC International Standards.
+This copyright notice must be included in all copies or derivative works.
+Copyright (c) ISO/IEC 2002.
+
+------------------------------------------------------------------------------
+ PSEUDO-CODE
+
+------------------------------------------------------------------------------
+*/
+
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+
+#ifdef AAC_PLUS
+
+
+#include    "sbr_get_additional_data.h"
+#include    "buf_getbits.h"
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here. Include conditional
+; compile variables also.
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; LOCAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; LOCAL STORE/BUFFER/POINTER DEFINITIONS
+; Variable declaration - defined here and used outside this module
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL FUNCTION REFERENCES
+; Declare functions defined elsewhere and referenced in this module
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL GLOBAL STORE/BUFFER/POINTER REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; FUNCTION CODE
+----------------------------------------------------------------------------*/
+
+void sbr_get_additional_data(SBR_FRAME_DATA * hFrameData,
+                             BIT_BUFFER     * hBitBuf)
+{
+    Int32 i;
+
+    Int32 flag = buf_getbits(hBitBuf, 1);
+
+    if (flag)
+    {
+        for (i = 0; i < hFrameData->nSfb[HI]; i++)
+        {
+            hFrameData->addHarmonics[i] = buf_getbits(hBitBuf, 1);
+        }
+    }
+}
+
+#endif
+
+
diff --git a/media/libstagefright/codecs/aacdec/sbr_get_additional_data.h b/media/libstagefright/codecs/aacdec/sbr_get_additional_data.h
new file mode 100644
index 0000000..51285c5
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/sbr_get_additional_data.h
@@ -0,0 +1,87 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Filename: sbr_get_additional_data.h
+ Funtions:
+
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+
+ Who:                                   Date: MM/DD/YYYY
+ Description:
+------------------------------------------------------------------------------
+
+
+----------------------------------------------------------------------------
+; CONTINUE ONLY IF NOT ALREADY DEFINED
+----------------------------------------------------------------------------*/
+#ifndef SBR_GET_ADDITIONAL_DATA_H
+#define SBR_GET_ADDITIONAL_DATA_H
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+#include "pv_audio_type_defs.h"
+#include    "s_bit_buffer.h"
+#include    "s_sbr_header_data.h"
+#include    "s_sbr_frame_data.h"
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here.
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL VARIABLES REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; SIMPLE TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; ENUMERATED TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; STRUCTURES TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; GLOBAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+
+void sbr_get_additional_data(SBR_FRAME_DATA * hFrameData,
+                             BIT_BUFFER     * hBitBuf);
+
+/*----------------------------------------------------------------------------
+; END
+----------------------------------------------------------------------------*/
+#endif
+
+
diff --git a/media/libstagefright/codecs/aacdec/sbr_get_cpe.cpp b/media/libstagefright/codecs/aacdec/sbr_get_cpe.cpp
new file mode 100644
index 0000000..657d032
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/sbr_get_cpe.cpp
@@ -0,0 +1,266 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Filename: sbr_get_cpe.c
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+
+ Who:                                   Date: MM/DD/YYYY
+ Description:
+
+------------------------------------------------------------------------------
+ INPUT AND OUTPUT DEFINITIONS
+
+ Arguments:     hFrameDataLeft  - handle to struct SBR_FRAME_DATA for first channel
+                hFrameDataRight - handle to struct SBR_FRAME_DATA for first channel
+                hBitBuf         - handle to struct BIT_BUF
+
+ Return:        SbrFrameOK
+
+
+------------------------------------------------------------------------------
+ FUNCTION DESCRIPTION
+
+
+------------------------------------------------------------------------------
+ REQUIREMENTS
+
+
+------------------------------------------------------------------------------
+ REFERENCES
+
+SC 29 Software Copyright Licencing Disclaimer:
+
+This software module was originally developed by
+  Coding Technologies
+
+and edited by
+  -
+
+in the course of development of the ISO/IEC 13818-7 and ISO/IEC 14496-3
+standards for reference purposes and its performance may not have been
+optimized. This software module is an implementation of one or more tools as
+specified by the ISO/IEC 13818-7 and ISO/IEC 14496-3 standards.
+ISO/IEC gives users free license to this software module or modifications
+thereof for use in products claiming conformance to audiovisual and
+image-coding related ITU Recommendations and/or ISO/IEC International
+Standards. ISO/IEC gives users the same free license to this software module or
+modifications thereof for research purposes and further ISO/IEC standardisation.
+Those intending to use this software module in products are advised that its
+use may infringe existing patents. ISO/IEC have no liability for use of this
+software module or modifications thereof. Copyright is not released for
+products that do not conform to audiovisual and image-coding related ITU
+Recommendations and/or ISO/IEC International Standards.
+The original developer retains full right to modify and use the code for its
+own purpose, assign or donate the code to a third party and to inhibit third
+parties from using the code for products that do not conform to audiovisual and
+image-coding related ITU Recommendations and/or ISO/IEC International Standards.
+This copyright notice must be included in all copies or derivative works.
+Copyright (c) ISO/IEC 2002.
+
+------------------------------------------------------------------------------
+ PSEUDO-CODE
+
+------------------------------------------------------------------------------
+*/
+
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+
+#ifdef AAC_PLUS
+
+
+#include    "sbr_get_cpe.h"
+#include    "buf_getbits.h"
+#include    "extractframeinfo.h"
+#include    "sbr_get_dir_control_data.h"
+#include    "sbr_get_envelope.h"
+#include    "sbr_get_noise_floor_data.h"
+#include    "sbr_get_additional_data.h"
+#include    "sbr_extract_extended_data.h"
+#include    "aac_mem_funcs.h"
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here. Include conditional
+; compile variables also.
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; LOCAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; LOCAL STORE/BUFFER/POINTER DEFINITIONS
+; Variable declaration - defined here and used outside this module
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL FUNCTION REFERENCES
+; Declare functions defined elsewhere and referenced in this module
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL GLOBAL STORE/BUFFER/POINTER REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; FUNCTION CODE
+----------------------------------------------------------------------------*/
+
+
+SBR_ERROR sbr_get_cpe(SBR_FRAME_DATA * hFrameDataLeft,
+                      SBR_FRAME_DATA * hFrameDataRight,
+                      BIT_BUFFER  * hBitBuf)
+{
+    Int32 i;
+    Int32 bits;
+    SBR_ERROR err =  SBRDEC_OK;
+
+    /* reserved bits */
+    bits = buf_getbits(hBitBuf, SI_SBR_RESERVED_PRESENT);
+
+    if (bits)
+    {
+        buf_getbits(hBitBuf, SI_SBR_RESERVED_BITS_DATA);
+        buf_getbits(hBitBuf, SI_SBR_RESERVED_BITS_DATA);
+    }
+
+    /* Read coupling flag */
+    bits = buf_getbits(hBitBuf, SI_SBR_COUPLING_BITS);
+
+    if (bits)
+    {
+        hFrameDataLeft->coupling = COUPLING_LEVEL;
+        hFrameDataRight->coupling = COUPLING_BAL;
+    }
+    else
+    {
+        hFrameDataLeft->coupling = COUPLING_OFF;
+        hFrameDataRight->coupling = COUPLING_OFF;
+    }
+
+
+    err = extractFrameInfo(hBitBuf, hFrameDataLeft);
+
+    if (err != SBRDEC_OK)
+    {
+        return err;
+    }
+
+    if (hFrameDataLeft->coupling)
+    {
+
+        pv_memcpy(hFrameDataRight->frameInfo,
+                  hFrameDataLeft->frameInfo,
+                  LENGTH_FRAME_INFO * sizeof(Int32));
+
+        hFrameDataRight->nNoiseFloorEnvelopes = hFrameDataLeft->nNoiseFloorEnvelopes;
+        hFrameDataRight->frameClass = hFrameDataLeft->frameClass;
+
+
+        sbr_get_dir_control_data(hFrameDataLeft, hBitBuf);
+        sbr_get_dir_control_data(hFrameDataRight, hBitBuf);
+
+        for (i = 0; i < hFrameDataLeft->nNfb; i++)
+        {
+            hFrameDataLeft->sbr_invf_mode_prev[i]  = hFrameDataLeft->sbr_invf_mode[i];
+            hFrameDataRight->sbr_invf_mode_prev[i] = hFrameDataRight->sbr_invf_mode[i];
+
+            hFrameDataLeft->sbr_invf_mode[i]  = (INVF_MODE) buf_getbits(hBitBuf, SI_SBR_INVF_MODE_BITS);
+            hFrameDataRight->sbr_invf_mode[i] = hFrameDataLeft->sbr_invf_mode[i];
+        }
+
+        sbr_get_envelope(hFrameDataLeft, hBitBuf);
+        sbr_get_noise_floor_data(hFrameDataLeft, hBitBuf);
+        sbr_get_envelope(hFrameDataRight, hBitBuf);
+
+    }
+    else
+    {
+        err = extractFrameInfo(hBitBuf, hFrameDataRight);
+
+        if (err != SBRDEC_OK)
+        {
+            return err;
+        }
+
+
+        sbr_get_dir_control_data(hFrameDataLeft,  hBitBuf);
+        sbr_get_dir_control_data(hFrameDataRight, hBitBuf);
+
+        for (i = 0; i <  hFrameDataLeft->nNfb; i++)
+        {
+            hFrameDataLeft->sbr_invf_mode_prev[i]  = hFrameDataLeft->sbr_invf_mode[i];
+            hFrameDataLeft->sbr_invf_mode[i]  =
+                (INVF_MODE) buf_getbits(hBitBuf, SI_SBR_INVF_MODE_BITS);
+        }
+
+        for (i = 0; i <  hFrameDataRight->nNfb; i++)
+        {
+            hFrameDataRight->sbr_invf_mode_prev[i] = hFrameDataRight->sbr_invf_mode[i];
+
+            hFrameDataRight->sbr_invf_mode[i] =
+                (INVF_MODE) buf_getbits(hBitBuf, SI_SBR_INVF_MODE_BITS);
+        }
+        sbr_get_envelope(hFrameDataLeft,  hBitBuf);
+        sbr_get_envelope(hFrameDataRight, hBitBuf);
+
+        sbr_get_noise_floor_data(hFrameDataLeft,  hBitBuf);
+
+    }
+
+    sbr_get_noise_floor_data(hFrameDataRight, hBitBuf);
+
+    pv_memset((void *)hFrameDataLeft->addHarmonics,
+              0,
+              hFrameDataLeft->nSfb[HI]*sizeof(Int32));
+
+    pv_memset((void *)hFrameDataRight->addHarmonics,
+              0,
+              hFrameDataRight->nSfb[HI]*sizeof(Int32));
+
+    sbr_get_additional_data(hFrameDataLeft, hBitBuf);
+    sbr_get_additional_data(hFrameDataRight, hBitBuf);
+
+    sbr_extract_extended_data(hBitBuf
+#ifdef PARAMETRICSTEREO
+                              , NULL
+#endif
+                             );
+
+    return SBRDEC_OK;
+
+}
+
+#endif
+
+
diff --git a/media/libstagefright/codecs/aacdec/sbr_get_cpe.h b/media/libstagefright/codecs/aacdec/sbr_get_cpe.h
new file mode 100644
index 0000000..b6f99f8
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/sbr_get_cpe.h
@@ -0,0 +1,88 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Filename: sbr_get_cpe.h
+
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+
+ Who:                                   Date: MM/DD/YYYY
+ Description:
+------------------------------------------------------------------------------
+
+
+----------------------------------------------------------------------------
+; CONTINUE ONLY IF NOT ALREADY DEFINED
+----------------------------------------------------------------------------*/
+#ifndef SBR_GET_CPE_H
+#define SBR_GET_CPE_H
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+#include    "pv_audio_type_defs.h"
+#include    "s_bit_buffer.h"
+#include    "s_sbr_frame_data.h"
+#include    "e_sbr_error.h"
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here.
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL VARIABLES REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; SIMPLE TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; ENUMERATED TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; STRUCTURES TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; GLOBAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+
+SBR_ERROR sbr_get_cpe(SBR_FRAME_DATA * hFrameDataLeft,
+                      SBR_FRAME_DATA * hFrameDataRight,
+                      BIT_BUFFER * hBitBuf);
+
+
+/*----------------------------------------------------------------------------
+; END
+----------------------------------------------------------------------------*/
+#endif
+
+
diff --git a/media/libstagefright/codecs/aacdec/sbr_get_dir_control_data.cpp b/media/libstagefright/codecs/aacdec/sbr_get_dir_control_data.cpp
new file mode 100644
index 0000000..3d7ad8c
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/sbr_get_dir_control_data.cpp
@@ -0,0 +1,153 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Filename: sbr_get_dir_control_data.c
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+
+ Who:                                   Date: MM/DD/YYYY
+ Description:
+
+------------------------------------------------------------------------------
+ INPUT AND OUTPUT DEFINITIONS
+
+ Arguments:     h_frame_data - handle to struct SBR_FRAME_DATA
+                hBitBuf      - handle to struct BIT_BUF
+
+ Return:        void
+
+
+------------------------------------------------------------------------------
+ FUNCTION DESCRIPTION
+
+  Reads direction control data from bitstream
+
+------------------------------------------------------------------------------
+ REQUIREMENTS
+
+
+------------------------------------------------------------------------------
+ REFERENCES
+
+SC 29 Software Copyright Licencing Disclaimer:
+
+This software module was originally developed by
+  Coding Technologies
+
+and edited by
+  -
+
+in the course of development of the ISO/IEC 13818-7 and ISO/IEC 14496-3
+standards for reference purposes and its performance may not have been
+optimized. This software module is an implementation of one or more tools as
+specified by the ISO/IEC 13818-7 and ISO/IEC 14496-3 standards.
+ISO/IEC gives users free license to this software module or modifications
+thereof for use in products claiming conformance to audiovisual and
+image-coding related ITU Recommendations and/or ISO/IEC International
+Standards. ISO/IEC gives users the same free license to this software module or
+modifications thereof for research purposes and further ISO/IEC standardisation.
+Those intending to use this software module in products are advised that its
+use may infringe existing patents. ISO/IEC have no liability for use of this
+software module or modifications thereof. Copyright is not released for
+products that do not conform to audiovisual and image-coding related ITU
+Recommendations and/or ISO/IEC International Standards.
+The original developer retains full right to modify and use the code for its
+own purpose, assign or donate the code to a third party and to inhibit third
+parties from using the code for products that do not conform to audiovisual and
+image-coding related ITU Recommendations and/or ISO/IEC International Standards.
+This copyright notice must be included in all copies or derivative works.
+Copyright (c) ISO/IEC 2002.
+
+------------------------------------------------------------------------------
+ PSEUDO-CODE
+
+------------------------------------------------------------------------------
+*/
+
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+
+#ifdef AAC_PLUS
+
+
+#include    "sbr_get_dir_control_data.h"
+#include    "buf_getbits.h"
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here. Include conditional
+; compile variables also.
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; LOCAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; LOCAL STORE/BUFFER/POINTER DEFINITIONS
+; Variable declaration - defined here and used outside this module
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL FUNCTION REFERENCES
+; Declare functions defined elsewhere and referenced in this module
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL GLOBAL STORE/BUFFER/POINTER REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; FUNCTION CODE
+----------------------------------------------------------------------------*/
+
+void sbr_get_dir_control_data(SBR_FRAME_DATA * h_frame_data,
+                              BIT_BUFFER     * hBitBuf)
+{
+    Int32 i;
+
+    h_frame_data->nNoiseFloorEnvelopes = h_frame_data->frameInfo[0] > 1 ? 2 : 1;
+
+
+    for (i = 0; i < h_frame_data->frameInfo[0]; i++)
+    {
+        h_frame_data->domain_vec1[i] = buf_getbits(hBitBuf, SI_SBR_DOMAIN_BITS);
+    }
+
+    for (i = 0; i < h_frame_data->nNoiseFloorEnvelopes; i++)
+    {
+        h_frame_data->domain_vec2[i] = buf_getbits(hBitBuf, SI_SBR_DOMAIN_BITS);
+    }
+}
+
+#endif
+
+
diff --git a/media/libstagefright/codecs/aacdec/sbr_get_dir_control_data.h b/media/libstagefright/codecs/aacdec/sbr_get_dir_control_data.h
new file mode 100644
index 0000000..3b587dc
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/sbr_get_dir_control_data.h
@@ -0,0 +1,87 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Filename: sbr_get_dir_control_data.h
+ Funtions:
+
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+
+ Who:                                   Date: MM/DD/YYYY
+ Description:
+------------------------------------------------------------------------------
+
+
+----------------------------------------------------------------------------
+; CONTINUE ONLY IF NOT ALREADY DEFINED
+----------------------------------------------------------------------------*/
+#ifndef SBR_GET_DIR_CONTROL_DATA_H
+#define SBR_GET_DIR_CONTROL_DATA_H
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+#include "pv_audio_type_defs.h"
+#include    "s_bit_buffer.h"
+#include    "s_sbr_frame_data.h"
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here.
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL VARIABLES REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; SIMPLE TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; ENUMERATED TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; STRUCTURES TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; GLOBAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+
+void sbr_get_dir_control_data(SBR_FRAME_DATA * h_frame_data,
+                              BIT_BUFFER * hBitBuf);
+
+
+/*----------------------------------------------------------------------------
+; END
+----------------------------------------------------------------------------*/
+#endif
+
+
diff --git a/media/libstagefright/codecs/aacdec/sbr_get_envelope.cpp b/media/libstagefright/codecs/aacdec/sbr_get_envelope.cpp
new file mode 100644
index 0000000..e92abb1
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/sbr_get_envelope.cpp
@@ -0,0 +1,265 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Filename: sbr_get_envelope.c
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+
+ Who:                                   Date: MM/DD/YYYY
+ Description:
+
+------------------------------------------------------------------------------
+ INPUT AND OUTPUT DEFINITIONS
+
+ Arguments:     h_frame_data - handle to struct SBR_FRAME_DATA
+                hBitBuf      - handle to struct BIT_BUF
+                channel      - channel number
+
+ Return:        void
+
+
+------------------------------------------------------------------------------
+ FUNCTION DESCRIPTION
+
+          Reads envelope data from bitstream
+
+------------------------------------------------------------------------------
+ REQUIREMENTS
+
+
+------------------------------------------------------------------------------
+ REFERENCES
+
+SC 29 Software Copyright Licencing Disclaimer:
+
+This software module was originally developed by
+  Coding Technologies
+
+and edited by
+  -
+
+in the course of development of the ISO/IEC 13818-7 and ISO/IEC 14496-3
+standards for reference purposes and its performance may not have been
+optimized. This software module is an implementation of one or more tools as
+specified by the ISO/IEC 13818-7 and ISO/IEC 14496-3 standards.
+ISO/IEC gives users free license to this software module or modifications
+thereof for use in products claiming conformance to audiovisual and
+image-coding related ITU Recommendations and/or ISO/IEC International
+Standards. ISO/IEC gives users the same free license to this software module or
+modifications thereof for research purposes and further ISO/IEC standardisation.
+Those intending to use this software module in products are advised that its
+use may infringe existing patents. ISO/IEC have no liability for use of this
+software module or modifications thereof. Copyright is not released for
+products that do not conform to audiovisual and image-coding related ITU
+Recommendations and/or ISO/IEC International Standards.
+The original developer retains full right to modify and use the code for its
+own purpose, assign or donate the code to a third party and to inhibit third
+parties from using the code for products that do not conform to audiovisual and
+image-coding related ITU Recommendations and/or ISO/IEC International Standards.
+This copyright notice must be included in all copies or derivative works.
+Copyright (c) ISO/IEC 2002.
+
+------------------------------------------------------------------------------
+ PSEUDO-CODE
+
+------------------------------------------------------------------------------
+*/
+
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+
+#ifdef AAC_PLUS
+
+
+#include    "sbr_get_envelope.h"
+#include    "s_huffman.h"
+#include    "e_coupling_mode.h"
+#include    "sbr_code_book_envlevel.h"
+#include    "buf_getbits.h"
+#include    "sbr_decode_huff_cw.h"
+
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here. Include conditional
+; compile variables also.
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; LOCAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; LOCAL STORE/BUFFER/POINTER DEFINITIONS
+; Variable declaration - defined here and used outside this module
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL FUNCTION REFERENCES
+; Declare functions defined elsewhere and referenced in this module
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL GLOBAL STORE/BUFFER/POINTER REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; FUNCTION CODE
+----------------------------------------------------------------------------*/
+
+void sbr_get_envelope(SBR_FRAME_DATA * h_frame_data,
+                      BIT_BUFFER * hBitBuf)
+{
+    Int32   i;
+    Int32   j;
+    Int32   tmp;
+    Int32   no_band[MAX_ENVELOPES];
+    Int32   delta = 0;
+    Int32   offset = 0;
+    Int32   ampRes;
+    Int32   envDataTableCompFactor;
+    Int32   start_bits;
+    Int32   start_bits_balance;
+    SbrHuffman    hcb_t;
+    SbrHuffman    hcb_f;
+    COUPLING_MODE coupling = h_frame_data->coupling;
+
+    h_frame_data->nScaleFactors = 0;
+
+    if ((h_frame_data->frameClass   == FIXFIX) &&
+            (h_frame_data->frameInfo[0] == 1))
+    {
+        h_frame_data->ampRes = SBR_AMP_RES_1_5;
+    }
+    else
+    {
+        h_frame_data->ampRes = h_frame_data->sbr_header.ampResolution;
+    }
+
+    ampRes = h_frame_data->ampRes;
+
+    /*
+     *    Set number of bits for first value depending on amplitude resolution
+     */
+    if (ampRes == SBR_AMP_RES_3_0)
+    {
+        start_bits         = SI_SBR_START_ENV_BITS_AMP_RES_3_0;
+        start_bits_balance = SI_SBR_START_ENV_BITS_BALANCE_AMP_RES_3_0;
+    }
+    else
+    {
+        start_bits         = SI_SBR_START_ENV_BITS_AMP_RES_1_5;
+        start_bits_balance = SI_SBR_START_ENV_BITS_BALANCE_AMP_RES_1_5;
+    }
+
+    /*
+     *    Calculate number of values for each envelope and alltogether
+     */
+    for (i = 0; i < h_frame_data->frameInfo[0]; i++)
+    {
+        no_band[i] =
+            h_frame_data->nSfb[h_frame_data->frameInfo[h_frame_data->frameInfo[0] + 2 + i]];
+        h_frame_data->nScaleFactors += no_band[i];
+    }
+
+
+    /*
+     *    Select huffman codebook depending on coupling mode and amplitude resolution
+     */
+    if (coupling == COUPLING_BAL)
+    {
+        envDataTableCompFactor = 1;
+        if (ampRes == SBR_AMP_RES_1_5)
+        {
+            hcb_t = bookSbrEnvBalance10T;
+            hcb_f = bookSbrEnvBalance10F;
+        }
+        else
+        {
+            hcb_t = bookSbrEnvBalance11T;
+            hcb_f = bookSbrEnvBalance11F;
+        }
+    }
+    else
+    {
+        envDataTableCompFactor = 0;
+        if (ampRes == SBR_AMP_RES_1_5)
+        {
+            hcb_t = bookSbrEnvLevel10T;
+            hcb_f = bookSbrEnvLevel10F;
+        }
+        else
+        {
+            hcb_t = bookSbrEnvLevel11T;
+            hcb_f = bookSbrEnvLevel11F;
+        }
+    }
+
+    /*
+     *    Now read raw envelope data
+     */
+    for (j = 0; j < h_frame_data->frameInfo[0]; j++)
+    {
+        if (h_frame_data->domain_vec1[j] == FREQ)
+        {
+            if (coupling == COUPLING_BAL)
+            {
+                tmp = buf_getbits(hBitBuf, start_bits_balance);
+                h_frame_data->iEnvelope_man[offset] = tmp << envDataTableCompFactor;
+            }
+            else
+            {
+                tmp = buf_getbits(hBitBuf, start_bits);
+                h_frame_data->iEnvelope_man[offset] = tmp;
+            }
+        }
+
+        for (i = (1 - h_frame_data->domain_vec1[j]); i < no_band[j]; i++)
+        {
+
+            if (h_frame_data->domain_vec1[j] == FREQ)
+            {
+                delta = sbr_decode_huff_cw(hcb_f, hBitBuf);
+            }
+            else
+            {
+                delta = sbr_decode_huff_cw(hcb_t, hBitBuf);
+            }
+
+            h_frame_data->iEnvelope_man[offset + i] = delta << envDataTableCompFactor;
+        }
+        offset += no_band[j];
+    }
+
+}
+
+#endif
+
diff --git a/media/libstagefright/codecs/aacdec/sbr_get_envelope.h b/media/libstagefright/codecs/aacdec/sbr_get_envelope.h
new file mode 100644
index 0000000..b7a266a
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/sbr_get_envelope.h
@@ -0,0 +1,93 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Filename: sbr_get_envelope.h
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+
+ Who:                                   Date: MM/DD/YYYY
+ Description:
+------------------------------------------------------------------------------
+
+
+----------------------------------------------------------------------------
+; CONTINUE ONLY IF NOT ALREADY DEFINED
+----------------------------------------------------------------------------*/
+#ifndef SBR_GET_ENVELOPE_H
+#define SBR_GET_ENVELOPE_H
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+#include "pv_audio_type_defs.h"
+#include    "s_bit_buffer.h"
+#include    "s_sbr_frame_data.h"
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here.
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL VARIABLES REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; SIMPLE TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; ENUMERATED TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; STRUCTURES TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; GLOBAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+    void sbr_get_envelope(SBR_FRAME_DATA * h_frame_data,
+    BIT_BUFFER  * hBitBuf);
+
+#ifdef __cplusplus
+}
+#endif
+
+/*----------------------------------------------------------------------------
+; END
+----------------------------------------------------------------------------*/
+#endif
+
+
diff --git a/media/libstagefright/codecs/aacdec/sbr_get_header_data.cpp b/media/libstagefright/codecs/aacdec/sbr_get_header_data.cpp
new file mode 100644
index 0000000..42789ae
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/sbr_get_header_data.cpp
@@ -0,0 +1,221 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Filename: sbr_get_header_data.c
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+
+ Who:                                   Date: MM/DD/YYYY
+ Description:
+
+------------------------------------------------------------------------------
+ INPUT AND OUTPUT DEFINITIONS
+
+ Arguments:     h_sbr_header - handle to struct SBR_HEADER_DATA
+                hBitBuf      - handle to struct BIT_BUFFER
+                id_sbr       - SBR_ELEMENT_ID
+
+ Return:        error status - 0 if ok
+
+
+------------------------------------------------------------------------------
+ FUNCTION DESCRIPTION
+
+    Reads header data from bitstream
+
+------------------------------------------------------------------------------
+ REQUIREMENTS
+
+
+------------------------------------------------------------------------------
+ REFERENCES
+
+SC 29 Software Copyright Licencing Disclaimer:
+
+This software module was originally developed by
+  Coding Technologies
+
+and edited by
+  -
+
+in the course of development of the ISO/IEC 13818-7 and ISO/IEC 14496-3
+standards for reference purposes and its performance may not have been
+optimized. This software module is an implementation of one or more tools as
+specified by the ISO/IEC 13818-7 and ISO/IEC 14496-3 standards.
+ISO/IEC gives users free license to this software module or modifications
+thereof for use in products claiming conformance to audiovisual and
+image-coding related ITU Recommendations and/or ISO/IEC International
+Standards. ISO/IEC gives users the same free license to this software module or
+modifications thereof for research purposes and further ISO/IEC standardisation.
+Those intending to use this software module in products are advised that its
+use may infringe existing patents. ISO/IEC have no liability for use of this
+software module or modifications thereof. Copyright is not released for
+products that do not conform to audiovisual and image-coding related ITU
+Recommendations and/or ISO/IEC International Standards.
+The original developer retains full right to modify and use the code for its
+own purpose, assign or donate the code to a third party and to inhibit third
+parties from using the code for products that do not conform to audiovisual and
+image-coding related ITU Recommendations and/or ISO/IEC International Standards.
+This copyright notice must be included in all copies or derivative works.
+Copyright (c) ISO/IEC 2002.
+
+------------------------------------------------------------------------------
+ PSEUDO-CODE
+
+------------------------------------------------------------------------------
+*/
+
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+
+#ifdef AAC_PLUS
+
+
+#include    "sbr_get_header_data.h"
+#include    "sbr_constants.h"
+#include    "buf_getbits.h"
+#include    "aac_mem_funcs.h"
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here. Include conditional
+; compile variables also.
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; LOCAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; LOCAL STORE/BUFFER/POINTER DEFINITIONS
+; Variable declaration - defined here and used outside this module
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL FUNCTION REFERENCES
+; Declare functions defined elsewhere and referenced in this module
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL GLOBAL STORE/BUFFER/POINTER REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; FUNCTION CODE
+----------------------------------------------------------------------------*/
+
+SBR_HEADER_STATUS sbr_get_header_data(SBR_HEADER_DATA   * h_sbr_header,
+                                      BIT_BUFFER          * hBitBuf,
+                                      SBR_SYNC_STATE     syncState)
+{
+    SBR_HEADER_DATA lastHeader;
+    Int32 headerExtra1, headerExtra2;
+
+
+    /* Copy header to temporary header */
+    if (syncState == SBR_ACTIVE)
+    {
+        pv_memcpy(&lastHeader, h_sbr_header, sizeof(SBR_HEADER_DATA));
+    }
+    else
+    {
+        pv_memset((void *)&lastHeader, 0, sizeof(SBR_HEADER_DATA));
+    }
+
+
+    /* Read new header from bitstream */
+    h_sbr_header->ampResolution   = buf_getbits(hBitBuf, SI_SBR_AMP_RES_BITS);
+    h_sbr_header->startFreq       = buf_getbits(hBitBuf, SI_SBR_START_FREQ_BITS);
+    h_sbr_header->stopFreq        = buf_getbits(hBitBuf, SI_SBR_STOP_FREQ_BITS);
+    h_sbr_header->xover_band      = buf_getbits(hBitBuf, SI_SBR_XOVER_BAND_BITS);
+
+    buf_getbits(hBitBuf, SI_SBR_RESERVED_BITS_HDR);
+
+    headerExtra1    = buf_getbits(hBitBuf, SI_SBR_HEADER_EXTRA_1_BITS);
+    headerExtra2    = buf_getbits(hBitBuf, SI_SBR_HEADER_EXTRA_2_BITS);
+
+    /* handle extra header information */
+    if (headerExtra1)
+    {
+        h_sbr_header->freqScale   = buf_getbits(hBitBuf, SI_SBR_FREQ_SCALE_BITS);
+        h_sbr_header->alterScale  = buf_getbits(hBitBuf, SI_SBR_ALTER_SCALE_BITS);
+        h_sbr_header->noise_bands = buf_getbits(hBitBuf, SI_SBR_NOISE_BANDS_BITS);
+    }
+    else
+    { /* Set default values.*/
+        h_sbr_header->freqScale   = SBR_FREQ_SCALE_DEFAULT;
+        h_sbr_header->alterScale  = SBR_ALTER_SCALE_DEFAULT;
+        h_sbr_header->noise_bands = SBR_NOISE_BANDS_DEFAULT;
+    }
+
+
+    if (headerExtra2)
+    {
+        h_sbr_header->limiterBands    = buf_getbits(hBitBuf, SI_SBR_LIMITER_BANDS_BITS);
+        h_sbr_header->limiterGains    = buf_getbits(hBitBuf, SI_SBR_LIMITER_GAINS_BITS);
+        h_sbr_header->interpolFreq    = buf_getbits(hBitBuf, SI_SBR_INTERPOL_FREQ_BITS);
+        h_sbr_header->smoothingLength = buf_getbits(hBitBuf, SI_SBR_SMOOTHING_LENGTH_BITS);
+    }
+    else
+    { /* Set default values.*/
+        h_sbr_header->limiterBands    = SBR_LIMITER_BANDS_DEFAULT;
+        h_sbr_header->limiterGains    = SBR_LIMITER_GAINS_DEFAULT;
+        h_sbr_header->interpolFreq    = SBR_INTERPOL_FREQ_DEFAULT;
+        h_sbr_header->smoothingLength = SBR_SMOOTHING_LENGTH_DEFAULT;
+    }
+
+    if (syncState == SBR_ACTIVE)
+    {
+        h_sbr_header->status = HEADER_OK;
+
+        /* look for new settings */
+        if (lastHeader.startFreq   != h_sbr_header->startFreq   ||
+                lastHeader.stopFreq    != h_sbr_header->stopFreq    ||
+                lastHeader.xover_band  != h_sbr_header->xover_band  ||
+                lastHeader.freqScale   != h_sbr_header->freqScale   ||
+                lastHeader.alterScale  != h_sbr_header->alterScale  ||
+                lastHeader.noise_bands != h_sbr_header->noise_bands)
+        {
+            h_sbr_header->status = HEADER_RESET;
+        }
+    }
+    else
+    {
+        h_sbr_header->status = HEADER_RESET;
+    }
+
+    return h_sbr_header->status;
+}
+
+#endif
+
+
+
diff --git a/media/libstagefright/codecs/aacdec/sbr_get_header_data.h b/media/libstagefright/codecs/aacdec/sbr_get_header_data.h
new file mode 100644
index 0000000..7bfb272
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/sbr_get_header_data.h
@@ -0,0 +1,89 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Filename: sbr_get_header_data.h
+ Funtions:
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+
+ Who:                                   Date: MM/DD/YYYY
+ Description:
+------------------------------------------------------------------------------
+
+
+----------------------------------------------------------------------------
+; CONTINUE ONLY IF NOT ALREADY DEFINED
+----------------------------------------------------------------------------*/
+#ifndef SBR_GET_HEADER_DATA_H
+#define SBR_GET_HEADER_DATA_H
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+#include "pv_audio_type_defs.h"
+#include    "s_bit_buffer.h"
+#include    "s_sbr_header_data.h"
+#include    "e_sbr_element_id.h"
+#include    "e_sbr_sync_state.h"
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here.
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL VARIABLES REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; SIMPLE TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; ENUMERATED TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; STRUCTURES TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; GLOBAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+
+SBR_HEADER_STATUS sbr_get_header_data(SBR_HEADER_DATA   *h_sbr_header,
+                                      BIT_BUFFER  * hBitBuf,
+                                      SBR_SYNC_STATE     syncState);
+
+
+/*----------------------------------------------------------------------------
+; END
+----------------------------------------------------------------------------*/
+#endif
+
+
diff --git a/media/libstagefright/codecs/aacdec/sbr_get_noise_floor_data.cpp b/media/libstagefright/codecs/aacdec/sbr_get_noise_floor_data.cpp
new file mode 100644
index 0000000..8d86158
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/sbr_get_noise_floor_data.cpp
@@ -0,0 +1,218 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Filename: sbr_get_noise_floor_data.c
+
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+
+ Who:                                   Date: MM/DD/YYYY
+ Description:
+
+------------------------------------------------------------------------------
+ INPUT AND OUTPUT DEFINITIONS
+
+ Arguments:     h_frame_data - handle to struct SBR_FRAME_DATA
+                hBitBuf      - handle to struct BIT_BUF
+
+ Return:        void
+
+
+------------------------------------------------------------------------------
+ FUNCTION DESCRIPTION
+
+    Reads noise-floor-level data from bitstream
+
+------------------------------------------------------------------------------
+ REQUIREMENTS
+
+
+------------------------------------------------------------------------------
+ REFERENCES
+
+SC 29 Software Copyright Licencing Disclaimer:
+
+This software module was originally developed by
+  Coding Technologies
+
+and edited by
+  -
+
+in the course of development of the ISO/IEC 13818-7 and ISO/IEC 14496-3
+standards for reference purposes and its performance may not have been
+optimized. This software module is an implementation of one or more tools as
+specified by the ISO/IEC 13818-7 and ISO/IEC 14496-3 standards.
+ISO/IEC gives users free license to this software module or modifications
+thereof for use in products claiming conformance to audiovisual and
+image-coding related ITU Recommendations and/or ISO/IEC International
+Standards. ISO/IEC gives users the same free license to this software module or
+modifications thereof for research purposes and further ISO/IEC standardisation.
+Those intending to use this software module in products are advised that its
+use may infringe existing patents. ISO/IEC have no liability for use of this
+software module or modifications thereof. Copyright is not released for
+products that do not conform to audiovisual and image-coding related ITU
+Recommendations and/or ISO/IEC International Standards.
+The original developer retains full right to modify and use the code for its
+own purpose, assign or donate the code to a third party and to inhibit third
+parties from using the code for products that do not conform to audiovisual and
+image-coding related ITU Recommendations and/or ISO/IEC International Standards.
+This copyright notice must be included in all copies or derivative works.
+Copyright (c) ISO/IEC 2002.
+
+------------------------------------------------------------------------------
+ PSEUDO-CODE
+
+------------------------------------------------------------------------------
+*/
+
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+
+#ifdef AAC_PLUS
+
+
+#include    "sbr_get_noise_floor_data.h"
+#include    "e_coupling_mode.h"
+#include    "buf_getbits.h"
+#include    "sbr_code_book_envlevel.h"
+#include    "s_huffman.h"
+#include    "sbr_decode_huff_cw.h"
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here. Include conditional
+; compile variables also.
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; LOCAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; LOCAL STORE/BUFFER/POINTER DEFINITIONS
+; Variable declaration - defined here and used outside this module
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL FUNCTION REFERENCES
+; Declare functions defined elsewhere and referenced in this module
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL GLOBAL STORE/BUFFER/POINTER REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; FUNCTION CODE
+----------------------------------------------------------------------------*/
+
+void sbr_get_noise_floor_data(SBR_FRAME_DATA * h_frame_data,
+                              BIT_BUFFER * hBitBuf)
+{
+    Int32 i;
+    Int32 j;
+    Int32 k;
+    Int32 tmp;
+    Int32 delta;
+    Int32 noNoiseBands = h_frame_data->nNfb;
+    Int32 envDataTableCompFactor;
+
+    COUPLING_MODE coupling = h_frame_data->coupling;
+
+    SbrHuffman hcb_noiseF;
+    SbrHuffman hcb_noise;
+
+
+    if (coupling == COUPLING_BAL)
+    {
+        hcb_noise  = bookSbrNoiseBalance11T;
+        hcb_noiseF = bookSbrEnvBalance11F;  /* "bookSbrNoiseBalance11F" */
+        envDataTableCompFactor = 1;
+    }
+    else
+    {
+        hcb_noise  = bookSbrNoiseLevel11T;
+        hcb_noiseF = bookSbrEnvLevel11F;  /* "bookSbrNoiseLevel11F" */
+        envDataTableCompFactor = 0;
+    }
+
+    /*
+     *  Calculate number of values alltogether
+     */
+    h_frame_data->nNoiseFactors = h_frame_data->frameInfo[((h_frame_data->frameInfo[0]) << 1) + 3] * noNoiseBands;
+
+
+    for (i = 0; i < h_frame_data->nNoiseFloorEnvelopes; i++)
+    {
+        k = i * noNoiseBands;
+        if (h_frame_data->domain_vec2[i] == FREQ)
+        {
+            if (coupling == COUPLING_BAL)
+            {
+                tmp = buf_getbits(hBitBuf, SI_SBR_START_NOISE_BITS_BALANCE_AMP_RES_3_0) << 1;  /*  max. 62  */
+                h_frame_data->sbrNoiseFloorLevel_man[k] = tmp;
+                h_frame_data->sbrNoiseFloorLevel_exp[k] =   0;
+            }
+            else
+            {
+                tmp = buf_getbits(hBitBuf, SI_SBR_START_NOISE_BITS_AMP_RES_3_0);  /*  max. 31  */
+                h_frame_data->sbrNoiseFloorLevel_man[k] = tmp;
+                h_frame_data->sbrNoiseFloorLevel_exp[k] =   0;
+            }
+
+            for (j = 1; j < noNoiseBands; j++)
+            {
+                delta = sbr_decode_huff_cw(hcb_noiseF, hBitBuf); /*
+                                                                  *  -31 < delta < 31
+                                                                  *  -24 < delta < 24   COUPLING_BAL (incl. <<1)
+                                                                  */
+                h_frame_data->sbrNoiseFloorLevel_man[k+j] = delta << envDataTableCompFactor;
+                h_frame_data->sbrNoiseFloorLevel_exp[k+j] =   0;
+            }
+        }
+        else
+        {
+            for (j = 0; j < noNoiseBands; j++)
+            {
+                delta = sbr_decode_huff_cw(hcb_noise, hBitBuf);  /*
+                                                                  *  -31 < delta < 31
+                                                                  *  -24 < delta < 24   COUPLING_BAL (incl. <<1)
+                                                                  */
+                h_frame_data->sbrNoiseFloorLevel_man[k+j] = delta << envDataTableCompFactor;
+                h_frame_data->sbrNoiseFloorLevel_exp[k+j] =   0;
+            }
+        }
+    }
+}
+
+#endif
+
+
diff --git a/media/libstagefright/codecs/aacdec/sbr_get_noise_floor_data.h b/media/libstagefright/codecs/aacdec/sbr_get_noise_floor_data.h
new file mode 100644
index 0000000..e61abda
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/sbr_get_noise_floor_data.h
@@ -0,0 +1,94 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Filename: sbr_get_noise_floor_data.h
+ Funtions:
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+
+ Who:                                   Date: MM/DD/YYYY
+ Description:
+------------------------------------------------------------------------------
+
+
+----------------------------------------------------------------------------
+; CONTINUE ONLY IF NOT ALREADY DEFINED
+----------------------------------------------------------------------------*/
+#ifndef SBR_GET_NOISE_FLOOR_DATA_H
+#define SBR_GET_NOISE_FLOOR_DATA_H
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+#include "pv_audio_type_defs.h"
+#include    "s_bit_buffer.h"
+#include    "s_sbr_frame_data.h"
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here.
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL VARIABLES REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; SIMPLE TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; ENUMERATED TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; STRUCTURES TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; GLOBAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+    void sbr_get_noise_floor_data(SBR_FRAME_DATA * h_frame_data,
+    BIT_BUFFER * hBitBuf);
+
+#ifdef __cplusplus
+}
+#endif
+
+/*----------------------------------------------------------------------------
+; END
+----------------------------------------------------------------------------*/
+#endif
+
+
diff --git a/media/libstagefright/codecs/aacdec/sbr_get_sce.cpp b/media/libstagefright/codecs/aacdec/sbr_get_sce.cpp
new file mode 100644
index 0000000..ba514f4
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/sbr_get_sce.cpp
@@ -0,0 +1,202 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Filename: sbr_get_sce.c
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+
+ Who:                                   Date: MM/DD/YYYY
+ Description:
+
+------------------------------------------------------------------------------
+ INPUT AND OUTPUT DEFINITIONS
+
+ Arguments:     hFrameData - handle to struct SBR_FRAME_DATA
+                hBitBuf    - handle to struct BIT_BUF
+
+ Return:        SbrFrameOK
+
+
+------------------------------------------------------------------------------
+ FUNCTION DESCRIPTION
+
+
+------------------------------------------------------------------------------
+ REQUIREMENTS
+
+
+------------------------------------------------------------------------------
+ REFERENCES
+
+SC 29 Software Copyright Licencing Disclaimer:
+
+This software module was originally developed by
+  Coding Technologies
+
+and edited by
+  -
+
+in the course of development of the ISO/IEC 13818-7 and ISO/IEC 14496-3
+standards for reference purposes and its performance may not have been
+optimized. This software module is an implementation of one or more tools as
+specified by the ISO/IEC 13818-7 and ISO/IEC 14496-3 standards.
+ISO/IEC gives users free license to this software module or modifications
+thereof for use in products claiming conformance to audiovisual and
+image-coding related ITU Recommendations and/or ISO/IEC International
+Standards. ISO/IEC gives users the same free license to this software module or
+modifications thereof for research purposes and further ISO/IEC standardisation.
+Those intending to use this software module in products are advised that its
+use may infringe existing patents. ISO/IEC have no liability for use of this
+software module or modifications thereof. Copyright is not released for
+products that do not conform to audiovisual and image-coding related ITU
+Recommendations and/or ISO/IEC International Standards.
+The original developer retains full right to modify and use the code for its
+own purpose, assign or donate the code to a third party and to inhibit third
+parties from using the code for products that do not conform to audiovisual and
+image-coding related ITU Recommendations and/or ISO/IEC International Standards.
+This copyright notice must be included in all copies or derivative works.
+Copyright (c) ISO/IEC 2002.
+
+------------------------------------------------------------------------------
+ PSEUDO-CODE
+
+------------------------------------------------------------------------------
+*/
+
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+
+#ifdef AAC_PLUS
+
+
+
+#include    "sbr_get_sce.h"
+#include    "sbr_get_additional_data.h"
+#include    "sbr_extract_extended_data.h"
+#include    "buf_getbits.h"
+#include    "sbr_get_envelope.h"
+#include    "sbr_get_noise_floor_data.h"
+#include    "extractframeinfo.h"
+#include    "sbr_get_dir_control_data.h"
+#include    "e_invf_mode.h"
+#include    "aac_mem_funcs.h"
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here. Include conditional
+; compile variables also.
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; LOCAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; LOCAL STORE/BUFFER/POINTER DEFINITIONS
+; Variable declaration - defined here and used outside this module
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL FUNCTION REFERENCES
+; Declare functions defined elsewhere and referenced in this module
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL GLOBAL STORE/BUFFER/POINTER REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; FUNCTION CODE
+----------------------------------------------------------------------------*/
+
+SBR_ERROR sbr_get_sce(SBR_FRAME_DATA * hFrameData,
+                      BIT_BUFFER * hBitBuf
+#ifdef PARAMETRICSTEREO
+                      , HANDLE_PS_DEC hParametricStereoDec
+#endif
+                     )
+{
+    Int32 i;
+    Int32 bits;
+    SBR_ERROR err =  SBRDEC_OK;
+
+    /* reserved bits */
+    bits = buf_getbits(hBitBuf, SI_SBR_RESERVED_PRESENT);
+
+    if (bits)
+    {
+        buf_getbits(hBitBuf, SI_SBR_RESERVED_BITS_DATA);
+    }
+
+    /* side info */
+    err = extractFrameInfo(hBitBuf, hFrameData);
+
+    if (err != SBRDEC_OK)
+    {
+        return err;
+    }
+
+
+    sbr_get_dir_control_data(hFrameData, hBitBuf);
+
+    for (i = 0; i < hFrameData->nNfb; i++)
+    {
+        hFrameData->sbr_invf_mode_prev[i] = hFrameData->sbr_invf_mode[i];
+        hFrameData->sbr_invf_mode[i] =
+            (INVF_MODE) buf_getbits(hBitBuf, SI_SBR_INVF_MODE_BITS);
+    }
+
+
+    /* raw data */
+    sbr_get_envelope(hFrameData, hBitBuf);
+
+    sbr_get_noise_floor_data(hFrameData, hBitBuf);
+
+    pv_memset((void *)hFrameData->addHarmonics,
+              0,
+              hFrameData->nSfb[HI]*sizeof(Int32));
+
+    sbr_get_additional_data(hFrameData, hBitBuf);
+
+    sbr_extract_extended_data(hBitBuf
+#ifdef PARAMETRICSTEREO
+                              , hParametricStereoDec
+#endif
+                             );
+
+    hFrameData->coupling = COUPLING_OFF;
+
+    return SBRDEC_OK;
+
+}
+
+
+#endif
diff --git a/media/libstagefright/codecs/aacdec/sbr_get_sce.h b/media/libstagefright/codecs/aacdec/sbr_get_sce.h
new file mode 100644
index 0000000..36adb04
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/sbr_get_sce.h
@@ -0,0 +1,102 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Filename: sbr_get_sce.h
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+
+ Who:                                   Date: MM/DD/YYYY
+ Description:
+------------------------------------------------------------------------------
+
+
+----------------------------------------------------------------------------
+; CONTINUE ONLY IF NOT ALREADY DEFINED
+----------------------------------------------------------------------------*/
+#ifndef SBR_GET_SCE_H
+#define SBR_GET_SCE_H
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+#include    "pv_audio_type_defs.h"
+#include    "s_bit_buffer.h"
+#include    "s_sbr_frame_data.h"
+#include    "e_sbr_error.h"
+
+#ifdef PARAMETRICSTEREO
+#include    "s_ps_dec.h"
+#endif
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here.
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL VARIABLES REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; SIMPLE TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; ENUMERATED TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; STRUCTURES TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; GLOBAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+    SBR_ERROR sbr_get_sce(SBR_FRAME_DATA * hFrameData,
+    BIT_BUFFER * hBitBuf
+#ifdef PARAMETRICSTEREO
+    , HANDLE_PS_DEC hParametricStereoDec
+#endif
+                         );
+
+#ifdef __cplusplus
+}
+#endif
+
+/*----------------------------------------------------------------------------
+; END
+----------------------------------------------------------------------------*/
+#endif
+
+
diff --git a/media/libstagefright/codecs/aacdec/sbr_inv_filt_levelemphasis.cpp b/media/libstagefright/codecs/aacdec/sbr_inv_filt_levelemphasis.cpp
new file mode 100644
index 0000000..833ace3
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/sbr_inv_filt_levelemphasis.cpp
@@ -0,0 +1,214 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Filename: sbr_inv_filt_levelemphasis.c
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+
+ Who:                                   Date: MM/DD/YYYY
+ Description:
+
+------------------------------------------------------------------------------
+ INPUT AND OUTPUT DEFINITIONS
+
+
+
+------------------------------------------------------------------------------
+ FUNCTION DESCRIPTION
+
+
+------------------------------------------------------------------------------
+ REQUIREMENTS
+
+
+------------------------------------------------------------------------------
+ REFERENCES
+
+SC 29 Software Copyright Licencing Disclaimer:
+
+This software module was originally developed by
+  Coding Technologies
+
+and edited by
+  -
+
+in the course of development of the ISO/IEC 13818-7 and ISO/IEC 14496-3
+standards for reference purposes and its performance may not have been
+optimized. This software module is an implementation of one or more tools as
+specified by the ISO/IEC 13818-7 and ISO/IEC 14496-3 standards.
+ISO/IEC gives users free license to this software module or modifications
+thereof for use in products claiming conformance to audiovisual and
+image-coding related ITU Recommendations and/or ISO/IEC International
+Standards. ISO/IEC gives users the same free license to this software module or
+modifications thereof for research purposes and further ISO/IEC standardisation.
+Those intending to use this software module in products are advised that its
+use may infringe existing patents. ISO/IEC have no liability for use of this
+software module or modifications thereof. Copyright is not released for
+products that do not conform to audiovisual and image-coding related ITU
+Recommendations and/or ISO/IEC International Standards.
+The original developer retains full right to modify and use the code for its
+own purpose, assign or donate the code to a third party and to inhibit third
+parties from using the code for products that do not conform to audiovisual and
+image-coding related ITU Recommendations and/or ISO/IEC International Standards.
+This copyright notice must be included in all copies or derivative works.
+Copyright (c) ISO/IEC 2002.
+
+------------------------------------------------------------------------------
+ PSEUDO-CODE
+
+------------------------------------------------------------------------------
+*/
+
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+
+#ifdef AAC_PLUS
+
+
+#include    "sbr_inv_filt_levelemphasis.h"
+#include    "sbr_generate_high_freq.h"
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here. Include conditional
+; compile variables also.
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; LOCAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; LOCAL STORE/BUFFER/POINTER DEFINITIONS
+; Variable declaration - defined here and used outside this module
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL FUNCTION REFERENCES
+; Declare functions defined elsewhere and referenced in this module
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL GLOBAL STORE/BUFFER/POINTER REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+
+#include "pv_audio_type_defs.h"
+#include "fxp_mul32.h"
+
+#define R_SHIFT     29
+#define Qfmt(x)   (Int32)(x*((Int32)1<<R_SHIFT) + (x>=0?0.5F:-0.5F))
+
+const Int32 InvFiltFactors[5] = {Qfmt(0.00f),    /* OFF_LEVEL */
+                                 Qfmt(0.60f),     /* TRANSITION_LEVEL */
+                                 Qfmt(0.75f),     /* LOW_LEVEL */
+                                 Qfmt(0.90f),     /* MID_LEVEL */
+                                 Qfmt(0.98f)
+                                };    /* HIGH_LEVEL */
+
+/*----------------------------------------------------------------------------
+; FUNCTION CODE
+----------------------------------------------------------------------------*/
+
+void sbr_inv_filt_levelemphasis(INVF_MODE *invFiltMode,
+                                INVF_MODE *prevInvFiltMode,
+                                Int32 nNfb,
+                                Int32  BwVector[MAX_NUM_PATCHES],
+                                Int32  BwVectorOld[MAX_NUM_PATCHES])
+{
+    Int32 i;
+    Int32 j;
+    Int32 tmp;
+
+    for (i = 0; i < nNfb; i++)
+    {
+        switch (invFiltMode[i])
+        {
+            case INVF_LOW_LEVEL:
+                if (prevInvFiltMode[i] == INVF_OFF)
+                {
+                    j = 1;
+                }
+                else
+                {
+                    j = 2;
+                }
+                break;
+
+            case INVF_MID_LEVEL:
+                j = 3;
+                break;
+
+            case INVF_HIGH_LEVEL:
+                j = 4;
+                break;
+
+            default:
+                if (prevInvFiltMode[i] == INVF_LOW_LEVEL)
+                {
+                    j = 1;
+                }
+                else
+                {
+                    j = 0;
+                }
+        }
+
+        tmp  =  InvFiltFactors[j];
+
+        if (tmp < BwVectorOld[i])
+        {
+            tmp = ((tmp << 1) + tmp + BwVectorOld[i]) >> 2;
+        }
+        else
+        {
+            tmp =  fxp_mul32_Q29(Qfmt(0.90625f), tmp);
+            tmp =  fxp_mac32_Q29(Qfmt(0.09375f), BwVectorOld[i], tmp);
+        }
+
+        if (tmp < Qfmt(0.015625F))
+        {
+            tmp = 0;
+        }
+
+        if (tmp >= Qfmt(0.99609375f))
+        {
+            tmp = Qfmt(0.99609375f);
+        }
+
+        BwVector[i] = tmp;
+    }
+}
+
+
+#endif
+
+
diff --git a/media/libstagefright/codecs/aacdec/sbr_inv_filt_levelemphasis.h b/media/libstagefright/codecs/aacdec/sbr_inv_filt_levelemphasis.h
new file mode 100644
index 0000000..586214c
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/sbr_inv_filt_levelemphasis.h
@@ -0,0 +1,91 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Filename: sbr_inv_filt_levelemphasis.h
+ Funtions:
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+
+ Who:                                   Date: MM/DD/YYYY
+ Description:
+------------------------------------------------------------------------------
+
+
+ ----------------------------------------------------------------------------
+; CONTINUE ONLY IF NOT ALREADY DEFINED
+----------------------------------------------------------------------------*/
+#ifndef SBR_INV_FILT_LEVELEMPHASIS_H
+#define SBR_INV_FILT_LEVELEMPHASIS_H
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+#include    "pv_audio_type_defs.h"
+#include    "e_invf_mode.h"
+#include    "sbr_generate_high_freq.h"
+
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here.
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL VARIABLES REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; SIMPLE TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; ENUMERATED TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; STRUCTURES TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; GLOBAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+
+
+void sbr_inv_filt_levelemphasis(INVF_MODE *invFiltMode,
+                                INVF_MODE *prevInvFiltMode,
+                                Int32  nNfb,
+                                Int32  BwVector[MAX_NUM_PATCHES],
+                                Int32  BwVectorOld[MAX_NUM_PATCHES]);
+
+/*----------------------------------------------------------------------------
+; END
+----------------------------------------------------------------------------*/
+#endif
+
+
+
diff --git a/media/libstagefright/codecs/aacdec/sbr_open.cpp b/media/libstagefright/codecs/aacdec/sbr_open.cpp
new file mode 100644
index 0000000..868819a
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/sbr_open.cpp
@@ -0,0 +1,195 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Filename: sbr_open.c
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+
+ Who:                                   Date: MM/DD/YYYY
+ Description:
+
+------------------------------------------------------------------------------
+ INPUT AND OUTPUT DEFINITIONS
+
+
+
+------------------------------------------------------------------------------
+ FUNCTION DESCRIPTION
+
+
+------------------------------------------------------------------------------
+ REQUIREMENTS
+
+
+------------------------------------------------------------------------------
+ REFERENCES
+
+SC 29 Software Copyright Licencing Disclaimer:
+
+This software module was originally developed by
+  Coding Technologies
+
+and edited by
+  -
+
+in the course of development of the ISO/IEC 13818-7 and ISO/IEC 14496-3
+standards for reference purposes and its performance may not have been
+optimized. This software module is an implementation of one or more tools as
+specified by the ISO/IEC 13818-7 and ISO/IEC 14496-3 standards.
+ISO/IEC gives users free license to this software module or modifications
+thereof for use in products claiming conformance to audiovisual and
+image-coding related ITU Recommendations and/or ISO/IEC International
+Standards. ISO/IEC gives users the same free license to this software module or
+modifications thereof for research purposes and further ISO/IEC standardisation.
+Those intending to use this software module in products are advised that its
+use may infringe existing patents. ISO/IEC have no liability for use of this
+software module or modifications thereof. Copyright is not released for
+products that do not conform to audiovisual and image-coding related ITU
+Recommendations and/or ISO/IEC International Standards.
+The original developer retains full right to modify and use the code for its
+own purpose, assign or donate the code to a third party and to inhibit third
+parties from using the code for products that do not conform to audiovisual and
+image-coding related ITU Recommendations and/or ISO/IEC International Standards.
+This copyright notice must be included in all copies or derivative works.
+Copyright (c) ISO/IEC 2002.
+
+------------------------------------------------------------------------------
+ PSEUDO-CODE
+
+------------------------------------------------------------------------------
+*/
+
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+
+#ifdef AAC_PLUS
+
+
+#include    "sbr_open.h"
+#include    "s_sbr_header_data.h"
+#include    "init_sbr_dec.h"
+#include    "e_sbr_error.h"
+#include    "aac_mem_funcs.h"
+
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here. Include conditional
+; compile variables also.
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; LOCAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; LOCAL STORE/BUFFER/POINTER DEFINITIONS
+; Variable declaration - defined here and used outside this module
+----------------------------------------------------------------------------*/
+const SBR_HEADER_DATA defaultHeader =
+{
+    HEADER_NOT_INITIALIZED,   /* status */
+    MASTER_RESET,             /* masterStatus */
+    0,                        /* crcEnable */
+    UP_BY_2,                  /* sampleRateMode */
+    SBR_AMP_RES_3_0,          /* ampResolution */
+    5,                        /* startFreq */
+    0,                        /* stopFreq */
+    0,                        /* xover_band */
+    SBR_FREQ_SCALE_DEFAULT,   /* freqScale */
+    SBR_ALTER_SCALE_DEFAULT,  /* alterScale */
+    SBR_NOISE_BANDS_DEFAULT,  /* noise_bands */
+    0,                        /* noNoiseBands */
+    SBR_LIMITER_BANDS_DEFAULT,
+    SBR_LIMITER_GAINS_DEFAULT,
+    SBR_INTERPOL_FREQ_DEFAULT,
+    SBR_SMOOTHING_LENGTH_DEFAULT
+};
+
+/*----------------------------------------------------------------------------
+; EXTERNAL FUNCTION REFERENCES
+; Declare functions defined elsewhere and referenced in this module
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL GLOBAL STORE/BUFFER/POINTER REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; FUNCTION CODE
+----------------------------------------------------------------------------*/
+
+void sbr_open(Int32 sampleRate,
+              SBR_DEC *sbrDec,
+              SBRDECODER_DATA * self,
+              bool bDownSampledSbr)
+
+{
+    Int16 i ;
+
+    SBR_CHANNEL *SbrChannel;
+
+
+    SbrChannel = self->SbrChannel;
+
+    for (i = 0; i < MAX_NUM_CHANNELS; i++)
+    {
+        pv_memset((void *)&(SbrChannel[i]),
+                  0,
+                  sizeof(SBR_CHANNEL));
+
+        /* init a default header such that we can at least do upsampling later */
+
+        pv_memcpy(&(SbrChannel[i].frameData.sbr_header),
+                  &defaultHeader,
+                  sizeof(SBR_HEADER_DATA));
+
+        /* should be handled by sample rate mode bit */
+        if (sampleRate > 24000 || bDownSampledSbr)
+        {
+            SbrChannel[i].frameData.sbr_header.sampleRateMode = SINGLE_RATE;
+        }
+
+
+        SbrChannel[i].outFrameSize =
+            init_sbr_dec(sampleRate,
+                         self->SbrChannel[0].frameData.sbr_header.sampleRateMode,
+                         sbrDec,
+                         &(SbrChannel[i].frameData));
+
+        SbrChannel[i].syncState     = UPSAMPLING;
+
+        SbrChannel[i].frameData.sUp = 1;        /* reset mode */
+    }
+}
+
+#endif
+
diff --git a/media/libstagefright/codecs/aacdec/sbr_open.h b/media/libstagefright/codecs/aacdec/sbr_open.h
new file mode 100644
index 0000000..8d17ffa
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/sbr_open.h
@@ -0,0 +1,116 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Filename: sbr_open.h
+ Funtions:
+    get_dse
+
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+
+ Who:                                   Date: MM/DD/YYYY
+ Description:
+------------------------------------------------------------------------------
+SC 29 Software Copyright Licencing Disclaimer:
+
+This software module was originally developed by
+  Coding Technologies
+
+and edited by
+  -
+
+in the course of development of the ISO/IEC 13818-7 and ISO/IEC 14496-3
+standards for reference purposes and its performance may not have been
+optimized. This software module is an implementation of one or more tools as
+specified by the ISO/IEC 13818-7 and ISO/IEC 14496-3 standards.
+ISO/IEC gives users free license to this software module or modifications
+thereof for use in products claiming conformance to audiovisual and
+image-coding related ITU Recommendations and/or ISO/IEC International
+Standards. ISO/IEC gives users the same free license to this software module or
+modifications thereof for research purposes and further ISO/IEC standardisation.
+Those intending to use this software module in products are advised that its
+use may infringe existing patents. ISO/IEC have no liability for use of this
+software module or modifications thereof. Copyright is not released for
+products that do not conform to audiovisual and image-coding related ITU
+Recommendations and/or ISO/IEC International Standards.
+The original developer retains full right to modify and use the code for its
+own purpose, assign or donate the code to a third party and to inhibit third
+parties from using the code for products that do not conform to audiovisual and
+image-coding related ITU Recommendations and/or ISO/IEC International Standards.
+This copyright notice must be included in all copies or derivative works.
+Copyright (c) ISO/IEC 2002.
+
+ $Id: ct_envcalc.h,v 1.3 2002/11/29 16:11:49 kaehleof Exp $
+*/
+
+/*----------------------------------------------------------------------------
+; CONTINUE ONLY IF NOT ALREADY DEFINED
+----------------------------------------------------------------------------*/
+#ifndef SBR_OPEN_H
+#define SBR_OPEN_H
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+#include "s_sbr_channel.h"
+#include "sbr_dec.h"
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here.
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL VARIABLES REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; SIMPLE TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; ENUMERATED TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; STRUCTURES TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; GLOBAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+void sbr_open(Int32 sampleRate,
+              SBR_DEC *sbrDec,
+              SBRDECODER_DATA * self,
+              bool bDownSampledSbr);
+
+/*----------------------------------------------------------------------------
+; END
+----------------------------------------------------------------------------*/
+#endif
+
+
diff --git a/media/libstagefright/codecs/aacdec/sbr_read_data.cpp b/media/libstagefright/codecs/aacdec/sbr_read_data.cpp
new file mode 100644
index 0000000..2220fce
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/sbr_read_data.cpp
@@ -0,0 +1,324 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Filename: sbr_read_data.c
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+
+ Who:                                   Date: MM/DD/YYYY
+ Description:
+
+------------------------------------------------------------------------------
+ INPUT AND OUTPUT DEFINITIONS
+
+    INPUT
+
+    SBRDECODER self,
+    SBRBITSTREAM * stream,
+    float *timeData,
+    int numChannels
+
+    OUTPUT
+
+    errorCode, noError if successful
+
+------------------------------------------------------------------------------
+ FUNCTION DESCRIPTION
+
+        sbr decoder processing, set up SBR decoder phase 2 in case of
+        different cotrol data
+
+------------------------------------------------------------------------------
+ REQUIREMENTS
+
+
+------------------------------------------------------------------------------
+ REFERENCES
+
+SC 29 Software Copyright Licencing Disclaimer:
+
+This software module was originally developed by
+  Coding Technologies
+
+and edited by
+  -
+
+in the course of development of the ISO/IEC 13818-7 and ISO/IEC 14496-3
+standards for reference purposes and its performance may not have been
+optimized. This software module is an implementation of one or more tools as
+specified by the ISO/IEC 13818-7 and ISO/IEC 14496-3 standards.
+ISO/IEC gives users free license to this software module or modifications
+thereof for use in products claiming conformance to audiovisual and
+image-coding related ITU Recommendations and/or ISO/IEC International
+Standards. ISO/IEC gives users the same free license to this software module or
+modifications thereof for research purposes and further ISO/IEC standardisation.
+Those intending to use this software module in products are advised that its
+use may infringe existing patents. ISO/IEC have no liability for use of this
+software module or modifications thereof. Copyright is not released for
+products that do not conform to audiovisual and image-coding related ITU
+Recommendations and/or ISO/IEC International Standards.
+The original developer retains full right to modify and use the code for its
+own purpose, assign or donate the code to a third party and to inhibit third
+parties from using the code for products that do not conform to audiovisual and
+image-coding related ITU Recommendations and/or ISO/IEC International Standards.
+This copyright notice must be included in all copies or derivative works.
+Copyright (c) ISO/IEC 2002.
+
+------------------------------------------------------------------------------
+ PSEUDO-CODE
+
+------------------------------------------------------------------------------
+*/
+
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+
+#ifdef AAC_PLUS
+
+
+#include    "sbr_read_data.h"
+#include    "s_bit_buffer.h"
+#include    "buf_getbits.h"
+#include    "sbr_get_sce.h"
+#include    "sbr_get_cpe.h"
+#include    "sbr_reset_dec.h"
+#include    "sbr_get_header_data.h"
+#include    "sbr_crc_check.h"
+#include    "aac_mem_funcs.h"
+
+
+#include    "init_sbr_dec.h"  /*  !!! */
+
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here. Include conditional
+; compile variables also.
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; LOCAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; LOCAL STORE/BUFFER/POINTER DEFINITIONS
+; Variable declaration - defined here and used outside this module
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL FUNCTION REFERENCES
+; Declare functions defined elsewhere and referenced in this module
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL GLOBAL STORE/BUFFER/POINTER REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; FUNCTION CODE
+----------------------------------------------------------------------------*/
+
+SBR_ERROR sbr_read_data(SBRDECODER_DATA * self,
+                        SBR_DEC * sbrDec,
+                        SBRBITSTREAM *stream)
+{
+    SBR_ERROR sbr_err =  SBRDEC_OK;
+    int32_t SbrFrameOK = 1;
+    int32_t sbrCRCAlwaysOn = 0;
+
+    UInt32 bs_header_flag = 0;
+
+    SBR_HEADER_STATUS headerStatus = HEADER_OK;
+
+    SBR_CHANNEL *SbrChannel = self->SbrChannel;
+
+    int32_t zeropadding_bits;
+
+    BIT_BUFFER bitBuf ;
+
+    /*
+     *  evaluate Bitstream
+     */
+
+    bitBuf.buffer_word    = 0;
+    bitBuf.buffered_bits  = 0;
+    bitBuf.nrBitsRead     = 0;
+
+    bitBuf.char_ptr  =  stream->sbrElement[0].Data;
+    bitBuf.bufferLen = (stream->sbrElement[0].Payload) << 3;
+
+
+    /*
+     *  we have to skip a nibble because the first element of Data only
+     *  contains a nibble of data !
+     */
+    buf_getbits(&bitBuf, LEN_NIBBLE);
+
+    if ((stream->sbrElement[0].ExtensionType == SBR_EXTENSION_CRC) ||
+            sbrCRCAlwaysOn)
+    {
+        int32_t CRCLen = ((stream->sbrElement[0].Payload - 1) << 3) + 4 - SI_SBR_CRC_BITS;
+        SbrFrameOK = sbr_crc_check(&bitBuf, CRCLen);
+    }
+
+
+    if (SbrFrameOK)
+    {
+        /*
+         *  The sbr data seems ok, if the header flag is set we read the header
+         *  and check if vital parameters have changed since the previous frame.
+         *  If the syncState equals UPSAMPLING, the SBR Tool has not been
+         *  initialised by SBR header data, and can only do upsampling
+         */
+
+        bs_header_flag = buf_getbits(&bitBuf, 1);  /* read Header flag */
+
+        if (bs_header_flag)
+        {
+            /*
+             *  If syncState == SBR_ACTIVE, it means that we've had a SBR header
+             *  before, and we will compare with the previous header to see if a
+             *  reset is required. If the syncState equals UPSAMPLING this means
+             *  that the SBR-Tool so far is only initialised to do upsampling
+             *  and hence we need to do a reset, and initialise the system
+             *  according to the present header.
+             */
+
+            headerStatus = sbr_get_header_data(&(SbrChannel[0].frameData.sbr_header),
+                                               &bitBuf,
+                                               SbrChannel[0].syncState);
+        }     /* if (bs_header_flag) */
+
+
+        switch (stream->sbrElement[0].ElementID)
+        {
+            case SBR_ID_SCE :
+
+                /* change of control data, reset decoder */
+                if (headerStatus == HEADER_RESET)
+                {
+                    sbr_err = sbr_reset_dec(&(SbrChannel[0].frameData),
+                                            sbrDec,
+                                            self->SbrChannel[0].frameData.sbr_header.sampleRateMode);
+
+                    if (sbr_err != SBRDEC_OK)
+                    {
+                        break;
+                    }
+                    /*
+                     * At this point we have a header and the system has been reset,
+                     * hence syncState from now on will be SBR_ACTIVE.
+                     */
+                    SbrChannel[0].syncState     = SBR_ACTIVE;
+                }
+
+                if ((SbrChannel[0].syncState == SBR_ACTIVE))
+                {
+                    sbr_err = sbr_get_sce(&(SbrChannel[0].frameData),
+                                          &bitBuf
+#ifdef PARAMETRICSTEREO
+                                          , self->hParametricStereoDec
+#endif
+                                         );
+
+                    if (sbr_err != SBRDEC_OK)
+                    {
+                        break;
+                    }
+                }
+
+                break;
+
+            case SBR_ID_CPE :
+
+                if (bs_header_flag)
+                {
+                    pv_memcpy(&(SbrChannel[1].frameData.sbr_header),
+                              &(SbrChannel[0].frameData.sbr_header),
+                              sizeof(SBR_HEADER_DATA));
+                }
+
+                /* change of control data, reset decoder */
+                if (headerStatus == HEADER_RESET)
+                {
+                    for (int32_t lr = 0 ; lr < 2 ; lr++)
+                    {
+                        sbr_err = sbr_reset_dec(&(SbrChannel[lr].frameData),
+                                                sbrDec,
+                                                self->SbrChannel[0].frameData.sbr_header.sampleRateMode);
+
+                        if (sbr_err != SBRDEC_OK)
+                        {
+                            break;
+                        }
+
+                        SbrChannel[lr].syncState = SBR_ACTIVE;
+                    }
+                }
+
+                if (SbrChannel[0].syncState == SBR_ACTIVE)
+                {
+                    sbr_err = sbr_get_cpe(&(SbrChannel[0].frameData),
+                                          &(SbrChannel[1].frameData),
+                                          &bitBuf);
+
+                    if (sbr_err != SBRDEC_OK)
+                    {
+                        break;
+                    }
+
+                }
+                break;
+
+            default:
+                sbr_err = SBRDEC_ILLEGAL_PLUS_ELE_ID;
+                break;
+        }
+
+    }           /* if (SbrFrameOK) */
+
+    /*
+     *  Check that the bits read did not go beyond SBR frame boundaries
+     */
+
+    zeropadding_bits = (8 - (bitBuf.nrBitsRead & 0x7)) & 0x7;
+
+    if ((bitBuf.nrBitsRead + zeropadding_bits)  > bitBuf.bufferLen)
+    {
+        sbr_err = SBRDEC_INVALID_BITSTREAM;
+    }
+
+    return sbr_err;
+}
+
+
+#endif
+
diff --git a/media/libstagefright/codecs/aacdec/sbr_read_data.h b/media/libstagefright/codecs/aacdec/sbr_read_data.h
new file mode 100644
index 0000000..74cf5b9
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/sbr_read_data.h
@@ -0,0 +1,127 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Filename: sbr_read_data.h
+ Funtions:
+    get_dse
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+
+ Who:                                   Date: MM/DD/YYYY
+ Description:
+------------------------------------------------------------------------------
+SC 29 Software Copyright Licencing Disclaimer:
+
+This software module was originally developed by
+  Coding Technologies
+
+and edited by
+  -
+
+in the course of development of the ISO/IEC 13818-7 and ISO/IEC 14496-3
+standards for reference purposes and its performance may not have been
+optimized. This software module is an implementation of one or more tools as
+specified by the ISO/IEC 13818-7 and ISO/IEC 14496-3 standards.
+ISO/IEC gives users free license to this software module or modifications
+thereof for use in products claiming conformance to audiovisual and
+image-coding related ITU Recommendations and/or ISO/IEC International
+Standards. ISO/IEC gives users the same free license to this software module or
+modifications thereof for research purposes and further ISO/IEC standardisation.
+Those intending to use this software module in products are advised that its
+use may infringe existing patents. ISO/IEC have no liability for use of this
+software module or modifications thereof. Copyright is not released for
+products that do not conform to audiovisual and image-coding related ITU
+Recommendations and/or ISO/IEC International Standards.
+The original developer retains full right to modify and use the code for its
+own purpose, assign or donate the code to a third party and to inhibit third
+parties from using the code for products that do not conform to audiovisual and
+image-coding related ITU Recommendations and/or ISO/IEC International Standards.
+This copyright notice must be included in all copies or derivative works.
+Copyright (c) ISO/IEC 2002.
+
+ $Id: ct_envcalc.h,v 1.3 2002/11/29 16:11:49 kaehleof Exp $
+*/
+
+/*----------------------------------------------------------------------------
+; CONTINUE ONLY IF NOT ALREADY DEFINED
+----------------------------------------------------------------------------*/
+#ifndef SBR_READ_DATA
+#define SBR_READ_DATA
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+#include "e_sbr_error.h"
+#include "s_sbr_channel.h"
+#include "s_sbrbitstream.h"
+#include "sbr_dec.h"
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here.
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL VARIABLES REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; SIMPLE TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; ENUMERATED TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; STRUCTURES TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; GLOBAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+    SBR_ERROR sbr_read_data(SBRDECODER_DATA * self,
+    SBR_DEC * sbrDec,
+    SBRBITSTREAM *stream);
+
+#ifdef __cplusplus
+}
+#endif
+
+/*----------------------------------------------------------------------------
+; END
+----------------------------------------------------------------------------*/
+#endif
+
+
diff --git a/media/libstagefright/codecs/aacdec/sbr_requantize_envelope_data.cpp b/media/libstagefright/codecs/aacdec/sbr_requantize_envelope_data.cpp
new file mode 100644
index 0000000..487496f
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/sbr_requantize_envelope_data.cpp
@@ -0,0 +1,183 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Filename: sbr_requantize_envelope_data.c
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+
+ Who:                                   Date: MM/DD/YYYY
+ Description:
+
+------------------------------------------------------------------------------
+ INPUT AND OUTPUT DEFINITIONS
+
+
+
+------------------------------------------------------------------------------
+ FUNCTION DESCRIPTION
+
+
+------------------------------------------------------------------------------
+ REQUIREMENTS
+
+
+------------------------------------------------------------------------------
+ REFERENCES
+
+SC 29 Software Copyright Licencing Disclaimer:
+
+This software module was originally developed by
+  Coding Technologies
+
+and edited by
+  -
+
+in the course of development of the ISO/IEC 13818-7 and ISO/IEC 14496-3
+standards for reference purposes and its performance may not have been
+optimized. This software module is an implementation of one or more tools as
+specified by the ISO/IEC 13818-7 and ISO/IEC 14496-3 standards.
+ISO/IEC gives users free license to this software module or modifications
+thereof for use in products claiming conformance to audiovisual and
+image-coding related ITU Recommendations and/or ISO/IEC International
+Standards. ISO/IEC gives users the same free license to this software module or
+modifications thereof for research purposes and further ISO/IEC standardisation.
+Those intending to use this software module in products are advised that its
+use may infringe existing patents. ISO/IEC have no liability for use of this
+software module or modifications thereof. Copyright is not released for
+products that do not conform to audiovisual and image-coding related ITU
+Recommendations and/or ISO/IEC International Standards.
+The original developer retains full right to modify and use the code for its
+own purpose, assign or donate the code to a third party and to inhibit third
+parties from using the code for products that do not conform to audiovisual and
+image-coding related ITU Recommendations and/or ISO/IEC International Standards.
+This copyright notice must be included in all copies or derivative works.
+Copyright (c) ISO/IEC 2002.
+
+------------------------------------------------------------------------------
+ PSEUDO-CODE
+
+------------------------------------------------------------------------------
+*/
+
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+
+#ifdef AAC_PLUS
+
+
+#include    "sbr_constants.h"
+#include    "sbr_requantize_envelope_data.h"
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here. Include conditional
+; compile variables also.
+----------------------------------------------------------------------------*/
+#define R_SHIFT     30
+#define Qfmt(x)   (Int32)(x*((Int32)1<<R_SHIFT) + (x>=0?0.5F:-0.5F))
+/*----------------------------------------------------------------------------
+; LOCAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; LOCAL STORE/BUFFER/POINTER DEFINITIONS
+; Variable declaration - defined here and used outside this module
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL FUNCTION REFERENCES
+; Declare functions defined elsewhere and referenced in this module
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL GLOBAL STORE/BUFFER/POINTER REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; FUNCTION CODE
+----------------------------------------------------------------------------*/
+
+void sbr_requantize_envelope_data(SBR_FRAME_DATA * hFrameData)
+
+{
+    Int32 i;
+
+
+    Int32  nScaleFactors      =  hFrameData->nScaleFactors;
+    Int32  nNoiseFactors      =  hFrameData->nNoiseFactors;
+    Int32  ampRes             =  hFrameData->ampRes;
+    Int32 *iEnvelope_man      =  hFrameData->iEnvelope_man;
+    Int32 *iEnvelope_exp      =  hFrameData->iEnvelope_exp;
+    Int32 *sbrNoiseFloorLevel_man = hFrameData->sbrNoiseFloorLevel_man;
+    Int32 *sbrNoiseFloorLevel_exp = hFrameData->sbrNoiseFloorLevel_exp;
+
+    /*
+     *  ampRes could be 0 (resolution step = 1.5 dB) or
+     *                  1 (resolution step = 3 dB)
+     */
+    if (ampRes)
+    {
+        /*  iEnvelope[i] always positive  6 bits max */
+        for (i = 0; i < nScaleFactors; i++)
+        {
+
+            iEnvelope_exp[i] = iEnvelope_man[i] + 6;
+            iEnvelope_man[i] = Qfmt(1.000F);
+        }
+    }
+    else
+    {
+        /*  iEnvelope[i] always positive  7 bits max */
+        for (i = 0; i < nScaleFactors; i++)
+        {
+            iEnvelope_exp[i] = (iEnvelope_man[i] >> 1) + 6;
+            if (iEnvelope_man[i] & 0x1)   /*  odd */
+            {
+                iEnvelope_man[i] = Qfmt(1.41421356237310F);
+            }
+            else
+            {
+                iEnvelope_man[i] = Qfmt(1.000F);
+            }
+        }
+
+    }
+    for (i = 0; i < nNoiseFactors; i++)
+    {
+        /*  sbrNoiseFloorLevel[i] varies from -31 to 31 if no coupling is used */
+
+        sbrNoiseFloorLevel_exp[i] = NOISE_FLOOR_OFFSET - sbrNoiseFloorLevel_man[i];
+        sbrNoiseFloorLevel_man[i] = 0x40000000;
+    }
+}
+
+#endif
+
diff --git a/media/libstagefright/codecs/aacdec/sbr_requantize_envelope_data.h b/media/libstagefright/codecs/aacdec/sbr_requantize_envelope_data.h
new file mode 100644
index 0000000..2113586
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/sbr_requantize_envelope_data.h
@@ -0,0 +1,83 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Filename: sbr_requantize_envelope_data.h
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+
+ Who:                                   Date: MM/DD/YYYY
+ Description:
+------------------------------------------------------------------------------
+
+
+----------------------------------------------------------------------------
+; CONTINUE ONLY IF NOT ALREADY DEFINED
+----------------------------------------------------------------------------*/
+#ifndef SBR_REQUANTIZE_ENVELOPE_DATA_H
+#define SBR_REQUANTIZE_ENVELOPE_DATA_H
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+#include    "pv_audio_type_defs.h"
+#include    "s_sbr_frame_data.h"
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here.
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL VARIABLES REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; SIMPLE TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; ENUMERATED TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; STRUCTURES TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+
+/*----------------------------------------------------------------------------
+; GLOBAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+
+void sbr_requantize_envelope_data(SBR_FRAME_DATA * hFrameData);
+
+/*----------------------------------------------------------------------------
+; END
+----------------------------------------------------------------------------*/
+#endif
+
+
diff --git a/media/libstagefright/codecs/aacdec/sbr_reset_dec.cpp b/media/libstagefright/codecs/aacdec/sbr_reset_dec.cpp
new file mode 100644
index 0000000..810a34a
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/sbr_reset_dec.cpp
@@ -0,0 +1,269 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Filename: sbr_reset_dec.c
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+
+ Who:                                   Date: MM/DD/YYYY
+ Description:
+
+------------------------------------------------------------------------------
+ INPUT AND OUTPUT DEFINITIONS
+
+
+
+------------------------------------------------------------------------------
+ FUNCTION DESCRIPTION
+
+    resets sbr decoder structure
+------------------------------------------------------------------------------
+ REQUIREMENTS
+
+
+------------------------------------------------------------------------------
+ REFERENCES
+
+SC 29 Software Copyright Licencing Disclaimer:
+
+This software module was originally developed by
+  Coding Technologies
+
+and edited by
+  -
+
+in the course of development of the ISO/IEC 13818-7 and ISO/IEC 14496-3
+standards for reference purposes and its performance may not have been
+optimized. This software module is an implementation of one or more tools as
+specified by the ISO/IEC 13818-7 and ISO/IEC 14496-3 standards.
+ISO/IEC gives users free license to this software module or modifications
+thereof for use in products claiming conformance to audiovisual and
+image-coding related ITU Recommendations and/or ISO/IEC International
+Standards. ISO/IEC gives users the same free license to this software module or
+modifications thereof for research purposes and further ISO/IEC standardisation.
+Those intending to use this software module in products are advised that its
+use may infringe existing patents. ISO/IEC have no liability for use of this
+software module or modifications thereof. Copyright is not released for
+products that do not conform to audiovisual and image-coding related ITU
+Recommendations and/or ISO/IEC International Standards.
+The original developer retains full right to modify and use the code for its
+own purpose, assign or donate the code to a third party and to inhibit third
+parties from using the code for products that do not conform to audiovisual and
+image-coding related ITU Recommendations and/or ISO/IEC International Standards.
+This copyright notice must be included in all copies or derivative works.
+Copyright (c) ISO/IEC 2002.
+
+------------------------------------------------------------------------------
+ PSEUDO-CODE
+
+------------------------------------------------------------------------------
+*/
+
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+#ifdef AAC_PLUS
+
+#include    "sbr_dec.h"
+
+#include    "pv_log2.h"
+#include    "fxp_mul32.h"
+
+
+#include    "sbr_reset_dec.h"
+#include    "sbr_find_start_andstop_band.h"
+#include    "sbr_update_freq_scale.h"
+#include    "sbr_downsample_lo_res.h"
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here. Include conditional
+; compile variables also.
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; LOCAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; LOCAL STORE/BUFFER/POINTER DEFINITIONS
+; Variable declaration - defined here and used outside this module
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL FUNCTION REFERENCES
+; Declare functions defined elsewhere and referenced in this module
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL GLOBAL STORE/BUFFER/POINTER REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; FUNCTION CODE
+----------------------------------------------------------------------------*/
+
+SBR_ERROR sbr_reset_dec(SBR_FRAME_DATA * hFrameData,
+                        SBR_DEC * sbrDec,
+                        Int32 upsampleFac)
+{
+
+    SBR_ERROR err = SBRDEC_OK;
+    Int lsbM;
+    Int lsb;
+    Int usb;
+    Int32 i;
+    Int32 tmp_q1;
+
+    SBR_HEADER_DATA *headerData  = &(hFrameData->sbr_header);
+    Int32           samplingFreq = sbrDec->outSampleRate;
+
+    hFrameData->reset_flag = 1;
+
+    /*Calculate master frequency function */
+    err = sbr_find_start_andstop_band(samplingFreq,
+                                      headerData->startFreq,
+                                      headerData->stopFreq,
+                                      &lsbM,
+                                      &usb);
+
+    if (err != SBRDEC_OK)
+    {
+        return err;
+    }
+
+    /* Calculate new v_k_master if needed */
+    if (headerData->masterStatus == MASTER_RESET)
+    {
+        sbr_update_freq_scale(sbrDec->V_k_master,
+                              &(sbrDec->Num_Master),
+                              lsbM,
+                              usb,
+                              headerData->freqScale,
+                              headerData->alterScale,
+                              0);
+
+    }
+
+    /*Derive Hiresolution from master frequency function*/
+
+    sbrDec->NSfb[HI] = sbrDec->Num_Master - headerData->xover_band;
+
+    for (i = headerData->xover_band; i <= sbrDec->Num_Master; i++)
+    {
+        sbrDec->FreqBandTable[HI][i-headerData->xover_band] = (Int)sbrDec->V_k_master[i];
+    }
+
+
+    if ((sbrDec->NSfb[HI] & 0x01) == 0) /* if even number of hires bands */
+    {
+
+        sbrDec->NSfb[LO] = sbrDec->NSfb[HI] >> 1;
+        /* Use every second lo-res=hi-res[0,2,4...] */
+        for (i = 0; i <= sbrDec->NSfb[LO]; i++)
+        {
+            sbrDec->FreqBandTable[LO][i] = sbrDec->FreqBandTable[HI][(i<<1)];
+        }
+    }
+    else
+    {            /* odd number of hi-res which means xover is odd */
+
+        sbrDec->NSfb[LO] = (sbrDec->NSfb[HI] + 1) >> 1;
+        /* Use lo-res=hi-res[0,1,3,5 ...] */
+        sbrDec->FreqBandTable[LO][0] = sbrDec->FreqBandTable[HI][0];
+        for (i = 1; i <= sbrDec->NSfb[LO]; i++)
+        {
+            sbrDec->FreqBandTable[LO][i] = sbrDec->FreqBandTable[HI][(i<<1)-1];
+        }
+
+    }
+
+    lsb = sbrDec->FreqBandTable[LOW_RES][0];
+    usb = sbrDec->FreqBandTable[LOW_RES][sbrDec->NSfb[LOW_RES]];
+
+    sbrDec->lowSubband  = lsb;
+    sbrDec->highSubband = usb;
+    sbrDec->noSubbands  = usb - lsb;
+
+    if ((lsb > 32) || (sbrDec->noSubbands <= 0))
+    {
+        return SBRDEC_ILLEGAL_SCFACTORS;   /* invalid bands */
+    }
+
+    /* Calculate number of noise bands */
+    if (headerData->noise_bands == 0)
+    {
+        sbrDec->NoNoiseBands = 1;
+    }
+    else /* Calculate number of noise bands 1,2 or 3 bands/octave */
+    {
+
+        if (! lsb)
+        {
+            return SBRDEC_ILLEGAL_SCFACTORS;   /* avoid div by 0 */
+        }
+
+        tmp_q1 = pv_log2((usb << 20) / lsb);
+
+        tmp_q1 = fxp_mul32_Q15(headerData->noise_bands, tmp_q1);
+
+        sbrDec->NoNoiseBands = (tmp_q1 + 16) >> 5;
+
+        if (sbrDec->NoNoiseBands == 0)
+        {
+            sbrDec->NoNoiseBands = 1;
+        }
+    }
+
+    headerData->noNoiseBands = sbrDec->NoNoiseBands;
+
+    /* Get noise bands */
+    sbr_downsample_lo_res(sbrDec->FreqBandTableNoise,
+                          sbrDec->NoNoiseBands,
+                          sbrDec->FreqBandTable[LO],
+                          sbrDec->NSfb[LO]);
+
+    sbrDec->sbStopCodec = sbrDec->lowSubband;
+
+    if (sbrDec->sbStopCodec > (upsampleFac << 5))
+    {
+        sbrDec->sbStopCodec = (upsampleFac << 5);
+    }
+
+    hFrameData->nSfb[LO] = sbrDec->NSfb[LO];
+    hFrameData->nSfb[HI] = sbrDec->NSfb[HI];
+    hFrameData->nNfb     = hFrameData->sbr_header.noNoiseBands;
+    hFrameData->offset   = ((hFrameData->nSfb[LO]) << 1) - hFrameData->nSfb[HI];
+
+    return (SBRDEC_OK);
+}
+
+#endif
+
diff --git a/media/libstagefright/codecs/aacdec/sbr_reset_dec.h b/media/libstagefright/codecs/aacdec/sbr_reset_dec.h
new file mode 100644
index 0000000..0ff94a5
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/sbr_reset_dec.h
@@ -0,0 +1,118 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Filename: sbr_reset_dec.h
+ Funtions:
+    get_dse
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+
+ Who:                                   Date: MM/DD/YYYY
+ Description:
+------------------------------------------------------------------------------
+SC 29 Software Copyright Licencing Disclaimer:
+
+This software module was originally developed by
+  Coding Technologies
+
+and edited by
+  -
+
+in the course of development of the ISO/IEC 13818-7 and ISO/IEC 14496-3
+standards for reference purposes and its performance may not have been
+optimized. This software module is an implementation of one or more tools as
+specified by the ISO/IEC 13818-7 and ISO/IEC 14496-3 standards.
+ISO/IEC gives users free license to this software module or modifications
+thereof for use in products claiming conformance to audiovisual and
+image-coding related ITU Recommendations and/or ISO/IEC International
+Standards. ISO/IEC gives users the same free license to this software module or
+modifications thereof for research purposes and further ISO/IEC standardisation.
+Those intending to use this software module in products are advised that its
+use may infringe existing patents. ISO/IEC have no liability for use of this
+software module or modifications thereof. Copyright is not released for
+products that do not conform to audiovisual and image-coding related ITU
+Recommendations and/or ISO/IEC International Standards.
+The original developer retains full right to modify and use the code for its
+own purpose, assign or donate the code to a third party and to inhibit third
+parties from using the code for products that do not conform to audiovisual and
+image-coding related ITU Recommendations and/or ISO/IEC International Standards.
+This copyright notice must be included in all copies or derivative works.
+Copyright (c) ISO/IEC 2002.
+
+ $Id: ct_envcalc.h,v 1.3 2002/11/29 16:11:49 kaehleof Exp $
+*/
+
+/*----------------------------------------------------------------------------
+; CONTINUE ONLY IF NOT ALREADY DEFINED
+----------------------------------------------------------------------------*/
+#ifndef SBR_RESET_DEC_H
+#define SBR_RESET_DEC_H
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+
+#include    "s_sbr_frame_data.h"
+#include    "sbr_dec.h"
+#include    "e_sbr_error.h"
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here.
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL VARIABLES REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; SIMPLE TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; ENUMERATED TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; STRUCTURES TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; GLOBAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+SBR_ERROR sbr_reset_dec(SBR_FRAME_DATA * hFrameData,
+                        SBR_DEC * sbrDec,
+                        Int32 upsampleFac);
+
+
+/*----------------------------------------------------------------------------
+; END
+----------------------------------------------------------------------------*/
+#endif
+
+
diff --git a/media/libstagefright/codecs/aacdec/sbr_update_freq_scale.cpp b/media/libstagefright/codecs/aacdec/sbr_update_freq_scale.cpp
new file mode 100644
index 0000000..18bd5d9
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/sbr_update_freq_scale.cpp
@@ -0,0 +1,364 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Filename: sbr_update_freq_scale.c
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+
+ Who:                                   Date: MM/DD/YYYY
+ Description:
+
+------------------------------------------------------------------------------
+ INPUT AND OUTPUT DEFINITIONS
+
+
+
+------------------------------------------------------------------------------
+ FUNCTION DESCRIPTION
+
+
+------------------------------------------------------------------------------
+ REQUIREMENTS
+
+
+------------------------------------------------------------------------------
+ REFERENCES
+
+SC 29 Software Copyright Licencing Disclaimer:
+
+This software module was originally developed by
+  Coding Technologies
+
+and edited by
+  -
+
+in the course of development of the ISO/IEC 13818-7 and ISO/IEC 14496-3
+standards for reference purposes and its performance may not have been
+optimized. This software module is an implementation of one or more tools as
+specified by the ISO/IEC 13818-7 and ISO/IEC 14496-3 standards.
+ISO/IEC gives users free license to this software module or modifications
+thereof for use in products claiming conformance to audiovisual and
+image-coding related ITU Recommendations and/or ISO/IEC International
+Standards. ISO/IEC gives users the same free license to this software module or
+modifications thereof for research purposes and further ISO/IEC standardisation.
+Those intending to use this software module in products are advised that its
+use may infringe existing patents. ISO/IEC have no liability for use of this
+software module or modifications thereof. Copyright is not released for
+products that do not conform to audiovisual and image-coding related ITU
+Recommendations and/or ISO/IEC International Standards.
+The original developer retains full right to modify and use the code for its
+own purpose, assign or donate the code to a third party and to inhibit third
+parties from using the code for products that do not conform to audiovisual and
+image-coding related ITU Recommendations and/or ISO/IEC International Standards.
+This copyright notice must be included in all copies or derivative works.
+Copyright (c) ISO/IEC 2002.
+
+------------------------------------------------------------------------------
+ PSEUDO-CODE
+
+------------------------------------------------------------------------------
+*/
+
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+
+#ifdef AAC_PLUS
+
+
+#include    "sbr_update_freq_scale.h"
+#include    "shellsort.h"
+
+#include    "pv_pow2.h"
+#include    "pv_log2.h"
+
+#include "fxp_mul32.h"
+#define R_SHIFT     30
+#define Q_fmt(x)    (Int32)(x*((Int32)1<<R_SHIFT) + (x>=0?0.5F:-0.5F))
+#define Q28fmt(x)   (Int32)(x*((Int32)1<<28) + (x>=0?0.5F:-0.5F))
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here. Include conditional
+; compile variables also.
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; LOCAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; LOCAL STORE/BUFFER/POINTER DEFINITIONS
+; Variable declaration - defined here and used outside this module
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL FUNCTION REFERENCES
+; Declare functions defined elsewhere and referenced in this module
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL GLOBAL STORE/BUFFER/POINTER REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; FUNCTION CODE
+----------------------------------------------------------------------------*/
+
+
+
+void sbr_update_freq_scale(Int32 * v_k_master,
+                           Int32 *h_num_bands,
+                           const Int32 lsbM,
+                           const Int32 usb,
+                           const Int32 freqScale,
+                           const Int32 alterScale,
+                           const Int32 channelOffset)
+{
+    Int32 i;
+    Int32 numBands = 0;
+    Int32 numBands2;
+    Int32 tmp_q1;
+
+    if (freqScale > 0) /*Bark mode*/
+    {
+        Int32 reg;
+        Int32 regions;
+        Int32 b_p_o;
+        Int32 k[3];
+        Int32 d[MAX_SECOND_REGION];
+        Int32 d2[MAX_SECOND_REGION];
+        Int32 w[2] = {Q_fmt(1.0F), Q_fmt(1.0F)};
+
+
+        k[0] = lsbM;
+        k[1] = usb;
+        k[2] = usb;
+
+        b_p_o = (freqScale == 1)  ? 12 : 8;
+        b_p_o = (freqScale == 2)  ? 10 : b_p_o;
+
+        w[1]  = (alterScale == 0) ? Q_fmt(0.5f) : Q_fmt(0.384615384615386f);
+
+        if (usb > fxp_mul32_Q28(lsbM, Q28fmt(2.2449)))
+        {
+            regions = 2;
+            k[1] = (lsbM << 1);
+        }
+        else
+        {
+            regions = 1;
+        }
+
+        *h_num_bands = 0;
+        for (reg = 0; reg < regions; reg++)
+        {
+            if (reg == 0)
+            {
+
+                tmp_q1 = pv_log2((k[1] << 20) / k[0]);
+
+                tmp_q1 = fxp_mul32_Q15(tmp_q1, b_p_o);
+                tmp_q1 = (tmp_q1 + 32) >> 6;
+
+                numBands = tmp_q1 << 1;
+
+
+                CalcBands(d, k[0], k[1], numBands);                                    /* CalcBands => d   */
+                shellsort(d, numBands);                                              /* SortBands sort d */
+                cumSum(k[0] - channelOffset,
+                       d,
+                       numBands,
+                       (v_k_master + *h_num_bands));   /* cumsum */
+
+                *h_num_bands += numBands;                                            /* Output nr of bands */
+            }
+            else
+            {
+                tmp_q1 = pv_log2((k[reg + 1] << 20) / k[reg]);
+
+                tmp_q1 = fxp_mul32_Q30(tmp_q1, w[reg]);
+                tmp_q1 = fxp_mul32_Q15(tmp_q1, b_p_o);
+                tmp_q1 = (tmp_q1 + 16) >> 5;
+
+                numBands2 = tmp_q1 << 1;
+
+                CalcBands(d2, k[reg], k[reg+1], numBands2);                            /* CalcBands => d   */
+                shellsort(d2, numBands2);                                              /* SortBands sort d */
+                if (d[numBands-1] > d2[0])
+                {
+
+                    Int32   change = d[numBands-1] - d2[0];
+                    /* Limit the change so that the last band cannot get narrower than the first one */
+                    if (change > (d2[numBands2-1] - d2[0]) >> 1)
+                    {
+                        change = (d2[numBands2-1] - d2[0]) >> 1;
+                    }
+
+                    d2[0] += change;
+                    d2[numBands2-1] -= change;
+                    shellsort(d2, numBands2);
+
+                }
+                cumSum(k[reg] - channelOffset,
+                       d2,
+                       numBands2,
+                       v_k_master + *h_num_bands);   /* cumsum */
+
+                *h_num_bands += numBands2;                                           /* Output nr of bands */
+            }
+        }
+    }
+    else
+    {                         /* Linear mode */
+        Int32     k2_achived;
+        Int32     k2_diff;
+        Int32     diff_tot[MAX_OCTAVE + MAX_SECOND_REGION];
+        Int32     dk;
+        Int32     incr = 0;
+
+
+        if (alterScale)
+        {
+            numBands = (usb - lsbM) >> 1;
+            dk = 1;
+            k2_achived = lsbM + numBands;
+        }
+        else
+        {
+            numBands = usb - lsbM;
+            if (numBands & 0x1) /* equivalent rounding */
+            {
+                numBands--;
+            }
+            dk = 2;
+            k2_achived = lsbM + (numBands << 1);
+        }
+
+        k2_diff = usb - k2_achived;
+
+        for (i = 0; i < numBands; i++)
+        {
+            diff_tot[i] = dk;
+        }
+
+        if (k2_diff < 0)        /* If linear scale wasn't achived */
+        {
+            incr = 1;           /* and we got too large SBR area */
+            i = 0;
+        }
+
+        if (k2_diff > 0)        /* If linear scale wasn't achived */
+        {
+            incr = -1;            /* and we got too small SBR area */
+            i = numBands - 1;
+        }
+
+        /* Adjust diff vector to get spec. SBR range */
+        while (k2_diff != 0)
+        {
+            diff_tot[i] -=  incr;
+            i += incr;
+            k2_diff += incr;
+        }
+
+        cumSum(lsbM,
+               diff_tot,
+               numBands,
+               v_k_master); /* cumsum */
+
+        *h_num_bands = numBands;                      /* Output nr of bands */
+    }
+}
+
+
+void CalcBands(Int32 * diff,
+               Int32 start,
+               Int32 stop,
+               Int32 num_bands)
+{
+    Int32 i;
+    Int32 previous;
+    Int32 current;
+    Int32 tmp_q1;
+
+
+    previous = start;
+
+    for (i = 1; i <= num_bands; i++)
+    {
+        /*              float temp=(start * pow( (float)stop/start, (float)i/num_bands)); */
+
+        tmp_q1 = pv_log2((stop << 20) / start);
+
+        tmp_q1 = fxp_mul32_Q20(tmp_q1, (i << 27) / num_bands);
+        tmp_q1 = pv_pow2(tmp_q1);
+
+        tmp_q1 = fxp_mul32_Q20(tmp_q1, start);
+
+        current = (tmp_q1 + 16) >> 5;
+
+        diff[i-1] = current - previous;
+        previous  = current;
+    }
+
+}  /* End CalcBands */
+
+
+void cumSum(Int32 start_value,
+            Int32 * diff,
+            Int32 length,
+            Int32 * start_adress)
+{
+    Int32 i;
+    Int32 *pt_start_adress   = start_adress;
+    Int32 *pt_start_adress_1 = start_adress;
+    Int32 *pt_diff           = diff;
+
+    if (length > 0)  /*  avoid possible error on loop */
+    {
+        *(pt_start_adress_1++) = start_value;
+
+        for (i = (length >> 1); i != 0; i--)
+        {
+            *(pt_start_adress_1++) = *(pt_start_adress++) + *(pt_diff++);
+            *(pt_start_adress_1++) = *(pt_start_adress++) + *(pt_diff++);
+        }
+
+        if (length&1)
+        {
+            *(pt_start_adress_1) = *(pt_start_adress) + *(pt_diff);
+        }
+    }
+
+}   /* End cumSum */
+
+
+#endif
diff --git a/media/libstagefright/codecs/aacdec/sbr_update_freq_scale.h b/media/libstagefright/codecs/aacdec/sbr_update_freq_scale.h
new file mode 100644
index 0000000..4acf3aa
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/sbr_update_freq_scale.h
@@ -0,0 +1,104 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Filename: sbr_update_freq_scale.h
+ Funtions:
+    get_dse
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+
+ Who:                                   Date: MM/DD/YYYY
+ Description:
+------------------------------------------------------------------------------
+
+
+ ----------------------------------------------------------------------------
+; CONTINUE ONLY IF NOT ALREADY DEFINED
+----------------------------------------------------------------------------*/
+#ifndef SBR_UPDATE_FREQ_SCALE_H
+#define SBR_UPDATE_FREQ_SCALE_H
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+#include "pv_audio_type_defs.h"
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here.
+----------------------------------------------------------------------------*/
+#define MAX_OCTAVE        29
+#define MAX_SECOND_REGION 50
+
+/*----------------------------------------------------------------------------
+; EXTERNAL VARIABLES REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; SIMPLE TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; ENUMERATED TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; STRUCTURES TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+
+/*----------------------------------------------------------------------------
+; GLOBAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+
+void sbr_update_freq_scale(Int32 * v_k_master,
+                           Int32 *h_num_bands,
+                           const Int32 lsbM,
+                           const Int32 usb,
+                           const Int32 freqScale,
+                           const Int32 alterScale,
+                           const Int32 channelOffset);
+
+
+void CalcBands(Int32 * diff,
+               Int32 start,
+               Int32 stop,
+               Int32 num_bands);
+
+void cumSum(Int32 start_value,
+            Int32 * diff,
+            Int32 length,
+            Int32 * start_adress);
+
+
+/*----------------------------------------------------------------------------
+; END
+----------------------------------------------------------------------------*/
+#endif
+
+
diff --git a/media/libstagefright/codecs/aacdec/set_mc_info.cpp b/media/libstagefright/codecs/aacdec/set_mc_info.cpp
new file mode 100644
index 0000000..5a11941
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/set_mc_info.cpp
@@ -0,0 +1,309 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Pathname: ./src/set_mc_info.c
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+ Description: Modified per review comments
+
+ Description: Change audioObjectType from Int to enum types
+
+ Who:                               Date:
+ Description:
+
+------------------------------------------------------------------------------
+ INPUT AND OUTPUT DEFINITIONS
+
+ Inputs:
+    pMC_Info    = pointer to structure MC_Info that holds information of
+                  multiple channels' configurations
+                  Data type pointer to MC_Info
+
+    objectType  = variable that holds the Audio Object Type of current
+                  file/bitstream.
+                  Data type Int
+
+    sampling_rate_idx = variable that indicates the sampling rate of the
+                        source file being encoded
+                        Data Type Int
+
+    tag         = variable that stores the element instance tag of the
+                  first (front) channel element.
+                  Data type Int
+
+    is_cpe      = variable that indicates if a Channel Pair Element (CPE)
+                  or a Single Channel Element (SCE) is used.
+                  Data type Int (maybe Boolean)
+
+    pWinSeqInfo = array of pointers that points to structures holding
+                  frame information of long and short window sequences.
+                  Data type FrameInfo
+
+    pSfbwidth128 = array that will store the scalefactor bandwidth of
+                   short window sequence frame.
+                   Data type Int array
+
+ Local Stores/Buffers/Pointers Needed:
+    None
+
+ Global Stores/Buffers/Pointers Needed:
+    None
+
+ Outputs:
+    return SUCCESS
+
+ Pointers and Buffers Modified:
+    pMC_Info->nch           contains the number of channels depending
+                            upon if CPE or SCE is used
+    pMC_Info->objectType    contents updated with the decoded Audio
+                            Object Type
+
+    pMC_Info->ch_info.tag   contents updated with the value of decoded
+                            channel element tag
+
+    PMC_Info->ch_info.cpe   contents updated depending upon if CPE or
+                            SCE is used
+
+    pWinSeqInfo             contents updated by calling infoinit if
+                            sampling_rate_idx is different from
+                            previous value
+
+    pSfbWidth128            contents updated by calling infoinit if
+                            sampling_rate_idx is different from
+                            previous value
+
+ Local Stores Modified:
+    None
+
+ Global Stores Modified:
+    None
+
+------------------------------------------------------------------------------
+ FUNCTION DESCRIPTION
+
+ This function initializes the channel configuration information. The
+ structure MC_Info stores the number of channels, channel element tag.
+ If sampling rate index is different from the previous value,
+ The frame information will be updated by calling infoinit.c
+
+------------------------------------------------------------------------------
+ REQUIREMENTS
+
+ This function shall update the relevant information on channel configs
+
+------------------------------------------------------------------------------
+ REFERENCES
+
+ (1) MPEG-2 NBC Audio Decoder
+   "This software module was originally developed by AT&T, Dolby
+   Laboratories, Fraunhofer Gesellschaft IIS in the course of development
+   of the MPEG-2 NBC/MPEG-4 Audio standard ISO/IEC 13818-7, 14496-1,2 and
+   3. This software module is an implementation of a part of one or more
+   MPEG-2 NBC/MPEG-4 Audio tools as specified by the MPEG-2 NBC/MPEG-4
+   Audio standard. ISO/IEC  gives users of the MPEG-2 NBC/MPEG-4 Audio
+   standards free license to this software module or modifications thereof
+   for use in hardware or software products claiming conformance to the
+   MPEG-2 NBC/MPEG-4 Audio  standards. Those intending to use this software
+   module in hardware or software products are advised that this use may
+   infringe existing patents. The original developer of this software
+   module and his/her company, the subsequent editors and their companies,
+   and ISO/IEC have no liability for use of this software module or
+   modifications thereof in an implementation. Copyright is not released
+   for non MPEG-2 NBC/MPEG-4 Audio conforming products.The original
+   developer retains full right to use the code for his/her own purpose,
+   assign or donate the code to a third party and to inhibit third party
+   from using the code for non MPEG-2 NBC/MPEG-4 Audio conforming products.
+   This copyright notice must be included in all copies or derivative
+   works."
+   Copyright(c)1996.
+
+  (2) ISO/IEC 14496-3: 1999(E)
+    Subpart 1   p20 Table 1.6.3
+    Subpart 4   p30 5.1.2.1
+    Subpart 4   p31 4.5.2.1.1
+
+------------------------------------------------------------------------------
+ PSEUDO-CODE
+
+    pMC_Info->nch   = 0;
+
+    pMC_Info->profile = objectType;
+
+    IF (pMC_Info->sampling_rate_idx != sampling_rate_idx)
+    THEN
+        pMC_Info->sampling_rate_idx = sampling_rate_idx;
+
+        CALL infoinit(
+                samp_rate_idx = sampling_rate_idx
+                ppWin_seq_info= pWinSeqInfo
+                pSfbwidth128  = pSfbwidth128)
+        MODIFYING(pWinSeqInfo, pSfbwidth128)
+        RETURNING(None)
+    ENDIF
+
+    pCh_Info = &pMC_Info->ch_info[0];
+    pCh_Info->tag = tag;
+
+    IF (is_cpe == FALSE)
+    THEN
+        pCh_Info->cpe = FALSE;
+
+        pMC_Info->nch = 1;
+
+    ELSE
+        pCh_Info->cpe = TRUE;
+        pCh_Info = &pMC_Info->ch_info[1];
+        pCh_Info->tag = tag;
+        pCh_Info->cpe = TRUE;
+
+        pMC_Info->nch = 2;
+
+    ENDIF
+
+    RETURN(SUCCESS)
+
+------------------------------------------------------------------------------
+ RESOURCES USED
+   When the code is written for a specific target processor the
+     the resources used should be documented below.
+
+ STACK USAGE: [stack count for this module] + [variable to represent
+          stack usage for each subroutine called]
+
+     where: [stack usage variable] = stack usage for [subroutine
+         name] (see [filename].ext)
+
+ DATA MEMORY USED: x words
+
+ PROGRAM MEMORY USED: x words
+
+ CLOCK CYCLES: [cycle count equation for this module] + [variable
+           used to represent cycle count for each subroutine
+           called]
+
+     where: [cycle count variable] = cycle count for [subroutine
+        name] (see [filename].ext)
+
+------------------------------------------------------------------------------
+*/
+
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+#include    "pv_audio_type_defs.h"
+#include    "set_mc_info.h"
+#include    "huffman.h"
+#include    "s_ch_info.h"
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here. Include conditional
+; compile variables also.
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; LOCAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; LOCAL STORE/BUFFER/POINTER DEFINITIONS
+; Variable declaration - defined here and used outside this module
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL FUNCTION REFERENCES
+; Declare functions defined elsewhere and referenced in this module
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL GLOBAL STORE/BUFFER/POINTER REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; FUNCTION CODE
+----------------------------------------------------------------------------*/
+Int set_mc_info(
+    MC_Info     *pMC_Info,
+    const tMP4AudioObjectType audioObjectType, /* used to be profile */
+    const Int    sampling_rate_idx,
+    const Int    tag,   /* always pass-in last element's value */
+    const Int    is_cpe,
+    FrameInfo   *pWinSeqInfo[],
+    Int          sfbwidth128[]
+)
+{
+    Ch_Info *pCh_Info; /*optional task: eliminate this structure */
+
+    /*
+     *   audioObjectType and sampling rate
+     *   re-configure if new sampling rate
+     *
+     */
+    pMC_Info->audioObjectType = audioObjectType;
+
+    if (pMC_Info->sampling_rate_idx != sampling_rate_idx)
+    {
+        pMC_Info->sampling_rate_idx = sampling_rate_idx;
+
+        Int status;
+        status = infoinit(sampling_rate_idx,
+                          pWinSeqInfo,
+                          sfbwidth128);
+        if (SUCCESS != status)
+        {
+            return 1;
+        }
+    }
+
+    /*
+     * first setup values for mono config, Single Channel Element (SCE)
+     * then if stereo, go inside if(is_cpe != FALSE) branch to setup
+     * values for stereo.
+     * set the channel counts
+     * save tag for left channel
+     */
+    pMC_Info->nch   = 1 + is_cpe;
+
+    pCh_Info = &pMC_Info->ch_info[0];
+    pCh_Info->tag = tag;
+    pCh_Info->cpe = is_cpe;
+
+    /* This if branch maybe deleted in the future */
+    if (is_cpe != FALSE)
+    {
+        /* Channel Pair Element (CPE) */
+        /* right channel*/
+        pCh_Info = &pMC_Info->ch_info[1];
+        pCh_Info->cpe = TRUE;
+
+    }
+
+    return(SUCCESS); /* possible future error checkings */
+}
diff --git a/media/libstagefright/codecs/aacdec/set_mc_info.h b/media/libstagefright/codecs/aacdec/set_mc_info.h
new file mode 100644
index 0000000..8043b3b
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/set_mc_info.h
@@ -0,0 +1,98 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Pathname: ./include/set_mc_info.h
+
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+ Description: (1) use enum type for audioObjectType (2) update revision history
+
+ Who:                       Date:
+ Description:
+
+------------------------------------------------------------------------------
+ INCLUDE DESCRIPTION
+
+ This file includes function declaration for set_mc_info.c
+
+------------------------------------------------------------------------------
+*/
+
+/*----------------------------------------------------------------------------
+; CONTINUE ONLY IF NOT ALREADY DEFINED
+----------------------------------------------------------------------------*/
+#ifndef SET_MC_INFO_H
+#define SET_MC_INFO_H
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+#include    "pv_audio_type_defs.h"
+#include    "s_mc_info.h"
+#include    "s_frameinfo.h"
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here.
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL VARIABLES REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; SIMPLE TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; ENUMERATED TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; STRUCTURES TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; GLOBAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+Int set_mc_info(
+    MC_Info     *pMC_Info,
+    const tMP4AudioObjectType objectType, /* used to be profile */
+    const Int    sampling_rate_idx,
+    const Int    tag,   /* always pass-in last element's value */
+    const Int    is_cpe,
+    FrameInfo   *pWinSeqInfo[],
+    Int          pSfbwidth128[]
+);
+
+/*----------------------------------------------------------------------------
+; END
+----------------------------------------------------------------------------*/
+#endif
+
+
diff --git a/media/libstagefright/codecs/aacdec/sfb.cpp b/media/libstagefright/codecs/aacdec/sfb.cpp
new file mode 100644
index 0000000..f2d3a3e
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/sfb.cpp
@@ -0,0 +1,275 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Pathname: ./src/sfb.c
+
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+ Description: created to define the scalefactor bands for all sampling rates
+
+ Description: Change short to Int16
+
+ Description: Modified structure to avoid assigning addresses to constant
+              tables. This solve linking problem when using the
+              /ropi option (Read-only position independent) for some
+              compilers
+              - Eliminated redundant vector sfb_96_128.
+              - Eliminated references to contant vector addresses in
+                samp_rate_info
+
+ Who:                              Date:
+ Description:
+
+------------------------------------------------------------------------------
+ INPUT AND OUTPUT DEFINITIONS
+
+ Inputs:
+
+ Local Stores/Buffers/Pointers Needed:
+
+ Global Stores/Buffers/Pointers Needed:
+
+ Outputs:
+
+ Pointers and Buffers Modified:
+
+
+ Local Stores Modified:
+
+ Global Stores Modified:
+
+------------------------------------------------------------------------------
+ FUNCTION DESCRIPTION
+
+ This function defines the scalefactor bands for all sampling rates
+
+------------------------------------------------------------------------------
+ REQUIREMENTS
+
+
+------------------------------------------------------------------------------
+ REFERENCES
+
+ (1) ISO/IEC 14496-3: 1999(E)
+    Subpart 4       p66     (sfb tables)
+                    p111    (4.6.10)
+                    p200    (Annex 4.B.5)
+
+------------------------------------------------------------------------------
+ PSEUDO-CODE
+
+------------------------------------------------------------------------------
+ RESOURCES USED
+   When the code is written for a specific target processor the
+     the resources used should be documented below.
+
+ STACK USAGE: [stack count for this module] + [variable to represent
+          stack usage for each subroutine called]
+
+     where: [stack usage variable] = stack usage for [subroutine
+         name] (see [filename].ext)
+
+ DATA MEMORY USED: x words
+
+ PROGRAM MEMORY USED: x words
+
+ CLOCK CYCLES: [cycle count equation for this module] + [variable
+           used to represent cycle count for each subroutine
+           called]
+
+     where: [cycle count variable] = cycle count for [subroutine
+        name] (see [filename].ext)
+
+------------------------------------------------------------------------------
+*/
+
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+#include    "pv_audio_type_defs.h"
+#include    "sfb.h"
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here. Include conditional
+; compile variables also.
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; LOCAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; LOCAL STORE/BUFFER/POINTER DEFINITIONS
+; Variable declaration - defined here and used outside this module
+----------------------------------------------------------------------------*/
+const Int16 sfb_96_1024[] =
+{
+    4, 8, 12, 16, 20, 24, 28,
+    32, 36, 40, 44, 48, 52, 56,
+    64, 72, 80, 88, 96, 108, 120,
+    132, 144, 156, 172, 188, 212, 240,
+    276, 320, 384, 448, 512, 576, 640,
+    704, 768, 832, 896, 960, 1024
+};         /* 41 scfbands */
+
+const Int16 sfb_64_1024[] =
+{
+    4, 8, 12, 16, 20, 24, 28,
+    32, 36, 40, 44, 48, 52, 56,
+    64, 72, 80, 88, 100, 112, 124,
+    140, 156, 172, 192, 216, 240, 268,
+    304, 344, 384, 424, 464, 504, 544,
+    584, 624, 664, 704, 744, 784, 824,
+    864, 904, 944, 984, 1024
+};               /* 41 scfbands 47 */
+
+const Int16 sfb_64_128[] =
+{
+    4, 8, 12, 16, 20, 24, 32,
+    40, 48, 64, 92, 128
+};                   /* 12 scfbands */
+
+
+const Int16 sfb_48_1024[] =
+{
+    4,  8,  12, 16, 20, 24, 28,
+    32, 36, 40, 48, 56, 64, 72,
+    80, 88, 96, 108,    120,    132,    144,
+    160,    176,    196,    216,    240,    264,    292,
+    320,    352,    384,    416,    448,    480,    512,
+    544,    576,    608,    640,    672,    704,    736,
+    768,    800,    832,    864,    896,    928,    1024
+};
+/* 49  scfbands*/
+
+const Int16 sfb_48_128[] =
+{
+    4,  8,  12, 16, 20, 28, 36,
+    44, 56, 68, 80, 96, 112, 128
+};         /* 14 scfbands */
+
+const Int16 sfb_32_1024[] =
+{
+    4,  8,  12, 16, 20, 24, 28,
+    32, 36, 40, 48, 56, 64, 72,
+    80, 88, 96, 108,    120,    132,    144,
+    160,    176,    196,    216,    240,    264,    292,
+    320,    352,    384,    416,    448,    480,    512,
+    544,    576,    608,    640,    672,    704,    736,
+    768,    800,    832,    864,    896,    928,    960,
+    992,    1024
+};                         /* 51 scfbands */
+
+const Int16 sfb_24_1024[] =
+{
+    4, 8, 12, 16, 20, 24, 28,
+    32, 36, 40, 44, 52, 60, 68,
+    76, 84, 92, 100, 108, 116, 124,
+    136, 148, 160, 172, 188, 204, 220,
+    240, 260, 284, 308, 336, 364, 396,
+    432, 468, 508, 552, 600, 652, 704,
+    768, 832, 896, 960, 1024
+};              /* 47 scfbands */
+
+const Int16 sfb_24_128[] =
+{
+    4, 8, 12, 16, 20, 24, 28,
+    36, 44, 52, 64, 76, 92, 108,
+    128
+};                                   /* 15 scfbands */
+
+const Int16 sfb_16_1024[] =
+{
+    8, 16, 24, 32, 40, 48, 56,
+    64, 72, 80, 88, 100, 112, 124,
+    136, 148, 160, 172, 184, 196, 212,
+    228, 244, 260, 280, 300, 320, 344,
+    368, 396, 424, 456, 492, 532, 572,
+    616, 664, 716, 772, 832, 896, 960,
+    1024
+};                                  /* 43 scfbands */
+
+const Int16 sfb_16_128[] =
+{
+    4, 8, 12, 16, 20, 24, 28,
+    32, 40, 48, 60, 72, 88, 108,
+    128
+};                                   /* 15 scfbands */
+
+const Int16 sfb_8_1024[] =
+{
+    12, 24, 36, 48, 60, 72, 84,
+    96, 108, 120, 132, 144, 156, 172,
+    188, 204, 220, 236, 252, 268, 288,
+    308, 328, 348, 372, 396, 420, 448,
+    476, 508, 544, 580, 620, 664, 712,
+    764, 820, 880, 944, 1024
+};               /* 40 scfbands */
+
+const Int16 sfb_8_128[] =
+{
+    4, 8, 12, 16, 20, 24, 28,
+    36, 44, 52, 60, 72, 88, 108,
+    128
+};                                   /* 15 scfbands */
+
+const SR_Info samp_rate_info[12] =
+{
+    /* sampling_frequency, #long sfb, #short sfb */
+    /* samp_rate, nsfb1024, nsfb128 */
+    {96000, 41, 12},       /* 96000 */
+    {88200, 41, 12},       /* 88200 */
+    {64000, 47, 12},       /* 64000 */
+    {48000, 49, 14},       /* 48000 */
+    {44100, 49, 14},       /* 44100 */
+    {32000, 51, 14},       /* 32000 */
+    {24000, 47, 15},       /* 24000 */
+    {22050, 47, 15},       /* 22050 */
+    {16000, 43, 15},       /* 16000 */
+    {12000, 43, 15},       /* 12000 */
+    {11025, 43, 15},       /* 11025 */
+    { 8000, 40, 15},       /* 8000  */
+};
+
+
+/*----------------------------------------------------------------------------
+; EXTERNAL FUNCTION REFERENCES
+; Declare functions defined elsewhere and referenced in this module
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL GLOBAL STORE/BUFFER/POINTER REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; FUNCTION CODE
+----------------------------------------------------------------------------*/
+
+
diff --git a/media/libstagefright/codecs/aacdec/sfb.h b/media/libstagefright/codecs/aacdec/sfb.h
new file mode 100644
index 0000000..0cc1707
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/sfb.h
@@ -0,0 +1,117 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Pathname: sfb.h
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+ Description: created to declare scalefactor bands for all sampling rates
+
+ Description: Change short to Int16
+
+ Description: Eliminated declaration of sfb_96_128 array, values are equal
+              to array sfb_64_128
+
+------------------------------------------------------------------------------
+ INCLUDE DESCRIPTION
+
+ this file declares the scalefactor bands for all sampling rates
+
+------------------------------------------------------------------------------
+*/
+
+
+/*----------------------------------------------------------------------------
+; CONTINUE ONLY IF NOT ALREADY DEFINED
+----------------------------------------------------------------------------*/
+#ifndef SFB_H
+#define SFB_H
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+#include    "pv_audio_type_defs.h"
+#include    "s_sr_info.h"
+#include    "e_progconfigconst.h"
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here.
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL VARIABLES REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+extern  const Int16 sfb_96_1024[];  /* 41 scfbands */
+
+extern const Int16 sfb_64_1024[];  /* 41 scfbands 47 */
+
+extern const Int16 sfb_64_128[];  /* 12 scfbands */
+
+
+extern const Int16 sfb_48_1024[]; /* 49 scfbands */
+
+extern const Int16 sfb_48_128[];  /* 14 scfbands */
+
+extern const Int16 sfb_32_1024[];  /* 51 scfbands */
+
+extern const Int16 sfb_24_1024[];  /* 47 scfbands */
+
+extern const Int16 sfb_24_128[];  /* 15 scfbands */
+
+extern const Int16 sfb_16_1024[];  /* 43 scfbands */
+
+extern const Int16 sfb_16_128[];  /* 15 scfbands */
+
+extern const Int16 sfb_8_1024[];  /* 40 scfbands */
+
+extern const Int16 sfb_8_128[];  /* 15 scfbands */
+
+extern const SR_Info samp_rate_info[12];
+
+/*----------------------------------------------------------------------------
+; SIMPLE TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; ENUMERATED TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; STRUCTURES TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; GLOBAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; END
+----------------------------------------------------------------------------*/
+#endif
+
+
diff --git a/media/libstagefright/codecs/aacdec/shellsort.cpp b/media/libstagefright/codecs/aacdec/shellsort.cpp
new file mode 100644
index 0000000..5feb803
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/shellsort.cpp
@@ -0,0 +1,138 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Filename: shellsort.c
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+
+ Who:                                   Date: MM/DD/YYYY
+ Description:
+
+------------------------------------------------------------------------------
+ INPUT AND OUTPUT DEFINITIONS
+
+
+
+------------------------------------------------------------------------------
+ FUNCTION DESCRIPTION
+
+        Sorting routine
+------------------------------------------------------------------------------
+ REQUIREMENTS
+
+
+------------------------------------------------------------------------------
+ REFERENCES
+
+
+
+------------------------------------------------------------------------------
+ PSEUDO-CODE
+
+------------------------------------------------------------------------------
+*/
+
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+
+#ifdef AAC_PLUS
+
+
+#include "shellsort.h"
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here. Include conditional
+; compile variables also.
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; LOCAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; LOCAL STORE/BUFFER/POINTER DEFINITIONS
+; Variable declaration - defined here and used outside this module
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL FUNCTION REFERENCES
+; Declare functions defined elsewhere and referenced in this module
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL GLOBAL STORE/BUFFER/POINTER REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; FUNCTION CODE
+----------------------------------------------------------------------------*/
+
+
+void shellsort(Int32 in[], Int32 n)
+{
+
+    Int32     i;
+    Int32     j;
+    Int32     v;
+    Int32     inc = 1;
+
+    do
+    {
+        inc = 3 * inc + 1;
+    }
+    while (inc <= n);
+
+    do
+    {
+        inc = inc / 3;
+        for (i = inc + 1; i <= n; i++)
+        {
+            v = in[i-1];
+            j = i;
+            while (in[j-inc-1] > v)
+            {
+                in[j-1] = in[j-inc-1];
+                j -= inc;
+                if (j <= inc)
+                {
+                    break;
+                }
+            }
+            in[j-1] = v;
+        }
+    }
+    while (inc > 1);
+
+}
+
+#endif
+
diff --git a/media/libstagefright/codecs/aacdec/shellsort.h b/media/libstagefright/codecs/aacdec/shellsort.h
new file mode 100644
index 0000000..a4658e3
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/shellsort.h
@@ -0,0 +1,84 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Filename: shellsort.h
+ Funtions:
+    get_dse
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+
+ Who:                                   Date: MM/DD/YYYY
+ Description:
+------------------------------------------------------------------------------
+
+
+ ----------------------------------------------------------------------------
+; CONTINUE ONLY IF NOT ALREADY DEFINED
+----------------------------------------------------------------------------*/
+#ifndef SHELLSORT_H
+#define SHELLSORT_H
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+#include "pv_audio_type_defs.h"
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here.
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL VARIABLES REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; SIMPLE TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; ENUMERATED TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; STRUCTURES TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+
+/*----------------------------------------------------------------------------
+; GLOBAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+
+void shellsort(Int32 in[], Int32 n);
+
+/*----------------------------------------------------------------------------
+; END
+----------------------------------------------------------------------------*/
+#endif
+
+
diff --git a/media/libstagefright/codecs/aacdec/stereo_2_mono.h b/media/libstagefright/codecs/aacdec/stereo_2_mono.h
new file mode 100644
index 0000000..3e27c70
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/stereo_2_mono.h
@@ -0,0 +1,97 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Pathname: stereo_2_mono.h
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+ Who:                       Date:
+ Description:
+
+------------------------------------------------------------------------------
+ INCLUDE DESCRIPTION
+
+ Header file for the declaration of the function stereo_2_mono()
+
+------------------------------------------------------------------------------
+*/
+
+/*----------------------------------------------------------------------------
+; CONTINUE ONLY IF NOT ALREADY DEFINED
+----------------------------------------------------------------------------*/
+#ifndef STEREO_2_MONO_H
+#define STEREO_2_MONO_H
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+    /*----------------------------------------------------------------------------
+    ; INCLUDES
+    ----------------------------------------------------------------------------*/
+#include "pv_audio_type_defs.h"
+
+    /*----------------------------------------------------------------------------
+    ; MACROS
+    ; Define module specific macros here
+    ----------------------------------------------------------------------------*/
+
+    /*----------------------------------------------------------------------------
+    ; DEFINES
+    ; Include all pre-processor statements here.
+    ----------------------------------------------------------------------------*/
+
+    /*----------------------------------------------------------------------------
+    ; EXTERNAL VARIABLES REFERENCES
+    ; Declare variables used in this module but defined elsewhere
+    ----------------------------------------------------------------------------*/
+
+    /*----------------------------------------------------------------------------
+    ; SIMPLE TYPEDEF'S
+    ----------------------------------------------------------------------------*/
+
+    /*----------------------------------------------------------------------------
+    ; ENUMERATED TYPEDEF'S
+    ----------------------------------------------------------------------------*/
+
+    /*----------------------------------------------------------------------------
+    ; STRUCTURES TYPEDEF'S
+    ----------------------------------------------------------------------------*/
+
+    /*----------------------------------------------------------------------------
+    ; GLOBAL FUNCTION DEFINITIONS
+    ; Function Prototype declaration
+    ----------------------------------------------------------------------------*/
+    void stereo_2_mono(
+        const Int16   sourceLeft[],
+        const Int16   sourceRight[],
+        Int16   outputBuffer[],
+        const Int     sourcePointsPerChannel);
+
+    /*----------------------------------------------------------------------------
+    ; END
+    ----------------------------------------------------------------------------*/
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* STEREO_2_MONO_H */
+
diff --git a/media/libstagefright/codecs/aacdec/synthesis_sub_band.cpp b/media/libstagefright/codecs/aacdec/synthesis_sub_band.cpp
new file mode 100644
index 0000000..c1418e3
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/synthesis_sub_band.cpp
@@ -0,0 +1,483 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Filename: synthesis_sub_band.c
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+
+ Who:                                   Date: MM/DD/YYYY
+ Description:
+
+------------------------------------------------------------------------------
+ INPUT AND OUTPUT DEFINITIONS
+
+    Int32 vec[],            Input vector, 32-bit
+    const Int32 *cosTerms,  Cosine Terms
+    Int32 *scratch_mem      Scratch memory
+
+
+------------------------------------------------------------------------------
+ FUNCTION DESCRIPTION
+
+    Implement root squared of a number
+
+------------------------------------------------------------------------------
+ REQUIREMENTS
+
+
+------------------------------------------------------------------------------
+ REFERENCES
+
+------------------------------------------------------------------------------
+ PSEUDO-CODE
+
+------------------------------------------------------------------------------
+*/
+
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+
+#ifdef AAC_PLUS
+
+
+#include "pv_audio_type_defs.h"
+#include "fxp_mul32.h"
+#include "dct64.h"
+#include "synthesis_sub_band.h"
+#include "mdst.h"
+#include "dct16.h"
+
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here. Include conditional
+; compile variables also.
+----------------------------------------------------------------------------*/
+
+#define Qfmt_30(x)   (Int32)(x*((Int32)(1<<30)) + (x>=0?0.5F:-0.5F))
+#define Qfmt_25(x)   (Int32)(x*((Int32)(1<<25))*(1.5625F) + (x>=0?0.5F:-0.5F))
+
+#define SCALE_DOWN_LP   Qfmt_30(0.075000F)  /* 3/40 */
+#define SCALE_DOWN_HQ     Qfmt_30(0.009375F*0.64F)  /* 3/40 * 1/8 */
+
+/*----------------------------------------------------------------------------
+; LOCAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; LOCAL STORE/BUFFER/POINTER DEFINITIONS
+; Variable declaration - defined here and used outside this module
+----------------------------------------------------------------------------*/
+
+const Int32 CosTable_64[64] =
+{
+    Qfmt_25(0.50003765191555F),   Qfmt_25(40.74468810335183F),   Qfmt_25(0.50033903744282F),   Qfmt_25(13.58429025728446F),
+    Qfmt_25(0.50094271763809F),   Qfmt_25(8.15384860246681F),   Qfmt_25(0.50185051748424F),   Qfmt_25(5.82768837784465F),
+    Qfmt_25(0.50306519130137F),   Qfmt_25(4.53629093696936F),   Qfmt_25(0.50459044322165F),   Qfmt_25(3.71524273832697F),
+    Qfmt_25(0.50643095492855F),   Qfmt_25(3.14746219178191F),   Qfmt_25(0.50859242104981F),   Qfmt_25(2.73164502877394F),
+    Qfmt_25(0.51108159270668F),   Qfmt_25(2.41416000025008F),   Qfmt_25(0.51390632984754F),   Qfmt_25(2.16395781875198F),
+    Qfmt_25(0.51707566313349F),   Qfmt_25(1.96181784857117F),   Qfmt_25(0.52059986630189F),   Qfmt_25(1.79520521907789F),
+    Qfmt_25(0.52449054011472F),   Qfmt_25(1.65559652426412F),   Qfmt_25(0.52876070920749F),   Qfmt_25(1.53699410085250F),
+    Qfmt_25(0.53342493339713F),   Qfmt_25(1.43505508844143F),   Qfmt_25(0.53849943529198F),   Qfmt_25(1.34655762820629F),
+    Qfmt_25(0.54400224638178F),   Qfmt_25(1.26906117169912F),   Qfmt_25(0.54995337418324F),   Qfmt_25(1.20068325572942F),
+    Qfmt_25(0.55637499348989F),   Qfmt_25(1.13994867510150F),   Qfmt_25(0.56329166534170F),   Qfmt_25(1.08568506425801F),
+    Qfmt_25(0.57073058801215F),   Qfmt_25(1.03694904091039F),   Qfmt_25(0.57872188513482F),   Qfmt_25(0.99297296126755F),
+    Qfmt_25(0.58729893709379F),   Qfmt_25(0.95312587439212F),   Qfmt_25(0.59649876302446F),   Qfmt_25(0.91688444618465F),
+    Qfmt_25(0.60636246227215F),   Qfmt_25(0.88381100455962F),   Qfmt_25(0.61693572600507F),   Qfmt_25(0.85353675100661F),
+    Qfmt_25(0.62826943197077F),   Qfmt_25(0.82574877386279F),   Qfmt_25(0.64042033824166F),   Qfmt_25(0.80017989562169F),
+    Qfmt_25(0.65345189537513F),   Qfmt_25(0.77660065823396F),   Qfmt_25(0.66743520092634F),   Qfmt_25(0.75481293911653F),
+    Qfmt_25(0.68245012597642F),   Qfmt_25(0.73464482364786F),   Qfmt_25(0.69858665064723F),   Qfmt_25(0.71594645497057F),
+};
+
+
+/*----------------------------------------------------------------------------
+; EXTERNAL FUNCTION REFERENCES
+; Declare functions defined elsewhere and referenced in this module
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL GLOBAL STORE/BUFFER/POINTER REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; FUNCTION CODE
+----------------------------------------------------------------------------*/
+
+
+
+void synthesis_sub_band_LC(Int32 Sr[], Int16 data[])
+{
+
+    Int32 *temp_o1 = (Int32 *) & data[0];
+
+    Int   i;
+    Int32 *pt_temp_e;
+    Int32 *pt_temp_o = temp_o1;
+    Int32 *pt_temp_x = &Sr[63];
+    Int32 temp1;
+    Int32 temp2;
+    Int32 temp3;
+    Int32 temp11;
+
+    Int16 *pt_data_1;
+    Int16 *pt_data_2;
+
+    Int32 *pt_Sr_1 = Sr;
+    Int16 tmp1;
+    Int16 tmp2;
+    Int16 tmp11;
+    Int16 tmp22;
+    const Int32 *pt_cosTerms = CosTable_48;
+
+
+    temp2 = *(pt_temp_x--);
+    for (i = 20; i != 0; i--)
+    {
+        temp1 = *(pt_Sr_1);
+        temp3 = *(pt_cosTerms++);
+        *(pt_Sr_1++) =   temp1  + temp2;
+        *(pt_temp_o++) = fxp_mul32_Q31((temp1 - temp2), temp3) << 1;
+        temp2 = *(pt_temp_x--);
+    }
+
+    for (i = 12; i != 0; i--)
+    {
+        temp1 = *(pt_Sr_1);
+        temp3 = *(pt_cosTerms++);
+        *(pt_Sr_1++) =   temp1  + temp2;
+        *(pt_temp_o++) = fxp_mul32_Q26((temp1 - temp2), temp3);
+        temp2 = *(pt_temp_x--);
+    }
+
+
+    pv_split_LC(temp_o1, &Sr[32]);
+
+    dct_16(temp_o1, 1);     // Even terms
+    dct_16(&Sr[32], 1);     // Odd  terms
+
+    /* merge */
+
+
+    pt_Sr_1 = &temp_o1[31];
+    pt_temp_e   =  &temp_o1[15];
+    pt_temp_o   =  &Sr[47];
+
+    temp1 = *(pt_temp_o--);
+    *(pt_Sr_1--) = temp1;
+    for (i = 5; i != 0; i--)
+    {
+        temp2 = *(pt_temp_o--);
+        *(pt_Sr_1--) = *(pt_temp_e--);
+        *(pt_Sr_1--) = temp1 + temp2;
+        temp3 = *(pt_temp_o--);
+        *(pt_Sr_1--) = *(pt_temp_e--);
+        *(pt_Sr_1--) = temp2 + temp3;
+        temp1 = *(pt_temp_o--);
+        *(pt_Sr_1--) = *(pt_temp_e--);
+        *(pt_Sr_1--) = temp1 + temp3;
+    }
+
+
+    pv_split_LC(Sr, &Sr[32]);
+
+    dct_16(Sr, 1);     // Even terms
+    dct_16(&Sr[32], 1);     // Odd  terms
+
+
+    pt_temp_x   =  &temp_o1[31];
+    pt_temp_e   =  &Sr[15];
+    pt_temp_o   =  &Sr[47];
+
+    pt_data_1 = &data[95];
+
+    temp2  = *(pt_temp_x--);
+    temp11 = *(pt_temp_x--);
+    temp1  = *(pt_temp_o--);
+
+    *(pt_data_1--) = (Int16) fxp_mul32_Q31(temp2, SCALE_DOWN_LP);
+    *(pt_data_1--) = (Int16) fxp_mul32_Q31(temp1, SCALE_DOWN_LP);
+
+    for (i = 5; i != 0; i--)
+    {
+        *(pt_data_1--) = (Int16) fxp_mul32_Q31((temp11 + temp2), SCALE_DOWN_LP);
+        temp3         = *(pt_temp_x--);
+        *(pt_data_1--) = (Int16) fxp_mul32_Q31(*(pt_temp_e--), SCALE_DOWN_LP);
+        temp2          = *(pt_temp_o--);
+        *(pt_data_1--) = (Int16) fxp_mul32_Q31((temp11 + temp3), SCALE_DOWN_LP);
+        temp11         = *(pt_temp_x--);
+        *(pt_data_1--) = (Int16) fxp_mul32_Q31((temp1 + temp2), SCALE_DOWN_LP);
+
+
+        *(pt_data_1--) = (Int16) fxp_mul32_Q31((temp11 + temp3), SCALE_DOWN_LP);
+        temp1         = *(pt_temp_x--);
+        *(pt_data_1--) = (Int16) fxp_mul32_Q31(*(pt_temp_e--), SCALE_DOWN_LP);
+        temp3          = *(pt_temp_o--);
+        *(pt_data_1--) = (Int16) fxp_mul32_Q31((temp11 + temp1), SCALE_DOWN_LP);
+        temp11         = *(pt_temp_x--);
+        *(pt_data_1--) = (Int16) fxp_mul32_Q31((temp2 + temp3), SCALE_DOWN_LP);
+
+
+        *(pt_data_1--) = (Int16) fxp_mul32_Q31((temp11 + temp1), SCALE_DOWN_LP);
+        temp2         = *(pt_temp_x--);
+        *(pt_data_1--) = (Int16) fxp_mul32_Q31(*(pt_temp_e--), SCALE_DOWN_LP);
+        temp1          = *(pt_temp_o--);
+        *(pt_data_1--) = (Int16) fxp_mul32_Q31((temp11 + temp2), SCALE_DOWN_LP);
+        temp11         = *(pt_temp_x--);
+        *(pt_data_1--) = (Int16) fxp_mul32_Q31((temp1 + temp3), SCALE_DOWN_LP);
+    }
+
+    *(pt_data_1--) = (Int16) fxp_mul32_Q31((temp11 + temp2), SCALE_DOWN_LP);
+    *(pt_data_1--) = (Int16) fxp_mul32_Q31(*(pt_temp_e), SCALE_DOWN_LP);
+
+    /* ---- merge ends---- */
+
+
+    pt_data_1 = &data[95];
+    pt_data_2 = &data[96];
+
+    *(pt_data_2++) =   0;
+    tmp1  =  *(pt_data_1--);
+    tmp2  =  *(pt_data_1--);
+    tmp11 =  *(pt_data_1--);
+    tmp22 =  *(pt_data_1--);
+
+    for (i = 7; i != 0; i--)
+    {
+        *(pt_data_2++) = (-tmp1);
+        *(pt_data_2++) = (-tmp2);
+        *(pt_data_2++) = (-tmp11);
+        *(pt_data_2++) = (-tmp22);
+        tmp1  =  *(pt_data_1--);
+        tmp2  =  *(pt_data_1--);
+        tmp11 =  *(pt_data_1--);
+        tmp22 =  *(pt_data_1--);
+    }
+
+
+    *(pt_data_2++) = (-tmp1);
+    *(pt_data_2++) = (-tmp2);
+    *(pt_data_2++) = (-tmp11);
+
+    pt_data_2 = &data[0];
+
+    *(pt_data_2++) =  tmp22;
+    tmp1  =  *(pt_data_1--);
+    tmp2  =  *(pt_data_1--);
+    tmp11 =  *(pt_data_1--);
+    tmp22 =  *(pt_data_1--);
+
+    for (i = 7; i != 0; i--)
+    {
+        *(pt_data_2++) =  tmp1;
+        *(pt_data_2++) =  tmp2;
+        *(pt_data_2++) =  tmp11;
+        *(pt_data_2++) =  tmp22;
+        tmp1  =  *(pt_data_1--);
+        tmp2  =  *(pt_data_1--);
+        tmp11 =  *(pt_data_1--);
+        tmp22 =  *(pt_data_1--);
+    }
+
+    *(pt_data_2++) =  tmp1;
+    *(pt_data_2++) =  tmp2;
+    *(pt_data_2++) =  tmp11;
+    *(pt_data_2)   =  tmp22;
+
+}
+
+
+void synthesis_sub_band_LC_down_sampled(Int32 Sr[], Int16 data[])
+{
+
+    Int i ;
+    Int16 *pt_data_1;
+
+    pt_data_1 = &data[0];
+
+    dct_32(Sr);
+
+    for (i = 0; i < 16; i++)
+    {
+        pt_data_1[   i] = (Int16)(Sr[16-i] >> 5);
+        pt_data_1[16+i] = (Int16)(Sr[i] >> 5);
+        pt_data_1[32+i] = (Int16)(Sr[16+i] >> 5);
+    }
+    for (i = 0; i < 15; i++)
+    {
+        pt_data_1[49+i] = (Int16)(-Sr[31-i] >> 5);
+    }
+    pt_data_1[48] = 0;
+}
+
+
+#ifdef HQ_SBR
+
+void synthesis_sub_band(Int32 Sr[], Int32 Si[], Int16 data[])
+{
+
+
+    Int32 i ;
+    Int16 *pt_data_1;
+    Int16 *pt_data_2;
+    Int32 *pt_Sr_1;
+    Int32 *pt_Sr_2;
+    Int32 *pt_Si_1;
+    Int32 *pt_Si_2;
+
+    Int32 tmp1;
+    Int32 tmp2;
+    Int32 tmp3;
+    Int32 tmp4;
+
+    Int32 cosx;
+    const Int32 *pt_CosTable = CosTable_64;
+
+
+    pt_Sr_1 = &Sr[0];
+    pt_Sr_2 = &Sr[63];
+
+    pt_Si_1 = &Si[0];
+    pt_Si_2 = &Si[63];
+
+
+    tmp3 = *pt_Sr_1;
+
+    for (i = 32; i != 0; i--)
+    {
+        tmp4 = *pt_Si_2;
+        cosx = *(pt_CosTable++);
+        *(pt_Sr_1++) = fxp_mul32_Q31(tmp3, cosx);
+        tmp3 = *pt_Si_1;
+        *(pt_Si_1++) = fxp_mul32_Q31(tmp4, cosx);
+        tmp4 = *pt_Sr_2;
+        cosx = *(pt_CosTable++);
+        *(pt_Si_2--) = fxp_mul32_Q31(tmp3, cosx);
+        *(pt_Sr_2--) = fxp_mul32_Q31(tmp4, cosx);
+        tmp3 = *pt_Sr_1;
+    }
+
+
+    dct_64(Sr, (Int32 *)data);
+    dct_64(Si, (Int32 *)data);
+
+
+    pt_data_1 = &data[0];
+    pt_data_2 = &data[127];
+
+    pt_Sr_1 = &Sr[0];
+    pt_Si_1 = &Si[0];
+
+    tmp1 = *(pt_Sr_1++);
+    tmp3 = *(pt_Sr_1++);
+    tmp2 = *(pt_Si_1++);
+    tmp4 = *(pt_Si_1++);
+
+    for (i = 32; i != 0; i--)
+    {
+        *(pt_data_1++) = (Int16) fxp_mul32_Q31((tmp2 - tmp1), SCALE_DOWN_HQ);
+        *(pt_data_1++) = (Int16) fxp_mul32_Q31(-(tmp3 + tmp4), SCALE_DOWN_HQ);
+        *(pt_data_2--) = (Int16) fxp_mul32_Q31((tmp1 + tmp2), SCALE_DOWN_HQ);
+        *(pt_data_2--) = (Int16) fxp_mul32_Q31((tmp3 - tmp4), SCALE_DOWN_HQ);
+
+        tmp1 = *(pt_Sr_1++);
+        tmp3 = *(pt_Sr_1++);
+        tmp2 = *(pt_Si_1++);
+        tmp4 = *(pt_Si_1++);
+    }
+
+}
+
+
+const Int32 exp_m0_25_phi[32] =
+{
+
+    0x7FFEFE6E,  0x7FEAFB4A, 0x7FC2F827, 0x7F87F505,
+    0x7F38F1E4,  0x7ED6EEC6, 0x7E60EBAB, 0x7DD6E892,
+    0x7D3AE57D,  0x7C89E26D, 0x7BC6DF61, 0x7AEFDC59,
+    0x7A06D958,  0x790AD65C, 0x77FBD367, 0x76D9D079,
+    0x75A6CD92,  0x7460CAB2, 0x7308C7DB, 0x719EC50D,
+    0x7023C248,  0x6E97BF8C, 0x6CF9BCDA, 0x6B4BBA33,
+    0x698CB796,  0x67BDB505, 0x65DEB27F, 0x63EFB005,
+    0x61F1AD97,  0x5FE4AB36, 0x5DC8A8E2, 0x5B9DA69C
+};
+
+void synthesis_sub_band_down_sampled(Int32 Sr[], Int32 Si[], Int16 data[])
+{
+
+    Int16 k;
+    Int16 *pt_data_1;
+    Int32 exp_m0_25;
+    const Int32 *pt_exp = exp_m0_25_phi;
+
+    Int32 *XX = Sr;
+    Int32 *YY = (Int32 *)data;
+    Int32 tmp1;
+    Int32 tmp2;
+
+    for (k = 0; k < 32; k++)
+    {
+        exp_m0_25 = *(pt_exp++);
+        tmp1 = Sr[k];
+        tmp2 = Si[k];
+        XX[k]    = cmplx_mul32_by_16(-tmp1,  tmp2, exp_m0_25);
+        YY[31-k] = cmplx_mul32_by_16(tmp2,  tmp1, exp_m0_25);
+    }
+
+    mdct_32(XX);
+    mdct_32(YY);
+
+    for (k = 0; k < 32; k++)
+    {
+        Si[k] = YY[k];
+    }
+
+    pt_data_1 = data;
+
+    for (k = 0; k < 16; k++)
+    {
+        *(pt_data_1++)  = (Int16)((XX[2*k  ] + Si[2*k  ]) >> 14);
+        *(pt_data_1++)  = (Int16)((XX[2*k+1] - Si[2*k+1]) >> 14);
+    }
+
+    for (k = 15; k > -1; k--)
+    {
+        *(pt_data_1++)  = (Int16)(-(XX[2*k+1] + Si[2*k+1]) >> 14);
+        *(pt_data_1++)  = (Int16)(-(XX[2*k  ] - Si[2*k  ]) >> 14);
+    }
+
+}
+
+
+#endif      /* HQ_SBR */
+
+#endif      /*  AAC_PLUS */
+
+
diff --git a/media/libstagefright/codecs/aacdec/synthesis_sub_band.h b/media/libstagefright/codecs/aacdec/synthesis_sub_band.h
new file mode 100644
index 0000000..042c488
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/synthesis_sub_band.h
@@ -0,0 +1,78 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Pathname: synthesis_sub_band.h
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+ Who:                                       Date:
+ Description:
+------------------------------------------------------------------------------
+ INCLUDE DESCRIPTION
+
+------------------------------------------------------------------------------
+*/
+
+#ifndef SYNTHESIS_SUB_BAND_H
+#define SYNTHESIS_SUB_BAND_H
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+
+#include "pv_audio_type_defs.h"
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+
+    /*----------------------------------------------------------------------------
+    ; EXTERNAL VARIABLES REFERENCES
+    ----------------------------------------------------------------------------*/
+
+    /*----------------------------------------------------------------------------
+    ; DEFINES AND SIMPLE TYPEDEF'S
+    ----------------------------------------------------------------------------*/
+
+
+    void synthesis_sub_band_LC(Int32 Sr[], Int16 data[]);
+    void synthesis_sub_band_LC_down_sampled(Int32 Sr[], Int16 data[]);
+
+
+#ifdef HQ_SBR
+
+    void synthesis_sub_band(Int32 Sr[], Int32 Si[], Int16 data[]);
+    void synthesis_sub_band_down_sampled(Int32 Sr[], Int32 Si[], Int16 data[]);
+
+#endif
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif  /* SYNTHESIS_SUB_BAND_H */
+
diff --git a/media/libstagefright/codecs/aacdec/tns_ar_filter.cpp b/media/libstagefright/codecs/aacdec/tns_ar_filter.cpp
new file mode 100644
index 0000000..db31a63
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/tns_ar_filter.cpp
@@ -0,0 +1,474 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Pathname: tns_ar_filter.c
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+ Description:  Modified from original shareware code
+
+ Description:  Implemented 24-bit fixed point version
+               Optimized C code
+
+ Description:
+            - Added OVERFLOW_SHIFT_DOWN to avoid overflow.
+            - Increased precision by using the Q format of the LPC coefficient.
+            - Modified interface to add LPC Q format and scratch memory
+              for the state variables.
+            - Added pv_memset to clear state filter
+            - Updated format for comments (to PV standard)
+            - Updated copyright notice
+
+ Description:
+            - Changed multiplication scheme to increase precision. This
+              works better than older version.
+
+ Description:
+            - Include log2(order) as a scaling down parameter.
+
+ Description:
+            Modified to reflect code review comments
+                - misspelled words, extra comments and explicit requirements
+
+ Description:
+            deleted comment about fix Q format (L 107)
+
+ Description:  Implemented a more efficient version, which eliminated the use
+ of "scratch memory" via introducing a pointer that references the actual
+ output.
+
+ Description: Removed the parameter "scratch_Int32_buffer" as this space
+ in memory is no longer needed by this function.
+
+ Description: Removed references to "scratch_Int32_buffer" in the Inputs
+ section.
+
+ Description:
+    Modified casting to ensure proper operations for different platforms
+
+ Description:
+    Per code review comment:
+    Eliminated casting to UInt and Int in b_low and b_high, they are
+    redundant and may add unncessary extra cycles in some platforms
+
+ Description: Updated the SW template to include the full pathname to the
+ source file and a slightly modified copyright header.
+
+ Description: Changed the order of the unsigned * signed multiply so the
+ casting to Int32 is performed on the unsigned operand.
+
+ Description:
+    Modified 32 by 16 bit multiplications to avoid unnecessary moves to
+    registers. Also split the code (based on flag direction) to simplify
+    pointer's updates
+
+ Description:
+
+------------------------------------------------------------------------------
+ INPUT AND OUTPUT DEFINITIONS
+
+ Inputs:
+    spec  = spectral input to be shaped by the filter.
+            Fixed point format
+            Int32[]
+            length = spec_length
+
+    spec_length  = length of spec array.
+            const Int
+
+    direction = direction for application of tns filter.
+                +1  filters spectrum from low to high frequencies
+                    (first input to filter is spec[0])
+                -1  filters spectrum from high to low frequencies
+                    (first input to filter is spec[spec_length-1])
+                const Int
+
+    lpc   = array of lpc coefficients, minus lpc[0] which is assumed to be "1"
+            Fixed point format
+            const Int[]
+            length = TNS_MAX_ORDER
+
+    Q_lpc = Q format for the lpc coeffcients (for max. precision, it assumes
+            that all 16 bits are used)
+            const Int
+
+    order = order of the TNS filter (Range of 1 - TNS_MAX_ORDER)
+            Int
+
+ Local Stores/Buffers/Pointers Needed:
+    None
+
+ Global Stores/Buffers/Pointers Needed:
+    None
+
+ Outputs:
+    None
+
+ Pointers and Buffers Modified:
+    spec = contains spectral data after application of TNS filter
+           Int32 array
+           length = spec_length
+
+
+ Local Stores Modified:
+
+ Global Stores Modified:
+
+
+------------------------------------------------------------------------------
+ FUNCTION DESCRIPTION
+
+    A block of spectral data (Int32 spec[]) of length (const Int spec_length)
+    is processed by a simple all-pole filter defined by
+    LPC coefficients passed via (const Int lpc[])
+
+    TNS filter equation
+        y(n) =  x(n) - lpc(2)*y(n-1) - ... - lpc(order+1)*y(n-order)
+
+    The filter calculation is performed in place, i.e. the output is passed
+    back to the calling function via (Int32 spec[])
+
+    The filter's order is defined by the variable (const Int order)
+    The direction of the filter's application is defined by (const Int inc)
+
+------------------------------------------------------------------------------
+ REQUIREMENTS
+
+    This function should match the functionality of the ISO code.
+    The implementation does support filter orders bigger or equal to 1.
+    The size of the spectral coeffcients has to be bigger or equal than 1.
+
+------------------------------------------------------------------------------
+ REFERENCES
+
+ (1) ISO/IEC 14496-3:1999(E)
+     Part 3
+        Subpart 4.6.8 (Temporal Noise Shaping)
+
+ (2) MPEG-2 NBC Audio Decoder
+   "This software module was originally developed by AT&T, Dolby
+   Laboratories, Fraunhofer Gesellschaft IIS in the course of development
+   of the MPEG-2 NBC/MPEG-4 Audio standard ISO/IEC 13818-7, 14496-1,2 and
+   3. This software module is an implementation of a part of one or more
+   MPEG-2 NBC/MPEG-4 Audio tools as specified by the MPEG-2 NBC/MPEG-4
+   Audio standard. ISO/IEC  gives users of the MPEG-2 NBC/MPEG-4 Audio
+   standards free license to this software module or modifications thereof
+   for use in hardware or software products claiming conformance to the
+   MPEG-2 NBC/MPEG-4 Audio  standards. Those intending to use this software
+   module in hardware or software products are advised that this use may
+   infringe existing patents. The original developer of this software
+   module and his/her company, the subsequent editors and their companies,
+   and ISO/IEC have no liability for use of this software module or
+   modifications thereof in an implementation. Copyright is not released
+   for non MPEG-2 NBC/MPEG-4 Audio conforming products.The original
+   developer retains full right to use the code for his/her  own purpose,
+   assign or donate the code to a third party and to inhibit third party
+   from using the code for non MPEG-2 NBC/MPEG-4 Audio conforming products.
+   This copyright notice must be included in all copies or derivative
+   works."
+   Copyright(c)1996.
+
+------------------------------------------------------------------------------
+ PSEUDO-CODE
+
+
+    FOR (i=0; i<order; i++)
+        state[i] = 0;
+    ENDFOR
+
+    IF (inc == -1)
+    THEN
+        spec = spec + spec_length - 1;
+    ENDIF
+
+    FOR (i=0; i<spec_length; i++)
+
+        y = *spec;
+
+        FOR (j=0; j<order; j++)
+
+            y -= lpc[j] * state[j];
+
+        ENDFOR
+
+        FOR (j=order-1; j>0; j--)
+
+            state[j] = state[j-1];
+
+        ENDFOR
+
+        state[0] = y;
+
+        *spec = y;
+
+        spec = spec + inc;
+
+    ENDFOR
+
+
+------------------------------------------------------------------------------
+ RESOURCES USED
+
+   When the code is written for a specific target processor
+     the resources used should be documented below.
+
+ STACK USAGE: [stack count for this module] + [variable to represent
+          stack usage for each subroutine called]
+
+     where: [stack usage variable] = stack usage for [subroutine
+         name] (see [filename].ext)
+
+ DATA MEMORY USED: x words
+
+ PROGRAM MEMORY USED: x words
+
+ CLOCK CYCLES: [cycle count equation for this module] + [variable
+           used to represent cycle count for each subroutine
+           called]
+
+     where: [cycle count variable] = cycle count for [subroutine
+        name] (see [filename].ext)
+
+------------------------------------------------------------------------------
+*/
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+#include "pv_audio_type_defs.h"
+#include "e_tns_const.h"
+#include "tns_ar_filter.h"
+#include "fxp_mul32.h"
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here. Include conditional
+; compile variables also.
+----------------------------------------------------------------------------*/
+#define MASK_LOW16               0xFFFF
+#define UPPER16                      16
+
+/*----------------------------------------------------------------------------
+; LOCAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; LOCAL STORE/BUFFER/POINTER DEFINITIONS
+; Variable declaration - defined here and used outside this module
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL FUNCTION REFERENCES
+; Declare functions defined elsewhere and referenced in this module
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL GLOBAL STORE/BUFFER/POINTER REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; FUNCTION CODE
+----------------------------------------------------------------------------*/
+
+Int tns_ar_filter(
+    Int32 spec[],
+    const Int spec_length,
+    const Int direction,
+    const Int32 lpc[],
+    const Int Q_lpc,
+    const Int order)
+{
+
+    Int i;
+    Int j;
+
+    /*
+     * Multiplication related variables
+     */
+
+    Int32 temp;
+
+    /*
+     *  Filter related variables
+     */
+    Int32 y0;
+
+    /*
+     *  Circular buffer to hold the filter's state
+     *  (y[n-1],y[n-2],y[n-3],etc.)
+     *
+     *  p_state and p_lpc should take advantage
+     *  of any special circular buffer instructions
+     *  if this code is hand-optimized in assembly.
+     */
+
+    Int32 *p_state = NULL;
+
+    const Int32 *p_lpc;
+
+
+    Int shift_up;
+    Int shift_down_amount;
+
+    /*
+     *  Pointer to the I/O memory space
+     */
+    Int32 *p_spec = spec;
+
+
+    i = 0;
+    j = order;
+
+    /*
+     *  get the power of 2 that is bigger than the order
+     *  i is the bit counter and j is modified until exceed
+     *  the power of 2 corresponding to TNS_MAX_ORDER
+     */
+
+    while (j < 0x010)
+    {
+        j <<= 1;
+        i++;
+    }
+
+    /*
+     *  5 is the number of bits needed to represent 0x010
+     *  TNS_MAX_ORDER = 20, power of 2 that include 20 is 5
+     */
+    shift_down_amount = 4 - i;
+
+    shift_up = UPPER16 - Q_lpc;
+
+    /*
+     *  shift_down_amount == power of 2 that is bigger than the order - 1
+     */
+
+    shift_down_amount += shift_up;
+
+    if (direction == -1)
+    {
+        p_spec += spec_length - 1;
+
+        for (i = order; i != 0; i--)
+        {
+
+            y0 = *p_spec >> shift_down_amount;
+
+            p_lpc = lpc;
+
+            /* 32 by 32 bit multiplication */
+            for (j = order; j > i; j--)
+            {
+                temp = *p_state++;
+                y0 -= fxp_mul32_Q31(temp, *(p_lpc++)) << shift_up;
+            }
+
+            /*
+            * Record the output in-place
+            */
+            p_state     = p_spec;
+            *(p_spec--) = y0;
+
+        }
+
+        if (spec_length > order)
+        {
+            for (i = (spec_length - order); i != 0; i--)
+            {
+                y0 = *p_spec >> shift_down_amount;
+
+                p_lpc = &(lpc[0]);
+
+                /* 32 by 32 bit multiplication */
+                for (j = order; j != 0; j--)
+                {
+                    temp = *p_state++;
+                    y0 -= fxp_mul32_Q31(temp, *(p_lpc++)) << shift_up;
+                }
+
+                /*
+                 * Record the output in-place
+                 */
+                p_state     = p_spec;
+                *(p_spec--) = y0;
+
+            } /* END for (i = (spec_length - order); i>0; i--) */
+        }
+
+    }
+    else
+    {
+        for (i = order; i != 0; i--)
+        {
+
+            p_lpc =  lpc;
+
+            y0 = 0;
+
+            /* 32 by 32 bit multiplication */
+            for (j = order; j > i; j--)
+            {
+                y0 -= fxp_mul32_Q31(*p_state--, *(p_lpc++));
+            }
+
+            p_state     = p_spec;
+            /*
+            * Record the output in-place
+            */
+            *(p_spec) = (*p_spec >> shift_down_amount) + (y0 << shift_up);
+            p_spec++;
+        }
+
+        if (spec_length > order)
+        {
+            for (i = (spec_length - order); i != 0; i--)
+            {
+                p_lpc =  lpc;
+
+                y0 = 0;
+
+                /* 32 by 32 bit multiplication */
+                for (j = order; j != 0; j--)
+                {
+                    y0 -= fxp_mul32_Q31(*p_state--, *(p_lpc++));
+                }
+
+                p_state     = p_spec;
+                /*
+                 * Record the output in-place
+                 */
+                *(p_spec) = (*p_spec >> shift_down_amount) + (y0 << shift_up);
+                p_spec++;
+
+            } /* END for (i = (spec_length - order); i>0; i--) */
+        }
+    }
+
+    return(shift_down_amount);
+
+
+} /* tns_ar_filter */
diff --git a/media/libstagefright/codecs/aacdec/tns_ar_filter.h b/media/libstagefright/codecs/aacdec/tns_ar_filter.h
new file mode 100644
index 0000000..2538b4d
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/tns_ar_filter.h
@@ -0,0 +1,104 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Pathname: tns_ar_filter.h
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+ Description: Per request of JT, the lpc coefficients q-format will now
+ be transmitted to the function.
+
+ Description: Removed the parameter "scratch_Int32_buffer" as this space
+ in memory is no longer needed by this function.
+
+ Who:                       Date:
+ Description:
+------------------------------------------------------------------------------
+ INCLUDE DESCRIPTION
+
+ This function includes the function declaration for tns_ar_filter()
+
+------------------------------------------------------------------------------
+*/
+
+/*----------------------------------------------------------------------------
+; CONTINUE ONLY IF NOT ALREADY DEFINED
+----------------------------------------------------------------------------*/
+#ifndef TNS_AR_FILTER_H
+#define TNS_AR_FILTER_H
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+#include "e_tns_const.h"
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here.
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL VARIABLES REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; SIMPLE TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; ENUMERATED TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; STRUCTURES TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; GLOBAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+    Int tns_ar_filter(
+        Int32 spec[],
+        const Int spec_length,
+        const Int inc,
+        const Int32 lpc[],
+        const Int lpc_qformat,
+        const Int order);
+
+#ifdef __cplusplus
+}
+#endif
+
+/*----------------------------------------------------------------------------
+; END
+----------------------------------------------------------------------------*/
+#endif
diff --git a/media/libstagefright/codecs/aacdec/tns_decode_coef.cpp b/media/libstagefright/codecs/aacdec/tns_decode_coef.cpp
new file mode 100644
index 0000000..366cce5
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/tns_decode_coef.cpp
@@ -0,0 +1,500 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Pathname: tns_decode_coef.c
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+ Description:  Modified from original shareware code
+
+ Description:  Implemented in 16-bit Fixed Point
+
+ Description:  Implemented in 24-bit Fixed Point
+
+ Description:  Modified to return the calculated LPC coefficients "in place"
+ This saves memory, cycles, etc. because it saves a large temporary
+ array being declared on the stack in another function (tns_setup_filter)
+
+ Description:  Modified to return the q-format of the lpc coefficients.
+
+ Description:  Modified for more reliable overflow protection.  tns_decode_coef
+ no longer relies on "reasonable" outputs.  This code should handle all
+ possible inputs.
+
+ Description:  Modified per review comments.
+
+ Description:  Added check condition to avoid numbers with a Q bigger than
+        15 from being passed, otherwise in a 16-bit number the sign is lost.
+
+ Description:  Modified to utilize scratch memory techniques, thereby
+ eliminating two arrays of size TNS_MAX_ORDER, which were previously declared
+ on the stack.
+
+ Description: Updated the SW template to include the full pathname to the
+ source file and a slightly modified copyright header.
+
+ Description:
+ (1) Changed the order of the unsigned * signed multiply so the
+     casting to Int32 is performed on the unsigned operand.
+
+ (2) Removed some unnecessary casting.
+ (3) Fixed a problem where a 16-bit value was casted to 32-bits AFTER
+     a shift.  It should have been cast to 32-bits BEFORE the shifting.
+
+
+ Description:  modified precision of coefficients
+
+ Who:                                   Date:
+ Description:
+------------------------------------------------------------------------------
+ INPUT AND OUTPUT DEFINITIONS
+
+ The inputs and their range are defined in ISO/IEC 14496-3:1999(E)
+                                            Part 3 MPEG-4 Audio
+                                            Subpart 4
+
+ Inputs:       order    = RANGE = 1-20
+               const Int
+
+               coef_res = RANGE = 0-1
+               const Int
+
+               lpc_coef = RANGE = -8 to 7 if coef_res = 1   compression OFF
+                                  -4 to 3 if coef_res = 1   compression ON
+                                  -4 to 3 if coef_res = 0   compression OFF
+                                  -2 to 1 if coef_res = 0   compression ON
+
+               [Int *, length TNS_MAX_ORDER]
+
+ Global Stores/Buffers/Pointers Needed:
+    None
+
+ Outputs:
+    q_lpc     = q_format for the calculated LPC coefs.
+    Int
+
+ Pointers and Buffers Modified:
+    lpc_coef  = used to return the calculated LPC coefs in-place.
+    Int *
+
+ Global Stores Modified:
+    None
+
+------------------------------------------------------------------------------
+ FUNCTION DESCRIPTION
+
+This function calculates the LPC coefs from the encoded coefs...
+
+------------------------------------------------------------------------------
+ REQUIREMENTS
+
+This function should match the functionality of the ISO source code within
+a reasonable tolerance for fixed point errors.
+
+------------------------------------------------------------------------------
+ REFERENCES
+
+ (1) ISO/IEC 14496-3:1999(E)
+     Part 3
+        Subpart 4.6.8 (Temporal Noise Shaping)
+ (2) Markel & Gray Page 95
+     As referenced in the ISO source code
+
+ (3) MPEG-2 NBC Audio Decoder
+   "This software module was originally developed by AT&T, Dolby
+   Laboratories, Fraunhofer Gesellschaft IIS in the course of development
+   of the MPEG-2 NBC/MPEG-4 Audio standard ISO/IEC 13818-7, 14496-1,2 and
+   3. This software module is an implementation of a part of one or more
+   MPEG-2 NBC/MPEG-4 Audio tools as specified by the MPEG-2 NBC/MPEG-4
+   Audio standard. ISO/IEC  gives users of the MPEG-2 NBC/MPEG-4 Audio
+   standards free license to this software module or modifications thereof
+   for use in hardware or software products claiming conformance to the
+   MPEG-2 NBC/MPEG-4 Audio  standards. Those intending to use this software
+   module in hardware or software products are advised that this use may
+   infringe existing patents. The original developer of this software
+   module and his/her company, the subsequent editors and their companies,
+   and ISO/IEC have no liability for use of this software module or
+   modifications thereof in an implementation. Copyright is not released
+   for non MPEG-2 NBC/MPEG-4 Audio conforming products.The original
+   developer retains full right to use the code for his/her  own purpose,
+   assign or donate the code to a third party and to inhibit third party
+   from using the code for non MPEG-2 NBC/MPEG-4 Audio conforming products.
+   This copyright notice must be included in all copies or derivative
+   works."
+   Copyright(c)1996.
+
+------------------------------------------------------------------------------
+*/
+
+/*----------------------------------------------------------------------------
+ PSEUDOCODE:  (ISO Reference Code)
+
+    int i, m;
+    Real iqfac, iqfac_m;
+    Real lpc_fp[TNS_MAX_ORDER+1];
+    Real sin_result_fp[TNS_MAX_ORDER+1], b[TNS_MAX_ORDER+1];
+
+    Inverse quantization
+    iqfac   = (Real)(((1 << (coef_res-1)) - 0.5) / (PI/2.0));
+    iqfac_m = (Real)(((1 << (coef_res-1)) + 0.5) / (PI/2.0));
+
+    for (i=0; i<order; i++)
+    {
+        sin_result[i+1] =
+        (Real)sin( coef[i] / ((coef[i] >= 0) ? iqfac : iqfac_m) );
+    }
+
+    lpc[0] = 1;
+    for (m=1; m<=order; m++)
+    {
+
+        b[0] = lpc[0];
+        for (i=1; i<m; i++)
+        {
+            b[i] = sin_result[m] * lpc[m-i];
+            b[i] += lpc[i];
+        }
+
+        b[m] = sin_result[m];
+
+
+        for (i=0; i<=m; i++)
+        {
+            lpc[i] = b[i];
+        }
+
+    }
+
+    return;
+
+}
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+#include "pv_audio_type_defs.h"
+#include "e_tns_const.h"
+#include "tns_decode_coef.h"
+#include "fxp_mul32.h"
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here. Include conditional
+; compile variables also.
+----------------------------------------------------------------------------*/
+#define MASK_LOW16  0xffff
+#define UPPER16     16
+
+/*----------------------------------------------------------------------------
+; LOCAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; LOCAL VARIABLE DEFINITIONS
+; Variable declaration - defined here and used outside this module
+----------------------------------------------------------------------------*/
+/*
+ * Derivation of tns_tables and q_tns_tables
+ *
+ * As defined in the ISO source code
+ * (with the modification that our coef_res has a range[0,1]
+ * The ISO code has a range of [3,4])
+ *
+ *               pi / 2                              pi / 2
+ * iqfac =  --------------------      iqfac_m =  --------------------
+ *          (coef_res + 2) - 1/                  (coef_res + 2) + 1/
+ *         2                 /2                 2                 /2
+ *
+ *
+ * ... Move 1/2 into denominator
+ *
+ *              pi                                   pi
+ * iqfac =  --------------------      iqfac_m =  --------------------
+ *          (coef_res + 3)                        (coef_res + 3)
+ *         2               - 1                   2              + 1
+ *
+ *
+ * if a coef is negative, it is multiplied by iqfac_m
+ *           if positive, "   "     "         iqfac
+ *
+ * The range of coefs is limited to  -4:3 if coef_res = 0
+ *                                   -8:7 if coef_res = 1
+ *
+ *
+ *
+ */
+
+
+const Int32 tns_table[2][16] =
+{
+    {
+        -2114858546,  -1859775393,  -1380375881,  -734482665,
+        0,    931758235,   1678970324,  2093641749
+    },
+    {
+        -2138322861,  -2065504841,  -1922348530,  -1713728946,
+        -1446750378,  -1130504462,   -775760571,   -394599085,
+        0,    446486956,    873460290,   1262259218,
+        1595891361,   1859775393,   2042378317,   2135719508
+    }
+};
+
+
+const Int neg_offset[2] = {4, 8};
+/*----------------------------------------------------------------------------
+; EXTERNAL FUNCTION REFERENCES
+; Declare functions defined elsewhere and referenced in this module
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL VARIABLES REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+ FUNCTION NAME: tns_decode_coef
+    Decoder transmitted coefficients for one TNS filter
+----------------------------------------------------------------------------*/
+
+Int tns_decode_coef(
+    const Int   order,
+    const Int   coef_res,
+    Int32 lpc_coef[TNS_MAX_ORDER],
+    Int32 scratchTnsDecCoefMem[2*TNS_MAX_ORDER])
+{
+
+    /* Simple loop counters */
+    Int i;
+    Int m;
+
+    /* Arrays for calculation of the LPC */
+    Int32 *pB = &(scratchTnsDecCoefMem[TNS_MAX_ORDER]);
+
+    Int32 *pA = scratchTnsDecCoefMem;
+
+    Int32 *temp_ptr = NULL;
+
+    /* Pointer for reading/storing the lpc_coef in place */
+    Int32 *pLPC;
+    Int q_lpc = Q_LPC;
+
+    /* TNS table related variables */
+    const Int32 *pTnsTable;
+    Int coef_offset;
+    Int32 table_index;
+    Int shift_amount;
+    Int32 sin_result;
+
+    Int32 tempInt32;
+
+    Int32 max;
+    Int32 mask;
+
+    Int32 mult_high;
+
+    /* Conversion to LPC coefficients Ref. (2) */
+    coef_offset = neg_offset[coef_res];
+    pTnsTable   = tns_table[coef_res];
+
+    m = 0;
+    pLPC = lpc_coef;
+
+
+    /*
+     *  Conversion to LPC coefficients
+     */
+
+    do
+    {
+        table_index = coef_offset + *(pLPC++);
+
+        /* Equiv. to sin_result  = tns_table[coef_res][table_index]; */
+        sin_result = *(pTnsTable + table_index);
+
+        /* sin_result has a range of -0.999 to +0.999 in Q-31 */
+
+        /*
+         * It is important that this for loop is not entered on the first
+         * iteration of the do-while( m < order ) loop.
+         */
+        for (i = m; i > 0; i--)
+        {
+
+            /*
+             * temp_ptr used to optimize index into pA
+             * mult = (Int32)( pA[m-i] * sin_result);
+             */
+
+            mult_high = fxp_mul32_Q31(*(temp_ptr--), sin_result);
+
+            /*
+             *  pB[i] = pA[i] + sin_result * pA[m-i]
+             *
+             *  (mult_high <<1)  eliminates extra sign bit
+             */
+
+            *(pB++) =  *(pA++) + (mult_high << 1);
+
+        } /* END for (i=m; i > 0; i--) */
+
+
+        /* Shift to place pB[m] in q_lpc format */
+
+        *pB =  sin_result >> 12;
+
+        /*
+         * Swapping the pointers here has the same effect
+         * as specifically copying the data from b to a
+         */
+
+        temp_ptr = pA;
+        pA       = pB;
+        pB       = temp_ptr;
+
+        /*
+         *  At this point, pA = pA[m]
+         *             and pB = pB[m]
+         */
+        temp_ptr = pA;
+
+        tempInt32 = *(pA);
+
+        mask = tempInt32 >> 31;
+        tempInt32 ^= mask;
+
+        max = tempInt32;
+
+        /*
+         * It is important that this for loop is not entered on the first
+         * iteration of the do-while( m < order ) loop.
+         */
+        for (i = m; i > 0; i--)
+        {
+            tempInt32 = *(--pA);
+
+            mask = tempInt32 >> 31;
+            tempInt32 ^= mask;
+
+            max |= tempInt32;
+        }
+
+        pB -= m;
+
+        /*
+         * Here, pA = &(pA[0])
+         * and   pB = &(pB[0])
+         */
+
+        if (max >= 0x40000000L)
+        {
+            max >>= 1;
+
+            for (i = m; i > 0; i--)
+            {
+                *(pA++) >>= 1;
+                *(pB++) >>= 1;
+            }
+
+            /* Shift the most recent entry down also */
+            *(pA) >>= 1;
+
+            q_lpc--;
+
+            pA -= m;
+            pB -= m;
+        }
+
+        m++;
+
+    }
+    while (m < order);
+
+
+    /*
+     * The following code compacts
+     * 32-bit LPC coefficients into 16-bit numbers,
+     * shifting by the minimum amount necessary.
+     */
+
+    shift_amount = 0;
+
+    while (max > 32767)
+    {
+        max >>= 1;
+        shift_amount++;
+    }
+
+    /*
+     * This while loop is for protective purposes only.
+     * I have not found data that causes it to be entered.
+     *
+     */
+    if (max != 0)
+    {
+        while (max < 16384)
+        {
+            max <<= 1;
+            shift_amount--;
+        }
+    }
+
+
+    pLPC = lpc_coef;
+
+    if (shift_amount >= 0)
+    {
+
+        for (m = order; m > 0; m--)
+        {
+            *(pLPC++) = *(pA++) << (16 - shift_amount);
+        }
+    }
+
+
+    q_lpc -= shift_amount;
+
+    /*
+     *  make sure that the numbers have some meaning, q_lpc can not be
+     *  bigger than 15 (15 bits + sign)
+     */
+
+    if (q_lpc > 15)
+    {
+        shift_amount = q_lpc - 15;
+        pLPC = lpc_coef;
+
+        for (m = order; m > 0; m--)
+        {
+            *(pLPC++) >>= shift_amount;
+        }
+
+        q_lpc -= shift_amount;
+    }
+
+    return (q_lpc);
+
+} /* tns_decode_coef */
diff --git a/media/libstagefright/codecs/aacdec/tns_decode_coef.h b/media/libstagefright/codecs/aacdec/tns_decode_coef.h
new file mode 100644
index 0000000..a6bac6c
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/tns_decode_coef.h
@@ -0,0 +1,115 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Pathname: tns_decode_coef.h
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+ Description: Modified to return the LPC coefficients in-place, so the
+ interface to tns_decode_coef is changed.
+
+ Description: Modified to return the q-format of the LPC coefficients.
+
+ Description: Modified so that only the function is declared here.  extern
+ references to constant tables removed.  Also, new copyright header included.
+
+ Description: Modified to include extra parameter, so tns_decode_coef can use
+ scratch memory techniques.
+
+ Description:
+ (1) Modified to include the lines...
+
+    #ifdef __cplusplus
+    extern "C" {
+    #endif
+
+    #ifdef __cplusplus
+    }
+    #endif
+
+ (2) Updated the copyright header.
+
+ Who:                       Date:
+ Description:
+------------------------------------------------------------------------------
+ INCLUDE DESCRIPTION
+
+ This function includes the function declaration for tns_decode_coef()
+
+------------------------------------------------------------------------------
+*/
+
+/*----------------------------------------------------------------------------
+; CONTINUE ONLY IF NOT ALREADY DEFINED
+----------------------------------------------------------------------------*/
+#ifndef TNS_DECODE_COEF_H
+#define TNS_DECODE_COEF_H
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+    /*----------------------------------------------------------------------------
+    ; INCLUDES
+    ----------------------------------------------------------------------------*/
+
+    /*----------------------------------------------------------------------------
+    ; MACROS
+    ; Define module specific macros here
+    ----------------------------------------------------------------------------*/
+
+    /*----------------------------------------------------------------------------
+    ; DEFINES
+    ; Include all pre-processor statements here.
+    ----------------------------------------------------------------------------*/
+
+    /*----------------------------------------------------------------------------
+    ; EXTERNAL VARIABLES REFERENCES
+    ; Declare variables used in this module but defined elsewhere
+    ----------------------------------------------------------------------------*/
+
+    /*----------------------------------------------------------------------------
+    ; SIMPLE TYPEDEF'S
+    ----------------------------------------------------------------------------*/
+
+    /*----------------------------------------------------------------------------
+    ; ENUMERATED TYPEDEF'S
+    ----------------------------------------------------------------------------*/
+
+    /*----------------------------------------------------------------------------
+    ; STRUCTURES TYPEDEF'S
+    ----------------------------------------------------------------------------*/
+
+    /*----------------------------------------------------------------------------
+    ; GLOBAL FUNCTION DEFINITIONS
+    ; Function Prototype declaration
+    ----------------------------------------------------------------------------*/
+    Int tns_decode_coef(
+        const Int   order,
+        const Int   coef_res,
+        Int32 lpc_coef[],
+        Int32 scratchTnsDecCoefMem[]);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* TNS_DECODE_COEF */
diff --git a/media/libstagefright/codecs/aacdec/tns_inv_filter.cpp b/media/libstagefright/codecs/aacdec/tns_inv_filter.cpp
new file mode 100644
index 0000000..631f887
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/tns_inv_filter.cpp
@@ -0,0 +1,421 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Pathname: tns_inv_filter.c
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+ Description: Changes made per review comments.
+
+ Description: As requested by JT, the q-format for the LPC coefficients is
+ now passed via the parameter lpc_qformat.
+
+ Description: For speed, the calculation of the shift amount was pulled
+ outside of the loop.
+
+ Description:
+    Modified casting to ensure proper operations for different platforms
+
+ Description:
+    Simplified MAC operations for filter by eliminating extra variables
+
+ Who:                       Date:
+ Description:
+
+------------------------------------------------------------------------------
+ INPUT AND OUTPUT DEFINITIONS
+
+ Inputs:
+
+    coef           = spectral input to be shaped by the filter.
+                     Fixed point format
+                     [Int32[], length = num_coef]
+
+    num_coef       = length of spec array.
+                     [const Int]
+
+    direction      = direction for application of tns filter.
+                     +1 applies forward filter
+                     (first input to filter is coef[0])
+                     -1 applies reversed filter
+                     (first input to filter is coef[num_coef-1])
+                     [const Int]
+
+    lpc            = array of lpc coefficients.
+                     Fixed point format Q-11
+                     [const Int[], length = TNS_MAX_ORDER]
+
+    lpc_qformat    = The q-format of the lpc coefficients.
+                     [const Int]
+
+    order          = order of the TNS filter (Range of 1 : TNS_MAX_ORDER)
+                     [const Int]
+
+    scratch_memory = scratch_memory needed for filter operation
+                     [Int[], length = TNS_MAX_ORDER]
+
+ Local Stores/Buffers/Pointers Needed:
+    None
+
+ Global Stores/Buffers/Pointers Needed:
+    None
+
+ Outputs:
+    None
+
+ Pointers and Buffers Modified:
+    coef = contains spectral data after application of TNS filter
+           q-format is not modified.
+           Int32 array
+           length = num_coef
+
+ Local Stores Modified:
+    None
+
+ Global Stores Modified:
+    None
+
+------------------------------------------------------------------------------
+ FUNCTION DESCRIPTION
+
+    A block of spectral data (Int32 coef[]) of length (const Int num_coef)
+    is processed by a simple all-zero filter defined by
+    LPC coefficients passed via (const Int lpc[])
+
+    TNS filter equation
+        y(n) =  x(n) + lpc(2)*x(n-1) + ... + lpc(order+1)*x(n-order)
+
+    The filter calculation is performed in place, i.e. the output is passed
+    back to the calling function via (Int32 coef[])
+
+    In order to avoid overflow, the filter input (Int32 coef[]) must utilize
+    only the lower 16-bits.  The upper 16-bits must be available.
+
+    The filter's order is defined by the variable (const Int order)
+
+    The direction of the filter's application is defined by
+    (const Int direction)
+
+------------------------------------------------------------------------------
+ REQUIREMENTS
+
+    [Int32 coef] must store no more than 16 bits of data.
+
+    This is required to utilize methods that do not change the q-format of
+    the input data [Int32 coef], and to make use of a fast
+    16 x 16 bit multiply.
+
+    This function should not be called for order <= 0.
+
+    This function must not be called with lpc_qformat < 5
+------------------------------------------------------------------------------
+ REFERENCES
+
+ (1) ISO/IEC 14496-3:1999(E)
+     Part 3
+        Subpart 4.6.6.4.1 (LTP with TNS)
+        Subpart 4.6.8 (Temporal Noise Shaping)
+
+ (2) MPEG-2 NBC Audio Decoder
+   "This software module was originally developed by AT&T, Dolby
+   Laboratories, Fraunhofer Gesellschaft IIS in the course of development
+   of the MPEG-2 NBC/MPEG-4 Audio standard ISO/IEC 13818-7, 14496-1,2 and
+   3. This software module is an implementation of a part of one or more
+   MPEG-2 NBC/MPEG-4 Audio tools as specified by the MPEG-2 NBC/MPEG-4
+   Audio standard. ISO/IEC  gives users of the MPEG-2 NBC/MPEG-4 Audio
+   standards free license to this software module or modifications thereof
+   for use in hardware or software products claiming conformance to the
+   MPEG-2 NBC/MPEG-4 Audio  standards. Those intending to use this software
+   module in hardware or software products are advised that this use may
+   infringe existing patents. The original developer of this software
+   module and his/her company, the subsequent editors and their companies,
+   and ISO/IEC have no liability for use of this software module or
+   modifications thereof in an implementation. Copyright is not released
+   for non MPEG-2 NBC/MPEG-4 Audio conforming products.The original
+   developer retains full right to use the code for his/her  own purpose,
+   assign or donate the code to a third party and to inhibit third party
+   from using the code for non MPEG-2 NBC/MPEG-4 Audio conforming products.
+   This copyright notice must be included in all copies or derivative
+   works."
+   Copyright(c)1996.
+
+------------------------------------------------------------------------------
+ PSEUDO-CODE
+
+    IF (direction == -1)
+    THEN
+        pCoef = pCoef + (num_coef - 1);
+    END IF
+
+    FOR (i = order; i > 0; i--)
+
+        *(pFilterInput) = 0;
+        pFilterInput = pFilterInput + 1;
+
+    END FOR
+
+    wrap_point = 0;
+
+    shift_amt  = (lpc_qformat - 5);
+
+    FOR (i = num_coef; i > 0; i--)
+
+        pLPC = lpc;
+
+        mult = 0;
+
+        FOR (j = wrap_point; j>0; j--)
+
+           tempInt32 = (Int32)(*(pLPC) * *(pFilterInput));
+           tempInt32 = tempInt32 >> 5;
+
+           mult = mult + tempInt32;
+
+           pFilterInput = pFilterInput + 1;
+           pLPC = pLPC + 1;
+
+        ENDFOR
+
+        pFilterInput = scratch_memory;
+
+        FOR (j = (order - wrap_point); j>0; j--)
+
+           tempInt32 = (Int32)(*(pLPC) * *(pFilterInput));
+           tempInt32 = tempInt32 >> 5;
+
+           mult = mult + tempInt32;
+
+           pFilterInput = pFilterInput + 1;
+           pLPC = pLPC + 1;
+
+        ENDFOR
+
+        pFilterInput = pFilterInput - 1;
+        *(pFilterInput) = (Int)(*pCoef);
+
+        mult = mult >> shift_amt;
+
+        *(pCoef) = *(pCoef) + mult;
+
+        pCoef = pCoef + direction;
+
+        wrap_point = wrap_point + 1;
+
+        IF (wrap_point == order)
+        THEN
+            wrap_point = 0;
+        END IF
+
+    END FOR
+
+------------------------------------------------------------------------------
+ RESOURCES USED
+
+   When the code is written for a specific target processor
+     the resources used should be documented below.
+
+ STACK USAGE: [stack count for this module] + [variable to represent
+          stack usage for each subroutine called]
+
+     where: [stack usage variable] = stack usage for [subroutine
+         name] (see [filename].ext)
+
+ DATA MEMORY USED: x words
+
+ PROGRAM MEMORY USED: x words
+
+ CLOCK CYCLES: [cycle count equation for this module] + [variable
+           used to represent cycle count for each subroutine
+           called]
+
+     where: [cycle count variable] = cycle count for [subroutine
+        name] (see [filename].ext)
+
+------------------------------------------------------------------------------
+*/
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+#include "pv_audio_type_defs.h"
+#include "tns_inv_filter.h"
+#include "fxp_mul32.h"
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here. Include conditional
+; compile variables also.
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; LOCAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; LOCAL STORE/BUFFER/POINTER DEFINITIONS
+; Variable declaration - defined here and used outside this module
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL FUNCTION REFERENCES
+; Declare functions defined elsewhere and referenced in this module
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL GLOBAL STORE/BUFFER/POINTER REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; FUNCTION CODE
+----------------------------------------------------------------------------*/
+
+void tns_inv_filter(
+    Int32 coef[],
+    const Int num_coef,
+    const Int direction,
+    const Int32 lpc[],
+    const Int lpc_qformat,
+    const Int order,
+    Int32 scratch_memory[])
+{
+
+    Int i;
+    Int j;
+    Int shift_amt;
+    Int wrap_point;
+
+    Int32 mult;
+
+    /*
+     * Circular buffer to hold the filter's input
+     *
+     * (x[n-1],x[n-2],x[n-3],etc.)
+     *
+     * This scratch space is necessary, because
+     * the filter's output is returned in-place.
+     *
+     * pFilterInput and pLPC should take advantage
+     * of any special circular buffer instructions
+     * if this code is hand-optimized in assembly.
+     *
+     */
+    Int32 *pFilterInput = scratch_memory;
+
+    const Int32 *pLPC;
+
+    /*
+     * Pointer to the I/O memory space
+     */
+    Int32 *pCoef = coef;
+
+    if (direction == -1)
+    {
+        pCoef += (num_coef - 1);
+    }
+
+    /* Make sure the scratch memory is "clean" */
+    for (i = order; i != 0; i--)
+    {
+        *(pFilterInput++) = 0;
+    }
+
+    wrap_point = 0;
+
+    shift_amt  = (lpc_qformat - 5);
+
+    for (i = num_coef; i > 0; i--)
+    {
+        /*
+         * Copy spectral input into special
+         * filter input buffer.
+         */
+        pLPC = lpc;
+
+        mult = 0;
+
+        /*
+         * wrap_point = 0 when this code is
+         * entered for the first iteration of
+         * for(i=num_coef; i>0; i--)
+         *
+         * So, this first for-loop will be
+         * skipped when i == num_coef.
+         */
+
+        for (j = wrap_point; j > 0; j--)
+        {
+            mult += fxp_mul32_Q31(*(pLPC++), *(pFilterInput++)) >> 5;
+
+        } /* for (j = wrap_point; j>0; j--) */
+
+        /*
+         * pFilterInput has reached &scratch_memory[order-1]
+         * Reset pointer to beginning of filter's state memory
+         */
+        pFilterInput = scratch_memory;
+
+        for (j = (order - wrap_point); j > 0; j--)
+        {
+            mult += fxp_mul32_Q31(*(pLPC++), *(pFilterInput++)) >> 5;
+
+        } /* for (j = wrap_point; j>0; j--) */
+
+
+        /*
+         * Fill the filter's state buffer
+         * avoid obvious casting
+         */
+        *(--pFilterInput) = (*pCoef);
+
+
+        /* Scale the data down so the output q-format is not adjusted.
+         *
+         * Here is an equation, which shows how the spectral coefficients
+         * and lpc coefficients are multiplied and the spectral
+         * coefficient's q-format does not change.
+         *
+         * Q-(coef) * Q-(lpc_qformat) >> 5 = Q-(coef + lpc_q_format - 5)
+         *
+         * Q-(coef + lpc_q_format - 5) >> (lpc_qformat - 5) = Q-(coef)
+         */
+
+        /* Store output in place */
+        *(pCoef) += (mult >> shift_amt);
+
+        /* Adjust pointers and placeholders */
+        pCoef += direction;
+
+        wrap_point++;
+
+        if (wrap_point == order)
+        {
+            wrap_point = 0;
+        }
+
+    } /* for (i = num_coef; i > 0; i--) */
+
+} /* tns_inv_filter */
diff --git a/media/libstagefright/codecs/aacdec/tns_inv_filter.h b/media/libstagefright/codecs/aacdec/tns_inv_filter.h
new file mode 100644
index 0000000..1b57fc1
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/tns_inv_filter.h
@@ -0,0 +1,99 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Pathname: tns_inv_filter.h
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+ Description: Per request of JT, the lpc coefficients q-format will now
+ be transmitted to the function.
+
+ Description: The scratch memory was mistakenly declared here as type "Int32"
+ It should have been "Int"
+
+ Who:                       Date:
+ Description:
+
+------------------------------------------------------------------------------
+ INCLUDE DESCRIPTION
+
+ This include file contains the function declaration for
+ tns_inv_filter.c
+
+------------------------------------------------------------------------------
+*/
+
+/*----------------------------------------------------------------------------
+; CONTINUE ONLY IF NOT ALREADY DEFINED
+----------------------------------------------------------------------------*/
+#ifndef TNS_INV_FILTER_H
+#define TNS_INV_FILTER_H
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+#include "pv_audio_type_defs.h"
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here.
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL VARIABLES REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; SIMPLE TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; ENUMERATED TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; STRUCTURES TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; GLOBAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+void tns_inv_filter(
+    Int32 coef[],
+    const Int   num_coef,
+    const Int   inc,
+    const Int32 lpc[],
+    const Int   lpc_qformat,
+    const Int   order,
+    Int32 scratch_memory[]);
+
+/*----------------------------------------------------------------------------
+; END
+----------------------------------------------------------------------------*/
+#endif
+
+
diff --git a/media/libstagefright/codecs/aacdec/trans4m_freq_2_time_fxp.cpp b/media/libstagefright/codecs/aacdec/trans4m_freq_2_time_fxp.cpp
new file mode 100644
index 0000000..6ccc023
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/trans4m_freq_2_time_fxp.cpp
@@ -0,0 +1,2604 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+  Pathname: trans4m_freq_2_time_fxp.c
+  Function: trans4m_freq_2_time_fxp
+
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+ Description:
+    changed to decrement loop
+    change wnd_shape from structure to passing parameters
+    modified window tables from UInt to UInt16 to assure proper operation
+    without dubious typecast
+    changed logic to hit most common states first.
+    modified Time_data from Int to Int32 to hold
+    possible overflow before saturation process.
+
+ Description:
+    Increase processing on some loop by using more pointers
+    changed interface to avoid passing a pointer for wnd_shape_prev_bk, this
+    element is not change in this function because of this function use
+    in the LTP module
+
+ Description:
+    Added rounding to multiplication
+
+ Description:
+    Update input description and eliminate unneeded comments
+
+ Description:
+    LONG_START_WINDOW was using SHORT_WINDOW instead of
+    HALF_SHORT_WINDOW, causing a for loop to exceed its count
+
+ Description:
+    Modified structure of code so exp is not tested before it
+    is initialized.  Also, new structure avoids double-testing
+    of exp_freq = ALL_ZEROS_BUFFER.
+
+ Description:
+    The result of a shift is undefined if the right operand is greater than
+    or equal to the number of bits in the left expression's type
+    To avoid undefined shift by 32, a check of the shift has been
+    added, so the function proceeds only when the exponent is less
+    than 32. By design the shift up is related to the global gain,
+    and controlled by the encoder, so saturation is not allowed.
+    In both short and long window, processing is skip if an all zero
+    input buffer or excessive down shift is detected.
+
+ Description:
+    Changes according to code review comments. Also, modified if-else
+    structure so the imdct_fxp is not called with an all zero input buffer
+
+ Description:
+    Replaced function buffer_normalization by buffer_adaptation, to ease
+    use of 16 bits. Function buffer_normalization becomes  obsolete.
+
+ Description:
+    Modified call to imdct_fxp to reflect extended precision use. Added
+    routine buffer_adaptation to extract 16 MSB and keep highest.
+    precision. Modify casting to ensure proper operations for different
+    platforms
+
+ Description:
+    Eliminate double access to memory by loading data directly to the
+    time array. Also reduced cycle count and added precision by combining
+    downshifting in only one operation. Added adaptive rounding factor.
+    Change exponent threshold when operations are waived. It is use to be 32
+    but by combining downshifting, this new threshold is now 16. This may
+    avoid unneeded calculations for extremely small numbers.
+
+ Description:
+    Per review comments:
+        - Added comments to clarify buffer_adaptation function
+        - Deleted  reference to include file "buffer_normalization.h"
+        - Modified IF-ELSE so long_windows case is considered first
+        - Eliminated extra IF when computing the rounding, so when exp ==0
+          less cycles are used shifting than in an extra if-else
+        - Corrected negative shift when computing rounding factor
+        - Added condition when exp > 16 (for long windows)
+
+ Description:
+    Modified IF-ELSE structure so now ALL_ZEROS_BUFFER condition is share
+    with exp > 16 condition. This avoid code duplication for both cases.
+
+ Description:
+        - Modified function interface to add output_buffer
+        - Eliminated the 32 bit version of the current output, calculations
+          are placed directly in output_buffer. In this way the buffer
+          Time_data needs only to be 1024 Int32, instead of 2048 (per channel).
+          Also, added the limit macro inside the function (this reduces access
+          to memory).
+        - Updated Pseudo - Code
+
+ Description:
+    Per review comments:
+          Corrected line sizes and mispelling,  added comments and swap
+          order or switch statement for ONLY_LONG_SEQUENCE.
+
+ Description:
+    Eliminated adaptive rounding due to potential saturation.
+
+ Description:
+    Eliminated use of buffer adaptation by shifting this functionality inside
+    the imdct_fxp() routine. Also modified the call to imdct_fxp to accomodate
+    new function interface.
+    Modified macro limit() to save cycles when testing the most common case:
+    no saturation.
+
+ Description:
+    Changed new function interface for imdct_fxp().
+
+ Description:
+    Replaced for-loop with memset and memcopy.
+
+ Who:                         Date:
+ Description:
+
+------------------------------------------------------------------------------
+ INPUT AND OUTPUT DEFINITIONS
+
+ Inputs:
+    Frequency_data    =  vector with spectral information, size 2048
+                         type Int32
+
+    Time_data         =  buffer with data from previous Frequency to Time
+                         conversion, used for overlap and add, size 1024
+                         type Int32
+
+    Output_buffer     =  place holder for current output,  size 1024
+                         type Int16
+
+    wnd_seq           =  window sequence
+                         type WINDOW_SEQUENCE
+
+    wnd_shape_prev_bk =  previous window shape type
+                         type Int
+
+    wnd_shape_this_bk =  current window shape type
+                         type Int
+
+    Q_format          =  Q format for the input frequency data
+                         type Int
+
+    freq_2_time_buffer[] =  scratch memory for computing FFT
+                         type Int32
+
+
+ Local Stores/Buffers/Pointers Needed:
+    None
+
+ Global Stores/Buffers/Pointers Needed:
+    None
+
+ Outputs:
+    None
+
+ Pointers and Buffers Modified:
+    Output_buffer
+    Time_data
+    Frequency_data
+    pWnd_shape_prev_bk
+
+ Local Stores Modified:
+    None
+
+ Global Stores Modified:
+    None
+
+------------------------------------------------------------------------------
+ FUNCTION DESCRIPTION
+
+The time/frequency representation of the signal is mapped onto the time
+domain by feeding it into the filterbank module. This module consists of
+an inverse modified discrete cosine transform (IMDCT), and a window and an
+overlap-add function. In order to adapt the time/frequency resolution of the
+filterbank to the characteristics of the input signal, a block switching tool
+is also adopted. N represents the window length, where N is a function of the
+window_sequence. For each channel, the N/2 time-frequency values are
+transformed into the N time domain values via the IMDCT. After applying the
+window function, for each channel, the first half of the sequence is added to
+the second half of the previous block windowed sequence to reconstruct the
+output samples for each channel outi,n.
+
+The adaptation of the time-frequency resolution of the filterbank to the
+characteristics of the input signal is done by shifting between transforms
+whose input lengths are either 2048 or 256 samples. By enabling the block
+switching tool, the following transitions are meaningful:
+
+from ONLY_LONG_SEQUENCE to   { LONG_START_SEQUENCE
+                               ONLY_LONG_SEQUENCE
+
+from LONG_START_SEQUENCE to  { LONG_STOP_SEQUENCE
+                               EIGHT_SHORT_SEQUENCE
+
+from LONG_STOP_SEQUENCE to   { LONG_START_SEQUENCE
+                               ONLY_LONG_SEQUENCE
+
+from EIGHT_SHORT_SEQUENCE to { LONG_STOP_SEQUENCE
+                               EIGHT_SHORT_SEQUENCE
+
+Window shape decisions are made by the encoder on a frame-by-frame-basis.
+The window selected is applicable to the second half of the window function
+only, since the first half is constrained to use the appropriate window
+shape from the preceding frame.
+The 2048 time-domain values x'(i)(n), (i window, n sample) to be windowed are
+the last 1024 values of the previous window_sequence concatenated with 1024
+values of the current block. The formula below shows this fact:
+
+                     |  x(i-1)(n+1024)      for    0 < n < 1024
+            x'(i)(n) {
+                     |  x(i)(n)             for 1024 < n < 2048
+
+
+Buffer Time_data data from previous Frequency to Time conversion, used
+for overlap and add
+
+Once the window shape is selected, the window_shape syntax element is
+initialized. Together with the chosen window_sequence all information needed
+for windowing exist.
+With the window halves described below all window_sequences can be assembled.
+For window_shape == 1, the window coefficients are given by the Kaiser -
+Bessel derived (KBD) window.
+Otherwise, for window_shape == 0, a sine window is employed.
+
+The window length N can be 2048 or 256 for the KBD and the sine window.
+All four window_sequences explained below have a total length of 2048
+samples.
+For all kinds of window_sequences the window_shape of the left half of
+the first transform window is determined by the window shape of the previous
+block.
+
+In the case of EIGHT_SHORT_SEQUENCE the processing is done in-place and
+in descendent order to avoid using extra memory.
+The ordering is as follows:
+
+                                            Pn: Previous data for window n
+                                            Cn:  Current data for window n
+
+
+                                                128 freq.
+                                                 samples
+                  FREQ                          ++++++
+IN                         ===========================
+                                                    \
+                                                      \
+                                                        ->  256 time
+                                                             samples
+
+                                                           P8    C8
+           8                                            #######++++++
+                                                    P7     C7
+           7                                     #######++++++
+           :                                :
+           :                                :
+                            P2    C2
+           2             #######++++++
+                     P1    C1
+           1      #######++++++
+                                                                          TIME
+OUT          ==============================================================
+
+------------------------------------------------------------------------------
+ REQUIREMENTS
+
+    This module shall implement a scheme to switch between window types
+
+------------------------------------------------------------------------------
+ REFERENCES
+
+    [1] ISO 14496-3:1999, pag 111
+
+------------------------------------------------------------------------------
+ PSEUDO-CODE
+
+
+
+    IF ( wnd_seq == EIGHT_SHORT_SEQUENCE)
+    THEN
+
+        FOR ( i=0; i<LONG_WINDOW; i++)
+            Time_data[LONG_WINDOW + i] = 0;
+        ENDFOR
+
+        FOR ( wnd=NUM_SHORT_WINDOWS-1; wnd>=0; wnd--)
+
+            pFreqInfo = &Frequency_data[ wnd*SHORT_WINDOW];
+
+            CALL IMDCT( pFreqInfo, SHORT_BLOCK1);
+            MODIFYING(pFreqInfo)
+
+
+            IF (wnd == 0)
+            THEN
+                pShort_Window_1 = &Short_Window[wnd_shape_prev_bk][0];
+            ELSE
+                pShort_Window_1 = &Short_Window[wnd_shape_this_bk][0];
+            ENDIF
+
+            pShort_Window_2   =
+                    &Short_Window[wnd_shape->this_bk][SHORT_WINDOW_m_1];
+
+            FOR( i=0, j=SHORT_WINDOW; i<SHORT_WINDOW; i++, j--)
+                pFreqInfo[             i]  *= pShort_Window_1[i];
+                pFreqInfo[SHORT_WINDOW+i]  *= pShort_Window_2[j];
+            ENDFOR
+
+
+            FOR( i=0; i<SHORT_BLOCK1; i++)
+                Time_data[W_L_STOP_1 + SHORT_WINDOW*wnd + i] += pFreqInfo[i];
+            ENDFOR
+
+        ENDFOR
+
+        FOR ( i=0; i<LONG_WINDOW; i++)
+            temp              = Time_data[i];
+            Output_buffer[i]  = Time_data[i];
+            Time_data[i]      = temp;
+        ENDFOR
+    ELSE
+
+        CALL IMDCT( Frequency_data, LONG_BLOCK1)
+            MODIFYING(Frequency_data)
+
+        SWITCH ( wnd_seq)
+
+            CASE ( ONLY_LONG_SEQUENCE)
+
+                pLong_Window_1 = &Long_Window[wnd_shape_prev_bk][0];
+                pLong_Window_2 =
+                        &Long_Window[wnd_shape_this_bk][LONG_WINDOW_m_1];
+
+                FOR (i=0; i<LONG_WINDOW; i++)
+                    Frequency_data[            i] *= *pLong_Window_1++;
+                    Frequency_data[LONG_WINDOW+i] *= *pLong_Window_2--;
+                ENDFOR
+
+                BREAK
+
+            CASE ( LONG_START_SEQUENCE)
+
+                pLong_Window_1 = &Long_Window[wnd_shape_prev_bk][0];
+
+                FOR ( i=0; i<LONG_WINDOW; i++)
+                    Frequency_data[ i] *= *pLong_Window_1++;
+                ENDFOR
+
+                pShort_Window_1   =
+                        &Short_Window[wnd_shape_this_bk][SHORT_WINDOW_m_1];
+
+                FOR ( i=0; i<SHORT_WINDOW; i++)
+                    Frequency_data[W_L_START_1 + i] *= *pShort_Window_1--;
+                ENDFOR
+
+                FOR ( i=W_L_START_2; i<LONG_BLOCK1; i++)
+                    Frequency_data[W_L_START_2 + i] = 0;
+                ENDFOR
+
+                BREAK
+
+
+            CASE ( LONG_STOP_SEQUENCE )
+
+                FOR ( i=0; i<W_L_STOP_1; i++)
+                    Frequency_data[ i] = 0;
+                ENDFOR
+
+                pShort_Window_1   = &Short_Window[wnd_shape_prev_bk][0];
+
+                FOR ( i=0; i<SHORT_WINDOW; i++)
+                    Frequency_data[W_L_STOP_1+ i] *= *pShort_Window_1++;
+                ENDFOR
+
+                pLong_Window_1 =
+                        &Long_Window[wnd_shape_this_bk][LONG_WINDOW_m_1];
+
+                FOR ( i=0; i<LONG_WINDOW; i++)
+                    Frequency_data[LONG_WINDOW + i]  *=  *pLong_Window_1--;
+                ENDFOR
+
+                BREAK
+
+        }
+
+
+        FOR ( i=0; i<LONG_WINDOW; i++)
+            Output_buffer[i]  = Frequency_data[i]  + Time_data[i];
+            Time_data[i] = Frequency_data[LONG_WINDOW+i];
+        ENDFOR
+
+    }
+
+    ENDIF
+
+
+
+------------------------------------------------------------------------------
+ RESOURCES USED
+   When the code is written for a specific target processor the
+     the resources used should be documented below.
+
+ STACK USAGE: [stack count for this module] + [variable to represent
+          stack usage for each subroutine called]
+
+     where: [stack usage variable] = stack usage for [subroutine
+         name] (see [filename].ext)
+
+ DATA MEMORY USED: x words
+
+ PROGRAM MEMORY USED: x words
+
+ CLOCK CYCLES: [cycle count equation for this module] + [variable
+           used to represent cycle count for each subroutine
+           called]
+
+     where: [cycle count variable] = cycle count for [subroutine
+        name] (see [filename].ext)
+
+------------------------------------------------------------------------------
+*/
+
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+
+#include "pv_audio_type_defs.h"
+#include "aac_mem_funcs.h"
+#include "window_block_fxp.h"
+#include "imdct_fxp.h"
+
+#include "fxp_mul32.h"
+
+
+/*----------------------------------------------------------------------------
+; MACROS
+; limit(x) saturates any number that exceeds a 16-bit representation into a
+; 16 bit number.
+----------------------------------------------------------------------------*/
+
+#define  ROUNDING_SCALED     (ROUNDING<<(16 - SCALING))
+
+
+#if defined(PV_ARM_V5)
+
+
+__inline Int16 sat(Int32 y)
+{
+    Int32 x;
+    Int32 z;
+    __asm
+    {
+        mov x, ROUNDING_SCALED
+        mov y, y, lsl #(15-SCALING)
+        qdadd z, x, y
+        mov y, z, lsr #16
+    }
+    return((Int16)y);
+}
+
+#define  limiter( y, x)   y = sat(x);
+
+
+
+#elif defined(PV_ARM_GCC_V5)
+
+
+__inline Int16 sat(Int32 y)
+{
+    register Int32 x;
+    register Int32 ra = (Int32)y;
+    register Int32 z = ROUNDING_SCALED;
+
+
+    asm volatile(
+        "mov %0, %1, lsl #5\n\t"    // (15-SCALING) assembler does not take symbols
+        "qdadd %0, %2, %0\n\t"
+        "mov %0, %0, lsr #16"
+    : "=&r*i"(x)
+                : "r"(ra),
+                "r"(z));
+
+    return ((Int16)x);
+}
+
+#define  limiter( y, x)   y = sat(x);
+
+
+#elif defined(PV_ARM_MSC_EVC_V5)
+
+
+#define  limiter( y, x)       z = x<< (15-SCALING); \
+                              y = _DAddSatInt( ROUNDING_SCALED, z)>>16;
+
+
+#else
+
+#define  limiter( y, x)   z = ((x + ROUNDING )>>SCALING); \
+                          if ((z>>15) != (z>>31))         \
+                          {                                    \
+                              z = (z >> 31) ^ INT16_MAX;       \
+                          } \
+                          y = (Int16)(z);
+
+#endif
+
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here. Include conditional
+; compile variables also.
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; LOCAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+
+
+/*----------------------------------------------------------------------------
+; LOCAL VARIABLE DEFINITIONS
+; Variable declaration - defined here and used outside this module
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL FUNCTION REFERENCES
+; Declare functions defined elsewhere and referenced in this module
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL VARIABLES REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL GLOBAL STORE/BUFFER/POINTER REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; FUNCTION CODE
+----------------------------------------------------------------------------*/
+
+#ifdef AAC_PLUS
+
+
+void trans4m_freq_2_time_fxp_1(
+    Int32               Frequency_data[],
+    Int32               Time_data[],
+    Int16               Output_buffer[],
+    WINDOW_SEQUENCE     wnd_seq,
+    Int                 wnd_shape_prev_bk,
+    Int                 wnd_shape_this_bk,
+    Int                 Q_format,
+    Int32               abs_max_per_window[],
+    Int32               freq_2_time_buffer[])
+
+{
+    Int exp;
+    Int shift;
+
+    Int  i;
+    Int  wnd;
+#if !(defined( PV_ARM_GCC_V5)||(PV_ARM_V5))
+    Int32 z;
+#endif
+
+    Int16 *pFreqInfo;
+    Int32 temp;
+    Int32 test;
+
+    Int16 *pFreq_2_Time_data_1;
+    Int16 *pFreq_2_Time_data_2;
+
+    const Int16 *pLong_Window_1;
+    const Int16 *pLong_Window_2;
+    const Int16 *pShort_Window_1;
+    const Int16 *pShort_Window_2;
+
+    Int32 *pOverlap_and_Add_Buffer_1;
+    Int32 *pOverlap_and_Add_Buffer_2;
+
+    Int16  *pOutput_buffer;
+    Int16  *pOutput_buffer_2;
+
+    const Int16 * Long_Window_fxp[NUM_WINDOW_SHAPES];
+    const Int16 * Short_Window_fxp[NUM_WINDOW_SHAPES];
+
+    Long_Window_fxp[0] = Long_Window_sine_fxp;
+    Long_Window_fxp[1] = Long_Window_KBD_fxp;
+    Short_Window_fxp[0] = Short_Window_sine_fxp;
+    Short_Window_fxp[1] = Short_Window_KBD_fxp;
+
+
+    if (wnd_seq != EIGHT_SHORT_SEQUENCE)
+    {
+
+        pFreqInfo = (Int16 *)Frequency_data;
+
+
+        exp = imdct_fxp(
+                  (Int32 *)pFreqInfo,
+                  freq_2_time_buffer,
+                  LONG_BLOCK1,
+                  Q_format,
+                  abs_max_per_window[0]);
+
+
+
+        /*
+         *  The C Programming Language, Second Edition, Kernighan & Ritchie,
+         *  page 206.
+         *  "The result [of a shift] is undefined if the right operand is
+         *  negative, or greater than or equal to the number of bits in the
+         *  left expression's type"
+         *   => avoid shift by 32 or 16
+         */
+
+        if (exp < 16)
+        {
+
+            pFreq_2_Time_data_1 = pFreqInfo;
+
+            switch (wnd_seq)
+            {
+
+                case ONLY_LONG_SEQUENCE:
+                default:
+
+                    pOutput_buffer = Output_buffer;
+
+                    pOverlap_and_Add_Buffer_1 = Time_data;
+
+                    {
+                        const Int16 *pLong_Window_2 = &Long_Window_fxp[wnd_shape_this_bk][LONG_WINDOW_m_1];
+
+                        Int32 * pFreq2T = (Int32 *)pFreqInfo;
+                        Int32 * win = (Int32 *) & Long_Window_fxp[wnd_shape_prev_bk][0];
+                        Int shift = exp + 15 - SCALING;
+
+
+                        Int32 * pFreq2T_2 = &pFreq2T[HALF_LONG_WINDOW];
+
+
+                        for (i = HALF_LONG_WINDOW; i != 0; i--)
+                        {
+                            Int16 win1, win2;
+                            Int32  temp2, test2;
+
+                            Int32  winx;
+
+                            temp2 = *(pFreq2T++);
+                            winx = *(win++);
+
+                            test  = *(pOverlap_and_Add_Buffer_1++);
+                            test2 = *(pOverlap_and_Add_Buffer_1--);
+                            temp  =   fxp_mul_16_by_16bb(temp2, winx) >> shift;
+                            temp2 =   fxp_mul_16_by_16tt(temp2, winx) >> shift;
+                            limiter(*(pOutput_buffer++), (temp + test));
+                            limiter(*(pOutput_buffer++), (temp2 + test2));
+
+                            temp2 = *(pFreq2T_2++);
+
+                            win1  = *(pLong_Window_2--);
+                            win2  = *(pLong_Window_2--);
+                            temp  = fxp_mul_16_by_16bb(temp2, win1) >> shift;
+                            test2 = fxp_mul_16_by_16tb(temp2, win2) >> shift;
+                            *(pOverlap_and_Add_Buffer_1++) = temp;
+                            *(pOverlap_and_Add_Buffer_1++) = test2;
+
+                        }
+                    }
+
+                    break;
+
+                case LONG_START_SEQUENCE:
+
+
+                    pFreq_2_Time_data_2 =
+                        &pFreq_2_Time_data_1[ HALF_LONG_WINDOW];
+
+                    pLong_Window_1 = &Long_Window_fxp[wnd_shape_prev_bk][0];
+                    pLong_Window_2 = &pLong_Window_1[ HALF_LONG_WINDOW];
+
+                    pOverlap_and_Add_Buffer_1 = &Time_data[0];
+                    pOverlap_and_Add_Buffer_2 = &Time_data[HALF_LONG_WINDOW];
+
+                    pOutput_buffer   = Output_buffer;
+                    pOutput_buffer_2 = pOutput_buffer + HALF_LONG_WINDOW;
+
+
+                    shift = exp + 15 - SCALING;
+
+                    for (i = HALF_LONG_WINDOW; i != 0; i--)
+                    {
+
+                        Int16 win1, win2;
+                        Int16  dat1, dat2;
+                        Int32  test1, test2;
+
+                        dat1   = *(pFreq_2_Time_data_1++);
+                        win1   = *(pLong_Window_1++);
+                        test1  = *(pOverlap_and_Add_Buffer_1++);
+
+                        dat2  =  *(pFreq_2_Time_data_2++);
+                        win2  = *(pLong_Window_2++);
+                        test2 = *(pOverlap_and_Add_Buffer_2++);
+
+                        limiter(*(pOutput_buffer++), (test1 + (fxp_mul_16_by_16(dat1, win1) >> shift)));
+
+                        limiter(*(pOutput_buffer_2++), (test2 + (fxp_mul_16_by_16(dat2, win2) >> shift)));
+
+                    }
+
+                    /*
+                     *  data unchanged from  LONG_WINDOW to W_L_START_1
+                     *  only scaled accordingly
+                     */
+
+                    pOverlap_and_Add_Buffer_1 = &Time_data[0];
+                    pFreq_2_Time_data_1       = &pFreqInfo[LONG_WINDOW];
+
+                    exp -= SCALING;
+
+                    if (exp >= 0)
+                    {
+
+                        for (i = (W_L_START_1 - LONG_WINDOW) >> 1; i != 0; i--)
+                        {
+                            *(pOverlap_and_Add_Buffer_1++) =
+                                *(pFreq_2_Time_data_1++) >> exp;
+                            *(pOverlap_and_Add_Buffer_1++) =
+                                *(pFreq_2_Time_data_1++) >> exp;
+
+                        }
+
+                    }
+                    else if (exp < 0)
+                    {
+
+                        Int shift = -exp;
+                        for (i = (W_L_START_1 - LONG_WINDOW) >> 1; i != 0 ; i--)
+                        {
+                            Int32 temp2 = ((Int32) * (pFreq_2_Time_data_1++)) << shift;
+                            *(pOverlap_and_Add_Buffer_1++) = temp2;
+                            temp2 = ((Int32) * (pFreq_2_Time_data_1++)) << shift;
+                            *(pOverlap_and_Add_Buffer_1++) = temp2;
+                        }
+
+                    }
+                    else
+                    {
+
+                        for (i = (W_L_START_1 - LONG_WINDOW) >> 1; i != 0; i--)
+                        {
+                            *(pOverlap_and_Add_Buffer_1++) =
+                                *(pFreq_2_Time_data_1++);
+                            *(pOverlap_and_Add_Buffer_1++) =
+                                *(pFreq_2_Time_data_1++);
+
+                        }
+
+                    }
+
+
+                    pFreq_2_Time_data_1  = &pFreqInfo[W_L_START_1];
+                    pFreq_2_Time_data_2  =
+                        &pFreq_2_Time_data_1[HALF_SHORT_WINDOW];
+
+                    pShort_Window_1   =
+                        &Short_Window_fxp[wnd_shape_this_bk][SHORT_WINDOW_m_1];
+
+                    pShort_Window_2   = pShort_Window_1 - HALF_SHORT_WINDOW;
+
+                    pOverlap_and_Add_Buffer_2 = pOverlap_and_Add_Buffer_1 +
+                                                HALF_SHORT_WINDOW;
+
+
+                    for (i = HALF_SHORT_WINDOW; i != 0; i--)
+                    {
+                        Int16 win1, win2;
+                        Int16  dat1, dat2;
+                        Int32  temp2;
+                        dat1  = (*pFreq_2_Time_data_1++);
+                        dat2  = (*pFreq_2_Time_data_2++);
+                        win1  = *(pShort_Window_1--);
+                        win2  = *(pShort_Window_2--);
+
+                        temp   =   fxp_mul_16_by_16(dat1, win1) >> shift;
+                        *(pOverlap_and_Add_Buffer_1++) = temp;
+
+                        temp2 =   fxp_mul_16_by_16(dat2, win2) >> shift;
+                        *(pOverlap_and_Add_Buffer_2++) = temp2;
+
+
+                    }
+
+
+                    pOverlap_and_Add_Buffer_1 += HALF_SHORT_WINDOW;
+
+                    pv_memset(
+                        pOverlap_and_Add_Buffer_1,
+                        0,
+                        (LONG_BLOCK1 - W_L_START_2)
+                        *sizeof(*pOverlap_and_Add_Buffer_1));
+
+
+                    break;
+
+
+                case LONG_STOP_SEQUENCE:
+
+                    pOverlap_and_Add_Buffer_1 = &Time_data[ W_L_STOP_2];
+
+                    pOutput_buffer         = &Output_buffer[W_L_STOP_2];
+
+                    pFreq_2_Time_data_1      = &pFreqInfo[W_L_STOP_2];
+
+                    exp -= SCALING; /*  !!!! */
+
+                    if (exp > 0)
+                    {
+                        Int16 tmp1 = (*(pFreq_2_Time_data_1++) >> exp);
+                        temp = *(pOverlap_and_Add_Buffer_1++);
+
+                        for (i = (LONG_WINDOW - W_L_STOP_2); i != 0; i--)
+                        {
+                            limiter(*(pOutput_buffer++), (temp + tmp1));
+
+                            tmp1 = *(pFreq_2_Time_data_1++) >> exp;
+                            temp = *(pOverlap_and_Add_Buffer_1++);
+
+                        }
+                    }
+                    else if (exp < 0)
+                    {
+                        shift = -exp;
+                        Int32 temp1 = ((Int32) * (pFreq_2_Time_data_1++)) << shift;
+                        temp = *(pOverlap_and_Add_Buffer_1++);
+
+                        for (i = (LONG_WINDOW - W_L_STOP_2); i != 0; i--)
+                        {
+                            limiter(*(pOutput_buffer++), (temp + temp1));
+
+                            temp1 = ((Int32) * (pFreq_2_Time_data_1++)) << shift;
+                            temp = *(pOverlap_and_Add_Buffer_1++);
+
+                        }
+                    }
+                    else
+                    {
+                        Int16 tmp1 = *(pFreq_2_Time_data_1++);
+                        temp = *(pOverlap_and_Add_Buffer_1++);
+
+                        for (i = (LONG_WINDOW - W_L_STOP_2); i != 0; i--)
+                        {
+                            limiter(*(pOutput_buffer++), (temp + tmp1));
+
+                            tmp1 = *(pFreq_2_Time_data_1++);
+                            temp = *(pOverlap_and_Add_Buffer_1++);
+
+                        }
+                    }
+
+
+                    pShort_Window_1 = &Short_Window_fxp[wnd_shape_prev_bk][0];
+                    pShort_Window_2 = &pShort_Window_1[HALF_SHORT_WINDOW];
+
+                    pFreq_2_Time_data_1 = &pFreqInfo[W_L_STOP_1];
+                    pFreq_2_Time_data_2 =
+                        &pFreq_2_Time_data_1[HALF_SHORT_WINDOW];
+
+                    pOverlap_and_Add_Buffer_1 = &Time_data[ W_L_STOP_1];
+                    pOverlap_and_Add_Buffer_2 = pOverlap_and_Add_Buffer_1
+                                                + HALF_SHORT_WINDOW;
+
+                    pOutput_buffer   = &Output_buffer[W_L_STOP_1];
+                    pOutput_buffer_2 = pOutput_buffer + HALF_SHORT_WINDOW;
+
+                    exp += SCALING;  /* +8 back to what it was */
+
+                    shift = exp + 15 - SCALING;
+
+
+                    for (i = HALF_SHORT_WINDOW; i != 0; i--)
+                    {
+                        Int16 win1;
+                        Int16  dat1;
+
+                        dat1 = *(pFreq_2_Time_data_1++);
+                        win1 = *(pShort_Window_1++);
+                        temp = *(pOverlap_and_Add_Buffer_1++);
+
+                        test  = fxp_mul_16_by_16(dat1, win1);
+
+                        limiter(*(pOutput_buffer++), (temp + (test >> shift)));
+
+                        dat1 = *(pFreq_2_Time_data_2++);
+                        win1 = *(pShort_Window_2++);
+                        temp = *(pOverlap_and_Add_Buffer_2++);
+                        test =  fxp_mul_16_by_16(dat1, win1);
+                        limiter(*(pOutput_buffer_2++), (temp + (test >> shift)));
+
+                    }
+
+
+                    pFreq_2_Time_data_2 = &pFreqInfo[LONG_WINDOW];
+
+                    pOverlap_and_Add_Buffer_1 = Time_data;
+
+                    pOutput_buffer = Output_buffer;
+
+                    pLong_Window_2   =
+                        &Long_Window_fxp[wnd_shape_this_bk][LONG_WINDOW_m_1];
+
+
+                    /*
+                     *  Copy previous time in current buffer, also copy overlap
+                     *  and add buffer
+                     */
+
+                    for (i = W_L_STOP_1; i != 0; i--)
+                    {
+                        Int16 win1;
+                        Int16 dat1;
+
+                        win1 = *(pLong_Window_2--);
+                        dat1 = *pFreq_2_Time_data_2++;
+
+                        limiter(*(pOutput_buffer++), *(pOverlap_and_Add_Buffer_1));
+
+
+                        temp = fxp_mul_16_by_16(dat1, win1) >> shift;
+                        *(pOverlap_and_Add_Buffer_1++) = temp ;
+
+                    }
+
+                    for (i = (LONG_WINDOW - W_L_STOP_1); i != 0; i--)
+                    {
+                        temp = fxp_mul_16_by_16(*pFreq_2_Time_data_2++, *(pLong_Window_2--)) >> shift;
+                        *(pOverlap_and_Add_Buffer_1++) = temp ;
+                    }
+
+
+                    break;
+
+
+
+            } /* switch (wnd_seq) */
+
+        }   /*  if (exp < 16)  */
+
+        else
+        {
+            /* all zeros buffer or excessive down shift */
+
+            /* Overlap and add, setup buffer for next iteration */
+            pOverlap_and_Add_Buffer_1 = &Time_data[0];
+
+            pOutput_buffer = Output_buffer;
+
+            temp  = (*pOverlap_and_Add_Buffer_1++);
+
+            for (i = LONG_WINDOW; i != 0; i--)
+            {
+
+                limiter(*(pOutput_buffer++), temp);
+
+                temp = (*pOverlap_and_Add_Buffer_1++);
+
+            }
+
+            pv_memset(Time_data, 0, LONG_WINDOW*sizeof(Time_data[0]));
+
+
+        }
+
+    }
+    else
+    {
+
+        Int32 *pScrath_mem;
+        Int32 *pScrath_mem_entry;
+        Int32  *pFrequency_data = Frequency_data;
+
+        Int32 * pOverlap_and_Add_Buffer_1;
+        Int32 * pOverlap_and_Add_Buffer_2;
+        Int32 * pOverlap_and_Add_Buffer_1x;
+        Int32 * pOverlap_and_Add_Buffer_2x;
+
+        /*
+         *  Frequency_data is 2*LONG_WINDOW length but only
+         *  the first LONG_WINDOW elements are filled in,
+         *  then the second part can be used as scratch mem,
+         *  then grab data from one window at a time in
+         *  reverse order.
+         *  The upper LONG_WINDOW Int32 are used to hold the
+         *  computed overlap and add, used in the next call to
+         *  this function, and also as sctrach memory
+         */
+
+        /*
+         *  Frequency_data usage for the case EIGHT_SHORT_SEQUENCE
+
+          |<----- Input Freq. data ----->|< Overlap & Add ->| Unused |-Scratch-|
+          |                              |  Store for next  |        |  memory |
+          |                              |  call            |        |         |
+          |                              |                  |        |         |
+          |//////////////////////////////|\\\\\\\\\\\\\\\\\\|--------|+++++++++|
+          |                              |                  |        |         |
+          0                         LONG_WINDOW        LONG_WINDOW   |   2*LONG_WINDOW
+                                                            +        |         |
+                                                       W_L_STOP_2    |         |
+                                                                     |<--   -->|
+                                                                      SHORT_WINDOW +
+                                                                    HALF_SHORT_WINDOW
+          *
+          */
+
+        pOverlap_and_Add_Buffer_1  = &pFrequency_data[
+                                         LONG_WINDOW + 3*SHORT_WINDOW + HALF_SHORT_WINDOW];
+
+        /*
+         *  Initialize to zero, only the firt short window used in overlap
+         *  and add
+         */
+        pv_memset(
+            pOverlap_and_Add_Buffer_1,
+            0,
+            SHORT_WINDOW*sizeof(*pOverlap_and_Add_Buffer_1));
+
+        /*
+         *  Showt windows are evaluated in decresing order. Windows from 7
+         *  to 0 are break down in four cases: window numbers 7 to 5, 4, 3,
+         *  and 2 to 0.
+         *  The data from short windows 3 and 4 is situated at the boundary
+         *  between the 'overlap and add' buffer and the output buffer.
+         */
+        for (wnd = NUM_SHORT_WINDOWS - 1; wnd >= NUM_SHORT_WINDOWS / 2 + 1; wnd--)
+        {
+
+            pFreqInfo = (Int16 *) & pFrequency_data[ wnd*SHORT_WINDOW];
+
+            exp = imdct_fxp(
+                      (Int32 *)pFreqInfo,
+                      freq_2_time_buffer,
+                      SHORT_BLOCK1,
+                      Q_format,
+                      abs_max_per_window[wnd]);
+
+            pOverlap_and_Add_Buffer_1 =
+                &pFrequency_data[ W_L_STOP_1 + SHORT_WINDOW*wnd];
+
+
+            pOverlap_and_Add_Buffer_2 =
+                pOverlap_and_Add_Buffer_1 + SHORT_WINDOW;
+
+            /*
+             *  If all element are zero or if the exponent is bigger than
+             *  16 ( it becomes an undefined shift) ->  skip
+             */
+
+            if (exp < 16)
+            {
+
+
+                pFreq_2_Time_data_1 = &pFreqInfo[0];
+                pFreq_2_Time_data_2 = &pFreqInfo[SHORT_WINDOW];
+
+
+                /*
+                 *  Each of the eight short blocks is windowed separately.
+                 *  Window shape decisions are made on a frame-by-frame
+                 *  basis.
+                 */
+
+                pShort_Window_1 = &Short_Window_fxp[wnd_shape_this_bk][0];
+
+                pShort_Window_2   =
+                    &Short_Window_fxp[wnd_shape_this_bk][SHORT_WINDOW_m_1];
+
+
+
+
+                /*
+                 * For short windows from 7 to 5
+                 *                                      |   =========================
+                 *                                      |   |     5     6     7
+                 *               _--_  _--_  _--_  _--_ | _-|-_  _--_  _--_  _--_
+                 *              /    \/    \/    \/    \|/  |  \/    \/    \/    \
+                 *             /     /\    /\    /\    /|\  |  /\    /\    /\     \
+                 *            /     /  \  /  \  /  \  / | \ | /  \  /  \  /  \     \
+                 *           /     /    \/    \/    \/  |  \|/    \/    \     \     \
+                 *      --------------------------------|---[///////////////////////]--------
+                 *
+                 */
+
+
+                shift = exp + 15 - SCALING;
+
+
+                for (i = SHORT_WINDOW; i != 0; i--)
+                {
+                    Int16 win1, win2;
+                    Int16  dat1, dat2;
+
+                    dat2 = *(pFreq_2_Time_data_2++);
+                    win2 = *(pShort_Window_2--);
+                    temp = *pOverlap_and_Add_Buffer_2;
+                    dat1 = *(pFreq_2_Time_data_1++);
+                    win1 = *(pShort_Window_1++);
+
+                    *(pOverlap_and_Add_Buffer_2++) =  temp + (fxp_mul_16_by_16(dat2, win2) >> shift);
+
+                    *(pOverlap_and_Add_Buffer_1++)  =  fxp_mul_16_by_16(dat1, win1) >> shift;
+
+                }
+
+            }   /* if (exp < 16) */
+            else
+            {
+                pv_memset(
+                    pOverlap_and_Add_Buffer_1,
+                    0,
+                    SHORT_WINDOW*sizeof(*pOverlap_and_Add_Buffer_1));
+            }
+
+
+        }/* for ( wnd=NUM_SHORT_WINDOWS-1; wnd>=NUM_SHORT_WINDOWS/2; wnd--) */
+
+
+        wnd = NUM_SHORT_WINDOWS / 2;
+
+        pFreqInfo = (Int16 *) & pFrequency_data[ wnd*SHORT_WINDOW];
+
+        /*
+         *  scratch memory is allocated in an unused part of memory
+         */
+
+
+        pScrath_mem = &pFrequency_data[ 2*LONG_WINDOW - HALF_SHORT_WINDOW];
+
+        pOverlap_and_Add_Buffer_1 = &pFrequency_data[ LONG_WINDOW];
+
+        pOverlap_and_Add_Buffer_2 = pOverlap_and_Add_Buffer_1
+                                    + HALF_SHORT_WINDOW;
+
+
+        exp = imdct_fxp(
+                  (Int32 *)pFreqInfo,
+                  freq_2_time_buffer,
+                  SHORT_BLOCK1,
+                  Q_format,
+                  abs_max_per_window[wnd]);
+
+        /*
+         *  If all element are zero or if the exponent is bigger than
+         *  16 ( it becomes an undefined shift) ->  skip
+         */
+
+
+        if (exp < 16)
+        {
+
+            pFreq_2_Time_data_1 = &pFreqInfo[0];
+            pFreq_2_Time_data_2 = &pFreqInfo[SHORT_WINDOW];
+
+            pShort_Window_1 = &Short_Window_fxp[wnd_shape_this_bk][0];
+
+            pShort_Window_2 =
+                &Short_Window_fxp[wnd_shape_this_bk][SHORT_WINDOW_m_1];
+
+
+            /*
+             * For short window 4
+             *                                    ====|===========
+             *                                        |   4
+             *                                    |   |   |      |
+             *                _--_  _--_  _--_  _-|-_ | _-|-_  _-|-_  _--_  _--_
+             *               /    \/    \/    \/  |  \|/  |  \/  |  \/    \/    \
+             *              /     /\    /\    /\  |  /|\  |  /\  |  /\    /\     \
+             *             /     /  \  /  \  /  \ | / | \ | /  \ | /  \  /  \     \
+             *            /     /    \/    \/    \|/  |  \|/    \|/    \/    \     \
+             *      ------------------------------[\\\|\\\|//////]-------------------
+             *           |                        | A | B |   C  |
+             *           |
+             *        W_L_STOP_1
+             */
+
+            shift = exp + 15 - SCALING;
+            {
+                Int16 win1;
+                Int16  dat1;
+                /* -------- segment A ---------------*/
+                dat1 = *(pFreq_2_Time_data_1++);
+                win1 = *(pShort_Window_1++);
+                for (i = HALF_SHORT_WINDOW; i != 0; i--)
+                {
+                    *(pScrath_mem++)  =  fxp_mul_16_by_16(dat1, win1) >> (shift);
+                    dat1 = *(pFreq_2_Time_data_1++);
+                    win1 = *(pShort_Window_1++);
+                }
+
+                /* -------- segment B ---------------*/
+                for (i = HALF_SHORT_WINDOW; i != 0; i--)
+                {
+                    *(pOverlap_and_Add_Buffer_1++)  =  fxp_mul_16_by_16(dat1, win1) >> shift;
+
+                    dat1 = *(pFreq_2_Time_data_1++);
+                    win1 = *(pShort_Window_1++);
+                }
+
+                /* -------- segment C ---------------*/
+                temp = *pOverlap_and_Add_Buffer_2;
+                dat1 = *(pFreq_2_Time_data_2++);
+                win1 = *(pShort_Window_2--);
+
+                for (i = SHORT_WINDOW; i != 0; i--)
+                {
+                    *(pOverlap_and_Add_Buffer_2++)  =  temp + (fxp_mul_16_by_16(dat1, win1) >> shift);
+
+                    temp = *pOverlap_and_Add_Buffer_2;
+                    dat1 = *(pFreq_2_Time_data_2++);
+                    win1 = *(pShort_Window_2--);
+                }
+            }
+
+        }   /* if (exp < 16) */
+        else
+        {
+            pv_memset(
+                pScrath_mem,
+                0,
+                HALF_SHORT_WINDOW*sizeof(*pScrath_mem));
+
+            pv_memset(
+                pOverlap_and_Add_Buffer_1,
+                0,
+                HALF_SHORT_WINDOW*sizeof(*pOverlap_and_Add_Buffer_1));
+        }
+
+
+        wnd = NUM_SHORT_WINDOWS / 2 - 1;
+
+        pFreqInfo = (Int16 *) & pFrequency_data[ wnd*SHORT_WINDOW];
+
+        pScrath_mem_entry =
+            &pFrequency_data[2*LONG_WINDOW - HALF_SHORT_WINDOW - SHORT_WINDOW];
+        pScrath_mem = pScrath_mem_entry;
+
+        pOverlap_and_Add_Buffer_1 = &pFrequency_data[ LONG_WINDOW];
+
+        /* point to end of buffer less HALF_SHORT_WINDOW */
+
+        pOutput_buffer_2 = &Output_buffer[LONG_WINDOW - HALF_SHORT_WINDOW];
+        pOutput_buffer   = pOutput_buffer_2;
+
+        pOverlap_and_Add_Buffer_1x = &Time_data[W_L_STOP_1 + SHORT_WINDOW*(wnd+1)];  /* !!!! */
+
+        exp = imdct_fxp(
+                  (Int32 *)pFreqInfo,
+                  freq_2_time_buffer,
+                  SHORT_BLOCK1,
+                  Q_format,
+                  abs_max_per_window[wnd]);
+
+        /*
+         *  If all element are zero or if the exponent is bigger than
+         *  16 ( it becomes an undefined shift) ->  skip
+         */
+
+        if (exp < 16)
+        {
+
+            pFreq_2_Time_data_1 = &pFreqInfo[0];
+            pFreq_2_Time_data_2 = &pFreqInfo[SHORT_WINDOW];
+
+
+            /*
+             * For short window 3
+             *                             ===========|====
+             *                                    3   |
+             *                             |      |   |   |
+             *               _--_  _--_  _-|-_  _-|-_ | _-|-_  _--_  _--_  _--_
+             *              /    \/    \/  |  \/  |  \|/  |  \/    \/    \/    \
+             *             /     /\    /\  |  /\  |  /|\  |  /\    /\    /\     \
+             *            /     /  \  /  \ | /  \ | / | \ | /  \  /  \  /  \     \
+             *           /     /    \/    \|/    \|/  |  \|/    \/    \     \     \
+             *     -----|------------------[\\\\\\|///|///]--------------------------
+             *          |                  |   A  | B | C |
+             *
+             *      W_L_STOP_1
+             */
+
+
+            pShort_Window_1 = &Short_Window_fxp[wnd_shape_this_bk][0];
+
+            pShort_Window_2 =
+                &Short_Window_fxp[wnd_shape_this_bk][SHORT_WINDOW_m_1];
+
+            shift = exp + 15 - SCALING;
+
+
+            Int16 win1;
+            Int16  dat1;
+            /* -------- segment A ---------------*/
+            dat1 = *(pFreq_2_Time_data_1++);
+            win1 = *(pShort_Window_1++);
+            for (i = SHORT_WINDOW; i != 0; i--)
+            {
+                *(pScrath_mem++)  =  fxp_mul_16_by_16(dat1, win1) >> shift;
+                dat1 = *(pFreq_2_Time_data_1++);
+                win1 = *(pShort_Window_1++);
+            }
+
+            dat1 = *(pFreq_2_Time_data_2++);
+            win1 = *(pShort_Window_2--);
+
+            /* -------- segment B ---------------*/
+            for (i = HALF_SHORT_WINDOW; i != 0; i--)
+            {
+                test = fxp_mul_16_by_16(dat1, win1) >> shift;
+
+                temp =  *(pScrath_mem++) + test;
+
+
+                test = *(pOverlap_and_Add_Buffer_1x++);  /* !!!! */
+
+                limiter(*(pOutput_buffer++), (temp + test));
+
+                dat1 = *(pFreq_2_Time_data_2++);
+                win1 = *(pShort_Window_2--);
+
+            }
+
+            /* -------- segment C ---------------*/
+            for (i = HALF_SHORT_WINDOW; i != 0; i--)
+            {
+                temp = fxp_mul_16_by_16(dat1, win1) >> (shift);
+
+                *(pOverlap_and_Add_Buffer_1++) += temp;
+
+                dat1 = *(pFreq_2_Time_data_2++);
+                win1 = *(pShort_Window_2--);
+            }
+
+        }   /* if (exp < 16) */
+        else
+        {
+
+            pv_memset(
+                pScrath_mem,
+                0,
+                SHORT_WINDOW*sizeof(*pScrath_mem));
+
+            pScrath_mem += SHORT_WINDOW;
+
+            temp = *(pScrath_mem++);
+            for (i = HALF_SHORT_WINDOW; i != 0; i--)
+            {
+                limiter(*(pOutput_buffer++), temp);
+                temp = *(pScrath_mem++);
+
+
+            }
+        }
+
+
+        for (wnd = NUM_SHORT_WINDOWS / 2 - 2; wnd >= 0; wnd--)
+        {
+
+
+            pOutput_buffer_2 -= SHORT_WINDOW;
+            pOutput_buffer = pOutput_buffer_2;
+
+            /*
+             * The same memory is used as scratch in every iteration
+             */
+            pScrath_mem = pScrath_mem_entry;
+
+            pOverlap_and_Add_Buffer_2x =
+                &Time_data[W_L_STOP_1 + SHORT_WINDOW*(wnd+1)];
+
+            pFreqInfo = (Int16 *) & pFrequency_data[ wnd*SHORT_WINDOW];
+
+
+
+            exp = imdct_fxp(
+                      (Int32 *)pFreqInfo,
+                      freq_2_time_buffer,
+                      SHORT_BLOCK1,
+                      Q_format,
+                      abs_max_per_window[wnd]);
+
+            /*
+             *  If all element are zero or if the exponent is bigger than
+             *  16 ( it becomes an undefined shift) ->  skip
+             */
+
+            if (exp < 16)
+            {
+
+                pFreq_2_Time_data_1 = &pFreqInfo[0];
+                pFreq_2_Time_data_2 = &pFreqInfo[SHORT_WINDOW];
+
+
+                /*
+                 *  Each of the eight short blocks is windowed separately.
+                 *  Window shape decisions are made on a frame-by-frame
+                 *  basis.
+                 */
+
+                pShort_Window_1 = &Short_Window_fxp[wnd_shape_this_bk][0];
+
+                if (wnd == 0)
+                {
+                    pShort_Window_1 =
+                        &Short_Window_fxp[wnd_shape_prev_bk][0];
+                }
+
+                pShort_Window_2   =
+                    &Short_Window_fxp[wnd_shape_this_bk][SHORT_WINDOW_m_1];
+
+
+                /*
+                 * For short windows from 2 to 0
+                 *
+                 *          =========================
+                 *                                       |
+                 *                0     1     2      |   |
+                 *               _--_  _--_  _--_  _-|-_ | _--_  _--_  _--_  _--_
+                 *              /    \/    \/    \/  |  \|/    \/    \/    \/    \
+                 *             /     /\    /\    /\  |  /|\    /\    /\    /\     \
+                 *            /     /  \  /  \  /  \ | / | \  /  \  /  \  /  \     \
+                 *           /     /    \/    \/    \|/  |  \/    \/    \     \     \
+                 *      ----[\\\\\\\\\\\\\\\\\\\\\\\\]---|-----------------------------
+                 *          |
+                 *
+                 *      W_L_STOP_1
+                 */
+
+                shift = exp + 15 - SCALING;
+
+                Int16 dat1 = *(pFreq_2_Time_data_2++);
+                Int16 win1 = *(pShort_Window_2--);
+
+                temp  =  *(pScrath_mem);
+                for (i = SHORT_WINDOW; i != 0; i--)
+                {
+                    test  =  fxp_mul_16_by_16(dat1, win1) >> shift;
+
+                    temp += test;
+
+                    dat1 = *(pFreq_2_Time_data_1++);
+                    win1 = *(pShort_Window_1++);
+
+                    limiter(*(pOutput_buffer++), (temp + *(pOverlap_and_Add_Buffer_2x++)));
+
+
+                    *(pScrath_mem++) = fxp_mul_16_by_16(dat1, win1) >> shift;
+                    dat1 = *(pFreq_2_Time_data_2++);
+                    win1 = *(pShort_Window_2--);
+                    temp  =  *(pScrath_mem);
+
+                }
+
+            }   /* if (exp < 16) */
+            else
+            {
+                test  = *(pScrath_mem);
+                temp  = *(pOverlap_and_Add_Buffer_2x++);
+
+                for (i = SHORT_WINDOW; i != 0; i--)
+                {
+                    limiter(*(pOutput_buffer++), (temp + test));
+
+                    *(pScrath_mem++) = 0;
+                    test  =  *(pScrath_mem);
+                    temp  = *(pOverlap_and_Add_Buffer_2x++);
+
+                }
+            }
+
+        }   /* for ( wnd=NUM_SHORT_WINDOWS/2-1; wnd>=0; wnd--) */
+
+        pOverlap_and_Add_Buffer_2x =  &Time_data[W_L_STOP_1];
+
+        pScrath_mem = pScrath_mem_entry;
+
+        pOutput_buffer_2 -= SHORT_WINDOW;
+        pOutput_buffer = pOutput_buffer_2;
+
+        test  = *(pScrath_mem++);
+        temp  = *(pOverlap_and_Add_Buffer_2x++);
+
+        for (i = SHORT_WINDOW; i != 0; i--)
+        {
+            limiter(*(pOutput_buffer++), (temp + test));
+
+            test  = *(pScrath_mem++);
+            temp  = *(pOverlap_and_Add_Buffer_2x++);
+
+        }
+
+        pOverlap_and_Add_Buffer_1x = Time_data;
+
+        pOutput_buffer = Output_buffer;
+
+
+        temp = *(pOverlap_and_Add_Buffer_1x++);
+
+        for (i = W_L_STOP_1; i != 0; i--)
+        {
+            limiter(*(pOutput_buffer++), temp);
+
+            temp = *(pOverlap_and_Add_Buffer_1x++);
+        }
+
+        pOverlap_and_Add_Buffer_1x = &Time_data[0];
+
+        pOverlap_and_Add_Buffer_2 = &pFrequency_data[LONG_WINDOW];
+
+        /*
+         *  update overlap and add buffer,
+         *  so is ready for next iteration
+         */
+
+        for (int i = 0; i < W_L_STOP_2; i++)
+        {
+            temp = *(pOverlap_and_Add_Buffer_2++);
+            *(pOverlap_and_Add_Buffer_1x++) = temp;
+        }
+
+        pv_memset(
+            pOverlap_and_Add_Buffer_1x,
+            0,
+            W_L_STOP_1*sizeof(*pOverlap_and_Add_Buffer_1x));
+
+    } /* if ( wnd_seq != EIGHT_SHORT_SEQUENCE) */
+
+}
+
+#endif
+/*----------------------------------------------------------------------------
+; FUNCTION CODE
+----------------------------------------------------------------------------*/
+
+
+
+void trans4m_freq_2_time_fxp_2(
+    Int32               Frequency_data[],
+    Int32               Time_data[],
+    WINDOW_SEQUENCE     wnd_seq,
+    Int                 wnd_shape_prev_bk,
+    Int                 wnd_shape_this_bk,
+    Int                 Q_format,
+    Int32               abs_max_per_window[],
+    Int32               freq_2_time_buffer[],
+    Int16               *Interleaved_output)
+
+{
+
+    Int exp;
+    Int shift;
+
+    Int  i;
+    Int  wnd;
+#if !(defined( PV_ARM_GCC_V5)||(PV_ARM_V5))
+    Int32 z;
+#endif
+    Int16 *pFreqInfo;
+    Int32 temp;
+    Int32 test;
+
+    Int16 *pFreq_2_Time_data_1;
+    Int16 *pFreq_2_Time_data_2;
+
+    const Int16 *pLong_Window_1;
+    const Int16 *pLong_Window_2;
+    const Int16 *pShort_Window_1;
+    const Int16 *pShort_Window_2;
+
+    Int32 *pOverlap_and_Add_Buffer_1;
+    Int32 *pOverlap_and_Add_Buffer_2;
+
+    Int16  *pInterleaved_output;
+    Int16  *pInterleaved_output_2;
+
+
+    const Int16 * Long_Window_fxp[NUM_WINDOW_SHAPES];
+    const Int16 * Short_Window_fxp[NUM_WINDOW_SHAPES];
+
+    Long_Window_fxp[0] = Long_Window_sine_fxp;
+    Long_Window_fxp[1] = Long_Window_KBD_fxp;
+    Short_Window_fxp[0] = Short_Window_sine_fxp;
+    Short_Window_fxp[1] = Short_Window_KBD_fxp;
+
+    if (wnd_seq != EIGHT_SHORT_SEQUENCE)
+    {
+
+        pFreqInfo = (Int16 *)Frequency_data;
+
+
+        exp = imdct_fxp(
+                  (Int32 *)pFreqInfo,
+                  freq_2_time_buffer,
+                  LONG_BLOCK1,
+                  Q_format,
+                  abs_max_per_window[0]);
+
+
+        /*
+         *  The C Programming Language, Second Edition, Kernighan & Ritchie,
+         *  page 206.
+         *  "The result [of a shift] is undefined if the right operand is
+         *  negative, or greater than or equal to the number of bits in the
+         *  left expression's type"
+         *   => avoid shift by 32 or 16
+         */
+
+        if (exp < 16)
+        {
+
+            pFreq_2_Time_data_1 = pFreqInfo;
+
+
+            switch (wnd_seq)
+            {
+
+                case ONLY_LONG_SEQUENCE:
+                default:
+
+                {
+                    pOverlap_and_Add_Buffer_1 = Time_data;
+
+                    pInterleaved_output = Interleaved_output;
+
+                    {
+
+                        const Int16 *pLong_Window_2 = &Long_Window_fxp[wnd_shape_this_bk][LONG_WINDOW_m_1];
+
+                        Int32 * pFreq2T   = (Int32 *)pFreqInfo;
+                        Int32 * pFreq2T_2 = &pFreq2T[HALF_LONG_WINDOW];
+                        Int32 * win = (Int32 *) & Long_Window_fxp[wnd_shape_prev_bk][0];
+
+                        Int shift = exp + 15 - SCALING;
+
+                        for (i = HALF_LONG_WINDOW; i != 0; i--)
+                        {
+                            Int16 win1, win2;
+                            Int32  temp2, test2;
+
+                            Int32  winx;
+
+                            temp2 = *(pFreq2T++);
+                            winx = *(win++);
+
+                            test  = *(pOverlap_and_Add_Buffer_1++);
+                            test2 = *(pOverlap_and_Add_Buffer_1--);
+                            temp  =   fxp_mul_16_by_16bb(temp2, winx) >> shift;
+                            temp2 =   fxp_mul_16_by_16tt(temp2, winx) >> shift;
+
+                            limiter(*(pInterleaved_output), (temp + test));
+
+                            limiter(*(pInterleaved_output + 2), (temp2 + test2));
+                            pInterleaved_output += 4;
+
+                            temp2 = *(pFreq2T_2++);
+
+                            win1  = *(pLong_Window_2--);
+                            win2  = *(pLong_Window_2--);
+                            temp  = fxp_mul_16_by_16bb(temp2, win1) >> shift;
+                            test2 = fxp_mul_16_by_16tb(temp2, win2) >> shift;
+
+                            *(pOverlap_and_Add_Buffer_1++) = temp;
+                            *(pOverlap_and_Add_Buffer_1++) = test2;
+                        }
+
+                    }
+
+                }
+
+                break;
+
+                case LONG_START_SEQUENCE:
+
+                    pFreq_2_Time_data_2 =
+                        &pFreq_2_Time_data_1[ HALF_LONG_WINDOW];
+
+                    pLong_Window_1 = &Long_Window_fxp[wnd_shape_prev_bk][0];
+                    pLong_Window_2 = &pLong_Window_1[ HALF_LONG_WINDOW];
+
+                    pOverlap_and_Add_Buffer_1 = &Time_data[0];
+                    pOverlap_and_Add_Buffer_2 = &Time_data[HALF_LONG_WINDOW];
+
+
+                    pInterleaved_output   = Interleaved_output;
+                    pInterleaved_output_2 = pInterleaved_output + (2 * HALF_LONG_WINDOW);
+
+
+                    /*
+                     *  process first  LONG_WINDOW elements
+                     */
+
+                    shift = exp + 15 - SCALING;
+
+                    for (i = HALF_LONG_WINDOW; i != 0; i--)
+                    {
+                        Int16 win1, win2;
+                        Int16  dat1, dat2;
+                        Int32  test1, test2;
+
+                        dat1   = *(pFreq_2_Time_data_1++);
+                        win1   = *(pLong_Window_1++);
+                        test1  = *(pOverlap_and_Add_Buffer_1++);
+
+                        dat2  =  *(pFreq_2_Time_data_2++);
+                        win2  = *(pLong_Window_2++);
+                        test2 = *(pOverlap_and_Add_Buffer_2++);
+
+                        limiter(*(pInterleaved_output), (test1 + (fxp_mul_16_by_16(dat1, win1) >> shift)));
+
+                        pInterleaved_output   += 2;
+
+                        limiter(*(pInterleaved_output_2), (test2 + (fxp_mul_16_by_16(dat2, win2) >> shift)));
+
+                        pInterleaved_output_2    += 2;
+                    }
+
+
+                    /*
+                     *  data unchanged from  LONG_WINDOW to W_L_START_1
+                     *  only scaled accordingly
+                     */
+
+                    pOverlap_and_Add_Buffer_1 = &Time_data[0];
+                    pFreq_2_Time_data_1       = &pFreqInfo[LONG_WINDOW];
+
+                    exp -= SCALING;
+
+                    if (exp >= 0)
+                    {
+
+                        for (i = (W_L_START_1 - LONG_WINDOW) >> 1; i != 0; i--)
+                        {
+                            *(pOverlap_and_Add_Buffer_1++) =
+                                *(pFreq_2_Time_data_1++) >> exp;
+                            *(pOverlap_and_Add_Buffer_1++) =
+                                *(pFreq_2_Time_data_1++) >> exp;
+
+                        }
+
+                    }
+                    else if (exp < 0)
+                    {
+
+                        Int shift = -exp;
+                        for (i = (W_L_START_1 - LONG_WINDOW) >> 1; i != 0 ; i--)
+                        {
+                            Int32 temp2 = ((Int32) * (pFreq_2_Time_data_1++)) << shift;
+                            *(pOverlap_and_Add_Buffer_1++) = temp2;
+                            temp2 = ((Int32) * (pFreq_2_Time_data_1++)) << shift;
+                            *(pOverlap_and_Add_Buffer_1++) = temp2;
+                        }
+
+                    }
+                    else
+                    {
+
+                        for (i = (W_L_START_1 - LONG_WINDOW) >> 1; i != 0; i--)
+                        {
+                            *(pOverlap_and_Add_Buffer_1++) =
+                                *(pFreq_2_Time_data_1++);
+                            *(pOverlap_and_Add_Buffer_1++) =
+                                *(pFreq_2_Time_data_1++);
+
+                        }
+
+                    }
+
+
+                    pFreq_2_Time_data_1  = &pFreqInfo[W_L_START_1];
+                    pFreq_2_Time_data_2  =
+                        &pFreq_2_Time_data_1[HALF_SHORT_WINDOW];
+
+                    pShort_Window_1   =
+                        &Short_Window_fxp[wnd_shape_this_bk][SHORT_WINDOW_m_1];
+
+                    pShort_Window_2   = pShort_Window_1 - HALF_SHORT_WINDOW;
+
+                    pOverlap_and_Add_Buffer_2 = pOverlap_and_Add_Buffer_1 +
+                                                HALF_SHORT_WINDOW;
+
+                    {
+                        Int16 win1, win2;
+                        Int16  dat1, dat2;
+                        Int32  temp2;
+
+                        for (i = HALF_SHORT_WINDOW; i != 0; i--)
+                        {
+
+                            dat1  = (*pFreq_2_Time_data_1++);
+                            dat2  = (*pFreq_2_Time_data_2++);
+                            win1  = *(pShort_Window_1--);
+                            win2  = *(pShort_Window_2--);
+
+                            temp   =   fxp_mul_16_by_16(dat1, win1) >> shift;
+                            *(pOverlap_and_Add_Buffer_1++) = temp;
+
+                            temp2 =   fxp_mul_16_by_16(dat2, win2) >> shift;
+                            *(pOverlap_and_Add_Buffer_2++) = temp2;
+
+                        }
+                    }
+
+                    pOverlap_and_Add_Buffer_1 += HALF_SHORT_WINDOW;
+
+
+                    pv_memset(
+                        pOverlap_and_Add_Buffer_1,
+                        0,
+                        (LONG_BLOCK1 - W_L_START_2)
+                        *sizeof(*pOverlap_and_Add_Buffer_1));
+
+
+                    break;
+
+
+                case LONG_STOP_SEQUENCE:
+
+                    pOverlap_and_Add_Buffer_1 = &Time_data[ W_L_STOP_2];
+
+                    pInterleaved_output    = &Interleaved_output[2*W_L_STOP_2];
+
+                    pFreq_2_Time_data_1      = &pFreqInfo[W_L_STOP_2];
+
+                    exp -= SCALING;
+
+
+                    if (exp > 0)
+                    {
+                        Int16 tmp1 = (*(pFreq_2_Time_data_1++) >> exp);
+                        temp = *(pOverlap_and_Add_Buffer_1++);
+
+                        for (i = (LONG_WINDOW - W_L_STOP_2); i != 0; i--)
+                        {
+                            limiter(*(pInterleaved_output), (temp + tmp1));
+
+                            pInterleaved_output += 2;
+                            tmp1 = *(pFreq_2_Time_data_1++) >> exp;
+                            temp = *(pOverlap_and_Add_Buffer_1++);
+                        }
+                    }
+                    else if (exp < 0)
+                    {
+                        shift = -exp;
+
+                        Int32 temp1 = ((Int32) * (pFreq_2_Time_data_1++)) << shift;
+                        temp = *(pOverlap_and_Add_Buffer_1++);
+
+                        for (i = (LONG_WINDOW - W_L_STOP_2); i != 0; i--)
+                        {
+                            limiter(*(pInterleaved_output), (temp + temp1));
+
+                            pInterleaved_output += 2;
+                            temp1 = ((Int32) * (pFreq_2_Time_data_1++)) << shift;
+                            temp = *(pOverlap_and_Add_Buffer_1++);
+                        }
+                    }
+                    else
+                    {
+                        Int16 tmp1 = *(pFreq_2_Time_data_1++);
+                        temp = *(pOverlap_and_Add_Buffer_1++);
+                        for (i = (LONG_WINDOW - W_L_STOP_2); i != 0; i--)
+                        {
+                            limiter(*(pInterleaved_output), (temp + tmp1));
+
+                            pInterleaved_output += 2;
+                            tmp1 = *(pFreq_2_Time_data_1++);
+                            temp = *(pOverlap_and_Add_Buffer_1++);
+                        }
+                    }
+
+
+
+                    pShort_Window_1 = &Short_Window_fxp[wnd_shape_prev_bk][0];
+                    pShort_Window_2 = &pShort_Window_1[HALF_SHORT_WINDOW];
+
+                    pFreq_2_Time_data_1 = &pFreqInfo[W_L_STOP_1];
+                    pFreq_2_Time_data_2 =
+                        &pFreq_2_Time_data_1[HALF_SHORT_WINDOW];
+
+                    pOverlap_and_Add_Buffer_1 = &Time_data[ W_L_STOP_1];
+                    pOverlap_and_Add_Buffer_2 = pOverlap_and_Add_Buffer_1
+                                                + HALF_SHORT_WINDOW;
+
+
+                    pInterleaved_output   = &Interleaved_output[2*W_L_STOP_1];
+                    pInterleaved_output_2 = pInterleaved_output + (2 * HALF_SHORT_WINDOW);
+
+                    exp += SCALING;  /* +8 back to what it was */
+                    shift = exp + 15 - SCALING;
+
+
+                    for (i = HALF_SHORT_WINDOW; i != 0; i--)
+                    {
+
+                        Int16 win1;
+                        Int16 dat1;
+
+                        dat1 = *(pFreq_2_Time_data_1++);
+                        win1 = *(pShort_Window_1++);
+                        temp = *(pOverlap_and_Add_Buffer_1++);
+
+                        test  = fxp_mul_16_by_16(dat1, win1);
+
+                        limiter(*(pInterleaved_output), (temp + (test >> shift)));
+
+                        pInterleaved_output += 2;
+
+                        dat1 = *(pFreq_2_Time_data_2++);
+                        win1 = *(pShort_Window_2++);
+                        temp = *(pOverlap_and_Add_Buffer_2++);
+                        test =  fxp_mul_16_by_16(dat1, win1);
+
+                        limiter(*(pInterleaved_output_2), (temp + (test >> shift)));
+
+                        pInterleaved_output_2 += 2;
+
+                    }
+
+
+
+                    pFreq_2_Time_data_2 = &pFreqInfo[LONG_WINDOW];
+
+                    pOverlap_and_Add_Buffer_1 = Time_data;
+
+
+                    pInterleaved_output = Interleaved_output;
+
+                    pLong_Window_2   =
+                        &Long_Window_fxp[wnd_shape_this_bk][LONG_WINDOW_m_1];
+
+
+                    /*
+                     *  Copy previous time in current buffer, also copy overlap
+                     *  and add buffer
+                     */
+
+                    for (i = W_L_STOP_1; i != 0; i--)
+                    {
+
+                        Int16 win1;
+                        Int16 dat1;
+
+                        win1 = *(pLong_Window_2--);
+                        dat1 = *pFreq_2_Time_data_2++;
+
+                        limiter(*(pInterleaved_output), *(pOverlap_and_Add_Buffer_1));
+
+                        pInterleaved_output += 2;
+
+                        temp = fxp_mul_16_by_16(dat1, win1) >> shift;
+                        *(pOverlap_and_Add_Buffer_1++) = temp ;
+
+                    }
+
+                    for (i = (LONG_WINDOW - W_L_STOP_1); i != 0; i--)
+                    {
+
+                        temp = fxp_mul_16_by_16(*pFreq_2_Time_data_2++, *(pLong_Window_2--)) >> shift;
+                        *(pOverlap_and_Add_Buffer_1++) = temp ;
+
+                    }
+
+                    break;
+
+
+
+            } /* switch (wnd_seq) */
+
+        }   /*  if (exp < 16)  */
+
+        else
+        {
+            /* all zeros buffer or excessive down shift */
+
+            /* Overlap and add, setup buffer for next iteration */
+            pOverlap_and_Add_Buffer_1 = &Time_data[0];
+
+            pInterleaved_output = Interleaved_output;
+
+
+            temp  = (*pOverlap_and_Add_Buffer_1++);
+            for (i = LONG_WINDOW; i != 0; i--)
+            {
+
+                limiter(*(pInterleaved_output), temp);
+
+                pInterleaved_output += 2;
+                temp  = (*pOverlap_and_Add_Buffer_1++);
+            }
+            pv_memset(Time_data, 0, LONG_WINDOW*sizeof(Time_data[0]));
+        }
+
+    }
+    else
+    {
+
+        Int32 *pScrath_mem;
+        Int32 *pScrath_mem_entry;
+        Int32  *pFrequency_data = Frequency_data;
+
+        Int32 * pOverlap_and_Add_Buffer_1;
+        Int32 * pOverlap_and_Add_Buffer_2;
+        Int32 * pOverlap_and_Add_Buffer_1x;
+        Int32 * pOverlap_and_Add_Buffer_2x;
+
+
+        /*
+         *  Frequency_data is 2*LONG_WINDOW length but only
+         *  the first LONG_WINDOW elements are filled in,
+         *  then the second part can be used as scratch mem,
+         *  then grab data from one window at a time in
+         *  reverse order.
+         *  The upper LONG_WINDOW Int32 are used to hold the
+         *  computed overlap and add, used in the next call to
+         *  this function, and also as sctrach memory
+         */
+
+        /*
+         *  Frequency_data usage for the case EIGHT_SHORT_SEQUENCE
+
+          |<----- Input Freq. data ----->|< Overlap & Add ->| Unused |-Scratch-|
+          |                              |  Store for next  |        |  memory |
+          |                              |  call            |        |         |
+          |                              |                  |        |         |
+          |//////////////////////////////|\\\\\\\\\\\\\\\\\\|--------|+++++++++|
+          |                              |                  |        |         |
+          0                         LONG_WINDOW        LONG_WINDOW   |   2*LONG_WINDOW
+                                                            +        |         |
+                                                       W_L_STOP_2    |         |
+                                                                     |<--   -->|
+                                                                      SHORT_WINDOW +
+                                                                    HALF_SHORT_WINDOW
+          *
+          */
+
+        pOverlap_and_Add_Buffer_1  = &pFrequency_data[
+                                         LONG_WINDOW + 3*SHORT_WINDOW + HALF_SHORT_WINDOW];
+
+        /*
+         *  Initialize to zero, only the firt short window used in overlap
+         *  and add
+         */
+        pv_memset(
+            pOverlap_and_Add_Buffer_1,
+            0,
+            SHORT_WINDOW*sizeof(*pOverlap_and_Add_Buffer_1));
+
+        /*
+         *  Showt windows are evaluated in decresing order. Windows from 7
+         *  to 0 are break down in four cases: window numbers 7 to 5, 4, 3,
+         *  and 2 to 0.
+         *  The data from short windows 3 and 4 is situated at the boundary
+         *  between the 'overlap and add' buffer and the output buffer.
+         */
+        for (wnd = NUM_SHORT_WINDOWS - 1; wnd >= NUM_SHORT_WINDOWS / 2 + 1; wnd--)
+        {
+
+            pFreqInfo = (Int16 *) & pFrequency_data[ wnd*SHORT_WINDOW];
+
+            exp = imdct_fxp(
+                      (Int32 *)pFreqInfo,
+                      freq_2_time_buffer,
+                      SHORT_BLOCK1,
+                      Q_format,
+                      abs_max_per_window[wnd]);
+
+            /*  W_L_STOP_1 == (LONG_WINDOW - SHORT_WINDOW)>>1 */
+            pOverlap_and_Add_Buffer_1 =
+                &pFrequency_data[ W_L_STOP_1 + SHORT_WINDOW*wnd];
+
+
+            pOverlap_and_Add_Buffer_2 =
+                pOverlap_and_Add_Buffer_1 + SHORT_WINDOW;
+
+            /*
+             *  If all element are zero or if the exponent is bigger than
+             *  16 ( it becomes an undefined shift) ->  skip
+             */
+
+            if (exp < 16)
+            {
+
+
+                pFreq_2_Time_data_1 = &pFreqInfo[0];
+                pFreq_2_Time_data_2 = &pFreqInfo[SHORT_WINDOW];
+
+
+                /*
+                 *  Each of the eight short blocks is windowed separately.
+                 *  Window shape decisions are made on a frame-by-frame
+                 *  basis.
+                 */
+
+                pShort_Window_1 = &Short_Window_fxp[wnd_shape_this_bk][0];
+
+                pShort_Window_2   =
+                    &Short_Window_fxp[wnd_shape_this_bk][SHORT_WINDOW_m_1];
+
+
+
+
+                /*
+                 * For short windows from 7 to 5
+                 *                                      |   =========================
+                 *                                      |   |     5     6     7
+                 *               _--_  _--_  _--_  _--_ | _-|-_  _--_  _--_  _--_
+                 *              /    \/    \/    \/    \|/  |  \/    \/    \/    \
+                 *             /     /\    /\    /\    /|\  |  /\    /\    /\     \
+                 *            /     /  \  /  \  /  \  / | \ | /  \  /  \  /  \     \
+                 *           /     /    \/    \/    \/  |  \|/    \/    \     \     \
+                 *      --------------------------------|---[///////////////////////]--------
+                 *
+                 */
+
+
+                shift = exp + 15 - SCALING;
+
+
+                for (i = SHORT_WINDOW; i != 0; i--)
+                {
+                    Int16 win1, win2;
+                    Int16  dat1, dat2;
+
+                    dat2 = *(pFreq_2_Time_data_2++);
+                    win2 = *(pShort_Window_2--);
+                    temp = *pOverlap_and_Add_Buffer_2;
+                    dat1 = *(pFreq_2_Time_data_1++);
+                    win1 = *(pShort_Window_1++);
+
+                    *(pOverlap_and_Add_Buffer_2++) =  temp + (fxp_mul_16_by_16(dat2, win2) >> shift);
+
+                    *(pOverlap_and_Add_Buffer_1++)  =  fxp_mul_16_by_16(dat1, win1) >> shift;
+
+                }
+
+            }   /* if (exp < 16) */
+            else
+            {
+                pv_memset(
+                    pOverlap_and_Add_Buffer_1,
+                    0,
+                    SHORT_WINDOW*sizeof(*pOverlap_and_Add_Buffer_1));
+            }
+
+
+        }/* for ( wnd=NUM_SHORT_WINDOWS-1; wnd>=NUM_SHORT_WINDOWS/2; wnd--) */
+
+
+        wnd = NUM_SHORT_WINDOWS / 2;
+
+        pFreqInfo = (Int16 *) & pFrequency_data[ wnd*SHORT_WINDOW];
+
+        /*
+         *  scratch memory is allocated in an unused part of memory
+         */
+
+
+        pScrath_mem = &pFrequency_data[ 2*LONG_WINDOW - HALF_SHORT_WINDOW];
+
+        pOverlap_and_Add_Buffer_1 = &pFrequency_data[ LONG_WINDOW];
+
+        pOverlap_and_Add_Buffer_2 = pOverlap_and_Add_Buffer_1
+                                    + HALF_SHORT_WINDOW;
+
+
+        exp = imdct_fxp(
+                  (Int32 *)pFreqInfo,
+                  freq_2_time_buffer,
+                  SHORT_BLOCK1,
+                  Q_format,
+                  abs_max_per_window[wnd]);
+
+        /*
+         *  If all element are zero or if the exponent is bigger than
+         *  16 ( it becomes an undefined shift) ->  skip
+         */
+
+
+        if (exp < 16)
+        {
+
+            pFreq_2_Time_data_1 = &pFreqInfo[0];
+            pFreq_2_Time_data_2 = &pFreqInfo[SHORT_WINDOW];
+
+            pShort_Window_1 = &Short_Window_fxp[wnd_shape_this_bk][0];
+
+            pShort_Window_2 =
+                &Short_Window_fxp[wnd_shape_this_bk][SHORT_WINDOW_m_1];
+
+
+            /*
+             * For short window 4
+             *                                    ====|===========
+             *                                        |   4
+             *                                    |   |   |      |
+             *                _--_  _--_  _--_  _-|-_ | _-|-_  _-|-_  _--_  _--_
+             *               /    \/    \/    \/  |  \|/  |  \/  |  \/    \/    \
+             *              /     /\    /\    /\  |  /|\  |  /\  |  /\    /\     \
+             *             /     /  \  /  \  /  \ | / | \ | /  \ | /  \  /  \     \
+             *            /     /    \/    \/    \|/  |  \|/    \|/    \/    \     \
+             *      ------------------------------[\\\|\\\|//////]-------------------
+             *           |                        | A | B |   C  |
+             *           |
+             *        W_L_STOP_1
+             */
+
+            shift = exp + 15 - SCALING;
+            {
+                Int16 win1;
+                Int16  dat1;
+                /* -------- segment A ---------------*/
+                dat1 = *(pFreq_2_Time_data_1++);
+                win1 = *(pShort_Window_1++);
+                for (i = HALF_SHORT_WINDOW; i != 0; i--)
+                {
+                    *(pScrath_mem++)  =  fxp_mul_16_by_16(dat1, win1) >> shift;
+                    dat1 = *(pFreq_2_Time_data_1++);
+                    win1 = *(pShort_Window_1++);
+                }
+
+                /* -------- segment B ---------------*/
+                for (i = HALF_SHORT_WINDOW; i != 0; i--)
+                {
+                    *(pOverlap_and_Add_Buffer_1++)  =  fxp_mul_16_by_16(dat1, win1) >> shift;
+
+                    dat1 = *(pFreq_2_Time_data_1++);
+                    win1 = *(pShort_Window_1++);
+                }
+
+                /* -------- segment C ---------------*/
+                temp = *pOverlap_and_Add_Buffer_2;
+                dat1 = *(pFreq_2_Time_data_2++);
+                win1 = *(pShort_Window_2--);
+
+                for (i = SHORT_WINDOW; i != 0; i--)
+                {
+                    *(pOverlap_and_Add_Buffer_2++)  =  temp + (fxp_mul_16_by_16(dat1, win1) >> shift);
+
+                    temp = *pOverlap_and_Add_Buffer_2;
+                    dat1 = *(pFreq_2_Time_data_2++);
+                    win1 = *(pShort_Window_2--);
+                }
+            }
+
+        }   /* if (exp < 16) */
+        else
+        {
+            pv_memset(
+                pScrath_mem,
+                0,
+                HALF_SHORT_WINDOW*sizeof(*pScrath_mem));
+
+            pv_memset(
+                pOverlap_and_Add_Buffer_1,
+                0,
+                HALF_SHORT_WINDOW*sizeof(*pOverlap_and_Add_Buffer_1));
+        }
+
+
+        wnd = NUM_SHORT_WINDOWS / 2 - 1;
+
+        pFreqInfo = (Int16 *) & pFrequency_data[ wnd*SHORT_WINDOW];
+
+        pScrath_mem_entry =
+            &pFrequency_data[2*LONG_WINDOW - HALF_SHORT_WINDOW - SHORT_WINDOW];
+
+
+        pScrath_mem = pScrath_mem_entry;
+
+        pOverlap_and_Add_Buffer_1 = &pFrequency_data[ LONG_WINDOW];
+
+        /* point to end of buffer less HALF_SHORT_WINDOW */
+
+        pInterleaved_output_2 = &Interleaved_output[2*(LONG_WINDOW - HALF_SHORT_WINDOW)];
+        pInterleaved_output = pInterleaved_output_2;
+
+        pOverlap_and_Add_Buffer_1x = &Time_data[W_L_STOP_1 + SHORT_WINDOW*(wnd+1)];
+
+
+        exp = imdct_fxp(
+                  (Int32 *)pFreqInfo,
+                  freq_2_time_buffer,
+                  SHORT_BLOCK1,
+                  Q_format,
+                  abs_max_per_window[wnd]);
+
+        /*
+         *  If all element are zero or if the exponent is bigger than
+         *  16 ( it becomes an undefined shift) ->  skip
+         */
+
+        if (exp < 16)
+        {
+
+            pFreq_2_Time_data_1 = &pFreqInfo[0];
+            pFreq_2_Time_data_2 = &pFreqInfo[SHORT_WINDOW];
+
+
+            /*
+             * For short window 3
+             *                             ===========|====
+             *                                    3   |
+             *                             |      |   |   |
+             *               _--_  _--_  _-|-_  _-|-_ | _-|-_  _--_  _--_  _--_
+             *              /    \/    \/  |  \/  |  \|/  |  \/    \/    \/    \
+             *             /     /\    /\  |  /\  |  /|\  |  /\    /\    /\     \
+             *            /     /  \  /  \ | /  \ | / | \ | /  \  /  \  /  \     \
+             *           /     /    \/    \|/    \|/  |  \|/    \/    \     \     \
+             *     -----|------------------[\\\\\\|///|///]--------------------------
+             *          |                  |   A  | B | C |
+             *
+             *      W_L_STOP_1
+             */
+
+
+            pShort_Window_1 = &Short_Window_fxp[wnd_shape_this_bk][0];
+
+            pShort_Window_2 =
+                &Short_Window_fxp[wnd_shape_this_bk][SHORT_WINDOW_m_1];
+
+            shift = exp + 15 - SCALING;
+
+            Int16 win1;
+            Int16  dat1;
+            /* -------- segment A ---------------*/
+            dat1 = *(pFreq_2_Time_data_1++);
+            win1 = *(pShort_Window_1++);
+            for (i = SHORT_WINDOW; i != 0; i--)
+            {
+                *(pScrath_mem++)  =  fxp_mul_16_by_16(dat1, win1) >> shift;
+                dat1 = *(pFreq_2_Time_data_1++);
+                win1 = *(pShort_Window_1++);
+            }
+
+            dat1 = *(pFreq_2_Time_data_2++);
+            win1 = *(pShort_Window_2--);
+
+
+            /* -------- segment B ---------------*/
+            for (i = HALF_SHORT_WINDOW; i != 0; i--)
+            {
+                test = fxp_mul_16_by_16(dat1, win1) >> shift;
+
+                temp =  *(pScrath_mem++) + test;
+
+                test = *(pOverlap_and_Add_Buffer_1x++);
+                limiter(*(pInterleaved_output), (temp + test));
+
+
+                pInterleaved_output += 2;
+                dat1 = *(pFreq_2_Time_data_2++);
+                win1 = *(pShort_Window_2--);
+
+            }
+
+            /* -------- segment C ---------------*/
+            for (i = HALF_SHORT_WINDOW; i != 0; i--)
+            {
+
+                temp = fxp_mul_16_by_16(dat1, win1) >> shift;
+
+                *(pOverlap_and_Add_Buffer_1++) += temp;
+
+                dat1 = *(pFreq_2_Time_data_2++);
+                win1 = *(pShort_Window_2--);
+            }
+
+
+        }   /* if (exp < 16) */
+        else
+        {
+
+            pv_memset(
+                pScrath_mem,
+                0,
+                SHORT_WINDOW*sizeof(*pScrath_mem));
+
+            pScrath_mem += SHORT_WINDOW;
+
+            temp = *(pScrath_mem++);
+            for (i = HALF_SHORT_WINDOW; i != 0; i--)
+            {
+                limiter(*(pInterleaved_output), (temp));
+
+                pInterleaved_output += 2;
+                temp = *(pScrath_mem++);
+
+            }
+        }
+
+
+        for (wnd = NUM_SHORT_WINDOWS / 2 - 2; wnd >= 0; wnd--)
+        {
+
+
+            pInterleaved_output_2 -= (SHORT_WINDOW * 2);
+            pInterleaved_output = pInterleaved_output_2;
+
+            /*
+             * The same memory is used as scratch in every iteration
+             */
+            pScrath_mem = pScrath_mem_entry;
+
+            pOverlap_and_Add_Buffer_2x =
+                &Time_data[W_L_STOP_1 + SHORT_WINDOW*(wnd+1)];
+
+            pFreqInfo = (Int16 *) & pFrequency_data[ wnd*SHORT_WINDOW];
+
+
+
+            exp = imdct_fxp(
+                      (Int32 *)pFreqInfo,
+                      freq_2_time_buffer,
+                      SHORT_BLOCK1,
+                      Q_format,
+                      abs_max_per_window[wnd]);
+
+            /*
+             *  If all element are zero or if the exponent is bigger than
+             *  16 ( it becomes an undefined shift) ->  skip
+             */
+
+            if (exp < 16)
+            {
+
+                pFreq_2_Time_data_1 = &pFreqInfo[0];
+                pFreq_2_Time_data_2 = &pFreqInfo[SHORT_WINDOW];
+
+
+                /*
+                 *  Each of the eight short blocks is windowed separately.
+                 *  Window shape decisions are made on a frame-by-frame
+                 *  basis.
+                 */
+
+                pShort_Window_1 = &Short_Window_fxp[wnd_shape_this_bk][0];
+
+                if (wnd == 0)
+                {
+                    pShort_Window_1 =
+                        &Short_Window_fxp[wnd_shape_prev_bk][0];
+                }
+
+                pShort_Window_2   =
+                    &Short_Window_fxp[wnd_shape_this_bk][SHORT_WINDOW_m_1];
+
+
+                /*
+                 * For short windows from 2 to 0
+                 *
+                 *          =========================
+                 *                                       |
+                 *                0     1     2      |   |
+                 *               _--_  _--_  _--_  _-|-_ | _--_  _--_  _--_  _--_
+                 *              /    \/    \/    \/  |  \|/    \/    \/    \/    \
+                 *             /     /\    /\    /\  |  /|\    /\    /\    /\     \
+                 *            /     /  \  /  \  /  \ | / | \  /  \  /  \  /  \     \
+                 *           /     /    \/    \/    \|/  |  \/    \/    \     \     \
+                 *      ----[\\\\\\\\\\\\\\\\\\\\\\\\]---|-----------------------------
+                 *          |
+                 *
+                 *      W_L_STOP_1
+                 */
+
+                shift = exp + 15 - SCALING;
+
+                Int16 dat1 = *(pFreq_2_Time_data_2++);
+                Int16 win1 = *(pShort_Window_2--);
+
+                temp  =  *(pScrath_mem);
+                for (i = SHORT_WINDOW; i != 0; i--)
+                {
+                    test  =  fxp_mul_16_by_16(dat1, win1) >> shift;
+
+                    temp += test;
+                    dat1 = *(pFreq_2_Time_data_1++);
+                    win1 = *(pShort_Window_1++);
+
+                    limiter(*(pInterleaved_output), (temp + *(pOverlap_and_Add_Buffer_2x++)));
+
+                    pInterleaved_output += 2;
+
+                    *(pScrath_mem++) = fxp_mul_16_by_16(dat1, win1) >> shift;
+                    dat1 = *(pFreq_2_Time_data_2++);
+                    win1 = *(pShort_Window_2--);
+                    temp  =  *(pScrath_mem);
+
+                }
+
+            }   /* if (exp < 16) */
+            else
+            {
+                test  = *(pScrath_mem);
+                temp  = *(pOverlap_and_Add_Buffer_2x++);
+
+                for (i = SHORT_WINDOW; i != 0; i--)
+                {
+                    limiter(*(pInterleaved_output), (temp + test));
+
+                    pInterleaved_output += 2;
+
+                    *(pScrath_mem++) = 0;
+                    test  =  *(pScrath_mem);
+                    temp  = *(pOverlap_and_Add_Buffer_2x++);
+                }
+            }
+
+        }   /* for ( wnd=NUM_SHORT_WINDOWS/2-1; wnd>=0; wnd--) */
+
+        pOverlap_and_Add_Buffer_2x =  &Time_data[W_L_STOP_1];
+
+        pScrath_mem = pScrath_mem_entry;
+
+        pInterleaved_output_2 -= (SHORT_WINDOW * 2);
+        pInterleaved_output    = pInterleaved_output_2;
+
+        test  = *(pScrath_mem++);
+        temp  = *(pOverlap_and_Add_Buffer_2x++);
+
+        for (i = SHORT_WINDOW; i != 0; i--)
+        {
+            limiter(*(pInterleaved_output), (temp + test));
+
+            pInterleaved_output += 2;
+            test  = *(pScrath_mem++);
+            temp  = *(pOverlap_and_Add_Buffer_2x++);
+
+        }
+
+        pOverlap_and_Add_Buffer_1x = Time_data;
+
+        pInterleaved_output = Interleaved_output;
+
+
+        temp = *(pOverlap_and_Add_Buffer_1x++);
+        for (i = W_L_STOP_1; i != 0; i--)
+        {
+            limiter(*(pInterleaved_output), temp);
+
+            pInterleaved_output += 2;
+            temp = *(pOverlap_and_Add_Buffer_1x++);
+
+        }
+
+        pOverlap_and_Add_Buffer_1x = &Time_data[0];
+
+        pOverlap_and_Add_Buffer_2 = &pFrequency_data[LONG_WINDOW];
+
+        /*
+         *  update overlap and add buffer,
+         *  so is ready for next iteration
+         */
+
+        for (int i = 0; i < W_L_STOP_2; i++)
+        {
+            temp = *(pOverlap_and_Add_Buffer_2++);
+            *(pOverlap_and_Add_Buffer_1x++) = temp;
+        }
+
+        pv_memset(
+            pOverlap_and_Add_Buffer_1x,
+            0,
+            W_L_STOP_1*sizeof(*pOverlap_and_Add_Buffer_1x));
+
+    } /* if ( wnd_seq != EIGHT_SHORT_SEQUENCE) */
+
+
+
+
+}   /* trans4m_freq_2_time_fxp */
+
+
+
+
diff --git a/media/libstagefright/codecs/aacdec/trans4m_time_2_freq_fxp.cpp b/media/libstagefright/codecs/aacdec/trans4m_time_2_freq_fxp.cpp
new file mode 100644
index 0000000..b1b44f0
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/trans4m_time_2_freq_fxp.cpp
@@ -0,0 +1,663 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+  Pathname: trans4m_time_2_freq_fxp.c
+  Function: trans4m_time_2_freq_fxp
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+ Description:
+        Modified normalization, so it now happen per window basis, eliminated
+        shifts left or rigth to accomodate TNS inverse filtering. The output
+        is 32 bits but only the lowest 16 are being used.
+        Modified fuction interface
+
+ Description: Modified variable names with leading "p" for pointers
+
+ Description:
+        Modified call to mdct_fxp to reflect extended precision use. Added routine
+        buffer_adaptation to extract 16 MSB and keep highest precision.
+        Modify casting to ensure proper operations for different platforms
+
+ Description:
+        Added comments according to code review
+
+ Description:
+        Removed include file "buffer_normalization.h"
+
+ Description:
+        Eliminated buffer_adaptation() and embedded its functionality in other
+        functions. Commented out the short window section given that this is
+        not supported by the standards
+
+ Description:
+        Added shift down operation for case when the window was equal to one.
+        This was not needed previuosly because buffer_adaptation() was doing
+        it.
+
+ Description: Created local version of vectors Long_Window_fxp and
+              Short_Window_fxp. This solve linking problem when using the
+              /ropi option (Read-only position independent) for some
+              compilers.
+
+
+ Who:                       Date:
+ Description:
+
+------------------------------------------------------------------------------
+ INPUT AND OUTPUT DEFINITIONS
+
+ Inputs:
+    Time2Freq_data    =  buffer with data in the time domain, it holds 2048
+                         points of input time data
+                         Output holds frequency (first 1024 points )
+                         type Int32
+
+    wnd_seq           =  window sequence
+                         type WINDOW_SEQUENCE
+
+    wnd_shape_prev_bk =  previous window shape type
+                         type Int
+
+    wnd_shape_this_bk =  current window shape type
+                         type Int
+
+    pQ_format          =  Holds the Q format of the data in, and data out
+                         type Int *
+
+    mem_4_in_place_FFT[] =  scratch memory for computing FFT, 1024 point
+                         type Int32
+
+
+
+ Local Stores/Buffers/Pointers Needed:
+    None
+
+ Global Stores/Buffers/Pointers Needed:
+    None
+
+ Outputs:
+    None
+
+ Pointers and Buffers Modified:
+    Frequency information (1024 pts.) is returned in Time2Freq_data
+    pQ_format content spectral coefficients Q format
+
+ Local Stores Modified:
+    None
+
+ Global Stores Modified:
+    None
+
+------------------------------------------------------------------------------
+ FUNCTION DESCRIPTION
+
+The time/frequency representation of the signal is mapped onto the frequency
+domain by feeding it into the filterbank module. This module consists of
+a modified discrete cosine transform (MDCT), (windowing and DCT).
+In order to adapt the time/frequency resolution of the filterbank to the
+ characteristics of the input signal, a block switching tool is also
+adopted. N represents the window length, where N is a function of the
+window_sequence. For each channel, the N time values are transformed into the
+N/2 frequency domain values via the MDCT.
+
+The adaptation of the time-frequency resolution of the filterbank to the
+characteristics of the input signal is done by shifting between transforms
+whose input lengths are either 2048 or 256 samples. By enabling the block
+switching tool, the following transitions are meaningful:
+
+from ONLY_LONG_SEQUENCE to   { LONG_START_SEQUENCE
+                               ONLY_LONG_SEQUENCE
+
+from LONG_START_SEQUENCE to  { LONG_STOP_SEQUENCE
+                               EIGHT_SHORT_SEQUENCE
+
+from LONG_STOP_SEQUENCE to   { LONG_START_SEQUENCE
+                               ONLY_LONG_SEQUENCE
+
+from EIGHT_SHORT_SEQUENCE to { LONG_STOP_SEQUENCE
+                               EIGHT_SHORT_SEQUENCE
+
+Window shape decisions are made by the encoder on a frame-by-frame-basis.
+The window selected is applicable to the second half of the window function
+only, since the first half is constrained to use the appropriate window
+shape from the preceding frame.
+The 2048 time-domain values x'(i)(n), (i window, n sample) to be windowed are
+the last 1024 values of the previous window_sequence concatenated with 1024
+values of the current block. The formula below shows this fact:
+
+                     |  x(i-1)(n+1024)      for    0 < n < 1024
+            x'(i)(n) {
+                     |  x(i)(n)             for 1024 < n < 2048
+
+
+
+Once the window shape is selected, the window_shape syntax element is
+initialized. Together with the chosen window_sequence all information needed
+for windowing exist.
+With the window halves described below all window_sequences can be assembled.
+For window_shape == 1, the window coefficients are given by the Kaiser -
+Bessel derived (KBD) window.
+Otherwise, for window_shape == 0, a sine window is employed.
+
+The window length N can be 2048 or 256 for the KBD and the sine window.
+All four window_sequences explained below have a total length of 2048
+samples.
+For all kinds of window_sequences the window_shape of the left half of
+the first transform window is determined by the window shape of the previous
+block.
+------------------------------------------------------------------------------
+ REQUIREMENTS
+
+    This module shall implement a scheme to switch between window types and
+    in turn perform time to frequency transformations
+
+
+------------------------------------------------------------------------------
+ REFERENCES
+
+    [1] ISO 14496-3:1999, pag 111
+
+------------------------------------------------------------------------------
+ PSEUDO-CODE
+
+    IF ( wnd_seq == EIGHT_SHORT_SEQUENCE)
+    THEN
+
+
+        FOR ( wnd=0; wnd<NUM_SHORT_WINDOWS; wnd++)
+
+            time_info = &Time2Freq_data[ W_L_STOP_1 + wnd*SHORT_WINDOW]
+
+            FOR( i=0; i<SHORT_BLOCK1; i++)
+                aux_temp[i] = time_info[i]
+            ENDFOR
+
+
+            IF (wnd == 0)
+            THEN
+                pShort_Window_1 = &Short_Window[wnd_shape_prev_bk][0]
+            ELSE
+                pShort_Window_1 = &Short_Window[wnd_shape_this_bk][0]
+            ENDIF
+
+
+            pShort_Window_2   =
+                    &Short_Window[wnd_shape->this_bk][SHORT_WINDOW_m_1]
+
+            FOR( i=0, j=SHORT_WINDOW; i<SHORT_WINDOW; i++, j--)
+                aux_temp[             i]  *= pShort_Window_1[i]
+                aux_temp[SHORT_WINDOW+i]  *= pShort_Window_2[j]
+            ENDFOR
+
+
+            CALL MDCT( aux_temp, SHORT_BLOCK1)
+            MODIFYING( aux_temp)
+
+            FOR( i=0; i<SHORT_WINDOW; i++)
+                Time2Freq_data[wnd*SHORT_WINDOW + i] = aux_temp[i];
+            ENDFOR
+
+        ENDFOR
+
+    ELSE
+
+        SWITCH ( wnd_seq)
+
+            CASE ( ONLY_LONG_SEQUENCE)
+
+                pLong_Window_1 = &Long_Window[wnd_shape_prev_bk][0]
+                pLong_Window_2 =
+                        &Long_Window[wnd_shape_this_bk][LONG_WINDOW_m_1]
+
+                FOR (i=0; i<LONG_WINDOW; i++)
+                    Time2Freq_data[            i] *= *pLong_Window_1++
+                    Time2Freq_data[LONG_WINDOW+i] *= *pLong_Window_2--
+                ENDFOR
+
+                BREAK
+
+
+            CASE ( LONG_START_SEQUENCE)
+
+                pLong_Window_1 = &Long_Window[wnd_shape_prev_bk][0];
+
+                FOR ( i=0; i<LONG_WINDOW; i++)
+                    Time2Freq_data[ i] *= *pLong_Window_1++;
+                ENDFOR
+
+
+                pShort_Window_1   =
+                        &Short_Window[wnd_shape->this_bk][SHORT_WINDOW_m_1];
+
+                FOR ( i=0; i<SHORT_WINDOW; i++)
+                    Time2Freq_data[W_L_START_1 + i] *= *pShort_Window_1--;
+                ENDFOR
+
+
+                FOR ( i=W_L_START_2; i<LONG_BLOCK1; i++)
+                    Time2Freq_data[W_L_START_2 + i] = 0;
+                ENDFOR
+
+                BREAK
+
+
+            CASE ( LONG_STOP_SEQUENCE )
+
+                FOR ( i=0; i<W_L_STOP_1; i++)
+                    Time2Freq_data[ i] = 0;
+                ENDFOR
+
+
+                pShort_Window_1   = &Short_Window[wnd_shape->prev_bk][0];
+
+                FOR ( i=0; i<SHORT_WINDOW; i++)
+                    Time2Freq_data[W_L_STOP_1+ i] *= *pShort_Window_1++;
+                ENDFOR
+
+
+                pLong_Window_1 =
+                        &Long_Window[wnd_shape->this_bk][LONG_WINDOW_m_1];
+
+                FOR ( i=0; i<LONG_WINDOW; i++)
+                    Time2Freq_data[LONG_WINDOW + i]  *=  *pLong_Window_1--;
+                ENDFOR
+
+                BREAK
+
+
+        }
+
+        MDCT( Time2Freq_data, LONG_BLOCK1);
+        MODIFYING( Time2Freq_data)
+
+    ENDIF
+
+------------------------------------------------------------------------------
+ RESOURCES USED
+   When the code is written for a specific target processor the
+     the resources used should be documented below.
+
+ STACK USAGE: [stack count for this module] + [variable to represent
+          stack usage for each subroutine called]
+
+     where: [stack usage variable] = stack usage for [subroutine
+         name] (see [filename].ext)
+
+ DATA MEMORY USED: x words
+
+ PROGRAM MEMORY USED: x words
+
+ CLOCK CYCLES: [cycle count equation for this module] + [variable
+           used to represent cycle count for each subroutine
+           called]
+
+     where: [cycle count variable] = cycle count for [subroutine
+        name] (see [filename].ext)
+
+------------------------------------------------------------------------------
+*/
+
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+
+#include "pv_audio_type_defs.h"
+#include "aac_mem_funcs.h"
+#include "window_block_fxp.h"
+#include "mdct_fxp.h"
+#include "long_term_prediction.h"
+#include    "fxp_mul32.h"
+
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here. Include conditional
+; compile variables also.
+----------------------------------------------------------------------------*/
+/*----------------------------------------------------------------------------
+; LOCAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; LOCAL VARIABLE DEFINITIONS
+; Variable declaration - defined here and used outside this module
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL FUNCTION REFERENCES
+; Declare functions defined elsewhere and referenced in this module
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL VARIABLES REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL GLOBAL STORE/BUFFER/POINTER REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; FUNCTION CODE
+----------------------------------------------------------------------------*/
+void trans4m_time_2_freq_fxp(
+    Int32   Time2Freq_data[],       /* time data size 2048 */
+    WINDOW_SEQUENCE wnd_seq,        /* window sequence */
+    Int     wnd_shape_prev_bk,      /* window shape, current and previous  */
+    Int     wnd_shape_this_bk,
+    Int     *pQ_format,
+    Int32   mem_4_in_place_FFT[])   /* scratch memory for computing FFT */
+{
+
+    Int  i;
+
+    Int32   *pAux_temp_1;
+    Int32   *pAux_temp_2;
+    Int32   *pAux_temp;
+//    Int32   temp;
+    const   Int16 *pLong_Window_1;
+    const   Int16 *pLong_Window_2;
+    const   Int16 *pShort_Window_1;
+    const   Int16 *pShort_Window_2;
+    Int     shift = *pQ_format - 1;
+
+    const Int16 * Long_Window_fxp[NUM_WINDOW_SHAPES];
+    const Int16 * Short_Window_fxp[NUM_WINDOW_SHAPES];
+
+    Long_Window_fxp[0] = Long_Window_sine_fxp;
+    Long_Window_fxp[1] = Long_Window_KBD_fxp;
+    Short_Window_fxp[0] = Short_Window_sine_fxp;
+    Short_Window_fxp[1] = Short_Window_KBD_fxp;
+
+    if (wnd_seq != EIGHT_SHORT_SEQUENCE)
+    {
+
+        pAux_temp = Time2Freq_data;
+
+        *pQ_format = LTP_Q_FORMAT - *pQ_format;
+
+        pAux_temp_1 = pAux_temp;
+
+        switch (wnd_seq)
+        {
+
+            case LONG_START_SEQUENCE:
+
+                pAux_temp_2 = &pAux_temp_1[HALF_LONG_WINDOW];
+
+                pLong_Window_1 = &Long_Window_fxp[wnd_shape_prev_bk][0];
+                pLong_Window_2 = &pLong_Window_1[ HALF_LONG_WINDOW];
+
+
+
+
+                for (i = HALF_LONG_WINDOW; i > 0; i--)
+                {
+
+                    *pAux_temp_1 = fxp_mul32_by_16((*pAux_temp_1), *pLong_Window_1++) >> shift;
+                    pAux_temp_1++;
+                    *pAux_temp_2 = fxp_mul32_by_16((*pAux_temp_2), *pLong_Window_2++) >> shift;
+                    pAux_temp_2++;
+
+                }
+
+
+                /* data unchanged from  LONG_WINDOW to W_L_START_1 */
+                pAux_temp_1 = &pAux_temp[LONG_WINDOW];
+                if (shift)
+                {
+                    for (i = (W_L_START_1 - LONG_WINDOW) >> 1; i != 0; i--)
+                    {
+                        *(pAux_temp_1++) >>= shift;
+                        *(pAux_temp_1++) >>= shift;
+                    }
+                }
+
+
+                pAux_temp_1 = &pAux_temp[W_L_START_1];
+                pAux_temp_2 = &pAux_temp_1[HALF_SHORT_WINDOW];
+
+                pShort_Window_1   =
+                    &Short_Window_fxp[wnd_shape_this_bk][SHORT_WINDOW_m_1];
+
+                pShort_Window_2   = pShort_Window_1 - HALF_SHORT_WINDOW;
+
+                for (i = HALF_SHORT_WINDOW; i > 0; i--)
+                {
+
+                    *pAux_temp_1 = fxp_mul32_by_16((*pAux_temp_1), *pShort_Window_1--) >> shift;
+                    pAux_temp_1++;
+                    *pAux_temp_2 = fxp_mul32_by_16((*pAux_temp_2), *pShort_Window_2--) >> shift;
+                    pAux_temp_2++;
+
+                }
+
+                pAux_temp_1 = &pAux_temp[W_L_START_2];
+
+                pv_memset(
+                    pAux_temp_1,
+                    0,
+                    (LONG_BLOCK1 - W_L_START_2)*sizeof(*pAux_temp_1));
+
+                break;
+
+
+            case LONG_STOP_SEQUENCE:
+
+                pv_memset(
+                    pAux_temp_1,
+                    0,
+                    (W_L_STOP_1)*sizeof(*pAux_temp_1));
+
+                pShort_Window_1   = &Short_Window_fxp[wnd_shape_prev_bk][0];
+                pShort_Window_2   = &pShort_Window_1[HALF_SHORT_WINDOW];
+
+                pAux_temp_1      = &pAux_temp_1[W_L_STOP_1];
+                pAux_temp_2      = pAux_temp_1 + HALF_SHORT_WINDOW;
+
+                for (i = HALF_SHORT_WINDOW; i > 0; i--)
+                {
+
+                    *pAux_temp_1 = fxp_mul32_by_16((*pAux_temp_1), *pShort_Window_1++) >> shift;
+                    pAux_temp_1++;
+                    *pAux_temp_2 = fxp_mul32_by_16((*pAux_temp_2), *pShort_Window_2++) >> shift;
+                    pAux_temp_2++;
+
+
+                }
+
+                /* data unchanged from  W_L_STOP_2 to LONG_WINDOW */
+                pAux_temp_1 = &pAux_temp[W_L_STOP_2];
+
+                if (shift)
+                {
+                    for (i = ((LONG_WINDOW - W_L_STOP_2) >> 1); i != 0; i--)
+                    {
+                        *(pAux_temp_1++) >>= shift;
+                        *(pAux_temp_1++) >>= shift;
+                    }
+                }
+
+
+
+                pAux_temp_1 = &pAux_temp[LONG_WINDOW];
+                pAux_temp_2 =  pAux_temp_1 + HALF_LONG_WINDOW;
+
+                pLong_Window_1 =
+                    &Long_Window_fxp[wnd_shape_this_bk][LONG_WINDOW_m_1];
+
+
+                pLong_Window_2   = &pLong_Window_1[-HALF_LONG_WINDOW];
+
+                for (i = HALF_LONG_WINDOW; i > 0; i--)
+                {
+                    *pAux_temp_1 = fxp_mul32_by_16((*pAux_temp_1), *pLong_Window_1--) >> shift;
+                    pAux_temp_1++;
+                    *pAux_temp_2 = fxp_mul32_by_16((*pAux_temp_2), *pLong_Window_2--) >> shift;
+                    pAux_temp_2++;
+
+                }
+
+                break;
+
+            case ONLY_LONG_SEQUENCE:
+            default:
+
+                pAux_temp_2 = &pAux_temp[LONG_WINDOW];
+
+                pLong_Window_1 = &Long_Window_fxp[wnd_shape_prev_bk][0];
+
+
+                pLong_Window_2 =
+                    &Long_Window_fxp[wnd_shape_this_bk][LONG_WINDOW_m_1];
+
+
+                for (i = LONG_WINDOW; i > 0; i--)
+                {
+
+                    *pAux_temp_1 = fxp_mul32_by_16((*pAux_temp_1), *pLong_Window_1++) >> shift;
+                    pAux_temp_1++;
+                    *pAux_temp_2 = fxp_mul32_by_16((*pAux_temp_2), *pLong_Window_2--) >> shift;
+                    pAux_temp_2++;
+                }
+
+                break;
+
+        }   /* end switch ( wnd_seq)  */
+
+
+
+        *pQ_format += mdct_fxp(
+                          pAux_temp,
+                          mem_4_in_place_FFT,
+                          LONG_BLOCK1);
+
+
+    }   /* end if( wnd_seq != EIGHT_SHORT_SEQUENCE) */
+
+
+
+    /*****************************************/
+    /* decoding process for short window */
+    /*****************************************/
+
+    /*
+     * For short window the following code will be applied
+     * in the future when short window is supported in the
+     * standards
+     */
+    /*-------------------------------------------------------------------------
+
+    *        pAux_temp = &mem_4_in_place_FFT[(2*SHORT_BLOCK1)];
+    *
+    *        for ( wnd=0; wnd<NUM_SHORT_WINDOWS; wnd++)
+    *        {
+    *
+    *            pShort_Window_1 = &Short_Window_fxp[wnd_shape_this_bk][0];
+    *
+    *            if (wnd == 0)
+    *            {
+    *                pShort_Window_1 = &Short_Window_fxp[wnd_shape_prev_bk][0];
+    *            }
+    *
+    *            pShort_Window_2   =
+    *                    &Short_Window_fxp[wnd_shape_this_bk][SHORT_WINDOW_m_1];
+    *
+    *            pAux_temp_1 =  pAux_temp;
+    *            pAux_temp_2 = pAux_temp_1 + SHORT_WINDOW;
+    *
+    *            Q_aux = 0;
+    *
+    *            buffer_adaptation (
+    *                &Q_aux,
+    *                &Time2Freq_data[ W_L_STOP_1 + wnd*SHORT_WINDOW],
+    *                (void *) pAux_temp,
+    *                SHORT_BLOCK1,
+    *                USING_INT,
+    *                16);
+    *
+    *
+    *            for ( i=SHORT_WINDOW; i>0; i--)
+    *            {
+    *                temp           = (*pAux_temp_1) * *pShort_Window_1++;
+    *                *pAux_temp_1++ = (temp + 0x08000L) >> 16;
+    *
+    *                temp           = (*pAux_temp_2) * *pShort_Window_2--;
+    *                *pAux_temp_2++ = (temp + 0x08000L) >> 16;
+    *
+    *            }
+    *
+    *
+    *            exp = mdct_fxp(
+    *                pAux_temp,
+    *                mem_4_in_place_FFT,
+    *                SHORT_BLOCK1);
+    *
+    *
+    *            exp += Q_aux;
+    *
+    *            pAux_temp_1  =  pAux_temp;
+    *            pAux_temp_2  =  pAux_temp_1  +  HALF_SHORT_WINDOW;
+    *            pTime_data_1 = &Time2Freq_data[wnd*SHORT_WINDOW];
+    *            pTime_data_2 =  pTime_data_1 + HALF_SHORT_WINDOW;
+    *
+    *
+    *            if (exp > 0)
+    *            {
+    *                for ( i=HALF_SHORT_WINDOW; i>0; i--)
+    *                {
+    *                    *pTime_data_1++ = (*pAux_temp_1++>>exp);
+    *                    *pTime_data_2++ = (*pAux_temp_2++>>exp);
+    *                }
+    *            }
+    *            else if (exp < 0)
+    *            {
+    *                exp = -exp;
+    *                for ( i=HALF_SHORT_WINDOW; i>0; i--)
+    *                {
+    *                    *pTime_data_1++ = (*pAux_temp_1++<<exp);
+    *                    *pTime_data_2++ = (*pAux_temp_2++<<exp);
+    *                }
+    *            }
+    *            else
+    *            {
+    *                for ( i=HALF_SHORT_WINDOW; i>0; i--)
+    *                {
+    *                    *pTime_data_1++ = (*pAux_temp_1++);
+    *                    *pTime_data_2++ = (*pAux_temp_2++);
+    *                }
+    *            }
+    *
+    *        }
+    *
+    *    }
+    *
+    *--------------------------------------------------------------------------*/
+
+}   /* trans4m_time_2_freq_fxp */
diff --git a/media/libstagefright/codecs/aacdec/unpack_idx.cpp b/media/libstagefright/codecs/aacdec/unpack_idx.cpp
new file mode 100644
index 0000000..9180994
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/unpack_idx.cpp
@@ -0,0 +1,660 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Pathname: ./src/unpack_idx.c
+ Function:  unpack_idx
+            unpack_idx_sgn
+            unpack_idx_esc
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+ Description:  Modified from original shareware code
+
+ Description:  Eliminated 3 divisions and 1 multiplication through a table
+ look-up method for calculating 1/mod and constant allocation of 1/mod^3
+ and 1/mod^2.
+ Eliminated 3 additions through simple optimizations in the code.
+ Changed if/else  statement to a switch/case utilizing fall-through.
+
+ Description:   Made changes per review comments.  Main improvements were
+ in change of switch/case to if statement, and use of temporary variable
+ to hold value of *pQuantSpec.
+
+ Description: (1) Typecast codeword_indx to Int32 before multiplication, this
+              assures the shift operation happens on a 32-bit product on
+              TI-C55x processor.
+              (2) define temp_spec as Int32 to avoid overflow
+
+ Description: Modified per review comments
+              (1) remove the two typecastings of codeword_indx when
+                  pHuffCodebook->dim == DIMENSION_4
+              (2) temp_spec is Int because the result never exceeds 16 bits
+
+ Description: Break up and combine unpack index with sign bit reading and for
+              special escape code. Parent function must know which one of the
+              3 functions should be called.
+
+ Description: Put back if-statement to get the max.
+
+ Description: When searching for the max, there was some instances where the
+              max was compared against a negative number, so the max was never
+              updated (defaulted to 0), leading to block processing in other
+              magnitude sensitive stages.
+
+ Who:                       Date:
+ Description:
+------------------------------------------------------------------------------
+ INPUT AND OUTPUT DEFINITIONS
+
+ Inputs:
+          Int  quant_spec[]  = Array for storage of the quantized
+                               spectral coefficients.  Length is either 2 or 4.
+                               See Ref #1, Page 76 for a complete description.
+
+          Int  codeword_indx = The index into the Huffman table.
+                               Range is [1-288]
+
+    const Hcb *pHuffCodebook = Pointer to HuffmanCodebook information.
+
+          BITS  *pInputStream = Pointer to the bitstream buffer.
+          Int *max           = Pointer to maximum coefficient value.
+
+ Local Stores/Buffers/Pointers Needed:
+    const UInt div_mod[18]   = An array with the values for 1/mod
+                               stored in Q-formats 13.
+
+ Global Stores/Buffers/Pointers Needed:
+    None
+
+ Outputs:
+    None
+
+ Pointers and Buffers Modified:
+    Int quant_spec[] = Output (the quantized and signed spectral coefficients)
+                       returned via this pointer.
+
+ Local Stores Modified:
+    None
+
+ Global Stores Modified:
+    None
+
+------------------------------------------------------------------------------
+ FUNCTION DESCRIPTION
+
+ This function decodes quantized spectral coefficients and decode their signs
+ from the input bitstream. Quantized spectral coefficients are transmitted as
+ four-tuples or 2-tuples, and this information is conveyed to the function via
+ the variable HuffCodebook->dim.
+
+ See Reference #1 for a complete description
+------------------------------------------------------------------------------
+ REQUIREMENTS
+
+ This function shall correctly calculate pQuantSpec[], given the inputs
+
+ codeword_indx     = {1-288};
+ HuffCodebook->off = {0, 1, 4};
+ HuffCodebook->mod = {3, 8, 9, 13, 17};
+
+ mod =   LAV + 1 if unsigned codebook
+ mod = 2*LAV + 1 if   signed codebook
+
+ Range of values for LAV is {2,7,12,16} if unsigned
+                            {1,4}       if   signed
+
+ Additionally,
+     LAV <= 2 if dim == 4
+
+ This restricts mod ==  3                if dim == 4
+            and mod == {3, 8, 9, 13, 17} if dim == 2
+
+ This function will NOT function correctly if fed values that do not
+ meet the requirements as stated above.
+
+ This limitation on the range of values was determined by analysis
+ of Reference #1 (see below.)
+
+------------------------------------------------------------------------------
+ REFERENCES
+
+ (1) ISO/IEC 14496-3:1999(E)
+     Part 3
+        Subpart 4.6.3.3   Decoding Process
+        Subpart 4.6.4     Tables
+ (2) MPEG-2 NBC Audio Decoder
+   "This software module was originally developed by AT&T, Dolby
+   Laboratories, Fraunhofer Gesellschaft IIS in the course of development
+   of the MPEG-2 NBC/MPEG-4 Audio standard ISO/IEC 13818-7, 14496-1,2 and
+   3. This software module is an implementation of a part of one or more
+   MPEG-2 NBC/MPEG-4 Audio tools as specified by the MPEG-2 NBC/MPEG-4
+   Audio standard. ISO/IEC  gives users of the MPEG-2 NBC/MPEG-4 Audio
+   standards free license to this software module or modifications thereof
+   for use in hardware or software products claiming conformance to the
+   MPEG-2 NBC/MPEG-4 Audio  standards. Those intending to use this software
+   module in hardware or software products are advised that this use may
+   infringe existing patents. The original developer of this software
+   module and his/her company, the subsequent editors and their companies,
+   and ISO/IEC have no liability for use of this software module or
+   modifications thereof in an implementation. Copyright is not released
+   for non MPEG-2 NBC/MPEG-4 Audio conforming products.The original
+   developer retains full right to use the code for his/her  own purpose,
+   assign or donate the code to a third party and to inhibit third party
+   from using the code for non MPEG-2 NBC/MPEG-4 Audio conforming products.
+   This copyright notice must be included in all copies or derivative
+   works."
+   Copyright(c)1996.
+
+------------------------------------------------------------------------------
+ PSEUDO-CODE
+
+    IF (pHuffCodebook->dim == 4)
+        *(pQuantSpec) = codeword_indx/(3^3);
+        codeword_indx = codeword_indx - *(pQuantSpec)*(3^3);
+        *(pQuantSpec) = *(pQuantSpec) - off;
+
+        pQuantSpec    = pQuantSpec + 1;
+
+        *(pQuantSpec) = codeword_indx/(3^2);
+        codeword_indx = codeword_indx - *(pQuantSpec)*(3^2);
+        *(pQuantSpec) = *(pQuantSpec) - off;
+
+        pQuantSpec    = pQuantSpec + 1;
+    ENDIF
+
+        *(pQuantSpec) = codeword_indx/mod;
+        codeword_indx = codeword_indx - (*pQuantSpec)*mod;
+        *(pQuantSpec) = *(pQuantSpec) - off;
+
+        pQuantSpec    = pQuantSpec + 1;
+
+        *(pQuantSpec) = codeword_indx - off;
+
+------------------------------------------------------------------------------
+ RESOURCES USED
+   When the code is written for a specific target processor the
+     the resources used should be documented below.
+
+ STACK USAGE: [stack count for this module] + [variable to represent
+          stack usage for each subroutine called]
+
+     where: [stack usage variable] = stack usage for [subroutine
+         name] (see [filename].ext)
+
+ DATA MEMORY USED: x words
+
+ PROGRAM MEMORY USED: x words
+
+ CLOCK CYCLES: [cycle count equation for this module] + [variable
+           used to represent cycle count for each subroutine
+           called]
+
+     where: [cycle count variable] = cycle count for [subroutine
+        name] (see [filename].ext)
+
+------------------------------------------------------------------------------
+*/
+
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+#include "pv_audio_type_defs.h"
+#include "s_hcb.h"
+#include "ibstream.h"
+#include "unpack_idx.h"
+
+#include "fxp_mul32.h"
+
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here. Include conditional
+; compile variables also.
+----------------------------------------------------------------------------*/
+#define DIV_3_CUBED    19  /* 19 = 1/27 in Q-9 format    */
+#define THREE_CUBED    27  /* 27 = 3^3                   */
+
+#define DIV_3_SQUARED  57  /* 57 = 1/9  in Q-9 format    */
+#define THREE_SQUARED   9  /*  9 = 3^2                   */
+
+#define Q_FORMAT_MOD   13  /* Q-format for 1/mod table   */
+#define Q_FORMAT_MOD2   9  /* Q-format for DIV_3_SQUARED */
+#define Q_FORMAT_MOD3   9  /* Q-format for DIV_3_CUBED   */
+
+#define LOWER_5_BITS_MASK 0x1F
+
+
+#if ( defined(PV_ARM_V5) || defined(PV_ARM_V4))
+
+__inline Int32 abs1(Int32 x)
+{
+    Int32 z;
+    /*
+        z = x - (x<0);
+        x = z ^ sign(z)
+     */
+    __asm
+    {
+        sub  z, x, x, lsr #31
+        eor  x, z, z, asr #31
+    }
+    return (x);
+}
+
+#define pv_abs(x)   abs1(x)
+
+
+#else
+
+#define pv_abs(x)   ((x) > 0)? (x) : (-x)
+
+#endif
+
+
+
+/*----------------------------------------------------------------------------
+; LOCAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; LOCAL STORE/BUFFER/POINTER DEFINITIONS
+; Variable declaration - defined here and used outside this module
+----------------------------------------------------------------------------*/
+/*--------------------------------------------------------------------------
+    Possible values for mod = {3,8,9,13,17}
+
+    There exists "empty" spaces in the table.  These can potentially
+    be utilized by other const tables, if available memory becomes an issue.
+---------------------------------------------------------------------------*/
+
+const Int div_mod[18] =   /*   mod   index  Q-format */
+{
+    /* ----------------------- */
+    0xCC,                 /* |      |  0  |          */
+    0xCC,                 /* |      |  1  |          */
+    0xCC,                 /* |      |  2  |          */
+    2731,                 /* |  3   |  3  |   13     */
+    0xCC,                 /* |      |  4  |          */
+    0xCC,                 /* |      |  5  |          */
+    0xCC,                 /* |      |  6  |          */
+    0xCC,                 /* |      |  7  |          */
+    1025,                 /* |  8   |  8  |   13     */
+    911,                 /* |  9   |  9  |   13     */
+    0xCC,                 /* |      | 10  |          */
+    0xCC,                 /* |      | 11  |          */
+    0xCC,                 /* |      | 12  |          */
+    631,                 /* |  13  | 13  |   13     */
+    0xCC,                 /* |      | 14  |          */
+    0xCC,                 /* |      | 15  |          */
+    0xCC,                 /* |      | 16  |          */
+    482,                 /* |  17  | 17  |   13     */
+};
+
+/*----------------------------------------------------------------------------
+; EXTERNAL FUNCTION REFERENCES
+; Declare functions defined elsewhere and referenced in this module
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL GLOBAL STORE/BUFFER/POINTER REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; FUNCTION CODE
+----------------------------------------------------------------------------*/
+void unpack_idx(
+    Int16   quant_spec[],
+    Int codeword_indx,
+    const Hcb   *pHuffCodebook,
+    BITS  *pInputStream,
+    Int *max)
+{
+    Int16 *pQuantSpec = &quant_spec[0];
+    Int  temp_spec;
+
+    const Int mod = pHuffCodebook->mod;
+    const Int off = pHuffCodebook->off;
+
+    OSCL_UNUSED_ARG(pInputStream);
+
+
+    if (pHuffCodebook->dim == DIMENSION_4)
+    {
+        /* Calculate pQuantSpec[0] */
+
+        temp_spec      = (codeword_indx * DIV_3_CUBED) >> Q_FORMAT_MOD3;
+
+        codeword_indx -= temp_spec * THREE_CUBED;
+
+        temp_spec -= off;
+        *pQuantSpec++  = (Int16)temp_spec;
+
+        temp_spec = pv_abs(temp_spec);
+
+        if (temp_spec > *max)
+        {
+            *max = temp_spec;
+        }
+
+        /* Calculate pQuantSpec[1] */
+        temp_spec      = (codeword_indx * DIV_3_SQUARED) >> Q_FORMAT_MOD2;
+
+        codeword_indx -= temp_spec * THREE_SQUARED;
+
+        temp_spec -= off;
+        *pQuantSpec++  = (Int16)temp_spec;
+
+        temp_spec = pv_abs(temp_spec);
+
+        if (temp_spec > *max)
+        {
+            *max = temp_spec;
+        }
+    }
+
+    /*
+     *  Calculate pQuantSpec[2] if dim == 4
+     *  Calculate pQuantSpec[0] if dim == 2
+     */
+
+    temp_spec      = ((Int32) codeword_indx * div_mod[mod]) >> Q_FORMAT_MOD;
+
+    codeword_indx -= temp_spec * mod;
+
+    temp_spec -= off;
+    *pQuantSpec++  = (Int16)temp_spec;
+
+    temp_spec = pv_abs(temp_spec);
+
+
+    if (temp_spec > *max)
+    {
+        *max = temp_spec;
+    }
+
+    /*
+    *  Calculate pQuantSpec[3] if dim == 4
+    *  Calculate pQuantSpec[1] if dim == 2
+    */
+    codeword_indx -= off;
+    *pQuantSpec    = (Int16)codeword_indx ;
+
+
+    codeword_indx = pv_abs(codeword_indx);
+
+    if (codeword_indx > *max)
+    {
+        *max = codeword_indx;
+    }
+
+
+    return ;
+} /* unpack_idx */
+
+
+void unpack_idx_sgn(
+    Int16   quant_spec[],
+    Int codeword_indx,
+    const Hcb   *pHuffCodebook,
+    BITS  *pInputStream,
+    Int *max)
+{
+    Int16 *pQuantSpec = &quant_spec[0];
+    Int  temp_spec;
+    Int  sgn;
+
+    const Int mod = pHuffCodebook->mod;
+    const Int off = pHuffCodebook->off;
+
+
+
+    if (pHuffCodebook->dim == DIMENSION_4)
+    {
+        /* Calculate pQuantSpec[0] */
+        preload_cache((Int32 *)pQuantSpec);
+        temp_spec      = (codeword_indx * DIV_3_CUBED) >> Q_FORMAT_MOD3;
+
+        codeword_indx -= temp_spec * THREE_CUBED;
+
+        temp_spec -= off;
+        if (temp_spec)
+        {
+            sgn = get1bits(pInputStream);
+
+
+            *pQuantSpec++ = (Int16)((sgn) ? -temp_spec : temp_spec);
+
+            temp_spec = pv_abs(temp_spec);
+
+            if (temp_spec > *max)
+            {
+                *max = temp_spec;
+            }
+
+        }
+        else
+        {
+            *pQuantSpec++ = 0;
+        }
+
+        /* Calculate pQuantSpec[1] */
+        temp_spec      = (codeword_indx * DIV_3_SQUARED) >> Q_FORMAT_MOD2;
+
+        codeword_indx -= temp_spec * THREE_SQUARED;
+
+        temp_spec -= off;
+        if (temp_spec)
+        {
+
+            sgn = get1bits(pInputStream);
+
+            *pQuantSpec++ = (Int16)((sgn) ? -temp_spec : temp_spec);
+
+            temp_spec = pv_abs(temp_spec);
+
+            if (temp_spec > *max)
+            {
+                *max = temp_spec;
+            }
+        }
+        else
+        {
+            *pQuantSpec++ = 0;
+        }
+    }
+
+    /*
+     *  Calculate pQuantSpec[2] if dim == 4
+     *  Calculate pQuantSpec[0] if dim == 2
+     */
+
+    temp_spec      = ((Int32) codeword_indx * div_mod[mod]) >> Q_FORMAT_MOD;
+
+    codeword_indx -= temp_spec * mod;
+
+    temp_spec -= off;
+    if (temp_spec)
+    {
+
+        sgn = get1bits(pInputStream);
+
+        *pQuantSpec++ = (Int16)((sgn) ? -temp_spec : temp_spec);
+
+        temp_spec = pv_abs(temp_spec);
+
+        if (temp_spec > *max)
+        {
+            *max = temp_spec;
+        }
+    }
+    else
+    {
+        *pQuantSpec++ = 0;
+    }
+
+    /*
+     *  Calculate pQuantSpec[3] if dim == 4
+     *  Calculate pQuantSpec[1] if dim == 2
+     */
+    codeword_indx -= off;
+    if (codeword_indx)
+    {
+
+        sgn = get1bits(pInputStream);
+
+        *pQuantSpec = (Int16)((sgn) ? -codeword_indx : codeword_indx);
+
+        codeword_indx = pv_abs(codeword_indx);
+
+        if (codeword_indx > *max)
+        {
+            *max = codeword_indx;
+        }
+    }
+    else
+    {
+        *pQuantSpec = 0;
+    }
+
+    return ;
+} /* unpack_idx_sgn */
+
+
+void unpack_idx_esc(
+    Int16   quant_spec[],
+    Int codeword_indx,
+    const Hcb   *pHuffCodebook,
+    BITS  *pInputStream,
+    Int *max)
+{
+    Int  temp_spec;
+    Int  sgn1 = 0, sgn2 = 0;
+    Int N;
+    Int32 esc_seq;
+
+    const Int mod = pHuffCodebook->mod;
+    const Int off = pHuffCodebook->off;
+
+
+    temp_spec      = ((Int32) codeword_indx * div_mod[mod]) >> Q_FORMAT_MOD;
+
+    codeword_indx -= temp_spec * mod;
+
+    temp_spec -= off;
+    if (temp_spec)
+    {
+        sgn1 = get1bits(pInputStream);
+    }
+
+    codeword_indx -= off;
+    if (codeword_indx)
+    {
+        sgn2 = get1bits(pInputStream);
+    }
+
+
+    if ((temp_spec & LOWER_5_BITS_MASK) == 16)
+    {
+        N = 3;
+        do
+        {
+            N++;
+
+            esc_seq = get1bits(pInputStream);
+
+        }
+        while (esc_seq != 0);
+
+        esc_seq  = getbits(N, pInputStream);
+
+        esc_seq += (1 << N);
+
+
+        temp_spec = (Int)((temp_spec * esc_seq) >> 4);
+
+    }
+
+
+    if (sgn1)
+    {
+        quant_spec[0]  = (Int16)(-temp_spec);
+    }
+    else
+    {
+        quant_spec[0]  = (Int16)temp_spec;
+    }
+
+    temp_spec = pv_abs(temp_spec);
+
+    if (temp_spec > *max)
+    {
+        *max = temp_spec;
+    }
+
+    if ((codeword_indx & LOWER_5_BITS_MASK) == 16)
+    {
+        N = 3;
+        do
+        {
+            N++;
+
+            esc_seq = get1bits(pInputStream);
+
+        }
+        while (esc_seq != 0);
+
+        esc_seq  = getbits(N, pInputStream);
+
+        esc_seq += (1 << N);
+
+        codeword_indx = (Int)((codeword_indx * esc_seq) >> 4);
+    }
+
+
+
+
+    if (sgn2)
+    {
+        quant_spec[1]    = (Int16)(-codeword_indx);
+    }
+    else
+    {
+        quant_spec[1]    = (Int16)codeword_indx;
+    }
+
+
+    codeword_indx = pv_abs(codeword_indx);
+
+    if (codeword_indx > *max)
+    {
+        *max = codeword_indx;
+    }
+
+
+    return ;
+} /* unpack_idx_esc */
diff --git a/media/libstagefright/codecs/aacdec/unpack_idx.h b/media/libstagefright/codecs/aacdec/unpack_idx.h
new file mode 100644
index 0000000..a308c4a
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/unpack_idx.h
@@ -0,0 +1,115 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Pathname: ./include/unpack_idx.h
+
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+ Who:                       Date:
+ Description:
+
+------------------------------------------------------------------------------
+ INCLUDE DESCRIPTION
+
+ This header file includes the function definition for unpack_idx()
+
+------------------------------------------------------------------------------
+*/
+
+/*----------------------------------------------------------------------------
+; CONTINUE ONLY IF NOT ALREADY DEFINED
+----------------------------------------------------------------------------*/
+#ifndef UNPACK_IDX_H
+#define UNPACK_IDX_H
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+#include    "pv_audio_type_defs.h"
+#include    "s_hcb.h"
+#include    "s_bits.h"
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here.
+----------------------------------------------------------------------------*/
+#define DIMENSION_4     4
+
+/*----------------------------------------------------------------------------
+; EXTERNAL VARIABLES REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; SIMPLE TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; ENUMERATED TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; STRUCTURES TYPEDEF'S
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; GLOBAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+
+    void unpack_idx(
+        Int16  QuantSpec[],
+        Int  codeword_indx,
+        const Hcb *pHuffCodebook,
+        BITS  *pInputStream,
+        Int *max);
+    void unpack_idx_sgn(
+        Int16  quant_spec[],
+        Int  codeword_indx,
+        const Hcb *pHuffCodebook,
+        BITS  *pInputStream,
+        Int *max);
+    void unpack_idx_esc(
+        Int16  quant_spec[],
+        Int  codeword_indx,
+        const Hcb *pHuffCodebook,
+        BITS  *pInputStream,
+        Int *max);
+
+#ifdef __cplusplus
+}
+#endif
+
+/*----------------------------------------------------------------------------
+; END
+----------------------------------------------------------------------------*/
+#endif
+
+
diff --git a/media/libstagefright/codecs/aacdec/window_block_fxp.h b/media/libstagefright/codecs/aacdec/window_block_fxp.h
new file mode 100644
index 0000000..f936199
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/window_block_fxp.h
@@ -0,0 +1,231 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Pathname: window_block_fxp.h
+
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+ Description:
+    modified function definition: Time_data from Int to Int32
+    change wnd_shape from structure to passing parameters
+    delete definition of wnd_shape1, not needed.
+
+ Description: Modified based on unit test comments
+
+ Description: Change copyright, add () around constants.
+
+ Description:
+    changed Long_Window_fxp and Short _Window_fxp tables definition, from
+    "const UInt16 *"  to "const UInt16 * const" to avoid global variable
+    definition.
+
+ Description: Updated function trans4m_freq_2_time_fxp definition
+
+ Description:  Modified function interface to add output_buffer
+
+
+ Description:
+
+------------------------------------------------------------------------------
+ INCLUDE DESCRIPTION
+
+ Header file for window and block switch
+
+
+------------------------------------------------------------------------------
+ REFERENCES
+
+ (1) ISO/IEC 13818-7 Part 7: Advanced Audo Coding (AAC)
+
+
+ (2) MPEG-2 NBC Audio Decoder
+   "This software module was originally developed by AT&T, Dolby
+   Laboratories, Fraunhofer Gesellschaft IIS in the course of development
+   of the MPEG-2 NBC/MPEG-4 Audio standard ISO/IEC 13818-7, 14496-1,2 and
+   3. This software module is an implementation of a part of one or more
+   MPEG-2 NBC/MPEG-4 Audio tools as specified by the MPEG-2 NBC/MPEG-4
+   Audio standard. ISO/IEC gives users of the MPEG-2 NBC/MPEG-4 Audio
+   standards free license to this software module or modifications thereof
+   for use in hardware or software products claiming conformance to the
+   MPEG-2 NBC/MPEG-4 Audio  standards. Those intending to use this software
+   module in hardware or software products are advised that this use may
+   infringe existing patents. The original developer of this software
+   module and his/her company, the subsequent editors and their companies,
+   and ISO/IEC have no liability for use of this software module or
+   modifications thereof in an implementation. Copyright is not released
+   for non MPEG-2 NBC/MPEG-4 Audio conforming products.The original
+   developer retains full right to use the code for his/her own purpose,
+   assign or donate the code to a third party and to inhibit third party
+   from using the code for non MPEG-2 NBC/MPEG-4 Audio conforming products.
+   This copyright notice must be included in all copies or derivative
+   works."
+   Copyright(c)1996.
+
+------------------------------------------------------------------------------
+*/
+
+/*----------------------------------------------------------------------------
+; CONTINUE ONLY IF NOT ALREADY DEFINED
+----------------------------------------------------------------------------*/
+#ifndef WINDOW_BLOCK_FXP_H
+#define WINDOW_BLOCK_FXP_H
+
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+#include "pv_audio_type_defs.h"
+#include "e_window_shape.h"
+#include "e_window_sequence.h"
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+    /*----------------------------------------------------------------------------
+    ; DEFINES
+    ; Include all pre-processor statements here.
+    ----------------------------------------------------------------------------*/
+#define LONG_WINDOW         (1024)
+#define SHORT_WINDOW        (128)
+
+#define HALF_LONG_WINDOW    (LONG_WINDOW>>1)
+#define HALF_SHORT_WINDOW   (SHORT_WINDOW>>1)
+
+#define NUM_SHORT_WINDOWS   (8)
+#define LONG_WINDOW_m_1     (LONG_WINDOW-1)
+#define SHORT_WINDOW_m_1    (SHORT_WINDOW-1)
+
+    /*
+     *  Limits for window sequences, they are used to build
+     *  each long window, they are defined in the standards
+     */
+#define W_L_START_1         ((3*LONG_WINDOW - SHORT_WINDOW)>>1)
+#define W_L_START_2         ((3*LONG_WINDOW + SHORT_WINDOW)>>1)
+#define W_L_STOP_1          ((LONG_WINDOW - SHORT_WINDOW)>>1)
+#define W_L_STOP_2          ((LONG_WINDOW + SHORT_WINDOW)>>1)
+
+
+#define LONG_BLOCK1          (2*LONG_WINDOW)
+#define SHORT_BLOCK1         (2*SHORT_WINDOW)
+
+
+#define  SCALING    10
+#define  ROUNDING     (1<<(SCALING-1))
+
+
+    /*----------------------------------------------------------------------------
+    ; EXTERNAL VARIABLES REFERENCES
+    ; Declare variables used in this module but defined elsewhere
+    ----------------------------------------------------------------------------*/
+    extern const Int16 Short_Window_KBD_fxp[ SHORT_WINDOW];
+    extern const Int16 Long_Window_KBD_fxp[ LONG_WINDOW];
+    extern const Int16 Short_Window_sine_fxp[ SHORT_WINDOW];
+    extern const Int16 Long_Window_sine_fxp[ LONG_WINDOW];
+
+    extern const Int16 * const Long_Window_fxp[];
+    extern const Int16 * const Short_Window_fxp[];
+
+    /*----------------------------------------------------------------------------
+    ; SIMPLE TYPEDEF'S
+    ----------------------------------------------------------------------------*/
+
+    /*----------------------------------------------------------------------------
+    ; ENUMERATED TYPEDEF'S
+    ----------------------------------------------------------------------------*/
+
+
+
+    /*----------------------------------------------------------------------------
+    ; STRUCTURES TYPEDEF'S
+    ----------------------------------------------------------------------------*/
+
+    /*----------------------------------------------------------------------------
+    ; GLOBAL FUNCTION DEFINITIONS
+    ; Function Prototype declaration
+    ----------------------------------------------------------------------------*/
+
+    void trans4m_freq_2_time_fxp(
+        Int32   Frequency_data[],
+        Int32   Time_data[],
+#ifdef AAC_PLUS
+        Int32   Output_buffer[],
+#else
+        Int16   Output_buffer[],
+#endif
+        WINDOW_SEQUENCE wnd_seq,
+        Int     wnd_shape_prev_bk,
+        Int     wnd_shape_this_bk,
+        Int     Q_format,
+        Int32   abs_max_per_window[],
+        Int32   freq_2_time_buffer[] ,
+        Int16   *Interleave_output
+    );
+
+
+
+    void trans4m_freq_2_time_fxp_1(
+        Int32   Frequency_data[],
+        Int32   Time_data[],
+        Int16   Output_buffer[],
+        WINDOW_SEQUENCE wnd_seq,
+        Int     wnd_shape_prev_bk,
+        Int     wnd_shape_this_bk,
+        Int     Q_format,
+        Int32   abs_max_per_window[],
+        Int32   freq_2_time_buffer[]
+    );
+
+
+    void trans4m_freq_2_time_fxp_2(
+        Int32   Frequency_data[],
+        Int32   Time_data[],
+        WINDOW_SEQUENCE wnd_seq,
+        Int     wnd_shape_prev_bk,
+        Int     wnd_shape_this_bk,
+        Int     Q_format,
+        Int32   abs_max_per_window[],
+        Int32   freq_2_time_buffer[] ,
+        Int16   *Interleave_output
+    );
+
+    void trans4m_time_2_freq_fxp(
+        Int32   Time2Freq_data[],
+        WINDOW_SEQUENCE wnd_seq,
+        Int     wnd_shape_prev_bk,
+        Int     wnd_shape_this_bk,
+        Int     *pQ_format,
+        Int32   mem_4_in_place_FFT[]);
+
+    /*----------------------------------------------------------------------------
+    ; END
+    ----------------------------------------------------------------------------*/
+#ifdef __cplusplus
+}
+#endif
+
+#endif  /*  WINDOW_BLOCK_FXP_H */
+
diff --git a/media/libstagefright/codecs/aacdec/window_tables_fxp.cpp b/media/libstagefright/codecs/aacdec/window_tables_fxp.cpp
new file mode 100644
index 0000000..aa04225
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/window_tables_fxp.cpp
@@ -0,0 +1,730 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Pathname: window_tables_fxp.c
+ Funtions:
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+ Description:
+    changed table content definition from UInt to UInt16.
+
+ Description:
+    changed Long_Window_fxp and Short _Window_fxp tables definition, from
+    "const UInt16 *"  to "const UInt16 * const" to avoid global variable
+    definition.
+
+ Description:
+    Improved rounding on table elements.
+
+ Description: Eliminated structure to avoid assigning addresses to constant
+              tables. This solve linking problem when using the
+              /ropi option (Read-only position independent) for some
+              compilers
+              - Eliminated Long_Window_fxp and Short_Window_fxp as global
+                contants vectors
+
+ Who:                       Date:
+ Description:
+
+  ------------------------------------------------------------------------------
+ MODULE DESCRIPTION
+
+    Window tables
+
+        For a sine table with N  points:
+
+            w_left  = sin(pi/N (n + 1/2))     for 0   =< n < N/2
+
+            w_rigth = sin(pi/N (n + 1/2))     for N/2 =< n < N
+
+
+        For Kaiser-Bessel derived (KBD)
+
+                               n             N/2
+            w_left  =  sqrt(( SUM W(p,a) )/( SUM W(p,a) )   for   0   =< n < N/2
+                              p=0            p=0
+
+
+                             N-n-1           N/2
+            w_rigth =  sqrt(( SUM W(p,a) )/( SUM W(p,a) )   for   N/2 =< n < N
+                              p=0            p=0
+
+
+            W(p,a) see ISO 14496-3, pag 113
+
+------------------------------------------------------------------------------
+ REQUIREMENTS
+
+    This module shall implement the fix point verwion of the windowing tables
+
+------------------------------------------------------------------------------
+ REFERENCES
+
+    [1] ISO 14496-3, pag 113
+
+------------------------------------------------------------------------------
+*/
+
+
+/*----------------------------------------------------------------------------
+; INCLUDES
+----------------------------------------------------------------------------*/
+#include "pv_audio_type_defs.h"
+#include "window_block_fxp.h"
+
+/*----------------------------------------------------------------------------
+; MACROS
+; Define module specific macros here
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; DEFINES
+; Include all pre-processor statements here. Include conditional
+; compile variables also.
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; LOCAL FUNCTION DEFINITIONS
+; Function Prototype declaration
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; LOCAL VARIABLE DEFINITIONS
+; Variable declaration - defined here and used outside this module
+----------------------------------------------------------------------------*/
+
+
+/*----------------------------------------------------------------------------
+; EXTERNAL FUNCTION REFERENCES
+; Declare functions defined elsewhere and referenced in this module
+----------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------------
+; EXTERNAL VARIABLES REFERENCES
+; Declare variables used in this module but defined elsewhere
+----------------------------------------------------------------------------*/
+
+
+const Int16 Long_Window_sine_fxp[LONG_WINDOW] =
+{
+
+
+    0x0019,  0x004B,  0x007E,  0x00B0,
+    0x00E2,  0x0114,  0x0147,  0x0179,
+    0x01AB,  0x01DD,  0x0210,  0x0242,
+    0x0274,  0x02A7,  0x02D9,  0x030B,
+    0x033D,  0x0370,  0x03A2,  0x03D4,
+    0x0406,  0x0438,  0x046B,  0x049D,
+    0x04CF,  0x0501,  0x0534,  0x0566,
+    0x0598,  0x05CA,  0x05FC,  0x062F,
+    0x0661,  0x0693,  0x06C5,  0x06F7,
+    0x072A,  0x075C,  0x078E,  0x07C0,
+    0x07F2,  0x0825,  0x0857,  0x0889,
+    0x08BB,  0x08ED,  0x091F,  0x0951,
+    0x0984,  0x09B6,  0x09E8,  0x0A1A,
+    0x0A4C,  0x0A7E,  0x0AB0,  0x0AE2,
+    0x0B14,  0x0B46,  0x0B78,  0x0BAB,
+    0x0BDD,  0x0C0F,  0x0C41,  0x0C73,
+    0x0CA5,  0x0CD7,  0x0D09,  0x0D3B,
+    0x0D6D,  0x0D9F,  0x0DD1,  0x0E03,
+    0x0E35,  0x0E67,  0x0E99,  0x0ECA,
+    0x0EFC,  0x0F2E,  0x0F60,  0x0F92,
+    0x0FC4,  0x0FF6,  0x1028,  0x105A,
+    0x108B,  0x10BD,  0x10EF,  0x1121,
+    0x1153,  0x1185,  0x11B6,  0x11E8,
+    0x121A,  0x124C,  0x127D,  0x12AF,
+    0x12E1,  0x1312,  0x1344,  0x1376,
+    0x13A8,  0x13D9,  0x140B,  0x143C,
+    0x146E,  0x14A0,  0x14D1,  0x1503,
+    0x1534,  0x1566,  0x1598,  0x15C9,
+    0x15FB,  0x162C,  0x165E,  0x168F,
+    0x16C1,  0x16F2,  0x1724,  0x1755,
+    0x1786,  0x17B8,  0x17E9,  0x181B,
+    0x184C,  0x187D,  0x18AF,  0x18E0,
+    0x1911,  0x1942,  0x1974,  0x19A5,
+    0x19D6,  0x1A07,  0x1A39,  0x1A6A,
+    0x1A9B,  0x1ACC,  0x1AFD,  0x1B2E,
+    0x1B60,  0x1B91,  0x1BC2,  0x1BF3,
+    0x1C24,  0x1C55,  0x1C86,  0x1CB7,
+    0x1CE8,  0x1D19,  0x1D4A,  0x1D7B,
+    0x1DAC,  0x1DDC,  0x1E0D,  0x1E3E,
+    0x1E6F,  0x1EA0,  0x1ED1,  0x1F01,
+    0x1F32,  0x1F63,  0x1F94,  0x1FC4,
+    0x1FF5,  0x2026,  0x2056,  0x2087,
+    0x20B7,  0x20E8,  0x2119,  0x2149,
+    0x217A,  0x21AA,  0x21DB,  0x220B,
+    0x223C,  0x226C,  0x229C,  0x22CD,
+    0x22FD,  0x232E,  0x235E,  0x238E,
+    0x23BE,  0x23EF,  0x241F,  0x244F,
+    0x247F,  0x24AF,  0x24E0,  0x2510,
+    0x2540,  0x2570,  0x25A0,  0x25D0,
+    0x2600,  0x2630,  0x2660,  0x2690,
+    0x26C0,  0x26F0,  0x2720,  0x274F,
+    0x277F,  0x27AF,  0x27DF,  0x280F,
+    0x283E,  0x286E,  0x289E,  0x28CD,
+    0x28FD,  0x292D,  0x295C,  0x298C,
+    0x29BB,  0x29EB,  0x2A1A,  0x2A4A,
+    0x2A79,  0x2AA8,  0x2AD8,  0x2B07,
+    0x2B37,  0x2B66,  0x2B95,  0x2BC4,
+    0x2BF4,  0x2C23,  0x2C52,  0x2C81,
+    0x2CB0,  0x2CDF,  0x2D0E,  0x2D3D,
+    0x2D6C,  0x2D9B,  0x2DCA,  0x2DF9,
+    0x2E28,  0x2E57,  0x2E86,  0x2EB5,
+    0x2EE3,  0x2F12,  0x2F41,  0x2F70,
+    0x2F9E,  0x2FCD,  0x2FFC,  0x302A,
+    0x3059,  0x3087,  0x30B6,  0x30E4,
+    0x3113,  0x3141,  0x316F,  0x319E,
+    0x31CC,  0x31FA,  0x3229,  0x3257,
+    0x3285,  0x32B3,  0x32E1,  0x330F,
+    0x333E,  0x336C,  0x339A,  0x33C8,
+    0x33F6,  0x3423,  0x3451,  0x347F,
+    0x34AD,  0x34DB,  0x3509,  0x3536,
+    0x3564,  0x3592,  0x35BF,  0x35ED,
+    0x361A,  0x3648,  0x3676,  0x36A3,
+    0x36D0,  0x36FE,  0x372B,  0x3759,
+    0x3786,  0x37B3,  0x37E0,  0x380E,
+    0x383B,  0x3868,  0x3895,  0x38C2,
+    0x38EF,  0x391C,  0x3949,  0x3976,
+    0x39A3,  0x39D0,  0x39FD,  0x3A29,
+    0x3A56,  0x3A83,  0x3AB0,  0x3ADC,
+    0x3B09,  0x3B35,  0x3B62,  0x3B8E,
+    0x3BBB,  0x3BE7,  0x3C14,  0x3C40,
+    0x3C6C,  0x3C99,  0x3CC5,  0x3CF1,
+    0x3D1D,  0x3D4A,  0x3D76,  0x3DA2,
+    0x3DCE,  0x3DFA,  0x3E26,  0x3E52,
+    0x3E7D,  0x3EA9,  0x3ED5,  0x3F01,
+    0x3F2D,  0x3F58,  0x3F84,  0x3FB0,
+    0x3FDB,  0x4007,  0x4032,  0x405E,
+    0x4089,  0x40B5,  0x40E0,  0x410B,
+    0x4136,  0x4162,  0x418D,  0x41B8,
+    0x41E3,  0x420E,  0x4239,  0x4264,
+    0x428F,  0x42BA,  0x42E5,  0x4310,
+    0x433B,  0x4365,  0x4390,  0x43BB,
+    0x43E5,  0x4410,  0x443B,  0x4465,
+    0x448F,  0x44BA,  0x44E4,  0x450F,
+    0x4539,  0x4563,  0x458D,  0x45B8,
+    0x45E2,  0x460C,  0x4636,  0x4660,
+    0x468A,  0x46B4,  0x46DE,  0x4707,
+    0x4731,  0x475B,  0x4785,  0x47AE,
+    0x47D8,  0x4802,  0x482B,  0x4855,
+    0x487E,  0x48A7,  0x48D1,  0x48FA,
+    0x4923,  0x494D,  0x4976,  0x499F,
+    0x49C8,  0x49F1,  0x4A1A,  0x4A43,
+    0x4A6C,  0x4A95,  0x4ABE,  0x4AE6,
+    0x4B0F,  0x4B38,  0x4B61,  0x4B89,
+    0x4BB2,  0x4BDA,  0x4C03,  0x4C2B,
+    0x4C53,  0x4C7C,  0x4CA4,  0x4CCC,
+    0x4CF4,  0x4D1D,  0x4D45,  0x4D6D,
+    0x4D95,  0x4DBD,  0x4DE5,  0x4E0D,
+    0x4E34,  0x4E5C,  0x4E84,  0x4EAB,
+    0x4ED3,  0x4EFB,  0x4F22,  0x4F4A,
+    0x4F71,  0x4F99,  0x4FC0,  0x4FE7,
+    0x500E,  0x5036,  0x505D,  0x5084,
+    0x50AB,  0x50D2,  0x50F9,  0x5120,
+    0x5147,  0x516D,  0x5194,  0x51BB,
+    0x51E2,  0x5208,  0x522F,  0x5255,
+    0x527C,  0x52A2,  0x52C8,  0x52EF,
+    0x5315,  0x533B,  0x5361,  0x5387,
+    0x53AE,  0x53D4,  0x53FA,  0x541F,
+    0x5445,  0x546B,  0x5491,  0x54B7,
+    0x54DC,  0x5502,  0x5527,  0x554D,
+    0x5572,  0x5598,  0x55BD,  0x55E2,
+    0x5608,  0x562D,  0x5652,  0x5677,
+    0x569C,  0x56C1,  0x56E6,  0x570B,
+    0x5730,  0x5754,  0x5779,  0x579E,
+    0x57C2,  0x57E7,  0x580C,  0x5830,
+    0x5854,  0x5879,  0x589D,  0x58C1,
+    0x58E5,  0x590A,  0x592E,  0x5952,
+    0x5976,  0x599A,  0x59BD,  0x59E1,
+    0x5A05,  0x5A29,  0x5A4C,  0x5A70,
+    0x5A94,  0x5AB7,  0x5ADA,  0x5AFE,
+    0x5B21,  0x5B44,  0x5B68,  0x5B8B,
+    0x5BAE,  0x5BD1,  0x5BF4,  0x5C17,
+    0x5C3A,  0x5C5D,  0x5C7F,  0x5CA2,
+    0x5CC5,  0x5CE7,  0x5D0A,  0x5D2C,
+    0x5D4F,  0x5D71,  0x5D94,  0x5DB6,
+    0x5DD8,  0x5DFA,  0x5E1C,  0x5E3E,
+    0x5E60,  0x5E82,  0x5EA4,  0x5EC6,
+    0x5EE8,  0x5F09,  0x5F2B,  0x5F4D,
+    0x5F6E,  0x5F90,  0x5FB1,  0x5FD2,
+    0x5FF4,  0x6015,  0x6036,  0x6057,
+    0x6078,  0x6099,  0x60BA,  0x60DB,
+    0x60FC,  0x611D,  0x613D,  0x615E,
+    0x617F,  0x619F,  0x61C0,  0x61E0,
+    0x6200,  0x6221,  0x6241,  0x6261,
+    0x6281,  0x62A1,  0x62C1,  0x62E1,
+    0x6301,  0x6321,  0x6341,  0x6360,
+    0x6380,  0x63A0,  0x63BF,  0x63DF,
+    0x63FE,  0x641D,  0x643D,  0x645C,
+    0x647B,  0x649A,  0x64B9,  0x64D8,
+    0x64F7,  0x6516,  0x6535,  0x6554,
+    0x6572,  0x6591,  0x65AF,  0x65CE,
+    0x65EC,  0x660B,  0x6629,  0x6647,
+    0x6666,  0x6684,  0x66A2,  0x66C0,
+    0x66DE,  0x66FC,  0x6719,  0x6737,
+    0x6755,  0x6772,  0x6790,  0x67AE,
+    0x67CB,  0x67E8,  0x6806,  0x6823,
+    0x6840,  0x685D,  0x687A,  0x6897,
+    0x68B4,  0x68D1,  0x68EE,  0x690B,
+    0x6927,  0x6944,  0x6961,  0x697D,
+    0x699A,  0x69B6,  0x69D2,  0x69EE,
+    0x6A0B,  0x6A27,  0x6A43,  0x6A5F,
+    0x6A7B,  0x6A97,  0x6AB2,  0x6ACE,
+    0x6AEA,  0x6B05,  0x6B21,  0x6B3C,
+    0x6B58,  0x6B73,  0x6B8E,  0x6BAA,
+    0x6BC5,  0x6BE0,  0x6BFB,  0x6C16,
+    0x6C31,  0x6C4C,  0x6C66,  0x6C81,
+    0x6C9C,  0x6CB6,  0x6CD1,  0x6CEB,
+    0x6D06,  0x6D20,  0x6D3A,  0x6D54,
+    0x6D6E,  0x6D88,  0x6DA2,  0x6DBC,
+    0x6DD6,  0x6DF0,  0x6E0A,  0x6E23,
+    0x6E3D,  0x6E56,  0x6E70,  0x6E89,
+    0x6EA2,  0x6EBC,  0x6ED5,  0x6EEE,
+    0x6F07,  0x6F20,  0x6F39,  0x6F52,
+    0x6F6B,  0x6F83,  0x6F9C,  0x6FB4,
+    0x6FCD,  0x6FE5,  0x6FFE,  0x7016,
+    0x702E,  0x7046,  0x705F,  0x7077,
+    0x708F,  0x70A6,  0x70BE,  0x70D6,
+    0x70EE,  0x7105,  0x711D,  0x7134,
+    0x714C,  0x7163,  0x717A,  0x7192,
+    0x71A9,  0x71C0,  0x71D7,  0x71EE,
+    0x7205,  0x721C,  0x7232,  0x7249,
+    0x7260,  0x7276,  0x728D,  0x72A3,
+    0x72B9,  0x72D0,  0x72E6,  0x72FC,
+    0x7312,  0x7328,  0x733E,  0x7354,
+    0x7369,  0x737F,  0x7395,  0x73AA,
+    0x73C0,  0x73D5,  0x73EB,  0x7400,
+    0x7415,  0x742A,  0x743F,  0x7454,
+    0x7469,  0x747E,  0x7493,  0x74A8,
+    0x74BC,  0x74D1,  0x74E5,  0x74FA,
+    0x750E,  0x7522,  0x7537,  0x754B,
+    0x755F,  0x7573,  0x7587,  0x759B,
+    0x75AE,  0x75C2,  0x75D6,  0x75E9,
+    0x75FD,  0x7610,  0x7624,  0x7637,
+    0x764A,  0x765E,  0x7671,  0x7684,
+    0x7697,  0x76A9,  0x76BC,  0x76CF,
+    0x76E2,  0x76F4,  0x7707,  0x7719,
+    0x772C,  0x773E,  0x7750,  0x7762,
+    0x7774,  0x7786,  0x7798,  0x77AA,
+    0x77BC,  0x77CE,  0x77DF,  0x77F1,
+    0x7803,  0x7814,  0x7825,  0x7837,
+    0x7848,  0x7859,  0x786A,  0x787B,
+    0x788C,  0x789D,  0x78AE,  0x78BE,
+    0x78CF,  0x78E0,  0x78F0,  0x7901,
+    0x7911,  0x7921,  0x7931,  0x7941,
+    0x7952,  0x7962,  0x7971,  0x7981,
+    0x7991,  0x79A1,  0x79B0,  0x79C0,
+    0x79CF,  0x79DF,  0x79EE,  0x79FD,
+    0x7A0D,  0x7A1C,  0x7A2B,  0x7A3A,
+    0x7A49,  0x7A57,  0x7A66,  0x7A75,
+    0x7A83,  0x7A92,  0x7AA0,  0x7AAF,
+    0x7ABD,  0x7ACB,  0x7AD9,  0x7AE7,
+    0x7AF5,  0x7B03,  0x7B11,  0x7B1F,
+    0x7B2D,  0x7B3A,  0x7B48,  0x7B55,
+    0x7B63,  0x7B70,  0x7B7D,  0x7B8B,
+    0x7B98,  0x7BA5,  0x7BB2,  0x7BBF,
+    0x7BCB,  0x7BD8,  0x7BE5,  0x7BF1,
+    0x7BFE,  0x7C0A,  0x7C17,  0x7C23,
+    0x7C2F,  0x7C3B,  0x7C47,  0x7C53,
+    0x7C5F,  0x7C6B,  0x7C77,  0x7C83,
+    0x7C8E,  0x7C9A,  0x7CA5,  0x7CB1,
+    0x7CBC,  0x7CC7,  0x7CD2,  0x7CDD,
+    0x7CE8,  0x7CF3,  0x7CFE,  0x7D09,
+    0x7D14,  0x7D1E,  0x7D29,  0x7D33,
+    0x7D3E,  0x7D48,  0x7D52,  0x7D5C,
+    0x7D67,  0x7D71,  0x7D7B,  0x7D84,
+    0x7D8E,  0x7D98,  0x7DA2,  0x7DAB,
+    0x7DB5,  0x7DBE,  0x7DC8,  0x7DD1,
+    0x7DDA,  0x7DE3,  0x7DEC,  0x7DF5,
+    0x7DFE,  0x7E07,  0x7E10,  0x7E18,
+    0x7E21,  0x7E29,  0x7E32,  0x7E3A,
+    0x7E42,  0x7E4B,  0x7E53,  0x7E5B,
+    0x7E63,  0x7E6B,  0x7E73,  0x7E7A,
+    0x7E82,  0x7E8A,  0x7E91,  0x7E99,
+    0x7EA0,  0x7EA7,  0x7EAF,  0x7EB6,
+    0x7EBD,  0x7EC4,  0x7ECB,  0x7ED2,
+    0x7ED8,  0x7EDF,  0x7EE6,  0x7EEC,
+    0x7EF3,  0x7EF9,  0x7EFF,  0x7F05,
+    0x7F0C,  0x7F12,  0x7F18,  0x7F1E,
+    0x7F23,  0x7F29,  0x7F2F,  0x7F35,
+    0x7F3A,  0x7F40,  0x7F45,  0x7F4A,
+    0x7F50,  0x7F55,  0x7F5A,  0x7F5F,
+    0x7F64,  0x7F69,  0x7F6D,  0x7F72,
+    0x7F77,  0x7F7B,  0x7F80,  0x7F84,
+    0x7F88,  0x7F8D,  0x7F91,  0x7F95,
+    0x7F99,  0x7F9D,  0x7FA1,  0x7FA4,
+    0x7FA8,  0x7FAC,  0x7FAF,  0x7FB3,
+    0x7FB6,  0x7FB9,  0x7FBD,  0x7FC0,
+    0x7FC3,  0x7FC6,  0x7FC9,  0x7FCC,
+    0x7FCE,  0x7FD1,  0x7FD4,  0x7FD6,
+    0x7FD9,  0x7FDB,  0x7FDD,  0x7FE0,
+    0x7FE2,  0x7FE4,  0x7FE6,  0x7FE8,
+    0x7FEA,  0x7FEB,  0x7FED,  0x7FEF,
+    0x7FF0,  0x7FF2,  0x7FF3,  0x7FF5,
+    0x7FF6,  0x7FF7,  0x7FF8,  0x7FF9,
+    0x7FFA,  0x7FFB,  0x7FFC,  0x7FFC,
+    0x7FFD,  0x7FFD,  0x7FFE,  0x7FFE,
+    0x7FFF,  0x7FFF,  0x7FFF,  0x7FFF
+
+};
+
+
+const Int16 Short_Window_sine_fxp[SHORT_WINDOW] =
+{
+
+    0x00C9,  0x025B,  0x03ED,  0x057F,
+    0x0711,  0x08A2,  0x0A33,  0x0BC4,
+    0x0D54,  0x0EE3,  0x1072,  0x1201,
+    0x138F,  0x151C,  0x16A8,  0x1833,
+    0x19BE,  0x1B47,  0x1CCF,  0x1E57,
+    0x1FDD,  0x2161,  0x22E5,  0x2467,
+    0x25E8,  0x2767,  0x28E5,  0x2A61,
+    0x2BDC,  0x2D55,  0x2ECC,  0x3041,
+    0x31B5,  0x3326,  0x3496,  0x3604,
+    0x376F,  0x38D9,  0x3A40,  0x3BA5,
+    0x3D07,  0x3E68,  0x3FC5,  0x4121,
+    0x427A,  0x43D0,  0x4524,  0x4675,
+    0x47C3,  0x490F,  0x4A58,  0x4B9D,
+    0x4CE0,  0x4E20,  0x4F5D,  0x5097,
+    0x51CE,  0x5302,  0x5432,  0x5560,
+    0x568A,  0x57B0,  0x58D3,  0x59F3,
+    0x5B0F,  0x5C28,  0x5D3E,  0x5E4F,
+    0x5F5D,  0x6068,  0x616E,  0x6271,
+    0x6370,  0x646C,  0x6563,  0x6656,
+    0x6746,  0x6832,  0x6919,  0x69FD,
+    0x6ADC,  0x6BB7,  0x6C8E,  0x6D61,
+    0x6E30,  0x6EFB,  0x6FC1,  0x7083,
+    0x7140,  0x71F9,  0x72AE,  0x735E,
+    0x740A,  0x74B2,  0x7555,  0x75F3,
+    0x768D,  0x7722,  0x77B3,  0x783F,
+    0x78C7,  0x794A,  0x79C8,  0x7A41,
+    0x7AB6,  0x7B26,  0x7B91,  0x7BF8,
+    0x7C59,  0x7CB6,  0x7D0E,  0x7D62,
+    0x7DB0,  0x7DFA,  0x7E3E,  0x7E7E,
+    0x7EB9,  0x7EEF,  0x7F21,  0x7F4D,
+    0x7F74,  0x7F97,  0x7FB4,  0x7FCD,
+    0x7FE1,  0x7FF0,  0x7FF9,  0x7FFE
+};
+
+
+
+const Int16 Long_Window_KBD_fxp[LONG_WINDOW] =
+{
+
+    0x000A,  0x000E,  0x0012,  0x0015,
+    0x0019,  0x001C,  0x0020,  0x0023,
+    0x0026,  0x002A,  0x002D,  0x0030,
+    0x0034,  0x0038,  0x003B,  0x003F,
+    0x0043,  0x0047,  0x004B,  0x004F,
+    0x0053,  0x0057,  0x005B,  0x0060,
+    0x0064,  0x0069,  0x006D,  0x0072,
+    0x0077,  0x007C,  0x0081,  0x0086,
+    0x008B,  0x0091,  0x0096,  0x009C,
+    0x00A1,  0x00A7,  0x00AD,  0x00B3,
+    0x00B9,  0x00BF,  0x00C6,  0x00CC,
+    0x00D3,  0x00DA,  0x00E0,  0x00E7,
+    0x00EE,  0x00F5,  0x00FD,  0x0104,
+    0x010C,  0x0113,  0x011B,  0x0123,
+    0x012B,  0x0133,  0x013C,  0x0144,
+    0x014D,  0x0156,  0x015F,  0x0168,
+    0x0171,  0x017A,  0x0183,  0x018D,
+    0x0197,  0x01A1,  0x01AB,  0x01B5,
+    0x01BF,  0x01CA,  0x01D4,  0x01DF,
+    0x01EA,  0x01F5,  0x0200,  0x020C,
+    0x0217,  0x0223,  0x022F,  0x023B,
+    0x0247,  0x0253,  0x0260,  0x026D,
+    0x027A,  0x0287,  0x0294,  0x02A1,
+    0x02AF,  0x02BC,  0x02CA,  0x02D8,
+    0x02E7,  0x02F5,  0x0304,  0x0312,
+    0x0321,  0x0331,  0x0340,  0x034F,
+    0x035F,  0x036F,  0x037F,  0x038F,
+    0x03A0,  0x03B0,  0x03C1,  0x03D2,
+    0x03E3,  0x03F5,  0x0406,  0x0418,
+    0x042A,  0x043C,  0x044F,  0x0461,
+    0x0474,  0x0487,  0x049A,  0x04AE,
+    0x04C1,  0x04D5,  0x04E9,  0x04FD,
+    0x0512,  0x0526,  0x053B,  0x0550,
+    0x0566,  0x057B,  0x0591,  0x05A7,
+    0x05BD,  0x05D3,  0x05EA,  0x0601,
+    0x0618,  0x062F,  0x0646,  0x065E,
+    0x0676,  0x068E,  0x06A6,  0x06BF,
+    0x06D8,  0x06F1,  0x070A,  0x0723,
+    0x073D,  0x0757,  0x0771,  0x078C,
+    0x07A6,  0x07C1,  0x07DC,  0x07F7,
+    0x0813,  0x082F,  0x084B,  0x0867,
+    0x0884,  0x08A0,  0x08BD,  0x08DA,
+    0x08F8,  0x0916,  0x0933,  0x0952,
+    0x0970,  0x098F,  0x09AE,  0x09CD,
+    0x09EC,  0x0A0C,  0x0A2C,  0x0A4C,
+    0x0A6C,  0x0A8D,  0x0AAD,  0x0ACF,
+    0x0AF0,  0x0B11,  0x0B33,  0x0B55,
+    0x0B78,  0x0B9A,  0x0BBD,  0x0BE0,
+    0x0C03,  0x0C27,  0x0C4B,  0x0C6F,
+    0x0C93,  0x0CB8,  0x0CDD,  0x0D02,
+    0x0D27,  0x0D4D,  0x0D73,  0x0D99,
+    0x0DBF,  0x0DE6,  0x0E0C,  0x0E33,
+    0x0E5B,  0x0E82,  0x0EAA,  0x0ED2,
+    0x0EFB,  0x0F23,  0x0F4C,  0x0F75,
+    0x0F9F,  0x0FC8,  0x0FF2,  0x101C,
+    0x1047,  0x1071,  0x109C,  0x10C7,
+    0x10F3,  0x111E,  0x114A,  0x1176,
+    0x11A3,  0x11D0,  0x11FC,  0x122A,
+    0x1257,  0x1285,  0x12B3,  0x12E1,
+    0x130F,  0x133E,  0x136D,  0x139C,
+    0x13CB,  0x13FB,  0x142B,  0x145B,
+    0x148B,  0x14BC,  0x14ED,  0x151E,
+    0x1550,  0x1581,  0x15B3,  0x15E5,
+    0x1618,  0x164A,  0x167D,  0x16B0,
+    0x16E3,  0x1717,  0x174B,  0x177F,
+    0x17B3,  0x17E8,  0x181D,  0x1852,
+    0x1887,  0x18BC,  0x18F2,  0x1928,
+    0x195E,  0x1995,  0x19CB,  0x1A02,
+    0x1A39,  0x1A71,  0x1AA8,  0x1AE0,
+    0x1B18,  0x1B50,  0x1B89,  0x1BC1,
+    0x1BFA,  0x1C34,  0x1C6D,  0x1CA7,
+    0x1CE0,  0x1D1A,  0x1D55,  0x1D8F,
+    0x1DCA,  0x1E05,  0x1E40,  0x1E7B,
+    0x1EB7,  0x1EF2,  0x1F2E,  0x1F6B,
+    0x1FA7,  0x1FE4,  0x2020,  0x205D,
+    0x209B,  0x20D8,  0x2116,  0x2153,
+    0x2191,  0x21D0,  0x220E,  0x224D,
+    0x228B,  0x22CA,  0x2309,  0x2349,
+    0x2388,  0x23C8,  0x2408,  0x2448,
+    0x2488,  0x24C9,  0x2509,  0x254A,
+    0x258B,  0x25CC,  0x260E,  0x264F,
+    0x2691,  0x26D3,  0x2715,  0x2757,
+    0x2799,  0x27DC,  0x281F,  0x2861,
+    0x28A4,  0x28E8,  0x292B,  0x296E,
+    0x29B2,  0x29F6,  0x2A3A,  0x2A7E,
+    0x2AC2,  0x2B06,  0x2B4B,  0x2B8F,
+    0x2BD4,  0x2C19,  0x2C5E,  0x2CA3,
+    0x2CE9,  0x2D2E,  0x2D74,  0x2DB9,
+    0x2DFF,  0x2E45,  0x2E8B,  0x2ED1,
+    0x2F18,  0x2F5E,  0x2FA5,  0x2FEB,
+    0x3032,  0x3079,  0x30C0,  0x3107,
+    0x314E,  0x3195,  0x31DD,  0x3224,
+    0x326C,  0x32B4,  0x32FB,  0x3343,
+    0x338B,  0x33D3,  0x341B,  0x3463,
+    0x34AC,  0x34F4,  0x353D,  0x3585,
+    0x35CE,  0x3616,  0x365F,  0x36A8,
+    0x36F1,  0x373A,  0x3783,  0x37CC,
+    0x3815,  0x385E,  0x38A7,  0x38F0,
+    0x393A,  0x3983,  0x39CC,  0x3A16,
+    0x3A5F,  0x3AA9,  0x3AF2,  0x3B3C,
+    0x3B86,  0x3BCF,  0x3C19,  0x3C63,
+    0x3CAC,  0x3CF6,  0x3D40,  0x3D8A,
+    0x3DD3,  0x3E1D,  0x3E67,  0x3EB1,
+    0x3EFB,  0x3F45,  0x3F8E,  0x3FD8,
+    0x4022,  0x406C,  0x40B6,  0x4100,
+    0x414A,  0x4193,  0x41DD,  0x4227,
+    0x4271,  0x42BB,  0x4304,  0x434E,
+    0x4398,  0x43E1,  0x442B,  0x4475,
+    0x44BE,  0x4508,  0x4551,  0x459B,
+    0x45E4,  0x462E,  0x4677,  0x46C0,
+    0x4709,  0x4753,  0x479C,  0x47E5,
+    0x482E,  0x4877,  0x48C0,  0x4909,
+    0x4951,  0x499A,  0x49E3,  0x4A2B,
+    0x4A74,  0x4ABC,  0x4B04,  0x4B4D,
+    0x4B95,  0x4BDD,  0x4C25,  0x4C6D,
+    0x4CB5,  0x4CFC,  0x4D44,  0x4D8C,
+    0x4DD3,  0x4E1A,  0x4E62,  0x4EA9,
+    0x4EF0,  0x4F37,  0x4F7E,  0x4FC4,
+    0x500B,  0x5051,  0x5098,  0x50DE,
+    0x5124,  0x516A,  0x51B0,  0x51F6,
+    0x523B,  0x5281,  0x52C6,  0x530B,
+    0x5351,  0x5396,  0x53DA,  0x541F,
+    0x5464,  0x54A8,  0x54EC,  0x5530,
+    0x5574,  0x55B8,  0x55FC,  0x563F,
+    0x5683,  0x56C6,  0x5709,  0x574C,
+    0x578F,  0x57D1,  0x5814,  0x5856,
+    0x5898,  0x58DA,  0x591B,  0x595D,
+    0x599E,  0x59E0,  0x5A21,  0x5A61,
+    0x5AA2,  0x5AE3,  0x5B23,  0x5B63,
+    0x5BA3,  0x5BE3,  0x5C22,  0x5C62,
+    0x5CA1,  0x5CE0,  0x5D1F,  0x5D5D,
+    0x5D9C,  0x5DDA,  0x5E18,  0x5E56,
+    0x5E93,  0x5ED1,  0x5F0E,  0x5F4B,
+    0x5F87,  0x5FC4,  0x6000,  0x603D,
+    0x6079,  0x60B4,  0x60F0,  0x612B,
+    0x6166,  0x61A1,  0x61DC,  0x6216,
+    0x6250,  0x628A,  0x62C4,  0x62FE,
+    0x6337,  0x6370,  0x63A9,  0x63E2,
+    0x641A,  0x6452,  0x648A,  0x64C2,
+    0x64F9,  0x6531,  0x6568,  0x659E,
+    0x65D5,  0x660B,  0x6641,  0x6677,
+    0x66AD,  0x66E2,  0x6717,  0x674C,
+    0x6781,  0x67B5,  0x67E9,  0x681D,
+    0x6851,  0x6885,  0x68B8,  0x68EB,
+    0x691D,  0x6950,  0x6982,  0x69B4,
+    0x69E6,  0x6A17,  0x6A48,  0x6A79,
+    0x6AAA,  0x6ADB,  0x6B0B,  0x6B3B,
+    0x6B6A,  0x6B9A,  0x6BC9,  0x6BF8,
+    0x6C27,  0x6C55,  0x6C83,  0x6CB1,
+    0x6CDF,  0x6D0D,  0x6D3A,  0x6D67,
+    0x6D93,  0x6DC0,  0x6DEC,  0x6E18,
+    0x6E44,  0x6E6F,  0x6E9A,  0x6EC5,
+    0x6EF0,  0x6F1A,  0x6F44,  0x6F6E,
+    0x6F98,  0x6FC1,  0x6FEA,  0x7013,
+    0x703C,  0x7064,  0x708C,  0x70B4,
+    0x70DB,  0x7103,  0x712A,  0x7151,
+    0x7177,  0x719D,  0x71C3,  0x71E9,
+    0x720F,  0x7234,  0x7259,  0x727E,
+    0x72A2,  0x72C7,  0x72EB,  0x730E,
+    0x7332,  0x7355,  0x7378,  0x739B,
+    0x73BD,  0x73E0,  0x7402,  0x7424,
+    0x7445,  0x7466,  0x7487,  0x74A8,
+    0x74C9,  0x74E9,  0x7509,  0x7529,
+    0x7548,  0x7568,  0x7587,  0x75A5,
+    0x75C4,  0x75E2,  0x7601,  0x761E,
+    0x763C,  0x7659,  0x7676,  0x7693,
+    0x76B0,  0x76CC,  0x76E9,  0x7705,
+    0x7720,  0x773C,  0x7757,  0x7772,
+    0x778D,  0x77A8,  0x77C2,  0x77DC,
+    0x77F6,  0x780F,  0x7829,  0x7842,
+    0x785B,  0x7874,  0x788C,  0x78A5,
+    0x78BD,  0x78D5,  0x78EC,  0x7904,
+    0x791B,  0x7932,  0x7949,  0x795F,
+    0x7976,  0x798C,  0x79A2,  0x79B7,
+    0x79CD,  0x79E2,  0x79F7,  0x7A0C,
+    0x7A21,  0x7A35,  0x7A4A,  0x7A5E,
+    0x7A72,  0x7A85,  0x7A99,  0x7AAC,
+    0x7ABF,  0x7AD2,  0x7AE5,  0x7AF7,
+    0x7B09,  0x7B1B,  0x7B2D,  0x7B3F,
+    0x7B51,  0x7B62,  0x7B73,  0x7B84,
+    0x7B95,  0x7BA5,  0x7BB6,  0x7BC6,
+    0x7BD6,  0x7BE6,  0x7BF6,  0x7C05,
+    0x7C15,  0x7C24,  0x7C33,  0x7C42,
+    0x7C50,  0x7C5F,  0x7C6D,  0x7C7B,
+    0x7C89,  0x7C97,  0x7CA5,  0x7CB2,
+    0x7CC0,  0x7CCD,  0x7CDA,  0x7CE7,
+    0x7CF3,  0x7D00,  0x7D0C,  0x7D18,
+    0x7D25,  0x7D31,  0x7D3C,  0x7D48,
+    0x7D53,  0x7D5F,  0x7D6A,  0x7D75,
+    0x7D80,  0x7D8B,  0x7D95,  0x7DA0,
+    0x7DAA,  0x7DB4,  0x7DBE,  0x7DC8,
+    0x7DD2,  0x7DDC,  0x7DE5,  0x7DEF,
+    0x7DF8,  0x7E01,  0x7E0A,  0x7E13,
+    0x7E1C,  0x7E25,  0x7E2D,  0x7E36,
+    0x7E3E,  0x7E46,  0x7E4E,  0x7E56,
+    0x7E5E,  0x7E66,  0x7E6D,  0x7E75,
+    0x7E7C,  0x7E83,  0x7E8B,  0x7E92,
+    0x7E99,  0x7EA0,  0x7EA6,  0x7EAD,
+    0x7EB3,  0x7EBA,  0x7EC0,  0x7EC6,
+    0x7ECD,  0x7ED3,  0x7ED9,  0x7EDE,
+    0x7EE4,  0x7EEA,  0x7EF0,  0x7EF5,
+    0x7EFA,  0x7F00,  0x7F05,  0x7F0A,
+    0x7F0F,  0x7F14,  0x7F19,  0x7F1E,
+    0x7F23,  0x7F27,  0x7F2C,  0x7F30,
+    0x7F35,  0x7F39,  0x7F3D,  0x7F41,
+    0x7F46,  0x7F4A,  0x7F4E,  0x7F52,
+    0x7F55,  0x7F59,  0x7F5D,  0x7F60,
+    0x7F64,  0x7F68,  0x7F6B,  0x7F6E,
+    0x7F72,  0x7F75,  0x7F78,  0x7F7B,
+    0x7F7E,  0x7F81,  0x7F84,  0x7F87,
+    0x7F8A,  0x7F8D,  0x7F90,  0x7F92,
+    0x7F95,  0x7F97,  0x7F9A,  0x7F9C,
+    0x7F9F,  0x7FA1,  0x7FA4,  0x7FA6,
+    0x7FA8,  0x7FAA,  0x7FAC,  0x7FAE,
+    0x7FB1,  0x7FB3,  0x7FB5,  0x7FB6,
+    0x7FB8,  0x7FBA,  0x7FBC,  0x7FBE,
+    0x7FBF,  0x7FC1,  0x7FC3,  0x7FC4,
+    0x7FC6,  0x7FC8,  0x7FC9,  0x7FCB,
+    0x7FCC,  0x7FCD,  0x7FCF,  0x7FD0,
+    0x7FD1,  0x7FD3,  0x7FD4,  0x7FD5,
+    0x7FD6,  0x7FD8,  0x7FD9,  0x7FDA,
+    0x7FDB,  0x7FDC,  0x7FDD,  0x7FDE,
+    0x7FDF,  0x7FE0,  0x7FE1,  0x7FE2,
+    0x7FE3,  0x7FE4,  0x7FE4,  0x7FE5,
+    0x7FE6,  0x7FE7,  0x7FE8,  0x7FE8,
+    0x7FE9,  0x7FEA,  0x7FEA,  0x7FEB,
+    0x7FEC,  0x7FEC,  0x7FED,  0x7FEE,
+    0x7FEE,  0x7FEF,  0x7FEF,  0x7FF0,
+    0x7FF0,  0x7FF1,  0x7FF1,  0x7FF2,
+    0x7FF2,  0x7FF3,  0x7FF3,  0x7FF4,
+    0x7FF4,  0x7FF4,  0x7FF5,  0x7FF5,
+    0x7FF6,  0x7FF6,  0x7FF6,  0x7FF7,
+    0x7FF7,  0x7FF7,  0x7FF8,  0x7FF8,
+    0x7FF8,  0x7FF8,  0x7FF9,  0x7FF9,
+    0x7FF9,  0x7FF9,  0x7FFA,  0x7FFA,
+    0x7FFA,  0x7FFA,  0x7FFA,  0x7FFB,
+    0x7FFB,  0x7FFB,  0x7FFB,  0x7FFB,
+    0x7FFC,  0x7FFC,  0x7FFC,  0x7FFC,
+    0x7FFC,  0x7FFC,  0x7FFC,  0x7FFC,
+    0x7FFD,  0x7FFD,  0x7FFD,  0x7FFD,
+    0x7FFD,  0x7FFD,  0x7FFD,  0x7FFD,
+    0x7FFD,  0x7FFD,  0x7FFE,  0x7FFE,
+    0x7FFE,  0x7FFE,  0x7FFE,  0x7FFE,
+    0x7FFE,  0x7FFE,  0x7FFE,  0x7FFE,
+    0x7FFE,  0x7FFE,  0x7FFE,  0x7FFE,
+    0x7FFE,  0x7FFE,  0x7FFE,  0x7FFE,
+    0x7FFF,  0x7FFF,  0x7FFF,  0x7FFF,
+    0x7FFF,  0x7FFF,  0x7FFF,  0x7FFF,
+    0x7FFF,  0x7FFF,  0x7FFF,  0x7FFF,
+    0x7FFF,  0x7FFF,  0x7FFF,  0x7FFF,
+    0x7FFF,  0x7FFF,  0x7FFF,  0x7FFF,
+    0x7FFF,  0x7FFF,  0x7FFF,  0x7FFF,
+    0x7FFF,  0x7FFF,  0x7FFF,  0x7FFF,
+    0x7FFF,  0x7FFF,  0x7FFF,  0x7FFF,
+    0x7FFF,  0x7FFF,  0x7FFF,  0x7FFF,
+    0x7FFF,  0x7FFF,  0x7FFF,  0x7FFF
+
+};
+
+
+
+
+const Int16 Short_Window_KBD_fxp[SHORT_WINDOW] =
+{
+
+    0x0001,  0x0004,  0x0008,  0x000D,
+    0x0014,  0x001D,  0x0029,  0x0039,
+    0x004C,  0x0063,  0x0080,  0x00A2,
+    0x00CB,  0x00FB,  0x0133,  0x0174,
+    0x01BE,  0x0214,  0x0275,  0x02E3,
+    0x035E,  0x03E8,  0x0481,  0x052B,
+    0x05E7,  0x06B4,  0x0795,  0x088A,
+    0x0993,  0x0AB2,  0x0BE7,  0x0D32,
+    0x0E94,  0x100E,  0x119F,  0x1347,
+    0x1507,  0x16DE,  0x18CC,  0x1AD0,
+    0x1CEB,  0x1F1A,  0x215F,  0x23B6,
+    0x2620,  0x289C,  0x2B27,  0x2DC0,
+    0x3066,  0x3317,  0x35D2,  0x3894,
+    0x3B5C,  0x3E28,  0x40F6,  0x43C4,
+    0x468F,  0x4956,  0x4C18,  0x4ED1,
+    0x5181,  0x5425,  0x56BC,  0x5944,
+    0x5BBB,  0x5E21,  0x6073,  0x62B1,
+    0x64DA,  0x66EC,  0x68E7,  0x6ACB,
+    0x6C96,  0x6E49,  0x6FE4,  0x7166,
+    0x72D0,  0x7421,  0x755B,  0x767E,
+    0x778A,  0x7881,  0x7962,  0x7A30,
+    0x7AEA,  0x7B92,  0x7C29,  0x7CB0,
+    0x7D28,  0x7D92,  0x7DF0,  0x7E42,
+    0x7E89,  0x7EC7,  0x7EFC,  0x7F2A,
+    0x7F50,  0x7F71,  0x7F8C,  0x7FA3,
+    0x7FB6,  0x7FC5,  0x7FD2,  0x7FDC,
+    0x7FE4,  0x7FEB,  0x7FF0,  0x7FF4,
+    0x7FF7,  0x7FF9,  0x7FFB,  0x7FFC,
+    0x7FFD,  0x7FFE,  0x7FFE,  0x7FFE,
+    0x7FFF,  0x7FFF,  0x7FFF,  0x7FFF,
+    0x7FFF,  0x7FFF,  0x7FFF,  0x7FFF,
+    0x7FFF,  0x7FFF,  0x7FFF,  0x7FFF
+};
+
diff --git a/media/libstagefright/codecs/aacdec/write_output.h b/media/libstagefright/codecs/aacdec/write_output.h
new file mode 100644
index 0000000..0085a63
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/write_output.h
@@ -0,0 +1,138 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+
+ Pathname: write_output.h
+
+------------------------------------------------------------------------------
+ REVISION HISTORY
+
+ Description: Change function prototype.
+
+ Description: Remove CR/LF from unknown editor
+
+ Who:                                       Date:
+ Description:
+
+------------------------------------------------------------------------------
+ INCLUDE DESCRIPTION
+
+ Header file for the declaration of the function write_output()
+
+------------------------------------------------------------------------------
+*/
+
+/*----------------------------------------------------------------------------
+; CONTINUE ONLY IF NOT ALREADY DEFINED
+----------------------------------------------------------------------------*/
+#ifndef WRITE_OUTPUT_H
+#define WRITE_OUTPUT_H
+
+#include "pv_audio_type_defs.h"
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+    /*----------------------------------------------------------------------------
+    ; INCLUDES
+    ----------------------------------------------------------------------------*/
+#include "pvmp4audiodecoder_api.h"
+
+    /*----------------------------------------------------------------------------
+    ; MACROS
+    ; Define module specific macros here
+    ----------------------------------------------------------------------------*/
+
+    /*----------------------------------------------------------------------------
+    ; DEFINES
+    ; Include all pre-processor statements here.
+    ----------------------------------------------------------------------------*/
+
+    /*----------------------------------------------------------------------------
+    ; EXTERNAL VARIABLES REFERENCES
+    ; Declare variables used in this module but defined elsewhere
+    ----------------------------------------------------------------------------*/
+
+    /*----------------------------------------------------------------------------
+    ; SIMPLE TYPEDEF'S
+    ----------------------------------------------------------------------------*/
+
+    /*----------------------------------------------------------------------------
+    ; ENUMERATED TYPEDEF'S
+    ----------------------------------------------------------------------------*/
+
+    /*----------------------------------------------------------------------------
+    ; STRUCTURES TYPEDEF'S
+    ----------------------------------------------------------------------------*/
+
+    /*----------------------------------------------------------------------------
+    ; GLOBAL FUNCTION DEFINITIONS
+    ; Function Prototype declaration
+    ----------------------------------------------------------------------------*/
+
+#ifndef AAC_PLUS
+
+    Int write_output(
+        const Int16   sourceLeft[],
+        const Int16   sourceRight[],
+        Int16   outputBuffer[],
+        const Int     sourcePointsPerChannel,
+        const Int     sourceChannels,
+        const Int     requestedChannels,
+        const tPVMP4AudioDecoderOutputFormat  outputFormat);
+
+#else
+
+    Int write_output(
+        const Int16   sourceLeft[],
+        const Int16   sourceRight[],
+        Int16   outputBuffer[],
+        const Int     sourcePointsPerChannel,
+        const Int     sourceChannels,
+        const Int     requestedChannels,
+#ifdef PARAMETRICSTEREO
+        Int32 sbrEnablePS,
+#endif
+        const tPVMP4AudioDecoderOutputFormat  outputFormat);
+
+#ifdef AAC_32_BIT_INTERFACE
+
+    Int write_output_1(
+        const Int32   sourceLeft[],
+        const Int32   sourceRight[],
+        Int16   outputBuffer[],
+        const Int     sourcePointsPerChannel,
+        const Int     sourceChannels,
+        const Int     requestedChannels,
+        const tPVMP4AudioDecoderOutputFormat  outputFormat);
+#endif
+
+#endif
+
+    /*----------------------------------------------------------------------------
+    ; END
+    ----------------------------------------------------------------------------*/
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* WRITE_OUTPUT_H */
+
+
-- 
1.7.10.4

